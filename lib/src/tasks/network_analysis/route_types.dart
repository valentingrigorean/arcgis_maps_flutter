part of arcgis_maps_flutter;

enum AttributeUnit {
  unknown(0),
  inches(1),
  feet(2),
  yards(3),
  miles(4),
  millimeters(5),
  centimeters(6),
  meters(7),
  kilometers(8),
  nauticalMiles(9),
  decimalDegrees(10),
  seconds(11),
  minutes(12),
  hours(13),
  days(14),
  decimeters(15);

  const AttributeUnit(this.value);

  factory AttributeUnit.fromValue(int value) {
    return AttributeUnit.values.firstWhere(
      (e) => e.value == value,
      orElse: () => AttributeUnit.unknown,
    );
  }

  final int value;
}

enum DirectionManeuverType {
  ///An unknown maneuver type.
  unknown(-1),

  ///A stop maneuver.
  stop(0),

  ///A moving straight.
  straight(1),

  ///A bear left.
  bearLeft(2),

  ///A bear right.
  bearRight(3),

  ///A turn left.
  turnLeft(4),

  ///A turn right.
  turnRight(5),

  ///A sharp turn left.
  sharpLeft(6),

  ///A sharp turn right.
  sharpRight(7),

  ///A u-turn.
  uTurn(8),

  ///A maneuver connected with a ferry.
  ferry(9),

  ///A maneuver via roundabout.
  roundabout(10),

  ///A merge of several highways.
  highwayMerge(11),

  ///An exit from highway.
  highwayExit(12),

  ///A change of highway.
  highwayChange(13),

  ///A straight at fork.
  forkCenter(14),

  ///A maneuver to the left at fork.
  forkLeft(15),

  ///A maneuver to the right at fork.
  forkRight(16),

  ///A departure.
  depart(17),

  ///A connected with trip planning.
  tripItem(18),

  ///An end of ferry transfer.
  endOfFerry(19),

  ///A maneuver to the right on ramp.
  rampRight(20),

  ///A maneuver to the left on ramp.
  rampLeft(21),

  ///A complex maneuver: turn left, then right.
  turnLeftRight(22),

  ///A complex maneuver: turn right, then left.
  turnRightLeft(23),

  ///A complex maneuver: turn right, then right.
  turnRightRight(24),

  ///A complex maneuver: turn left, then left.
  turnLeftLeft(25),

  ///A maneuver via pedestrian ramp.
  pedestrianRamp(26),

  ///A maneuver using elevator.
  elevator(27),

  ///A maneuver using escalator.
  escalator(28),

  ///A maneuver using stairs.
  stairs(29),

  ///A passing through a door.
  doorPassage(30),
  ;

  const DirectionManeuverType(this.value);

  factory DirectionManeuverType.fromValue(int value) {
    return DirectionManeuverType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => DirectionManeuverType.unknown,
    );
  }

  final int value;
}

enum DirectionMessageType {
  unknown(-1),

  /// A street name.
  streetName(0),

  /// An alternative street name.
  alternativeName(1),

  /// A signpost branch.
  branch(2),

  /// A signpost toward.
  toward(3),

  /// An intersected street name.
  crossStreet(4),

  /// A signpost exit.
  exit(5),
  ;

  const DirectionMessageType(this.value);

  factory DirectionMessageType.fromValue(int value) {
    return DirectionMessageType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => DirectionMessageType.unknown,
    );
  }

  final int value;
}

enum DirectionsStyle {
  /// The driving directions generated by this style are good for desktop/printing apps.
  desktop(0),

  /// The driving directions generated by this style are good for navigation applications.
  navigation(1),

  /// The driving directions generated by this style are good for campus routing.
  campus(2),
  ;

  const DirectionsStyle(this.value);

  factory DirectionsStyle.fromValue(int value) {
    return DirectionsStyle.values.firstWhere(
      (e) => e.value == value,
      orElse: () => DirectionsStyle.desktop,
    );
  }

  final int value;
}

enum NetworkDirectionsSupport {
  /// Directions support is unknown.
  unknown(0),

  /// Directions are unsupported.
  unsupported(1),

  /// Directions are supported.
  supported(2),
  ;

  const NetworkDirectionsSupport(this.value);

  factory NetworkDirectionsSupport.fromValue(int value) {
    return NetworkDirectionsSupport.values.firstWhere(
      (e) => e.value == value,
      orElse: () => NetworkDirectionsSupport.unknown,
    );
  }

  final int value;
}

enum RouteShapeType {
  /// A none shape type.
  none(0),

  /// A straight line shape type.
  straightLine(1),

  ///  A true shape type with measures.
  trueShapeWithMeasures(2),
  ;

  const RouteShapeType(this.value);

  factory RouteShapeType.fromValue(int value) {
    return RouteShapeType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => RouteShapeType.none,
    );
  }

  final int value;
}

enum UTurnPolicy {
  notAllowed(0),
  allowedAtDeadEnds(1),
  allowedAtIntersections(2),
  allowedAtDeadEndsAndIntersections(3),
  ;

  const UTurnPolicy(this.value);

  factory UTurnPolicy.fromValue(int value) {
    return UTurnPolicy.values.firstWhere(
      (e) => e.value == value,
      orElse: () => UTurnPolicy.notAllowed,
    );
  }

  final int value;
}

enum CurbApproach {
  /// An unknown type, used when approach is not determined.
  unknown(-1),

  /// An either side curb approach.
  eitherSide(0),

  /// A left side curb approach.
  leftSide(1),

  /// A right side curb approach.
  rightSide(2),

  /// A no U-Turn curb approach.
  noUTurn(3),
  ;

  const CurbApproach(this.value);

  factory CurbApproach.fromValue(int value) {
    return CurbApproach.values.firstWhere(
      (e) => e.value == value,
      orElse: () => CurbApproach.unknown,
    );
  }

  final int value;
}

enum LocationStatus {
  /// The element's location on the network dataset can't be determined.
  notLocated(0),

  /// The element has been located on the closest network location
  onClosest(1),

  /// The closest network location to the element is not traversable because
  /// of a restriction or barrier, so the element has been located
  /// on the closest traversable network feature instead.
  onClosestNotRestricted(2),

  ///  The element can't be reached during analysis.
  notReached(3),
  ;

  const LocationStatus(this.value);

  factory LocationStatus.fromValue(int value) {
    return LocationStatus.values.firstWhere(
      (e) => e.value == value,
      orElse: () => LocationStatus.notLocated,
    );
  }

  final int value;
}

enum StopType {
  /// A location where a vehicle would arrive and/or depart.
  stop(0),

  /// A location between stops that a route must pass through.
  waypoint(1),

  /// A location where a route pauses e.g. for a required lunch break.
  restBreak(2),
  ;

  const StopType(this.value);

  factory StopType.fromValue(int value) {
    return StopType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => StopType.stop,
    );
  }

  final int value;
}
