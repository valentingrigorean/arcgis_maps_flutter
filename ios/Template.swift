import AVFoundation
import AuthenticationServices
import Combine
import CoreGraphics
import CoreGraphics.CGGeometry
import CoreLocation
import CoreMotion
import Darwin
import Dispatch
import ExternalAccessory
import Foundation
import Foundation.NSBundle
import Foundation.NSData
import Foundation.NSDate
import Foundation.NSError
import Foundation.NSLocale
import Foundation.NSURL
import Foundation.NSUUID
import MetalKit
import SwiftUI
import UIKit
import UIKit.UIColor
import UIKit.UIDevice
import UIKit.UIGestureRecognizerSubclass
import UIKit.UIImage
import UIKit.UIInterface
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import os
import os.log

/// An API key to access API key enabled services and resources in ArcGIS
/// Online.
/// - Note: See Also: ``APIKeyResource``
/// - Since: 200.1
@frozen public struct APIKey : RawRepresentable, Hashable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: String

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    public init?(_ rawValue: String)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = String
}

extension APIKey : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension APIKey : Sendable {
}

/// An interface for getting and setting the API key of an object.
///
/// This interface will be used for getting and setting the API key generated from ArcGIS Developers
/// website on object where required.
/// - Since: 200.1
public protocol APIKeyResource {

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    var apiKey: ArcGIS.APIKey? { get set }
}

/// Adds raster datasets to a ``MosaicDatasetRaster`` by setting various parameters.
///
/// Mosaic datasets (via the ``MosaicDatasetRaster`` class) are used to manage, display,
/// serve, and share raster data. When you create a new mosaic dataset, it is created as
/// an empty container in a geodatabase to which you can add raster data. The
/// AddRastersParameters object provides the mechanism to set various properties, so
/// that a raster can be added to a mosaic dataset via the
/// `MosaicDatasetRaster.addRasters(using:)` method.
///
/// Some of the parameters (aka. properties) on AddRastersParameters class that enable
/// adding a raster into a mosaic dataset include specifying the file filter type (like
/// .tif or .jpg) of the rasters that are to be included (``filter``
/// property), the directory location (``inputDirectoryURL`` property)
/// of the raster files, the minimum pixel cell size of the raster to be included
/// (``minPixelSizeFactor`` property) and more.
/// - Since: 200.1
public class AddRastersParameters {

    /// Creates an add rasters parameters object.
    ///
    /// Creates an add rasters parameters object to be used for adding rasters to a mosaic dataset raster.
    public convenience init()

    /// Raster filename filter.
    ///
    /// This function sets the optional raster filename filter, which is a regular expression with ECMA-262 grammar (https://262.ecma-international.org/5.1/#sec-15.10)
    public var filter: String

    /// Input directory.
    ///
    /// This function sets the optional input directory of rasters.
    public var inputDirectoryURL: URL?

    /// Input CSV file.
    ///
    /// This function sets the optional input CSV file.
    public var inputFileURL: URL?

    /// Max pixel size factor.
    ///
    /// This function sets the optional max pixel size factor.
    public var maxPixelSizeFactor: Double

    /// Min pixel size factor.
    ///
    /// This function sets the optional min pixel size factor.
    public var minPixelSizeFactor: Double

    /// Raster function template file.
    ///
    /// This function sets the optional raster function template file.
    public var rasterFunctionTemplateFileURL: URL?
}

/// Analysis is a base class for those classes used to render analysis results in a scene view.
///
/// This class defines common members for an analysis object, including the current Status and an ID.
/// - Since: 200.1
public class Analysis {

    /// Whether or not an Analysis is visible.
    ///
    /// Visibility can be controlled for individual Analyses as well as for the AnalysisOverlay that contains them.
    public var isVisible: Bool
}

/// AnalysisOverlay manages the display of one or more Analyses on a scene view.
///
/// AnalysisOverlay allows you to group related analyses and control visibility for all members of the collection. A scene view can contain many AnalysisOverlays.
/// - Since: 200.1
final public class AnalysisOverlay {

    /// Creates an AnalysisOverlay object.
    ///
    /// An AnalysisOverlay manages a collection of Analysis objects in a scene view.
    public convenience init()

    /// The collection of analysis objects managed by the AnalysisOverlay.
    ///
    /// The collection is specific to an AnalysisOverlay so you can't reuse an analyses collection coming from another
    /// ``AnalysisOverlay``. You must create a new analyses collection using `Array.init(valueType:)`.
    /// - Note: See Also: ``Analysis``
    final public var analyses: [ArcGIS.Analysis] { get }

    /// Adds a sequence of `Analysis` values to the end of the `analyses` property.
    /// - Parameter newAnalyses: The new `Analysis` values to append.
    final public func addAnalyses<S>(_ newAnalyses: S) where S : Sequence, S.Element == ArcGIS.Analysis

    /// Adds an `Analysis` value to the end of the `analyses` property.
    /// - Parameter newAnalysis: The new `Analysis` value to append.
    final public func addAnalysis(_ newAnalysis: ArcGIS.Analysis)

    /// Inserts a collection of `Analysis` values into the `analyses` property at the specified position.
    /// - Parameters:
    ///   - newAnalyses: The new `Analysis` values to insert.
    ///   - index: The position at which to insert the new `Analysis` values.
    final public func insertAnalyses<C>(_ newAnalyses: C, at index: Int) where C : Collection, C.Element == ArcGIS.Analysis

    /// Inserts an `Analysis` value into the `analyses` property at the specified position.
    /// - Parameters:
    ///   - newAnalysis: The new `Analysis` value to insert.
    ///   - index: The position at which to insert the new `Analysis` value.
    final public func insertAnalysis(_ newAnalysis: ArcGIS.Analysis, at index: Int)

    /// Removes all values from the `analyses` property.
    final public func removeAllAnalyses()

    /// Removes a sequence of `Analysis` values from the `analyses` property.
    /// - Parameter analyses: The `Analysis` values to remove.
    final public func removeAnalyses<S>(_ analyses: S) where S : Sequence, S.Element == ArcGIS.Analysis

    /// Removes an `Analysis` value from the `analyses` property.
    /// - Parameter analysis: The `Analysis` value to remove.
    final public func removeAnalysis(_ analysis: ArcGIS.Analysis)

    /// The visibility for the AnalysisOverlay.
    ///
    /// If the overlay's visibility is `false`, none of the Analyses in the collection will display. If `true`, only those Analyses whose visibility is also `true` will display.
    final public var isVisible: Bool
}

extension AnalysisOverlay {

    /// Creates an overlay with the provided analyses.
    /// - Parameter analyses: The analyses to create the overlay with.
    public convenience init(analyses: [ArcGIS.Analysis])
}

/// Defines an angular unit of measurement.
///
/// The angular unit class is derived from the unit class.
/// - Note: See Also: ``Unit``
/// - Since: 200.1
final public class AngularUnit : ArcGIS.Unit {

    /// Defines a list of the most commonly-used angular units of measurement.
    ///
    /// These values can be used to create instances of ``AngularUnit``, as an alternative to using well-known IDs (WKIDs).
    /// In addition to the units in this enumeration, you can also use less commonly-used units, by passing a WKID of an
    /// angular unit to the inherited `Unit.fromWKID(_:)` factory method.
    /// The function ``Unit/wkid`` returns the WKID of the unit.
    public enum ID {

        /// Indicates an angular measurement in degrees.
        /// This unit has a WKID of 9102.
        case degrees

        /// Indicates an angular measurement in grads.
        /// This unit has a WKID of 9105.
        case grads

        /// Indicates an angular measurement in minutes, equal to one-sixtieth of a degree.
        /// This unit has a WKID of 9103.
        case minutes

        /// Indicates an angular measurement in radians.
        /// This unit has an WKID of 9101.
        case radians

        /// Indicates an angular measurement in seconds, equal to one-sixtieth of a minute.
        /// This unit has a WKID of 9104.
        case seconds

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.AngularUnit.ID, b: ArcGIS.AngularUnit.ID) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a unit given its known id.
    /// - Parameter angularID: The known id of the unit.
    public convenience init(angularID: ArcGIS.AngularUnit.ID)

    /// The ``ID`` of the given angular unit.
    final public var angularID: ArcGIS.AngularUnit.ID? { get }

    /// Converts a value in another UOM into this UOM.
    /// - Parameters:
    ///   - unit: The UOM to convert from.
    ///   - angle: The value to convert.
    /// - Returns: The value in the this UOM or `nan` if the conversion fails.
    final public func convert(from unit: ArcGIS.AngularUnit, angle: Double) -> Double

    /// Converts a value in this UOM into another UOM.
    /// - Parameters:
    ///   - unit: The UOM to convert to.
    ///   - angle: The value to convert.
    /// - Returns: The value in the target UOM or `nan` if the conversion fails.
    final public func convert(to unit: ArcGIS.AngularUnit, angle: Double) -> Double

    /// Converts a radian value to this UOM.
    /// - Parameter radians: The value to convert.
    /// - Returns: The value in this UOM or `nan` if the conversion fails.
    final public func fromRadians(_ radians: Double) -> Double

    /// Converts a value in this UOM to radians.
    /// - Parameter angle: The value to convert.
    /// - Returns: The value in radians or `nan` if the conversion fails.
    final public func toRadians(angle: Double) -> Double
}

extension AngularUnit {

    /// An angular unit representing degrees.
    public static let degrees: ArcGIS.AngularUnit

    /// An angular unit representing radians.
    public static let radians: ArcGIS.AngularUnit
}

extension AngularUnit.ID : Equatable {
}

extension AngularUnit.ID : Hashable {
}

/// A layer that can visualize annotation text data.
///
/// Annotation can be used to symbolize text on your maps as described here in
/// ["Annotation"](https://pro.arcgis.com/en/pro-app/help/data/annotation/annotation.htm).
/// It is defined using a text string, geographical location, and display properties including
/// font, size, and color. This information is stored together in an annotation feature class
/// within a geodatabase.
///
/// There are two kinds of annotation:
/// * Standard annotation is not formally associated with features in the geodatabase. An
/// example of standard annotation is the text on a map for a mountain range. No specific
/// feature represents the mountain range, but it is an area you want to mark. Standard
/// annotation is read-only.
/// * Feature-linked annotation is associated with a specific feature in another feature class
/// in the geodatabase. The text in feature-linked annotation reflects the value of a field or
/// fields from the feature to which it is linked. For example, the water transmission mains in
/// a water network can be annotated with their names, which are stored in a field in the
/// transmission mains feature class. If you edit the attributes and/or geographical position
/// of the feature associated with the feature-linked annotation, any changes will be applied
/// to the annotation feature table, and visible changes to the annotation will be reflected in
/// the `MapView`. If the feature-linked annotation is stored in an Enterprise server, its
/// feature and annotation tables must contain global object ids.
///
/// You can construct an annotation layer using any of the following:
/// * URL or portal item of an online annotation feature class
/// * Feature table containing annotation features:
///   - An online ``ServiceFeatureTable`` that has a feature layer service type of
///     ``ArcGISFeatureLayerInfoServiceType/annotationLayer``
///   - An offline ``GeodatabaseFeatureTable`` returned by the
///     ``Geodatabase/annotationTables`` collection when a
///     ``GenerateGeodatabaseJob`` has completed
///
/// Annotation layers can be taken offline from a feature service hosted on ArcGIS Enterprise
/// 10.7.1 or later, using the ``GeodatabaseSyncTask``. Annotation layers are also supported in
/// mobile map packages created in ArcGIS Pro 2.3 or later.
///
/// Annotation respects the reference scale defined by the map, so annotation will always be
/// presented to the user at the correct size and position, as defined by the annotation
/// author.
///
/// Each annotation layer is partitioned into annotation sublayers. Each annotation sublayer
/// corresponds to the label class of the original labels that were used to publish the
/// annotation. In ArcGIS Pro, the annotation sublayers are known as annotation classes.
///
/// Annotation sublayers offer greater control over the annotation:
/// * An author can set different visual properties on the sublayer compared to the parent
///   annotation layer. For example, font, size, color, or different minimum and maximum scale
///   ranges.
/// * You can access the annotation sublayer metadata information, such as the legend
///   information, and set the visibility of each annotation sublayer
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class AnnotationLayer : ArcGIS.Layer {

    /// Creates an annotation layer from a feature table containing annotation features.
    ///
    /// If the feature table does not contain annotation data then the AnnotationLayer will fail to load.
    /// ``ArcGISFeatureTable/layerInfo`` and ``ArcGISFeatureLayerInfo/featureServiceType`` can be checked, to verify the
    /// feature type, before attempting to create a ``Layer``.
    /// - Parameter featureTable: The feature table, containing annotation features, used as the source of the annotation layer.
    /// - Note: See Also: ``ArcGISFeatureTable``
    public convenience init(featureTable: ArcGIS.ArcGISFeatureTable)

    /// Creates a new annotation layer object from a feature service portal item.
    /// - Parameters:
    ///   - item: A feature service ``PortalItem``.
    ///   - layerID: The layer ID for which to create the layer.
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item, layerID: Int)

    /// Creates a new annotation layer from a feature service URI.
    ///
    /// If the specified URI is not a valid Feature Service endpoint, then it will fail to load.
    /// - Parameter url: The URI to the feature service layer.
    public convenience init(url: URL)

    /// The weight of annotation features when considered as barriers to labeling.
    ///
    /// The default is ``LabelBarrierWeight/high``.
    final public var barrierWeight: ArcGIS.LabelBarrierWeight

    /// An expression which is a SQL statement where clause to specify the subset of features to be displayed.
    ///
    /// The definition expression string uses the SQL-92 where clause syntax
    /// (https://en.wikipedia.org/wiki/SQL-92).
    /// The default value is an empty string, which will allow all annotation features
    /// in the data source to be used by the ``AnnotationLayer``.
    /// - Warning: Be sure to escape special characters
    /// in the expression string as required for your platform. The DATE keyword expects
    /// the date format yyyy-mm-dd and the TIMESTAMP keyword expects the time stamp format
    /// yyyy-mm-dd hh:mm:ss. See the ArcGIS Blog article entitled "Querying Feature Services
    /// Date-Time Queries"
    /// (https://www.esri.com/arcgis-blog/products/api-rest/data-management/querying-feature-services-date-time-queries/)
    /// for more information.
    final public var definitionExpression: String

    /// The feature table associated with this layer.
    final public var featureTable: ArcGIS.ArcGISFeatureTable? { get }

    /// The layer ID that defines the layer within the feature service portal item.
    /// - Note: See Also: ``Layer/item``
    final public var layerID: Int { get }

    /// The reference scale for the layer. If `nil`, there is no reference scale.
    ///
    /// The reference scale of the layer is the scale at which a client should view the layer
    /// for the text to appear at its authored size.
    ///
    /// If the client changes the viewing scale, then text will grow or shrink to keep a
    /// consistent size on the map (not the screen).
    ///
    /// For a valid layer, the reference scale will always be a finite value, greater than
    /// zero. Until the layer is loaded, the reference scale will be zero.
    final public var referenceScale: Double? { get }

    /// Returns a list of the currently selected features.
    final public var selectedFeatures: ArcGIS.FeatureQueryResult { get async throws }

    /// The URI of a feature service to define the layer.
    final public var url: URL? { get }

    /// Updates any selected features in the layer back to the un-selected state.
    final public func clearSelection()

    /// Resets the visibility of the layer's features back to the original visibility when loaded from the data source.
    final public func resetFeaturesVisible()

    /// Selects the given feature and adds it to the current list of
    /// selected features.
    /// - Parameter feature: The feature.
    final public func selectFeature(_ feature: ArcGIS.Feature)

    /// Selects the features in the list and adds them to the current list of
    /// selected features.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func selectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Selects the features that match the criteria in the ``QueryParameters`` object and
    /// adds them to the current list of selected features.
    /// - Parameters:
    ///   - parameters: The definition of the query to submit to the feature table.
    ///   - mode: Defines how the list of currently selected features will be updated with the features returned from the query.
    /// - Returns: A ``FeatureQueryResult``.
    @discardableResult
    final public func selectFeatures(using parameters: ArcGIS.QueryParameters, mode: ArcGIS.FeatureLayer.SelectionMode) async throws -> ArcGIS.FeatureQueryResult

    /// Sets the visibility of the given features.
    /// - Parameters:
    ///   - visible: `true` to show, `false` to hide.
    ///   - features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func setVisible<S>(_ visible: Bool, for features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Sets the visibility of the given feature.
    /// - Parameters:
    ///   - visible: `true` to show, `false` to hide.
    ///   - feature: The feature.
    final public func setVisible(_ visible: Bool, for feature: ArcGIS.Feature)

    /// Unselects the given feature and removes it from
    /// the current list of selected features.
    /// - Parameter feature: The feature.
    final public func unselectFeature(_ feature: ArcGIS.Feature)

    /// Unselects the features in the given list and
    /// removes them from the current list of selected features.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func unselectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature
}

/// Allows you to interrogate the properties of a sublayer within an annotation layer and to change the visibility of the sublayer.
///
/// You can get an `Array` of ``AnnotationSublayer`` from ``AnnotationLayer`` using
/// ``LayerContent/subLayerContents``. ``AnnotationSublayer`` objects only exist as part of an
/// ``AnnotationLayer`` object, populated when the ``AnnotationLayer`` is loaded. They cannot
/// exist separately. Annotation sublayers offer finer control over your annotation, allowing
/// the author to set different visual properties from the parent annotation layer. These visual
/// properties include font, size, color, or different minimum and maximum scale ranges.
/// - Since: 200.1
final public class AnnotationSublayer : ArcGIS.LayerContent {

    /// The where-clause of the sql expression that defines which annotation features from the feature table are selected into this sublayer.
    ///
    /// The definition expression string uses the SQL-92 where clause syntax
    /// (https://en.wikipedia.org/wiki/SQL-92). Be sure to escape special characters
    /// in the expression string as required for your platform. The DATE keyword expects
    /// the date format yyyy-mm-dd and the TIMESTAMP keyword expects the time stamp format
    /// yyyy-mm-dd hh:mm:ss. See the ArcGIS Blog article entitled "Querying Feature Services
    /// Date-Time Queries"
    /// (https://www.esri.com/arcgis-blog/products/api-rest/data-management/querying-feature-services-date-time-queries/)
    /// for more information.
    final public var definitionExpression: String { get }

    /// The maximum scale at which to display the Sublayer. If `nil`, there is no maximum.
    final public var maxScale: Double? { get }

    /// The minimum scale at which to display the Sublayer. If `nil`, there is no minimum.
    ///
    /// Zero indicates that the annotation will be visible no matter how far the user zooms out.
    final public var minScale: Double? { get }

    /// The opacity with which to display the annotation text associated with this Sublayer.
    ///
    /// Opacity is a value between 0 and 1, with 0 indicating that the annotation will be completely transparent,
    /// and 1 indicating that the annotation will be completely opaque.
    final public var opacity: Float { get }

    /// The property specifies whether the annotation text scales with the `MapView`.
    ///
    /// For ``AnnotationLayer`` and ``AnnotationSublayer`` this is always `true`.
    final public var scalesSymbols: Bool { get }

    /// Non-negative integer id number of the ``AnnotationSublayer`` within its ``AnnotationLayer``.
    final public var sublayerID: Int { get }

    /// A flag indicating whether the layer content's visibility can be changed.
    ///
    /// A flag indicating whether the layer content visibility can be changed.
    final public var canChangeVisibility: Bool { get }

    /// The layer content's visibility.
    ///
    /// The layer content visibility.
    final public var isVisible: Bool

    /// Fetches the list of legend info.
    final public var legendInfos: [ArcGIS.LegendInfo] { get async throws }

    /// The layer content's name.
    ///
    /// The layer content name.
    final public var name: String { get }

    /// A flag indicating whether the layer content participates in the legend.
    ///
    /// A flag indicating whether the layer content is shown in the legend.
    final public var shouldShowInLegend: Bool

    /// The sub layer contents of a layer content.
    @ArcGIS.Streamed final public var subLayerContents: [ArcGIS.LayerContent] { get }

    final public var $subLayerContents: AsyncStream<[ArcGIS.LayerContent]> { get }

    /// Returns the layer content's effective visibility at the specified scale.
    ///
    /// Returns the effective layer content visibility. This effective visibility takes care of the effective visibility of the parents at the specified scale.
    /// - Parameter scale: The scale the visibility has to be calculated for.
    /// - Returns: A bool.
    final public func isVisible(atScale scale: Double) -> Bool
}

/// An ArcGIS authentication challenge.
///
/// An ArcGIS authentication challenge is raised by the ``ArcGISAuthenticationChallengeHandler`` if an ArcGIS secured resource
/// requires OAuth or ArcGIS Token authentication.
/// - Since: 200.1
final public class ArcGISAuthenticationChallenge {

    /// The underlying error that led to this authentication challenge.
    final public var error: Error { get }

    /// The URL of the request that led to this authentication challenge.
    final public var requestURL: URL { get }
}

extension ArcGISAuthenticationChallenge {

    /// The disposition to handle ArcGIS authentication challenge.
    public enum Disposition : Hashable {

        /// Continue with specified credential. If the provided credential cannot be
        /// shared with the authentication challenge's request, then it will
        /// throw ``ArcGISAuthenticationError/credentialCannotBeShared``.
        case continueWithCredential(ArcGIS.ArcGISCredential)

        /// Proceed as if
        /// ``ArcGISAuthenticationChallengeHandler/handleArcGISAuthenticationChallenge(_:)``
        /// is not implemented. The request which issued authentication
        /// challenge will fail with the error in
        /// ``ArcGISAuthenticationChallenge/error``.
        case continueWithoutCredential

        /// The request which issued authentication challenge will fail with
        /// `CancellationError`.
        case cancel

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ArcGISAuthenticationChallenge.Disposition, b: ArcGIS.ArcGISAuthenticationChallenge.Disposition) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

/// A type that is able to handle ArcGIS authentication challenges.
/// - Since: 200.1
public protocol ArcGISAuthenticationChallengeHandler {

    /// Returns a disposition indicating how the provided challenge should be handled.
    ///
    /// If this function throws, then the request which issued an authentication challenge will fail
    /// with the thrown error.
    /// - Remark: The credential provided while handling the challenge is placed in the ArcGIS
    /// credential store of the ``ArcGISEnvironment/authenticationManager`` and used by
    /// all subsequent requests that have a matching server context.
    /// - Parameter challenge: The challenge that was received.
    /// - Returns: An ArcGIS authentication challenge disposition.
    func handleArcGISAuthenticationChallenge(_ challenge: ArcGIS.ArcGISAuthenticationChallenge) async throws -> ArcGIS.ArcGISAuthenticationChallenge.Disposition
}

/// The types of ArcGIS authentication errors.
/// - Since: 200.1
public enum ArcGISAuthenticationError : Error {

    /// The credential cannot be shared with the request URL.
    case credentialCannotBeShared

    /// You do not have permission to access the resource.
    case forbidden

    /// Invalid API key.
    case invalidAPIKey

    /// Invalid credentials.
    case invalidCredentials

    /// Invalid token.
    case invalidToken

    /// The OAuth authorization end point responded with a specific failure.
    case oAuthAuthorizationFailure(type: String, details: String)

    /// SSL required.
    case sslRequired

    /// Token has expired.
    case tokenExpired

    /// A token or API key is required.
    case tokenRequired

    /// Unable to determine generate token URL.
    case unableToDetermineTokenURL
}

extension ArcGISAuthenticationError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ArcGISAuthenticationError, b: ArcGIS.ArcGISAuthenticationError) -> Bool
}

/// A base class for types of ArcGIS credentials used to access secured resources.
///
/// This is a base class for ArcGIS credentials requiring OAuth or ArcGIS Token authentication,
/// such as ``OAuthUserCredential``, ``PregeneratedTokenCredential`` and ``TokenCredential``.
/// - Note: See Also: ``OAuthUserCredential``, ``PregeneratedTokenCredential``, ``TokenCredential``
/// - Since: 200.1
public class ArcGISCredential : ArcGIS.JSONSerializable {

    /// The referer used to generate a token.
    ///
    /// For ``TokenCredential``, the referer is "arcgis". For ``PregeneratedTokenCredential``,
    /// the referer passed to the constructor should match the referer used to generate the token, or empty
    /// string if none was used.
    public var referer: String { get }

    /// The URL by which the root of a server is accessed.
    ///
    /// This is the URL against which rest endpoints are resolved. For example,
    /// "https://sampleserver3.arcgisonline.com/ArcGIS/rest/services/SanFrancisco/311Incidents/FeatureServer/0"
    /// would have a server context of "https://sampleserver3.arcgisonline.com/ArcGIS", on which we could add
    /// "/rest/info" or "/rest" to fetch the server information.
    public var serverContext: URL { get }

    /// The user associated with the credential.
    public var username: String { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension ArcGISCredential : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.ArcGISCredential, rhs: ArcGIS.ArcGISCredential) -> Bool
}

extension ArcGISCredential : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A store for instances of the subclasses of ``ArcGISCredential``.
///
/// The credential provided while handling an authentication challenge is placed in the store and used by
/// all subsequent requests that have a matching server context.
/// - Note: See Also: ``OAuthUserCredential``, ``PregeneratedTokenCredential``, ``TokenCredential``, ``ArcGISAuthenticationChallengeHandler``
/// - Since: 200.1
final public class ArcGISCredentialStore {

    /// Creates an instance of an ``ArcGISCredentialStore``.
    public convenience init()

    /// Returns an array of unique credentials contained in the ``ArcGISCredentialStore``.
    ///
    /// During a logout workflow, users should call this method before calling `ArcGISCredentialStore.removeAll()`,
    /// filter all instances of ``OAuthUserCredential`` and invalidate them by calling `OAuthUserCredential.revokeToken()`.
    final public var credentials: [ArcGIS.ArcGISCredential] { get }

    /// Adds the specified credential to the ``ArcGISCredentialStore``. The credential's server context is used to
    /// determine what services the credential can be shared with.
    ///
    /// If a credential for the same server context is already in the store, then it will be replaced.
    /// - Parameter credential: The credential to be stored within ``ArcGISCredentialStore``.
    /// - Note: See Also: ``ArcGISCredential/serverContext``, `ArcGISCredentialStore.add(_:for:)`
    final public func add(_ credential: ArcGIS.ArcGISCredential)

    /// Adds a specified credential to the store for a given URL. The URL must be shareable with the
    /// server context of the credential. Otherwise, this method throws a `CoreErrorCode.authenticationCredentialCannotBeShared`.
    /// When the credential is added to the store with this function, for the credential to be shared with a secured service
    /// endpoint, the service endpoint must begin with the specified URL passed to this function call.
    /// For example, if you were to specify a store URL of https://www.server.net/arcgis/rest/services/service1/ when calling this function,
    /// then the specified credential would be shared with an endpoint such as
    /// https://www.server.net/arcgis/rest/services/service1/query, but not for  https://www.server.net/arcgis/rest/services/service2/query.
    ///
    /// If a credential was already stored for the same URL then it will be replaced.
    /// - Parameters:
    ///   - credential: The credential to be stored within ``ArcGISCredentialStore``.
    ///   - url: The URL to associate the credential with.
    /// - Note: See Also: `ArcGISCredentialStore.add(_:)`
    final public func add(_ credential: ArcGIS.ArcGISCredential, for url: URL) throws

    /// Returns the best matched credential in the ``ArcGISCredentialStore`` for the given URL.
    /// - Parameter url: The URL of an ArcGIS secured resource.
    /// - Returns: An ``ArcGISCredential`` in the ``ArcGISCredentialStore`` that best matches the given URL.
    final public func credential(for url: URL) -> ArcGIS.ArcGISCredential?

    /// Removes the credential from ``ArcGISCredentialStore`` if present.
    /// - Parameter credential: The credential to be removed from ``ArcGISCredentialStore``.
    /// - Returns: `true` if the credential was found and removed from the store, otherwise `false`.
    @discardableResult
    final public func remove(_ credential: ArcGIS.ArcGISCredential) -> Bool

    /// Removes all credentials from the ``ArcGISCredentialStore``.
    ///
    /// During a logout workflow, before calling this function, users should call `ArcGISCredentialStore.credentials`,
    /// filter all instances of ``OAuthUserCredential``, and invalidate them using `OAuthUserCredential.revokeToken()`.
    final public func removeAll()

    /// Removes any credentials from the ``ArcGISCredentialStore`` that would be shared with a service endpoint
    /// represented by the provided URL.
    /// - Parameter url: The URL to search for and remove credentials from the store.
    /// - Returns: An array of credentials that were removed.
    @discardableResult
    final public func removeCredentials(for url: URL) -> [ArcGIS.ArcGISCredential]
}

extension ArcGISCredentialStore {

    /// Creates a credential store with a backing persistent storage that is in the device keychain.
    ///
    /// Any credentials in the keychain will be copied into the initialized in-memory credential
    /// store. Any changes to the in-memory credential store will be synchronized with the keychain.
    /// - Remark: Persisted items will be stored in the default group.
    /// To know more about what the default group would be you can find information about that [here](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps).
    /// - Warning: Any previously persisted credentials that  cannot be read from the persistent store
    /// will be removed. This is a possibility when upgrading if the persistence format changes
    /// from a previous release.
    /// - Parameters:
    ///   - access: When the item can be accessed.
    ///   - synchronizesWithiCloud: A Boolean value indicating whether the store is synchronized with iCloud.
    public static func makePersistent(access: ArcGIS.KeychainAccess, synchronizesWithiCloud: Bool = false) async throws -> ArcGIS.ArcGISCredentialStore
}

/// Provides access to and manipulation of environment settings, such as configurations for the operating environment and licenses for deployment.
/// - Since: 200.1
public enum ArcGISEnvironment {

    /// The default API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    public static var apiKey: ArcGIS.APIKey?

    /// Console messages that are sent from any Arcade script.
    ///
    /// This asynchronous stream allows clients to retrieve messages from evaluating an Arcade script expression in an attribute rule,
    /// labeling, popup, dictionary renderer, geotrigger, and more.
    public static var arcadeConsoleMessages: AsyncStream<(context: ArcGIS.ArcadeConsoleMessageContext, message: String)> { get }

    /// The object responsible for issuing authentication challenges and managing credential stores.
    /// - Note: See Also: ``AuthenticationManager``
    public static var authenticationManager: ArcGIS.AuthenticationManager { get }

    /// Get the license details about the application.
    ///
    /// The license details includes the ``License/Status-swift.enum``, ``License/Level-swift.enum``, and ``License/Kind-swift.enum``
    /// values for the licensed application. It also contains the expiry date of the license or
    /// whether the provided license is perpetual.
    public static var license: ArcGIS.License { get }

    /// Determines if curve geometries are fetched from and sent to services that support them.
    ///
    /// By default, curve geometries are not fetched from services that support curves, meaning that densified
    /// versions of any curve geometries are fetched from the service. To instead fetch original geometries with
    /// curve segments (those where ``Geometry/hasCurves`` is `true`), set this property to
    /// ServiceCurveGeometryMode.fetchCurves. Ensure that you do this before any calls to services are made, as
    /// it cannot be changed after the first request has begun.
    ///
    /// By default, this API is not a `true` curve-enabled client when sending updates to services that
    /// support curves. This means that curve geometries stored in services where
    /// ``ArcGISFeatureServiceInfo/onlyAllowTrueCurveUpdatesByTrueCurveClients`` is `true` cannot be updated by
    /// default. To update such geometries, ensure your app correctly handles curve segments (where
    /// ``Segment/isCurve`` is `true`) in geometries throughout the workflow and set this property to
    /// ``ServiceCurveGeometryMode/trueCurveClient``. You must do this before any calls to services
    /// are made - it cannot be changed after making the first request.
    ///
    /// For details of curve support in services, see [ArcGIS REST API documentation](https://developers.arcgis.com/rest/services-reference/enterprise/get-started-with-the-services-directory.htm).
    ///
    /// For services that don't support curves, this value has no effect. It also has no effect on local data
    /// sources that may contain curve geometries, such as mobile geodatabases or mobile map packages
    /// created using ArcGIS Pro.
    ///
    /// Some geometry operations do not support curve geometries; see ``GeometryEngine`` for details of curve
    /// support. ``GeometryEditor`` and ``GeometryEditor`` do not support curve geometries.
    /// - Note: See Also: ``Geometry/hasCurves``
    public static var serviceCurveGeometryMode: ArcGIS.ServiceCurveGeometryMode

    /// License an application for deployment using license info.
    ///
    /// License an application for deployment using a license info for named-user access.
    /// A license info instance can be obtained from a portal for the current logged in user.
    /// The license info instance is only valid for 30 days so the user will be required to log into the portal
    /// again when this expires.
    /// - Parameter licenseInfo: The ``LicenseInfo`` used for named-user access.
    /// - Returns: The ``LicenseResult`` of the main license attempting to be set.
    @discardableResult
    public static func setLicense(from licenseInfo: ArcGIS.LicenseInfo) throws -> ArcGIS.LicenseResult

    /// License an application for deployment using an ESRI license string and extension license strings.
    ///
    /// License an application for deployment using an ESRI license string and one or more extension license strings.
    /// - Parameters:
    ///   - licenseKey: The lite, basic, standard, or advanced ESRI license string.
    ///   - extensions: An `Array` of extension license strings.
    /// - Returns: The ``LicenseResult`` of the main license attempting to be set.
    @discardableResult
    public static func setLicense(with licenseKey: ArcGIS.LicenseKey, extensions: [ArcGIS.LicenseKey] = []) throws -> ArcGIS.LicenseResult
}

extension ArcGISEnvironment {

    /// The session used by ArcGIS to make normal network requests.
    public static var urlSession: ArcGIS.ArcGISURLSession

    /// The session used by ArcGIS for making requests that can continue to execute while the
    /// application is in the background.
    public static var backgroundURLSession: ArcGIS.ArcGISURLSession

    /// The session used by ArcGIS for web socket connections.
    public static var webSocketURLSession: ArcGIS.ArcGISURLSession
}

/// An ArcGIS-specific error.
/// - Since: 200.1
public struct ArcGISError : Error {

    /// The type of error.
    public let code: Int

    /// A basic description for the error.
    public let description: String

    /// Details beyond the basic message about the error.
    public let details: String
}

extension ArcGISError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ArcGISError, b: ArcGIS.ArcGISError) -> Bool
}

/// An ArcGIS specific feature stored in an ``ArcGISFeatureTable``.
///
/// ArcGIS features are stored in ArcGIS specific data sources such as a ``GeodatabaseFeatureTable`` or
/// ``ServiceFeatureTable``. Since ``ArcGISFeature`` is a subclass of ``Feature``, it contains a geometry
/// that defines its location and shape, and a set of attributes that describe the real-world entity it
/// represents.
///
/// In addition, ``ArcGISFeature`` objects can also contain:
/// * Feature attachments such as images or documents, that can be edited, updated or deleted.
/// * Feature subtypes that define different default values or domains for fields.
/// * The ability to relate this feature to another ``ArcGISFeature``.
/// * Geometry that has m-values, which are typically used for linear referencing.
///
/// If you create a ``ServiceFeatureTable`` from the URL of a feature service, features in the
/// table are initially in one of the following states:
/// * A minimum set of attributes are available in the table, and m-values are omitted. This
///   is an optimization for faster rendering.
/// * All attributes defined by the service are available in the table, including m-values,
///   which might be `nan`.
///
/// The initial state of features is determined by the feature request mode of the table. For
/// important details, see ``FeatureRequestMode``.
///
/// By default, a query on ``ArcGISFeature`` objects in a minimum state returns them in the same state.
/// To access all attributes (or the m-values) of features returned by a query, you must load
/// the features. You can do one of the following:
/// * Call ``Loadable/load()`` on each feature.
/// * Call `ServiceFeatureTable.loadOrRefresh(_:)` and pass
///   a mutable array of the features to be loaded.
/// * Call `ServiceFeatureTable.queryFeatures(using:queryFeatureFields:)`
///   with the constant ``ServiceFeatureTable/QueryFeatureFields/loadAll``, which returns all features in a fully
///   loaded state.
///
/// For more information, see the class description for ``ServiceFeatureTable``.
/// - Note: See Also: ``Attachment``, ``FeatureSubtype``, ``RelationshipInfo``, ``ArcGISFeatureTable``.
/// - Since: 200.1
final public class ArcGISFeature : ArcGIS.Feature, ArcGIS.Loadable {

    /// Gets a collection of attachments on this feature. Attachments are returned in descending order based on their id.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public var attachments: [ArcGIS.Attachment] { get async throws }

    /// `true` if attachments on this feature can be edited, otherwise `false`.
    final public var canEditAttachments: Bool { get }

    /// `true` if the geometry of this feature can be edited, otherwise `false`.
    final public var canUpdateGeometry: Bool { get }

    /// Gets the corresponding ``FeatureSubtype`` for this feature.
    ///
    /// If this feature belongs to an ``ArcGISFeatureTable`` that defines an ``ArcGISFeatureTable/subtypeField``,
    /// a ``FeatureSubtype`` that matches ``FeatureSubtype/code`` with this feature's attribute value for subtype field
    /// is returned; otherwise, this will return `nil`.
    final public var subtype: ArcGIS.FeatureSubtype? { get }

    /// Adds a new attachment to this feature.
    /// - Parameters:
    ///   - name: The attachment name.
    ///   - contentType: The type of content.
    ///   - data: The attachment data.
    /// - Returns: An ``Attachment``.
    /// - Note: See Also: ``FeatureServiceSessionType``
    @discardableResult
    final public func addAttachment(named name: String, contentType: String, data: Data) async throws -> ArcGIS.Attachment

    /// Deletes the given attachment from this feature.
    /// - Parameter attachment: The attachment.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func deleteAttachment(_ attachment: ArcGIS.Attachment) async throws

    /// Deletes the given attachments from this feature.
    /// - Parameter attachments: An `Array` of ``Attachment``. Contents of the `Array` are copied.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func deleteAttachments(_ attachments: [ArcGIS.Attachment]) async throws

    /// Updates the given attachment of this feature.
    /// - Parameters:
    ///   - attachmentInfo: Information describing the attachment.
    ///   - name: The attachment name.
    ///   - contentType: The type of content.
    ///   - data: The attachment data.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func updateAttachment(_ attachmentInfo: ArcGIS.Attachment, name: String, contentType: String, data: Data) async throws

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension ArcGISFeature {

    /// Sets up a relationship between this feature and the provided feature based on the given `relationshipInfo`.
    /// - Throws: ``InvalidArgumentError`` when there is no existing relationship between the tables of the two features.
    /// - Throws: ``InvalidCallError`` when this feature has no associated feature table.
    /// - Throws: ``GeodatabaseError/databaseClosed`` when the associated geodatabase is closed.
    /// - Parameters:
    ///   - feature: The feature to which this feature should be related.
    ///   - relationshipInfo: The relationship info to use when relating the two features.
    final public func relate(to feature: ArcGIS.ArcGISFeature, using relationshipInfo: ArcGIS.RelationshipInfo? = nil) throws

    /// Removes the relationship between this feature and the provided feature.
    /// - Throws: ``InvalidArgumentError`` when there is no existing relationship between the features.
    /// - Throws: ``InvalidCallError`` when this feature has no associated feature table.
    /// - Throws: ``GeodatabaseError/databaseClosed`` when the associated geodatabase is closed.
    /// - Parameter feature: The feature from which this feature should remove its relationship.
    final public func unrelate(from feature: ArcGIS.ArcGISFeature) throws
}

/// An object that represents the service layer metadata for an ArcGIS Feature Layer.
/// - Since: 200.1
final public class ArcGISFeatureLayerInfo {

    /// `true` if the layer allows geometry updates.
    final public var allowsGeometryUpdates: Bool { get }

    /// The layer's attribution.
    final public var attribution: String { get }

    /// The layer's capabilities.
    final public var capabilities: ArcGIS.FeatureServiceCapabilities? { get }

    /// The layer's CIM version.
    final public var cimVersion: String { get }

    /// `true` if the layer has versioned data.
    final public var dataIsVersioned: Bool { get }

    /// The layer's default subtype code.
    final public var defaultSubtypeCode: Any? { get }

    /// The layer's description.
    final public var description: String { get }

    /// The layer's display field name.
    final public var displayFieldName: String { get }

    /// The layer's drawing info.
    final public var drawingInfo: ArcGIS.DrawingInfo? { get }

    /// The layer's edit fields info..
    final public var editFieldsInfo: ArcGIS.EditFieldsInfo? { get }

    /// The layer's effective max scale. If `nil`, there is no maximum.
    final public var effectiveMaxScale: Double? { get }

    /// The layer's effective min scale. If `nil`, there is no maximum.
    final public var effectiveMinScale: Double? { get }

    /// The layer's extent.
    final public var extent: ArcGIS.Envelope? { get }

    /// The layer's type.
    final public var featureServiceType: ArcGIS.ArcGISFeatureLayerInfoServiceType? { get }

    /// The layer's feature subtypes.
    final public var featureSubtypes: [ArcGIS.FeatureSubtype] { get }

    /// The layer's feature templates.
    final public var featureTemplates: [ArcGIS.FeatureTemplate] { get }

    /// The layer's feature types.
    final public var featureTypes: [ArcGIS.FeatureType] { get }

    /// The layer's field definitions.
    final public var fields: [ArcGIS.Field] { get }

    /// The layer's geometry type.
    final public var geometryType: ArcGIS.Geometry.Type? { get }

    /// The layer's global id field name.
    final public var globalIDFieldName: String { get }

    /// `true` if the layer has attachments.
    final public var hasAttachments: Bool { get }

    /// `true` if the layer has m ordinates.
    final public var hasM: Bool { get }

    /// `true` if the layer has z ordinates.
    final public var hasZ: Bool { get }

    /// `true` if the layer default visibility value.
    final public var isVisibleByDefault: Bool { get }

    /// The layer's max record count.
    final public var maxRecordCount: Int { get }

    /// The layer's max scale. If `nil`, there is no maximum.
    final public var maxScale: Double? { get }

    /// The layer's min scale. If `nil`, there is no minimum.
    final public var minScale: Double? { get }

    /// The layer's object id field name.
    final public var objectIDFieldName: String { get }

    /// The layer's ownership based access control.
    final public var ownershipBasedAccessControl: ArcGIS.OwnershipBasedAccessControlInfo? { get }

    /// A list of ``RelationshipInfo`` objects that describe this layer
    /// or table's relationship with another layer or table in the service.
    final public var relationshipInfos: [ArcGIS.RelationshipInfo] { get }

    /// The layer's ID.
    final public var serviceLayerID: Int { get }

    /// The layer's name.
    final public var serviceLayerName: String { get }

    /// The service type of this layer..
    final public var sourceServiceType: ArcGIS.ServiceType? { get }

    /// The layer's subtype field.
    final public var subtypeField: String { get }

    /// `true` if the layer supports advanced queries.
    final public var supportsAdvancedQueries: Bool { get }

    /// `true` if the layer supports OBAC for anonymous users.
    final public var supportsOBACForAnonymousUsers: Bool { get }

    /// `true` if the layer supports paginated queries (with a record count and offset).
    final public var supportsPagination: Bool { get }

    /// `true` if the layer supports queries for the extent of features meeting a specified criteria.
    final public var supportsQueryExtent: Bool { get }

    /// `true` if the layer supports rolling back changes on failure.
    final public var supportsRollbackOnFailureParameter: Bool { get }

    /// `true` if the layer supports statistical queries.
    final public var supportsStatistics: Bool { get }

    /// The layer's time info.
    final public var timeInfo: ArcGIS.LayerTimeInfo? { get }

    /// The layer's type id field name.
    final public var typeIDFieldName: String { get }

    /// The layer's URL.
    final public var url: URL { get }

    /// The layer's version.
    final public var version: String { get }

    /// The layer's default z value.
    final public var zDefault: Double { get }

    /// If the layer provides default z values.
    final public var zDefaultsAreEnabled: Bool { get }

    /// Gets a feature type with the given name.
    /// - Parameter name: The name.
    /// - Returns: A ``FeatureType``.
    final public func featureType(named name: String) -> ArcGIS.FeatureType?

    /// Returns the field definition of the given field name.
    /// - Parameter fieldName: The field name.
    /// - Returns: A ``Field``.
    final public func field(named fieldName: String) -> ArcGIS.Field?
}

/// The type of the dataset underlying an ``ArcGISFeatureLayerInfo``.
///
/// This is used to determine the type of the dataset behind an ``ArcGISFeatureLayerInfo``.
/// Spatial datasets are considered to be layers whereas non-spatial datasets are tables.
/// - Since: 200.1
public enum ArcGISFeatureLayerInfoServiceType {

    /// A feature layer.
    ///
    /// Containing geometrical features such as a points, lines or polygons.
    case layer

    /// A feature table.
    case table

    /// A group layer.
    case groupLayer

    /// An annotation layer.
    ///
    /// Containing text features to be drawn at specific positions.
    case annotationLayer

    /// A dimension layer.
    ///
    /// Containing schematic measurement features to be drawn at specific positions.
    case dimensionLayer

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ArcGISFeatureLayerInfoServiceType, b: ArcGIS.ArcGISFeatureLayerInfoServiceType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ArcGISFeatureLayerInfoServiceType : Equatable {
}

extension ArcGISFeatureLayerInfoServiceType : Hashable {
}

/// An object that represents the service metadata for an ArcGIS Feature Service.
/// - Since: 200.1
final public class ArcGISFeatureServiceInfo {

    /// `true` if the service allows geometry updates.
    final public var allowsGeometryUpdates: Bool { get }

    /// `true` if the service allows curve geometries to be updated.
    ///
    /// This property can only be `true` if ``supportsTrueCurve`` is `true`.
    ///
    /// If this property is `true` and ``onlyAllowTrueCurveUpdatesByTrueCurveClients`` is
    /// `false`, features with curve geometries can be updated by any client. This includes cases where the client
    /// provides a densified geometry to update the curve geometry.
    ///
    /// By default, this API is not a `true` curve-enabled client. Use
    /// ``ArcGISEnvironment/serviceCurveGeometryMode`` to change this behavior.
    /// - Note: See Also: ``supportsTrueCurve``, ``onlyAllowTrueCurveUpdatesByTrueCurveClients``
    final public var allowsTrueCurveUpdates: Bool { get }

    /// The service's attribution.
    final public var attribution: String { get }

    /// The service's description.
    final public var description: String { get }

    /// The service's document info.
    final public var documentInfo: ArcGIS.ServiceDocumentInfo? { get }

    /// The service's editor tracking info.
    final public var editorTrackingInfo: ArcGIS.EditorTrackingInfo? { get }

    /// The service's capabilities.
    final public var featureServiceCapabilities: ArcGIS.FeatureServiceCapabilities { get }

    /// The service's full extent.
    final public var fullExtent: ArcGIS.Envelope? { get }

    /// `true` if the service has static data.
    final public var hasStaticData: Bool { get }

    /// `true` if the service has sync enabled.
    final public var hasSyncEnabled: Bool { get }

    /// `true` if the service has versioned data.
    final public var hasVersionedData: Bool { get }

    /// The service's initial extent.
    final public var initialExtent: ArcGIS.Envelope? { get }

    /// The service's layers.
    ///
    /// The ``IDInfo`` provides basic layer metadata.
    /// Each ``IDInfo`` can be cast to a ``FeatureServiceLayerIDInfo`` for more detailed metadata.
    final public var layerInfos: [ArcGIS.IDInfo] { get }

    /// The service's max record count.
    final public var maxRecordCount: Int { get }

    /// `true` if the service only allows curve geometries to be updated by client code that identifies itself as a
    /// `true` curve-enabled client, indicating that client editing workflows account for curve segments correctly.
    ///
    /// This property can only be `true` if ``allowsTrueCurveUpdates`` is `true`.
    ///
    /// By default, this API is not a `true` curve-enabled client. Use
    /// ``ArcGISEnvironment/serviceCurveGeometryMode`` to change this behavior.
    /// - Note: See Also: ``supportsTrueCurve``, ``allowsTrueCurveUpdates``
    final public var onlyAllowTrueCurveUpdatesByTrueCurveClients: Bool { get }

    /// The service's service description.
    final public var serviceDescription: String { get }

    /// The service's spatial reference.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// `true` if the service supports disconnected editing.
    final public var supportsDisconnectedEditing: Bool { get }

    /// `true` if the service supports curve segments in feature geometries.
    ///
    /// Some services support storing feature geometries with curve segments. By default, these services return
    /// densified versions of the feature geometries instead. Use
    /// ``ArcGISEnvironment/serviceCurveGeometryMode`` to change this behavior.
    /// - Note: See Also: ``allowsTrueCurveUpdates``,
    /// ``onlyAllowTrueCurveUpdatesByTrueCurveClients``
    final public var supportsTrueCurve: Bool { get }

    /// The service's sync capabilities.
    final public var syncCapabilities: ArcGIS.SyncCapabilities? { get }

    /// The service's tables.
    final public var tableInfos: [ArcGIS.IDInfo] { get }

    /// Units used by the service.
    final public var unit: ArcGIS.Unit { get }

    /// The service's URL.
    final public var url: URL? { get }

    /// The service's current version.
    final public var version: String { get }

    /// The service's default z value.
    final public var zDefault: Double { get }

    /// `true` if the service defaults z values.
    final public var zDefaultsAreEnabled: Bool { get }
}

/// A table of features that typically represents real-world objects created from an ArcGIS feature service or an ArcGIS geodatabase.
///
/// This is the base class for the ArcGIS specific feature tables ``GeodatabaseFeatureTable`` and
/// ``ServiceFeatureTable``. You can create instances of these subclasses using their constructors.
///
/// If the ``FeatureTable/hasGeometry`` is `true`, you can display the features in a ``Map`` or ``Scene``. To do
/// this create a ``FeatureLayer`` from the feature table and add it to the map or scene's collection of operational
/// layers (``GeoModel/operationalLayers``). The ``ArcGISFeatureTable`` can also contain features that do not have a
/// geometry (``FeatureTable/hasGeometry`` is `false`).
///
/// ``ArcGISFeatureTable`` provides methods for querying related features (for example,
/// ArcGISFeatureTable.queryRelatedFeaturesAsync(ArcGISFeature)), and methods to create new features based on a
/// ``FeatureSubtype`` or a ``FeatureTemplate``.
/// - Since: 200.1
public class ArcGISFeatureTable : ArcGIS.FeatureTable {

    /// Returns the features added since the last sync.
    ///
    /// For mobile geodatabases created by ArcGIS Pro, this method returns no
    /// features because there is no concept of syncing.
    public var addedFeatures: ArcGIS.FeatureQueryResult { get async throws }

    /// Returns the number of features added since the last sync.
    ///
    /// For mobile geodatabases created by ArcGIS Pro, this method returns 0
    /// because there is no concept of syncing.
    public var addedFeaturesCount: Int { get async throws }

    /// The table's contingent values definition.
    ///
    /// The contingent values definition must be loaded after the table has loaded.
    /// If the list of field groups is empty after loading, then no contingent values
    /// are defined for this table.
    public var contingentValuesDefinition: ArcGIS.ContingentValuesDefinition { get }

    /// The table's default subtype code.
    public var defaultSubtypeCode: Any? { get }

    /// Returns the features deleted since the last sync.
    ///
    /// For mobile geodatabases created by ArcGIS Pro, this method returns no
    /// features because there is no concept of syncing.
    public var deletedFeatures: ArcGIS.FeatureQueryResult { get async throws }

    /// Returns the number of features deleted since the last sync.
    ///
    /// For mobile geodatabases created by ArcGIS Pro, this method returns 0
    /// because there is no concept of syncing.
    public var deletedFeaturesCount: Int { get async throws }

    /// A list of editable fields.
    public var editableAttributeFields: [ArcGIS.Field] { get }

    /// The table's feature subtypes.
    public var featureSubtypes: [ArcGIS.FeatureSubtype] { get }

    /// A list of the feature templates on this table.
    public var featureTemplates: [ArcGIS.FeatureTemplate] { get }

    /// The feature types for this table.
    public var featureTypes: [ArcGIS.FeatureType] { get }

    /// The global id field name.
    public var globalIDField: String { get }

    /// `true` if the features in this table have attachments, `false` otherwise.
    public var hasAttachments: Bool { get }

    /// Checks whether the feature table has local edits
    ///
    /// For ``ServiceFeatureTable``, local edits are edits that have not yet
    /// been applied to the feature service.  For ``GeodatabaseFeatureTable``,
    /// local edits are edits that have been made since the last acknowledged
    /// upload. For mobile geodatabases created by ArcGIS Pro, this method
    /// returns `false` because there is no concept of uploading or applying edits.
    /// For mobile geodatabases, use `GeodatabaseFeatureTable.hasLocalEdits(since:)`.
    ///
    /// When a table is not change tracked, it will throw a
    /// `CoreErrorCode.geodatabaseChangeTrackingNotEnabled`.
    public var hasLocalEdits: Bool { get }

    /// The service information related to the feature layer.
    ///
    /// Explore the editing capabilities of this feature table with ``ArcGISFeatureLayerInfo/capabilities`` or the
    /// editor tracked fields with ``ArcGISFeatureLayerInfo/editFieldsInfo``.
    public var layerInfo: ArcGIS.ArcGISFeatureLayerInfo? { get }

    /// Returns all the features that were added, updated or deleted since the last sync.
    ///
    /// Returns a result object containing a feature edit iterator. For mobile geodatabase
    /// created by ArcGIS Pro, the iterator in the result object is empty because there
    /// is no concept of syncing.
    ///
    /// Note that edits inside a transaction (between calls to `Geodatabase.beginTransaction()`
    /// and either `Geodatabase.commitTransaction()` or `Geodatabase.rollbackTransaction()`)
    /// share a common ``LocalFeatureEdit/editDate`` and may not be returned in a consistent
    /// order.
    public var localEdits: ArcGIS.LocalFeatureEditsResult { get async throws }

    /// Returns the number of features that were added, updated or deleted since the last sync.
    ///
    /// For mobile geodatabases created by ArcGIS Pro, this method returns a count of 0 because
    /// there is no concept of syncing.
    public var localEditsCount: Int { get async throws }

    /// The object id field name.
    public var objectIDField: String { get }

    /// Returns a list of all related tables that have been added to the map.
    ///
    /// Only returns tables that have been added to the map that this table is associated with.
    public var relatedTables: [ArcGIS.ArcGISFeatureTable] { get }

    /// The layer ID in the feature service that this table was created from.
    public var serviceLayerID: Int { get }

    /// The table's subtype field.
    public var subtypeField: String { get }

    /// The type id field name.
    public var typeIDField: String { get }

    /// Returns the features updated since the last sync.
    ///
    /// For mobile geodatabases created by ArcGIS Pro, this method returns no
    /// features because there is no concept of syncing.
    public var updatedFeatures: ArcGIS.FeatureQueryResult { get async throws }

    /// Returns the number of features updated since the last sync.
    ///
    /// For mobile geodatabases created by ArcGIS Pro, this method returns 0
    /// because there is no concept of syncing.
    public var updatedFeaturesCount: Int { get async throws }

    /// The username of the feature table.
    ///
    /// The username is used for ownership-based access control (OBAC) and editor tracking purposes.
    public var username: String { get }

    /// `true` if the table is using advanced symbology, `false` otherwise.
    public var usesAdvancedSymbology: Bool

    /// Returns possible values for the specified field, in the context of defined contingencies.
    ///
    /// This method iterates over all the field groups that the input field participates in. For each, it looks
    /// at the input feature's field values for the other fields participating in that field group. Contingencies
    /// that are satisfied by the other fields are identified, and their values for the input field are aggregated.
    /// These are returned in a ``ContingentValuesResult``, which contains a dictionary of field group names to an
    /// array of ``ContingentValue`` objects accessed via ``ContingentValuesResult/contingentValuesByFieldGroup``,
    /// specifying possible values for the input field that will satisfy a contingency in that field group. If the
    /// feature participates in multiple field groups and there are values that will satisfy all groups, they will
    /// be returned by ``ContingentValuesResult/contingentValuesAllGroups``.
    /// - Parameters:
    ///   - feature: The feature.
    ///   - field: The name of the field for which to get possible values.
    /// - Returns: A ``ContingentValuesResult``.
    public func contingentValues(with feature: ArcGIS.ArcGISFeature, forFieldNamed field: String) -> ArcGIS.ContingentValuesResult?

    /// Searches for the feature template with the given name.
    /// - Parameter name: The name.
    /// - Returns: A ``FeatureTemplate``.
    public func featureTemplate(named name: String) -> ArcGIS.FeatureTemplate?

    /// Searches for the feature type with the given name.
    /// - Parameter name: The name.
    /// - Returns: A ``FeatureType``.
    public func featureType(named name: String) -> ArcGIS.FeatureType?

    /// Creates a new feature based on the provided feature subtype and geometry.
    /// - Parameters:
    ///   - subtype: The feature subtype.
    ///   - geometry: The geometry.
    /// - Returns: An ``ArcGISFeature``.
    /// - Precondition: `loadStatus == .loaded`
    public func makeFeature(subtype: ArcGIS.FeatureSubtype, geometry: ArcGIS.Geometry? = nil) -> ArcGIS.ArcGISFeature

    /// Creates a new feature based on the provided feature template and geometry.
    /// - Parameters:
    ///   - template: The feature template.
    ///   - geometry: The geometry.
    /// - Returns: An ``ArcGISFeature``.
    /// - Precondition: `loadStatus == .loaded`
    public func makeFeature(template: ArcGIS.FeatureTemplate, geometry: ArcGIS.Geometry? = nil) -> ArcGIS.ArcGISFeature

    /// Creates a new feature based on the provided feature type and geometry.
    /// - Parameters:
    ///   - type: Type of the feature.
    ///   - geometry: The geometry.
    /// - Returns: An ``ArcGISFeature``.
    /// - Precondition: `loadStatus == .loaded`
    public func makeFeature(type: ArcGIS.FeatureType, geometry: ArcGIS.Geometry? = nil) -> ArcGIS.ArcGISFeature

    /// Returns list of tables related by the given relationship info.
    ///
    /// Only returns tables that have been added to the map. If there are multiple
    /// instances of the related table on the map, all such instances will be
    /// returned.
    /// - Parameter relationshipInfo: The relationship info.
    /// - Returns: `Array` of ``ArcGISFeatureTable``
    public func relatedTables(by relationshipInfo: ArcGIS.RelationshipInfo) -> [ArcGIS.ArcGISFeatureTable]

    /// Returns an array of contingency constraint violations based on the input feature. An empty
    /// array indicates that all contingencies associated with the feature are valid.
    /// - Parameter feature: The feature.
    /// - Returns: An array of ``ContingencyConstraintViolation``.
    public func validateContingencyConstraints(for feature: ArcGIS.ArcGISFeature) -> [ArcGIS.ContingencyConstraintViolation]

    /// Validates constraints for a given feature participating in a relationship.
    ///
    /// The following are considered violations:
    /// * In a composite relationship, adding an orphan feature to the destination table
    ///   without relating it to an origin feature
    /// * Cardinality Violations:
    ///   - In 1:1 relationships, if an origin feature is already related to a destination
    ///     feature, relating another feature to either of them
    ///   - In 1:n relationships, relating a destination feature to more than one origin
    ///     feature
    ///
    /// To recover from an orphaned destination feature violation, simply relate it to a valid origin feature, using `ArcGISFeature.relate(to:using:)`.
    /// You can usually recover from a cardinality violation by removing the relationship between the
    /// appropriate features, using `ArcGISFeature.unrelate(from:)`
    ///
    /// Note that edit operations do not error when there are constraint violations. This allows you to recover from violations in a back office operation after applying edits or syncing,
    /// if you choose to do so. See ArcGIS Desktop [Validate Features](https://desktop.arcgis.com/en/arcmap/10.3/manage-data/editing-attributes/validating-features-and-relationships-in-arcmap.htm) process here.
    ///
    /// Note: This method makes network calls to query for the related features if they are not present locally. If you have just related the feature you are
    /// validating, you need to first call `FeatureTable.update(_:)` to reflect the modified attribute value in the table. If this is not done, validation
    /// results may be incorrect.
    /// - Parameter feature: The feature.
    /// - Returns: A task that represents the asynchronous validation of relationship constraints operation. The value
    /// of the task result contains a ``RelationshipConstraintViolationType`` object.
    public func validateRelationshipConstraints(for feature: ArcGIS.ArcGISFeature) async throws -> ArcGIS.RelationshipConstraintViolationType

    override public func load() async throws
}

extension ArcGISFeatureTable {

    /// Unknown data from the source JSON.
    /// - Remark: Unknown JSON is a dictionary of values that was in the source JSON but was unparsed by this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    public var _unknownJSON: [String : Any] { get }

    /// Unsupported data from the source JSON.
    /// - Remark: Unsupported JSON is a dictionary of values that are supported by web maps, but not exposed through this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    public var _unsupportedJSON: [String : Any] { get }

    /// Performs a query that returns the number of related features to the supplied feature based on the parameters.
    /// - Parameters:
    ///   - feature: The feature which should be queried for the number of related features.
    ///   - parameters: The parameters to the query.
    /// - Returns: The related feature count.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func queryRelatedFeatureCount(to feature: ArcGIS.ArcGISFeature, using parameters: ArcGIS.RelatedQueryParameters? = nil) async throws -> Int

    /// Queries for related features of a given feature in a specific relationship.
    /// - Remark: The origin and all destination tables must be associated with the same
    /// map, either as a feature source for a layer or added to the map via
    /// its table collection. Otherwise, the query will return no results.
    /// - Parameters:
    ///   - feature: The feature for which to query related features.
    ///   - parameters: The parameters that describe the relationship and the query to perform.
    /// - Returns: An array of the related feature query results.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func queryRelatedFeatures(to feature: ArcGIS.ArcGISFeature, using parameters: ArcGIS.RelatedQueryParameters? = nil) async throws -> [ArcGIS.RelatedFeatureQueryResult]
}

/// An object that represents service metadata for an ArcGIS Image Service
/// - Since: 200.1
final public class ArcGISImageServiceInfo {

    /// The list of raster pixel types.
    public enum PixelType {

        /// 1-bit.
        case uint1

        /// 2-bit.
        case uint2

        /// 4-bit.
        case uint4

        /// Unsigned 8-bit integer.
        case uint8

        /// Signed 8-bit integer.
        case int8

        /// Unsigned 16-bit integer.
        case uint16

        /// Signed 16-bit integer.
        case int16

        /// Unsigned 32-bit integer.
        case uint32

        /// Signed 32-bit integer.
        case int32

        /// 32-bit floating point number.
        case float32

        /// 64-bit floating point number.
        case float64

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ArcGISImageServiceInfo.PixelType, b: ArcGIS.ArcGISImageServiceInfo.PixelType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Copyright information from image service info object.
    final public var attribution: String { get }

    /// Current version from image service info object.
    final public var currentVersion: String { get }

    /// Optional mosaic dataset catalog table fields from image service info object.
    final public var fields: [ArcGIS.Field] { get }

    /// Full extent from image service info object.
    final public var fullExtent: ArcGIS.Envelope? { get }

    /// Max scale value from image service info object. If `nil`, there is no maximum.
    final public var maxScale: Double? { get }

    /// Min scale value from image service info object. If `nil`, there is no minimum.
    final public var minScale: Double? { get }

    /// Name from image service info object.
    final public var name: String { get }

    /// Pixel type from image service info object.
    final public var pixelType: ArcGIS.ArcGISImageServiceInfo.PixelType? { get }

    /// Rendering rules from image service info object.
    final public var renderingRuleInfos: [ArcGIS.RenderingRuleInfo] { get }

    /// Spatial reference from image service info object.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The time info from the image service.
    final public var timeInfo: ArcGIS.LayerTimeInfo? { get }

    /// URL from image service info object.
    final public var url: URL { get }
}

extension ArcGISImageServiceInfo.PixelType : Equatable {
}

extension ArcGISImageServiceInfo.PixelType : Hashable {
}

/// Displays data from an ArcGIS Map service by using dynamically generated map images.
///
/// Functional characteristics
/// Map images are created and returned by the server on every request, so they always show
/// the latest data at the time of the request. Characteristics of the image, such as
/// ``ImageAdjustmentLayer/brightness``, ``ImageAdjustmentLayer/contrast``,
/// ``ImageAdjustmentLayer/gamma``, and ``Layer/opacity`` can be specified. By obtaining
/// the associated sub-layers of the ``ArcGISMapImageLayer`` using the
/// ``mapImageSublayers`` property, you can control if each sub-layer is
/// ``ArcGISSublayer/isVisible`` and filter the data via the
/// ``ArcGISSublayer/definitionExpression``. Also, the
/// ``Layer/spatialReference`` can be changed from the service's default and the service
/// will reproject each image on the fly.
///
/// The underlying ``ServiceFeatureTable``, for each map image sub-layer or for
/// non-spatial tables used in the service, can be accessed via the
/// ``tables`` property. These tables can be queried using any
/// valid combination of attribute, spatial, and temporal criteria via the numerous
/// query methods. You can also query for
/// `FeatureTable.queryStatistics(using:)` to see summary
/// statistics or to find related features in other tables via the numerous
/// query methods.
///
/// If you want the background color for the map image to be transparent, make sure the
/// ``imageFormat`` is set to PNG.
///
/// Performance characteristic
/// The map service creates map images on the fly. Rendering time depends on the amount
/// and complexity of the data in the map. This will typically be slower than fetching the
/// equivalent map as prerendered (or cached) tiles via an ``ArcGISTiledLayer``. Because the
/// server renders the map, map image layers require less processing time on the client than
/// similar maps rendered locally.
///
/// ArcGIS map image layers are good candidates for showing features that change periodically,
/// or that require filtering by the user. Although rendering occurs on the server, the
/// client has access to service feature tables for all sublayers (as well as non-spatial
/// tables and relationships).
/// - Note: See Also: ``Layer``, ``ImageAdjustmentLayer``
/// - Since: 200.1
final public class ArcGISMapImageLayer : ArcGIS.ImageAdjustmentLayer, ArcGIS.TimeAware {

    /// Creates a map image layer object from an item.
    /// - Parameter item: An ``Item`` (only ``PortalItem`` are supported).
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// Creates a map image layer object.
    ///
    /// If the specified URI is a portal item URL (see ``PortalItem/init(url:)`` for the supported URL formats), the underlying ``PortalItem`` will be created and accessible through ``Layer/item``.
    /// - Parameter url: The URI to the service or to a map service portal item.
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(url: URL)

    /// The geodatabase version of the map image layer.
    final public var geodatabaseVersion: String

    /// The image format of the map image layer.
    ///
    /// If set to ``MapServiceImageFormat/default``, the default image format is defined by the service.
    final public var imageFormat: ArcGIS.MapServiceImageFormat?

    /// The sublayers of a map image layer.
    ///
    /// The collection is specific to a layer so you can't reuse a sublayer collection coming from another ``ArcGISMapImageLayer`` or ``ArcGISSublayer``.
    /// You have to create a new layer collection by using `Array.init(valueType:)`.
    /// - Note: See Also: ``ArcGISSublayer``, `Array`, `Array.init(valueType:)`, ``ArcGISSublayer/sublayers``
    final public var mapImageSublayers: [ArcGIS.ArcGISMapImageSublayer] { get }

    /// Adds a sequence of `ArcGISMapImageSublayer` values to the end of the `mapImageSublayers` property.
    /// - Parameter newMapImageSublayers: The new `ArcGISMapImageSublayer` values to append.
    final public func addMapImageSublayers<S>(_ newMapImageSublayers: S) where S : Sequence, S.Element == ArcGIS.ArcGISMapImageSublayer

    /// Adds an `ArcGISMapImageSublayer` value to the end of the `mapImageSublayers` property.
    /// - Parameter newMapImageSublayer: The new `ArcGISMapImageSublayer` value to append.
    final public func addMapImageSublayer(_ newMapImageSublayer: ArcGIS.ArcGISMapImageSublayer)

    /// Inserts a collection of `ArcGISMapImageSublayer` values into the `mapImageSublayers` property at the specified position.
    /// - Parameters:
    ///   - newMapImageSublayers: The new `ArcGISMapImageSublayer` values to insert.
    ///   - index: The position at which to insert the new `ArcGISMapImageSublayer` values.
    final public func insertMapImageSublayers<C>(_ newMapImageSublayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.ArcGISMapImageSublayer

    /// Inserts an `ArcGISMapImageSublayer` value into the `mapImageSublayers` property at the specified position.
    /// - Parameters:
    ///   - newMapImageSublayer: The new `ArcGISMapImageSublayer` value to insert.
    ///   - index: The position at which to insert the new `ArcGISMapImageSublayer` value.
    final public func insertMapImageSublayer(_ newMapImageSublayer: ArcGIS.ArcGISMapImageSublayer, at index: Int)

    /// Removes all values from the `mapImageSublayers` property.
    final public func removeAllMapImageSublayers()

    /// Removes a sequence of `ArcGISMapImageSublayer` values from the `mapImageSublayers` property.
    /// - Parameter mapImageSublayers: The `ArcGISMapImageSublayer` values to remove.
    final public func removeMapImageSublayers<S>(_ mapImageSublayers: S) where S : Sequence, S.Element == ArcGIS.ArcGISMapImageSublayer

    /// Removes an `ArcGISMapImageSublayer` value from the `mapImageSublayers` property.
    /// - Parameter mapImageSublayer: The `ArcGISMapImageSublayer` value to remove.
    final public func removeMapImageSublayer(_ mapImageSublayer: ArcGIS.ArcGISMapImageSublayer)

    /// The map service information.
    final public var mapServiceInfo: ArcGIS.ArcGISMapServiceInfo? { get }

    /// A list of tables in the map image layer.
    ///
    /// The collection is specific to this map image layer.
    /// Tables are not loaded by default. Tables are loaded internally when
    /// asynchronous operations like query are performed. Alternatively, they can
    /// be loaded by calling ``FeatureTable/load()``.
    /// - Note: See Also: ``FeatureTable``
    final public var tables: [ArcGIS.ServiceFeatureTable] { get }

    /// The URI of the map service.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:)``
    final public var url: URL? { get }

    /// Loads all of the map service's sublayers and non spatial tables.
    final public func loadTablesAndLayers() async throws

    /// Resets the sublayers of a map image layer to the default values defined by the service.
    ///
    /// After this call, any changes to the sublayers (either by using an ArcGISMapImageSublayer setter or
    /// by changing the sublayer collections) are lost. The sublayer hierarchy returns to its initial state
    /// (defined by the service) and image requests to display the layer will no longer use the dynamic layer
    /// capabilities of the service.
    /// - Note: See Also: ``ArcGISSublayer/sublayers``
    final public func resetSublayers()

    /// The full time extent of the object.
    @ArcGIS.Streamed final public var fullTimeExtent: ArcGIS.TimeExtent? { get }

    final public var $fullTimeExtent: AsyncStream<ArcGIS.TimeExtent?> { get }

    /// A flag indicating whether the object supports filtering its contents by time values with the extent set on the owning `GeoView`.
    final public var supportsTimeFiltering: Bool { get }

    /// A flag indicating whether the object must use the time extent defined on the owning `GeoView` to filter its data.
    final public var timeFilteringIsEnabled: Bool

    /// The suggested time slider step size for this time aware object.
    ///
    /// Can be `nil` if no time interval is suggested for this time aware object.
    final public var timeInterval: ArcGIS.TimeValue? { get }

    /// The time offset applied to this object.
    /// The offset is subtracted from the time extent set on the owning `GeoView`.
    /// This allows for data from different periods of time to be compared.
    final public var timeOffset: ArcGIS.TimeValue?

    override final public func load() async throws
}

/// An ArcGIS map image sublayer.
///
/// ``ArcGISMapImageLayer`` displays maps from an ArcGIS map server. Each layer in the underlying map service
/// is represented by an ``ArcGISSublayer``. You can control the visibility and symbols of sublayers and
/// filter data with layer definition expressions.
///
/// You can get this object from ``ArcGISMapImageLayer/mapImageSublayers`` once the map image layer is loaded
/// or you can get a collection of handles from another map image sublayer by using ``ArcGISSublayer/sublayers``.
/// You can also create a new sublayer from ``init(id:source:)``.
/// - Note: See Also: ``ArcGISSublayer``, ``ArcGISMapImageLayer/mapImageSublayers``, ``ArcGISSublayer/sublayers``, ``init(id:source:)``
/// - Since: 200.1
final public class ArcGISMapImageSublayer : ArcGIS.ArcGISSublayer {

    /// The map image sublayer's definition expression.
    ///
    /// The definition expression string uses the SQL-92 where clause syntax
    /// (https://en.wikipedia.org/wiki/SQL-92). Be sure to escape special characters
    /// in the expression string as required for your platform. The DATE keyword expects
    /// the date format yyyy-mm-dd and the TIMESTAMP keyword expects the time stamp format
    /// yyyy-mm-dd hh:mm:ss. See the ArcGIS Blog article entitled "Querying Feature Services
    /// Date-Time Queries"
    /// (https://www.esri.com/arcgis-blog/products/api-rest/data-management/querying-feature-services-date-time-queries/)
    /// for more information.
    override final public var definitionExpression: String

    /// The sublayer's default visibility.
    ///
    /// The sublayer default visibility.
    final public var isVisibleByDefault: Bool { get }

    /// The collection of ``LabelDefinition`` objects for this layer.
    final public var labelDefinitions: [ArcGIS.LabelDefinition] { get }

    /// Adds a sequence of `LabelDefinition` values to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinitions: The new `LabelDefinition` values to append.
    final public func addLabelDefinitions<S>(_ newLabelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Adds a `LabelDefinition` value to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinition: The new `LabelDefinition` value to append.
    final public func addLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition)

    /// Inserts a collection of `LabelDefinition` values into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinitions: The new `LabelDefinition` values to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` values.
    final public func insertLabelDefinitions<C>(_ newLabelDefinitions: C, at index: Int) where C : Collection, C.Element == ArcGIS.LabelDefinition

    /// Inserts a `LabelDefinition` value into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinition: The new `LabelDefinition` value to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` value.
    final public func insertLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition, at index: Int)

    /// Removes all values from the `labelDefinitions` property.
    final public func removeAllLabelDefinitions()

    /// Removes a sequence of `LabelDefinition` values from the `labelDefinitions` property.
    /// - Parameter labelDefinitions: The `LabelDefinition` values to remove.
    final public func removeLabelDefinitions<S>(_ labelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Removes a `LabelDefinition` value from the `labelDefinitions` property.
    /// - Parameter labelDefinition: The `LabelDefinition` value to remove.
    final public func removeLabelDefinition(_ labelDefinition: ArcGIS.LabelDefinition)

    /// The map image sublayer's flag indicating whether the sublayer's labels are enabled/disabled.
    override final public var labelsAreEnabled: Bool

    /// The map image sublayer's maximum scale. If `nil`, there is no maximum.
    override final public var maxScale: Double?

    /// The map image sublayer's minimum scale. If `nil`, there is no minimum.
    override final public var minScale: Double?

    /// The map image sublayer's name.
    override final public var name: String

    /// The map image sublayer's opacity.
    override final public var opacity: Float

    /// The map image sublayer's renderer.
    override final public var renderer: ArcGIS.Renderer?

    /// The map image sublayer's flag indicating whether the sublayer renders its symbols based on scale.
    override final public var scalesSymbols: Bool

    /// The sublayer's source.
    ///
    /// The sublayer source.
    final public var source: ArcGIS.SublayerSource? { get }

    /// The sublayer's feature table.
    ///
    /// This only applies to sublayers of type "Feature layer" or "Table". This method returns
    /// `nil` if the sublayer has not been loaded.
    final public var table: ArcGIS.ServiceFeatureTable? { get }
}

extension ArcGISMapImageSublayer {

    /// Creates a map image sublayer with the specified ID and a sublayer source.
    ///
    /// Only map services that support dynamic layers will be able to manage sublayers with sublayer sources.
    /// - Parameters:
    ///   - id: The sublayer ID.
    ///   - source: The sublayer source.
    /// - Precondition: `id >= 0`.
    public convenience init(id: Int, source: ArcGIS.SublayerSource? = nil)
}

/// Represents the map service metadata for an ArcGIS Map Service.
/// - Since: 200.1
final public class ArcGISMapServiceInfo : ArcGIS.JSONSerializable {

    /// Whether exporting tiles in compact version 2 format (.tpkx) is supported.
    ///
    /// The export tile cache compact version 2 (.tpkx) format now supersedes the compact (.tpk) format across
    /// ArcGIS software. For more information, see ``TileCache/StorageFormat-swift.enum/compactV2``.
    ///
    /// If this property is `true`, the map service supports exporting tiles as .tpkx format. If this property is
    /// `false`, the service does not support exporting .tpkx format, and you should check
    /// ``allowsExportTiles`` to confirm whether it supports exporting the earlier .tpk format
    /// version.
    ///
    /// ArcGIS Server/Enterprise ``currentVersion``, 10.9 or greater, supports exporting tiles
    /// as .tpkx. Compact V2 tile caches can also be exported from export-enabled Esri image basemaps and elevation
    /// services hosted on ArcGIS Online. For more details on the specification of a .tpkx file format, see
    /// https://github.com/Esri/tile-package-spec.
    /// - Note: See Also: ``TileCache/StorageFormat-swift.enum``
    final public var allowsExportTileCacheCompactV2: Bool { get }

    /// Whether exporting tiles in compact format (.tpk) is supported.
    ///
    /// This property indicates whether the map service supports exporting tiles as compact (.tpk) format. Exporting
    /// tiles allows you to use them as a basemap, operational layer, or elevation source, without network connectivity. See
    /// ``TileCache`` for information on creating a layer from a local tile cache.
    ///
    /// To export tiles, you can use either the ``ExportTileCacheTask`` or the ``OfflineMapTask``.
    ///
    /// There are two formats for exporting a tile cache:
    /// * Compact (.tpk) is the legacy format for a tile cache. All services that support
    /// exporting tiles, support the .tpk format. See ``TileCache/StorageFormat-swift.enum/compact``
    /// * Compact V2 (.tpkx) is the latest format used for exporting tiles. Check
    /// ``allowsExportTileCacheCompactV2`` to confirm whether the service
    /// supports this format.
    /// - Note: See Also: ``TileCache/StorageFormat-swift.enum``
    final public var allowsExportTiles: Bool { get }

    /// The copyright text.
    final public var attribution: String { get }

    /// The map service's capabilities.
    final public var capabilities: ArcGIS.MapServiceCapabilities { get }

    /// The current version of the ArcGIS map service.
    final public var currentVersion: String { get }

    /// The description.
    final public var description: String { get }

    /// The document information which includes title, author and comments among other things.
    final public var documentInfo: ArcGIS.ServiceDocumentInfo? { get }

    /// The full extent of the layer.
    final public var fullExtent: ArcGIS.Envelope? { get }

    /// `true` if the  ArcGIS map service has a single fused map cache, `false` otherwise.
    final public var hasSingleFusedMapCache: Bool { get }

    /// The initial extent of the layer.
    final public var initialExtent: ArcGIS.Envelope? { get }

    /// The service's layers.
    final public var layerInfos: [ArcGIS.IDInfo] { get }

    /// The name of the map.
    final public var mapName: String { get }

    /// The maximum number of tiles that can be exported.
    final public var maxExportTilesCount: Int { get }

    /// The max image height in pixels.
    final public var maxImageHeight: Int { get }

    /// The max image width in pixels.
    final public var maxImageWidth: Int { get }

    /// The maximum number of records that will be returned at once for a query.
    final public var maxRecordCount: Int { get }

    /// The layers's max scale. If `nil`, there is no maximum.
    final public var maxScale: Double? { get }

    /// The layers's min scale. If `nil`, there is no minimum.
    final public var minScale: Double? { get }

    /// The ArcGIS map service description.
    final public var serviceDescription: String { get }

    /// The type of this ArcGIS service.
    final public var serviceSourceType: ArcGIS.ServiceType? { get }

    /// The spatial reference of the map service.
    /// - Note: See Also: ``SpatialReference``
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The image format types supported by this layer when generating a map image.
    ///
    /// An `Array` of `String`
    /// - Note: See Also: `Array`, `String`
    final public var supportedImageFormatTypes: [String] { get }

    /// `true` if the  ArcGIS map service supports dynamic layers, `false` otherwise.
    final public var supportsDynamicLayers: Bool { get }

    /// The service's tables.
    final public var tableInfos: [ArcGIS.IDInfo] { get }

    /// The tile information of this ArcGIS map service.
    final public var tileInfo: ArcGIS.TileInfo? { get }

    /// A list of tile server URLs that can be used to split requests for tiles.
    ///
    /// An `Array` of `String`.
    /// - Note: See Also: `Array`, `String`
    final public var tileServers: [URL] { get }

    /// Information on the support of time based queries and map requests of this map service. If this map
    /// service does not support time based requests, this will be `nil`.
    final public var timeInfo: ArcGIS.ServiceTimeInfo? { get }

    /// The units used by this ArcGIS map service.
    final public var unit: ArcGIS.Unit? { get }

    /// The map service URL.
    final public var url: URL? { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

/// Represents the metadata for an ArcGIS Map Service sublayer.
/// - Since: 200.1
final public class ArcGISMapServiceSublayerInfo : ArcGIS.JSONSerializable {

    /// The type of the service underlying an ``ArcGISMapServiceSublayerInfo``.
    ///
    /// This is used to determine the type of the service behind an ``ArcGISMapServiceSublayerInfo``.
    public enum SublayerType {

        /// A feature layer.
        case featureLayer

        /// A feature table.
        case table

        /// A group layer.
        case groupLayer

        /// A raster layer.
        case rasterLayer

        /// A network analysis layer.
        case networkAnalysisLayer

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ArcGISMapServiceSublayerInfo.SublayerType, b: ArcGIS.ArcGISMapServiceSublayerInfo.SublayerType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The sublayer's attribution.
    final public var attribution: String { get }

    /// A flag indicating whether the sublayer supports modifying its renderer and/or its data source.
    final public var canModifyLayer: Bool { get }

    /// A flag indicating whether the text and symbols on the sublayer will change as the map scale varies.
    final public var canScaleSymbols: Bool { get }

    /// The sublayer's capabilities.
    final public var capabilities: ArcGIS.MapServiceCapabilities { get }

    /// `true` if the sublayer has versioned data.
    final public var dataIsVersioned: Bool { get }

    /// The sublayer's default subtype code.
    final public var defaultSubtypeCode: Any? { get }

    /// The sublayer's definition expression.
    ///
    /// The definition expression string uses the SQL-92 where clause syntax
    /// (https://en.wikipedia.org/wiki/SQL-92). Be sure to escape special characters
    /// in the expression string as required for your platform. The DATE keyword expects
    /// the date format yyyy-mm-dd and the TIMESTAMP keyword expects the time stamp format
    /// yyyy-mm-dd hh:mm:ss. See the ArcGIS Blog article entitled "Querying Feature Services
    /// Date-Time Queries"
    /// (https://www.esri.com/arcgis-blog/products/api-rest/data-management/querying-feature-services-date-time-queries/)
    /// for more information.
    final public var definitionExpression: String { get }

    /// The sublayer's description.
    final public var description: String { get }

    /// The sublayer's display field name.
    final public var displayFieldName: String { get }

    /// The sublayer's drawing info.
    final public var drawingInfo: ArcGIS.DrawingInfo? { get }

    /// The sublayer's effective max scale. If `nil`, there is no maximum.
    final public var effectiveMaxScale: Double? { get }

    /// The sublayer's effective min scale. If `nil`, there is no maximum.
    final public var effectiveMinScale: Double? { get }

    /// The sublayer's extent.
    final public var extent: ArcGIS.Envelope? { get }

    /// The sublayer's feature subtypes.
    final public var featureSubtypes: [ArcGIS.FeatureSubtype] { get }

    /// The sublayer's feature types.
    final public var featureTypes: [ArcGIS.FeatureType] { get }

    /// The sublayer's field definitions.
    final public var fields: [ArcGIS.Field] { get }

    /// The sublayer's geometry type.
    final public var geometryType: ArcGIS.Geometry.Type? { get }

    /// `true` if the sublayer has attachments.
    final public var hasAttachments: Bool { get }

    /// `true` if the sublayer has labels defined on it.
    final public var hasLabels: Bool { get }

    /// `true` if the sublayer has m ordinates.
    final public var hasM: Bool { get }

    /// `true` if the sublayer has z ordinates.
    final public var hasZ: Bool { get }

    /// `true` if the sublayer is visible by default.
    final public var isVisibleByDefault: Bool { get }

    /// The sublayer's max record count.
    final public var maxRecordCount: Int { get }

    /// The sublayer's max scale. If `nil`, there is no maximum.
    final public var maxScale: Double? { get }

    /// The sublayer's min scale. If `nil`, there is no minimum.
    final public var minScale: Double? { get }

    /// The sublayer's ownership based access control.
    final public var ownershipBasedAccessControl: ArcGIS.OwnershipBasedAccessControlInfo? { get }

    /// The parent layer info.
    ///
    /// An ``IDInfo`` containing the sublayer parent id and name.
    final public var parentLayerInfo: ArcGIS.IDInfo? { get }

    /// The sublayer's relationship infos.
    final public var relationshipInfos: [ArcGIS.RelationshipInfo] { get }

    /// The sublayer's ID.
    final public var serviceLayerID: Int { get }

    /// The sublayer's name.
    final public var serviceLayerName: String { get }

    /// The sublayer info.
    /// - Note: See Also: `Array`
    final public var sublayerInfos: [ArcGIS.IDInfo] { get }

    /// The sublayer's type.
    final public var sublayerType: ArcGIS.ArcGISMapServiceSublayerInfo.SublayerType? { get }

    /// The sublayer's subtype field.
    final public var subtypeField: String { get }

    /// `true` if the sublayer supports advanced queries such as order by fields.
    final public var supportsAdvancedQueries: Bool { get }

    /// `true` if the sublayer supports statistical functions in query operations.
    final public var supportsStatistics: Bool { get }

    /// The sublayer's time info.
    final public var timeInfo: ArcGIS.LayerTimeInfo? { get }

    /// The sublayer's type id field name.
    final public var typeIDFieldName: String { get }

    /// The sublayer's URL.
    final public var url: URL? { get }

    /// A flag indicating whether the sublayer requires the use of standardized queries.
    /// Returns `true` indicates the sublayer requires the use of standardized queries, a value of `false` indicates otherwise.
    final public var usesStandardizedQueries: Bool { get }

    /// The sublayer's version.
    final public var version: String { get }

    /// Returns the field definition of the given field name.
    /// - Parameter fieldName: The field name.
    /// - Returns: A ``Field``.
    final public func field(named fieldName: String) -> ArcGIS.Field?

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension ArcGISMapServiceSublayerInfo.SublayerType : Equatable {
}

extension ArcGISMapServiceSublayerInfo.SublayerType : Hashable {
}

/// A layer to visualize an ArcGIS scene service.
///
/// Scene layers display content from a scene service or a scene package.
///
/// The ``ArcGISSceneLayer`` is a layer type optimized for displaying large
/// amounts of data in a `SceneView`. The ``ArcGISSceneLayer`` class displays data published as
/// scene services, scene layer packages (.slpk), and scene layers in mobile scene packages
/// (.mspk).
///
/// ``ArcGISSceneLayer`` supports:
/// * 3D Object (e.g. buildings)
/// * Integrated mesh (e.g. buildings, trees, and elevation) (see ``IntegratedMeshLayer``)
/// * Point features (e.g. trees)
///
/// The scene layer complies with the
/// [Indexed 3D Scene layer (I3S)](https://github.com/esri/i3s-spec)
/// format. The I3S format is an open 3D content delivery format used to disseminate 3D GIS data
/// to mobile, web, and desktop clients.
///
/// Functional characteristics
///
/// * 3D object  3D object scene layers contain objects explicitly modeled in three dimensions and are used
/// to represent objects such as buildings.
/// These features have attributes and can be identified. See the
/// [3D Object Scene Layer](https://pro.arcgis.com/en/pro-app/latest/help/mapping/layer-properties/the-3d-objects-scene-layer-in-arcgis-pro.htm)
/// for more information.
/// * Integrated mesh  3D mesh data is typically captured by an automated process for
/// constructing 3D objects out of large sets of overlapping imagery. The result integrates the
/// original input image information as a textured mesh including 3D objects, such as buildings
/// and trees, and elevation information. Integrated mesh scene layers are often created for
/// citywide 3D mapping. They can represent something as small as a single building or as large
/// as a city or state. They are often assembled automatically from imagery collected by a
/// drone; they cannot be restyled because there is no underlying feature data. See the
/// [Integrated Mesh Scene Layer](https://pro.arcgis.com/en/pro-app/latest/help/mapping/layer-properties/the-integrated-mesh-scene-layer-in-arcgis-pro.htm)
/// for more information.
/// * Point features  To ensure fast visualization, cached scene layers are used to display large
/// amounts of 3D point data about individual features, such as all the trees in a city. Point
/// scene layers have features that can be identified and that have attributes that may be
/// cached or available from an associated feature layer. The display of point scene layers is
/// automatically thinned to improve performance and visibility at smaller scales and longer
/// distances. Automatic thinning means that not all features are displayed at small scales; as
/// you zoom in, additional features are displayed. See the
/// [Point scene layer](https://pro.arcgis.com/en/pro-app/latest/help/mapping/layer-properties/the-point-scene-layer-in-arcgis-pro.htm)
/// for more information.
///
/// Point scene layers are generated from point feature layers. Point scene layers can be
/// generated by ArcGIS Pro and hosted as a scene service or scene layer package.
///
/// Note: When publishing a scene from ArcGIS Pro (sharing as a web scene) any point feature
/// layers in the 3D Layers section of the contents pane will be published as a scene service.
/// The scene service will be referenced within the web scene.
///
/// Performance characteristics
/// For a scene layer, the rendering of 3D data is based on the current level of detail (LOD),
/// which is determined by the distance from the camera. Each object in a 3D object service is
/// represented differently at various LODs determined by the camera distance. As the camera
/// distance changes in the scene, objects will be displayed appropriately for the current LOD.
/// This results in good client performance and low memory usage, at the expense of frequently
/// loading and unloading objects.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class ArcGISSceneLayer : ArcGIS.Layer, ArcGIS.APIKeyResource, ArcGIS.FloorAware {

    /// Identifies data type contained within a scene layer.
    public enum DataType {

        /// The type of the scene layer is 3D scene objects.
        ///
        /// Examples of 3D are building, ground etc. The
        /// geometry of the data is a mesh.
        case sceneObject

        /// The type of the scene layer is point objects.
        case point

        /// The type of the scene layer is an integrated mesh.
        case integratedMesh

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ArcGISSceneLayer.DataType, b: ArcGIS.ArcGISSceneLayer.DataType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates scene layer object with a portal item.
    /// - Parameter item: The scene layer item (only ``PortalItem`` are supported).
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// Creates a Scene layer object.
    ///
    /// If the specified URI is a portal item URL (see ``PortalItem/init(url:)`` for the supported URL formats), the underlying ``PortalItem`` will be created and accessible through ``Layer/item``.
    /// - Parameter url: The URI to the service, scene layer package, or portal item.
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(url: URL)

    /// The layer altitude offset.
    final public var altitudeOffset: Double

    /// The content type of a ArcGIS scene layer.
    ///
    /// The type of a scene layer can only be established once the layer has loaded.
    /// It can be used to identify the content type contained within the ArcGIS Scene layer.
    final public var dataType: ArcGIS.ArcGISSceneLayer.DataType? { get }

    /// The feature table associated with this layer.
    final public var featureTable: ArcGIS.FeatureTable? { get }

    /// `true` if labels should be displayed.
    ///
    /// Note that this property is only supported for ``DataType-swift.enum/point`` layers.
    final public var labelsAreEnabled: Bool

    /// Returns a list of the currently selected features.
    final public var selectedFeatures: ArcGIS.FeatureQueryResult { get async throws }

    /// The surface placement form the Scene layer.
    final public var surfacePlacement: ArcGIS.SurfacePlacement

    /// The URI of the ArcGIS scene layer.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:)``
    final public var url: URL? { get }

    /// Clears all selected features.
    final public func clearSelection()

    /// Selects the given feature and adds it to the current list of selected features.
    /// - Parameter feature: The feature.
    final public func selectFeature(_ feature: ArcGIS.Feature)

    /// Selects the features in the list and adds them to the current list of selected features.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func selectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Unselects the given feature and removes it from the current list of selected features.
    /// - Parameter feature: The feature.
    final public func unselectFeature(_ feature: ArcGIS.Feature)

    /// Unselects the features in the given list and removes them from the current list of selected features.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func unselectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// Defines the properties that allow a layer to be floor-aware.
    ///
    /// When a layer is configured as floor-aware, it has a ``floorDefinition`` property that defines
    /// properties that allow a layer to be floor-aware. When it is `nil` (default value) the specific layer
    /// does not support floor filtering.
    final public var floorDefinition: ArcGIS.LayerFloorDefinition?
}

extension ArcGISSceneLayer.DataType : Equatable {
}

extension ArcGISSceneLayer.DataType : Hashable {
}

/// A ``DynamicEntityDataSource`` that receives a stream of observations from an ArcGIS stream service.
///
/// Currently, this is the only concrete class deriving from ``DynamicEntityDataSource``.
///
/// Members of this class allow an application to:
/// * connect to and receive observations from an ArcGIS stream service
/// * access metadata about the ArcGIS stream service
/// * set a server-side filter on the service to limit the number and type of observations sent
///
/// In the current release, only stream services that send point geometries are supported.
///
/// To learn more about ArcGIS stream services see:
/// [ArcGIS Server - Stream Services](https://enterprise.arcgis.com/en/server/latest/publish-services/windows/stream-services.htm)
/// in the ArcGIS Enterprise documentation.
/// - Since: 200.1
final public class ArcGISStreamService : ArcGIS.DynamicEntityDataSource {

    /// Creates a new stream service.
    /// - Parameter url: The URL of the stream service.
    public convenience init(url: URL)

    /// Defines which observations are returned from the service.
    ///
    /// Use this property to define a filter that informs the server which observations to send on the stream. The
    /// filter may include spatial or attribute criteria (or both). Using this server-side filter is useful for
    /// limiting how much data must be handled in the client application, which can help with application performance
    /// and memory footprint.
    ///
    /// This property is used when the data source connection is initiated; therefore, the filter cannot be changed once
    /// the data source is loaded.
    ///
    /// The default value is `nil`, meaning no filter is applied.
    final public var filter: ArcGIS.ArcGISStreamServiceFilter?

    /// Metadata that describes the ArcGIS stream service.
    ///
    /// This property is `nil` by default and is populated when the data source loads.
    ///
    /// Once the data source is loaded, you can use this metadata to find things like:
    /// * Fields: Field definitions for data in the stream
    /// * Track ID field: The field that contains a unique ID for each track in a track-aware service
    /// * Archive service URL: A service that contains the latest observations for dynamic entities provided by this stream
    final public var info: ArcGIS.ArcGISStreamServiceInfo? { get }

    /// The URL of the stream service.
    final public var url: URL { get }
}

/// Limits which dynamic entities are returned from an ArcGIS stream service.
///
/// Set ``ArcGISStreamService/filter`` to an object of this type to apply a server-side filter on observations streamed
/// from an ArcGIS stream service. Spatial or attribute filters (or both) are supported.
///
/// Using this server-side filter is useful for limiting how much data is streamed from an ``ArcGISStreamService``
/// and handled in the client application, which can help with application performance and memory efficiency.
/// - Since: 200.1
final public class ArcGISStreamServiceFilter {

    /// Creates an empty ``ArcGISStreamServiceFilter`` object.
    public convenience init()

    /// The geometry that is used to filter results.
    ///
    /// Dynamic entity observations that intersect this geometry are included in the stream. Those that are outside are excluded.
    ///
    /// The default value is `nil`, meaning no spatial filter is applied to the stream.
    ///
    /// Currently, only `Envelope.Type` geometries are supported.
    final public var geometry: ArcGIS.Geometry?

    /// The spatial reference that dynamic entities are returned in.
    ///
    /// Use this property to instruct the service to provide observation geometries in the given
    /// spatial reference.
    ///
    /// This property is useful if the client application needs dynamic entities in a specific
    /// spatial reference. Setting this property forces the server to reproject geometries before
    /// adding observations to the stream. This relieves the client application from the
    /// performance burden of reprojecting dynamic entities.
    ///
    /// The default value is `nil`, meaning observation geometries should be returned in the spatial reference of the service.
    final public var outSpatialReference: ArcGIS.SpatialReference?

    /// A SQL expression that defines the dynamic entities to return.
    ///
    /// Use this property to filter dynamic entities by attribute value. Setting this property forces the server to
    /// filter observations using the given expression before adding them to the stream.
    ///
    /// The expression used as the ``whereClause`` should follow standard SQL syntax
    /// as discussed in the document
    /// [SQL reference for query expressions used in ArcGIS](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm).
    ///
    /// The default value is an empty string, meaning that no attribute filter will be applied to the stream.
    final public var whereClause: String
}

/// Metadata for an ArcGIS stream service.
///
/// An object of this type is provided by the ``ArcGISStreamService/info`` property after loading the data source.
///
/// To learn about ArcGIS stream services see:
/// [ArcGIS Server - Stream Services](https://enterprise.arcgis.com/en/server/latest/publish-services/windows/stream-services.htm)
/// in the ArcGIS Enterprise documentation.
/// - Since: 200.1
final public class ArcGISStreamServiceInfo {

    /// The maximum time (in seconds) until the latest (last known) features are purged from the feature layer.
    ///
    /// The default is 0 which means never expire.
    final public var archiveMaximumFeatureAge: TimeInterval { get }

    /// The URL of the feature service with the last known observation for each track.
    final public var archiveServiceURL: URL? { get }

    /// The frequency at which a snapshot of incoming observations is saved to the archive.
    ///
    /// The default is 30.
    final public var archiveUpdateInterval: TimeInterval { get }

    /// The current version of the ArcGIS stream service.
    final public var currentVersion: String { get }

    /// The description of the ArcGIS stream service.
    final public var description: String { get }

    /// The ArcGIS stream service drawing info.
    final public var drawingInfo: ArcGIS.DrawingInfo? { get }

    /// The name of the field in the track-aware service that contains end time.
    final public var endTimeField: String { get }

    /// The ArcGIS stream service's field definitions.
    final public var fields: [ArcGIS.Field] { get }

    /// The name of the field that stores geometry.
    final public var geometryField: String { get }

    /// The type of geometry.
    final public var geometryType: ArcGIS.Geometry.Type? { get }

    /// The name of the field that stores a unique global identifier.
    final public var globalIDField: String { get }

    /// The name of the field that stores a unique object ID.
    final public var objectIDField: String { get }

    /// The name of a field in the feature service identified by ``relatedFeaturesURL`` that relates features in that service to features in the stream service.
    ///
    /// Values in the join field must match track ID values in the ``trackIDField`` of the stream service.
    final public var relatedFeaturesJoinField: String { get }

    /// The URL of a feature service that contains features related to the stream service.
    ///
    /// The field name provided for ``relatedFeaturesJoinField`` is used to match track ID values in the feature service to ``trackIDField`` values in the stream service.
    final public var relatedFeaturesURL: URL? { get }

    /// The ``SpatialReference`` of this stream service.
    ///
    /// The default is WGS84 (4326).
    /// - Note: See Also: ``SpatialReference``
    final public var spatialReference: ArcGIS.SpatialReference { get }

    /// The name of the field in the track-aware service that contains start time.
    final public var startTimeField: String { get }

    /// The name of the field in the track-aware service that contains track ID.
    final public var trackIDField: String { get }
}

/// An ArcGIS sublayer.
///
/// This is a base class for ``ArcGISMapImageSublayer`` and ``ArcGISTiledSublayer``.
/// You can get a collection of handles from another sublayer by using ``sublayers``.
/// - Note: See Also: ``ArcGISMapImageSublayer``, ``ArcGISTiledSublayer``, ``sublayers``
/// - Since: 200.1
public class ArcGISSublayer : ArcGIS.LayerContent, ArcGIS.Loadable, ArcGIS.PopupSource {

    /// The sublayer's definition expression.
    ///
    /// The definition expression string uses the SQL-92 where clause syntax
    /// (https://en.wikipedia.org/wiki/SQL-92). Be sure to escape special characters
    /// in the expression string as required for your platform. The DATE keyword expects
    /// the date format yyyy-mm-dd and the TIMESTAMP keyword expects the time stamp format
    /// yyyy-mm-dd hh:mm:ss. See the ArcGIS Blog article entitled "Querying Feature Services
    /// Date-Time Queries"
    /// (https://www.esri.com/arcgis-blog/products/api-rest/data-management/querying-feature-services-date-time-queries/)
    /// for more information.
    public var definitionExpression: String { get }

    /// The sublayer's Id.
    ///
    /// The sublayer ID.
    public var id: Int { get }

    /// The flag indicating whether the sublayer's labels are enabled/disabled.
    public var labelsAreEnabled: Bool { get }

    /// The sublayer's metadata.
    ///
    /// The sublayer metadata once the sublayer is loaded.
    public var mapServiceSublayerInfo: ArcGIS.ArcGISMapServiceSublayerInfo? { get }

    /// The sublayer's maximum scale. If `nil`, there is no maximum.
    ///
    /// The sublayer maximum scale.
    public var maxScale: Double? { get }

    /// The sublayer's minimum scale. If `nil`, there is no minimum.
    ///
    /// The sublayer minimum scale.
    public var minScale: Double? { get }

    /// The sublayer's opacity.
    public var opacity: Float { get }

    /// The sublayer's renderer.
    public var renderer: ArcGIS.Renderer? { get }

    /// The flag indicating whether the sublayer renderers its symbols based on scale.
    public var scalesSymbols: Bool { get }

    /// The sublayers of a sublayer.
    ///
    /// The collection is specific to a layer so you can't reuse a sublayer collection coming from another ``ArcGISMapImageLayer`` or ``ArcGISSublayer``.
    /// You have to create a new layer collection by using `Array.init(valueType:)`.
    /// - Note: See Also: ``ArcGISSublayer``, `Array`, `Array.init(valueType:)`, ``ArcGISMapImageLayer/mapImageSublayers``
    public var sublayers: [ArcGIS.ArcGISSublayer] { get }

    /// Adds a sequence of `ArcGISSublayer` values to the end of the `sublayers` property.
    /// - Parameter newSublayers: The new `ArcGISSublayer` values to append.
    public func addSublayers<S>(_ newSublayers: S) where S : Sequence, S.Element == ArcGIS.ArcGISSublayer

    /// Adds an `ArcGISSublayer` value to the end of the `sublayers` property.
    /// - Parameter newSublayer: The new `ArcGISSublayer` value to append.
    public func addSublayer(_ newSublayer: ArcGIS.ArcGISSublayer)

    /// Inserts a collection of `ArcGISSublayer` values into the `sublayers` property at the specified position.
    /// - Parameters:
    ///   - newSublayers: The new `ArcGISSublayer` values to insert.
    ///   - index: The position at which to insert the new `ArcGISSublayer` values.
    public func insertSublayers<C>(_ newSublayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.ArcGISSublayer

    /// Inserts an `ArcGISSublayer` value into the `sublayers` property at the specified position.
    /// - Parameters:
    ///   - newSublayer: The new `ArcGISSublayer` value to insert.
    ///   - index: The position at which to insert the new `ArcGISSublayer` value.
    public func insertSublayer(_ newSublayer: ArcGIS.ArcGISSublayer, at index: Int)

    /// Removes all values from the `sublayers` property.
    public func removeAllSublayers()

    /// Removes a sequence of `ArcGISSublayer` values from the `sublayers` property.
    /// - Parameter sublayers: The `ArcGISSublayer` values to remove.
    public func removeSublayers<S>(_ sublayers: S) where S : Sequence, S.Element == ArcGIS.ArcGISSublayer

    /// Removes an `ArcGISSublayer` value from the `sublayers` property.
    /// - Parameter sublayer: The `ArcGISSublayer` value to remove.
    public func removeSublayer(_ sublayer: ArcGIS.ArcGISSublayer)

    /// Clones the ``ArcGISSublayer``.
    /// - Returns: A new ``ArcGISSublayer`` with the same values as the current ``ArcGISSublayer``.
    public func clone() -> Self

    /// A flag indicating whether the layer content's visibility can be changed.
    ///
    /// A flag indicating whether the layer content visibility can be changed.
    public var canChangeVisibility: Bool { get }

    /// The layer content's visibility.
    ///
    /// The layer content visibility.
    public var isVisible: Bool

    /// Fetches the list of legend info.
    public var legendInfos: [ArcGIS.LegendInfo] { get async throws }

    /// The layer content's name.
    ///
    /// The layer content name.
    public var name: String { get }

    /// A flag indicating whether the layer content participates in the legend.
    ///
    /// A flag indicating whether the layer content is shown in the legend.
    public var shouldShowInLegend: Bool

    /// The sub layer contents of a layer content.
    @ArcGIS.Streamed public var subLayerContents: [ArcGIS.LayerContent] { get }

    public var $subLayerContents: AsyncStream<[ArcGIS.LayerContent]> { get }

    /// Returns the layer content's effective visibility at the specified scale.
    ///
    /// Returns the effective layer content visibility. This effective visibility takes care of the effective visibility of the parents at the specified scale.
    /// - Parameter scale: The scale the visibility has to be calculated for.
    /// - Returns: A bool.
    public func isVisible(atScale scale: Double) -> Bool

    /// The pop-up definition.
    ///
    /// The ``PopupDefinition`` associated with the popup source.
    public var popupDefinition: ArcGIS.PopupDefinition?

    /// A flag indicating whether the ``PopupDefinition`` defined on the ``PopupSource`` is enable / disable.
    public var popupsAreEnabled: Bool

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

extension ArcGISSublayer : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.ArcGISSublayer, rhs: ArcGIS.ArcGISSublayer) -> Bool
}

/// An instance of this class represents an elevation source that can visualize ArcGIS elevation image service.
/// - Since: 200.1
final public class ArcGISTiledElevationSource : ArcGIS.ElevationSource {

    /// Creates an ArcGIS tiled elevation source with a portal item.
    ///
    /// An ArcGIS tiled elevation source is added to a ``Surface`` and provides elevation data on which layers may be
    /// draped or offset from. The ArcGIS tiled elevation source uses an ArcGIS Image service to provide the elevation data.
    /// - Parameter item: The ArcGIS tiled elevation source item (only ``PortalItem`` are supported).
    public convenience init(item: ArcGIS.Item)

    /// Creates an ArcGIS tiled elevation source with a Tile cache.
    ///
    /// An ArcGIS tiled elevation source is added to a ``Surface`` and provides elevation data that layers may be
    /// draped or offset from. The ArcGIS tiled elevation source uses a Tile cache to provide the elevation data. Only
    /// tile caches that contain LERC tiles are supported. Use an ``ExportTileCacheTask`` to create an offline tile cache from an elevation image service.
    /// - Parameter tileCache: Metadata for a local cache of elevation tiles that can be used to create a elevation source.
    public convenience init(tileCache: ArcGIS.TileCache)

    /// Creates a ArcGIS tiled elevation source with using a URL to an elevation service object.
    ///
    /// An ArcGIS tiled elevation source is added to a ``Surface`` and provides elevation data on which layers may be
    /// draped or offset from. The ArcGIS tiled elevation source uses an ArcGIS Image service to provide the elevation data.
    /// - Parameter url: The URI to a elevation service or to a elevation service portal item.
    public convenience init(url: URL)

    /// The item for the elevation service.
    /// - Note: See Also: ``ArcGISTiledElevationSource``
    final public var item: ArcGIS.Item? { get }

    /// The tile cache for the elevation service.
    /// - Note: See Also: ``ArcGISTiledElevationSource``
    final public var tileCache: ArcGIS.TileCache? { get }

    /// The URI of the ArcGIS tiled elevation source.
    ///
    /// The elevation source URI in the ArcGIS tiled elevation source.
    /// This method can't be called once the elevation source is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:)``
    final public var url: URL? { get }
}

/// Displays data from a ArcGIS Map service using pre-generated tiles.
///
/// ArcGIS tiled layers consume image tiles provided by an ArcGIS map service or a tile package.
/// Raster tiles are cached by the server at various scales instead of dynamically generating
/// map images at the request of the client application. The client requests the tiles needed at
/// a particular map extent. You can use the ``ExportTileCacheTask``
/// class to generate and download tiles from the service, creating a tile package (.tpk/.tpkx)
/// for use locally on the device. Alternatively, you can use ArcGIS Pro to create a map tile
/// package and provision it to the device. You can tell if an ArcGIS map server is hosting
/// a compatible ``ArcGISTiledLayer`` when "Single Fused Map Cache" is `true` in
/// the ArcGIS REST Services Directory.
///
/// Functional characteristics
/// ArcGIS tiled layers do not support reprojection, query, select, identify, or editing.
///
/// Performance characteristics
/// Tiled image layers (those that derive functionality from the ``ImageTiledLayer`` class) provide
/// fast display of geographic imagery stored in raster files. These rasters typically contain
/// image data acquired from satellite, aircraft, or drones. The resolution of such imagery can be
/// very high, providing a detailed view. With increased resolution comes increased file sizes and
/// potentially slower performance.
///
/// Raster tiling is a process that resamples the pixel size at different scales to
/// create images with the appropriate resolution for each scale. The tiling process creates
/// level-of-detail pyramids to efficiently manage how much detail you see as you zoom in and
/// out on the map. Typically, as you zoom closer to the Earth's surface, you want to see greater
/// detail of the geographic information. Tiled image layers allow you to see just the information
/// you need very quickly based on the level-of-detail pyramid at a particular scale, rather
/// than having to load a single large image at once.
///
/// Tiles are generated by the server when the service is created. Requests for tiles are made on
/// multiple threads and handled asynchronously. The size of each returned tile increases as the
/// resolution or complexity of the image in the tile increases. For example, high-resolution imagery
/// tiles can be result in larger file sizes than topographic mapping for the same area and map extent.
/// - Note: See Also: ``Layer``, ``ImageTiledLayer``
/// - Since: 200.1
final public class ArcGISTiledLayer : ArcGIS.ImageTiledLayer, ArcGIS.APIKeyResource {

    /// Creates an ArcGIS Tiled Layer object from an item.
    /// - Parameter item: A ``PortalItem`` (only ``PortalItem`` are supported).
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// Creates an ArcGIS Tiled Layer object from a tile cache.
    /// - Parameter tileCache: A tile cache.
    public convenience init(tileCache: ArcGIS.TileCache)

    /// Creates an ArcGIS Tiled Layer object.
    ///
    /// If the specified URI is a portal item URL (see ``PortalItem/init(url:)`` for the supported URL
    /// formats), the underlying ``PortalItem`` will be created and accessible through ``Layer/item``.
    /// Use this object to create an ArcGIS tiled layer.
    /// - Parameter url: The URI to a map service or to a map service portal item.
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `LayerTileEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(url: URL)

    /// The map service information.
    final public var mapServiceInfo: ArcGIS.ArcGISMapServiceInfo? { get }

    /// The tile cache of a tiled layer.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(tileCache:)``
    final public var tileCache: ArcGIS.TileCache? { get }

    /// The sublayers of an ArcGIS tiled layer.
    /// - Note: See Also: ``ArcGISTiledSublayer``, ``ArcGISSublayer``
    @ArcGIS.Streamed final public var tiledSublayers: [ArcGIS.LayerContent] { get }

    final public var $tiledSublayers: AsyncStream<[ArcGIS.LayerContent]> { get }

    /// The URI of the map service.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:)``
    final public var url: URL? { get }

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?
}

/// An ArcGIS tiled sublayer.
///
/// You can get this object from ``ArcGISTiledLayer/tiledSublayers`` once the tiled layer is loaded
/// or you can get a collection of handles from another tiled sublayer by using ``ArcGISSublayer/sublayers``.
/// - Note: See Also: ``ArcGISSublayer``, ``ArcGISTiledLayer/tiledSublayers``, ``ArcGISSublayer/sublayers``
/// - Since: 200.1
final public class ArcGISTiledSublayer : ArcGIS.ArcGISSublayer {
}

/// An object that is able to make network requests that support ArcGIS authentication.
/// - Since: 200.1
final public class ArcGISURLSession {

    /// The handler for when background events are finished by the `URLSession` used internally
    /// by this ``ArcGISURLSession``.
    /// You can set this to be notified when background events are finished as discussed here:
    /// https://developer.apple.com/documentation/foundation/urlsessiondelegate/1617185-urlsessiondidfinishevents.
    final public var backgroundSessionEventsHandler: ArcGIS.BackgroundURLSessionEventsHandler?

    /// Creates an ``ArcGISURLSession`` that is backed by a `URLSession` with a specified
    /// configuration.
    /// - Remark: The ``ArcGISURLSession`` may have to re-create a backing `URLSession`.
    /// In those cases the specified `configurationProvider` closure is called again.
    /// If providing a background session with an identifier, each time the closure is
    /// called a new identifier should be specified.
    /// - Parameter configurationProvider: A closure that specifies the configuration that should be
    /// used by the `ArcGISURLSession` to create a backing `URLSession`.
    public init(configurationProvider: @escaping () -> URLSessionConfiguration)
}

extension ArcGISURLSession {

    /// Loads data using a URL and query parameters.
    /// - Parameters:
    ///   - url: The URL for which to load data for.
    ///   - queryParameters: A dictionary of name-value pairs for the query.
    /// - Returns: A tuple value containing the loaded data and the response.
    final public func data(from url: URL, queryParameters: [String : String] = [:]) async throws -> (Data, URLResponse)

    /// Loads data using a request.
    /// - Parameters:
    ///   - request: The request for which to load data for.
    /// - Returns: A tuple value containing the loaded data and the response.
    final public func data(for request: URLRequest) async throws -> (Data, URLResponse)

    /// Downloads a file using a URL and query parameters to a specified location.
    /// - Parameters:
    ///   - sourceURL: The URL for which to download a file for.
    ///   - destinationURL: The location to save the file to.
    ///   - queryParameters: A dictionary of name-value pairs for the query.
    ///   - progressAction: The action called when a progress update is available.
    /// - Returns: The URL response.
    @discardableResult
    final public func download(from sourceURL: URL, to destinationURL: URL, queryParameters: [String : String] = [:], progressAction: ((ArcGIS.DownloadTaskProgress) -> Void)? = nil) async throws -> URLResponse

    /// Downloads a file using a request to a specified location.
    /// - Parameters:
    ///   - request: The request for which to download a file for.
    ///   - destinationURL: The location to save the file to.
    ///   - progressAction: The action called when a progress update is available.
    /// - Returns: The URL response.
    final public func download(for request: URLRequest, to destinationURL: URL, progressAction: ((ArcGIS.DownloadTaskProgress) -> Void)? = nil) async throws -> URLResponse
}

extension ArcGISURLSession {

    /// An async stream of request details for data tasks. A new value is emitted asynchronously
    /// to the stream when any data task managed by ``ArcGISURLSession`` makes a request.
    final public class var dataTaskRequestDetails: AsyncStream<ArcGIS.DataTaskRequestDetails> { get }

    /// An async stream of result details for data tasks. A new value is emitted asynchronously
    /// to the stream when any data task managed by ``ArcGISURLSession`` will complete.
    final public class var dataTaskResultDetails: AsyncStream<ArcGIS.DataTaskResultDetails> { get }

    /// An async stream of request details for download tasks. A new value is emitted asynchronously
    /// to the stream when any download task managed by ``ArcGISURLSession`` makes a request.
    final public class var downloadTaskRequestDetails: AsyncStream<ArcGIS.DownloadTaskRequestDetails> { get }

    /// An async stream of result details for download tasks. A new value is emitted asynchronously
    /// to the stream when any download task managed by ``ArcGISURLSession`` will complete.
    final public class var downloadTaskResultDetails: AsyncStream<ArcGIS.DownloadTaskResultDetails> { get }
}

extension ArcGISURLSession {

    /// The interceptor used for all data tasks.
    final public class var dataTaskInterceptor: ArcGIS.DataTaskInterceptor?

    /// The interceptor used for all download tasks.
    final public class var downloadTaskInterceptor: ArcGIS.DownloadTaskInterceptor?
}

/// Displays data from an ArcGIS vector tiled data source.
///
/// The ArcGIS Vector Tiled Layer is similar to the ArcGIS Tiled Layer. An ArcGIS Vector Tiled
/// Layer is loaded from ArcGIS online, ArcGIS Enterprise, ArcGIS Server, or a
/// local vector tile layer package file. The tile data format is optimized to reduce
/// network bandwidth and reduce CPU load while rendering the tiles. Vector Tiled Layers
/// are appropriate for basemap, reference and possibly operational layers. They do not contain
/// any feature data, and do not support identify or search operations.
///
/// Vector tiles are an alternative to raster tile basemap layers. Instead of pixels (raster), the cartography
/// is delivered using 2D points. The points describe lines, polygons, or the locations of labels and marker
/// symbols. The file format of tiles is binary and conforms to the Mapbox Vector Tile Specification. This
/// specification allows a more continuous visual experience between levels of detail compared to raster tiles.
/// The vector tile file format also requires less space than raster tiles.
///
/// You can create a vector tiled layer using either a URI or a portal item. The URI can point to a
/// vector tile source, a vector tile style sheet, or a local vector tile package file. The portal
/// item will contain a URI to a vector tile stylesheet. The style sheet describes the appearance of
/// the geometry and must be in the Mapbox GL Style format. The style sheet also contains a URI to a
/// vector tile source. The source must be in the Mapbox TileJSON format. The source info includes a
/// URI to a default style sheet.
///
/// More than one vector tile style sheet can use the same source. Both the source info and the
/// style sheet are human readable JSON files.
///
/// Vector tile packages can also be downloaded from a ArcGIS Online vector tile service. The
/// vector tile package is a single file (.vptk) that contains all of the tile data files, the
/// source information, a style sheet, and the font and symbol marker resources required to
/// display the map.
///
/// Vector tile packages are also distributed inside Mobile Map Packages. The MMPK contains JSON
/// that points to the location of the vector tile style sheet or the root of the vector tile
/// package data.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class ArcGISVectorTiledLayer : ArcGIS.Layer, ArcGIS.APIKeyResource {

    /// Creates an ArcGIS Vector Tiled Layer object from an item.
    /// - Parameter item: An ``Item``.
    /// - Note: See Also: ``init(url:)``
    public convenience init(item: ArcGIS.Item)

    /// Creates an ArcGIS Vector Tiled Layer object.
    ///
    /// Use this object to create an ArcGIS vector tiled layer.
    /// - Parameter url: The URI to the data source; a style or service URL or local tile cache.
    /// - Note: See Also: ``init(item:)``
    public convenience init(url: URL)

    /// Creates an ArcGIS Vector Tiled Layer object from a vector tile cache and an item resource cache containing
    /// a custom style for this vector tile layer.
    /// - Parameters:
    ///   - vectorTileCache: A ``VectorTileCache``.
    ///   - itemResourceCache: An ``ItemResourceCache``
    /// - Note: See Also: ``init(url:)``
    public convenience init(vectorTileCache: ArcGIS.VectorTileCache, itemResourceCache: ArcGIS.ItemResourceCache? = nil)

    /// The item resource cache of a vector tiled layer. This should contain a custom style to apply to
    /// the vector tiles in this layer.
    ///
    /// This method can only be called if the layer load status is `LoadStatus.notLoaded` or
    /// `LoadStatus.failedToLoad` otherwise `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(vectorTileCache:itemResourceCache:)``
    final public var itemResourceCache: ArcGIS.ItemResourceCache? { get }

    /// The vector tile source info.
    final public var sourceInfo: ArcGIS.VectorTileSourceInfo? { get }

    /// The vector tile style info.
    final public var style: ArcGIS.VectorTileStyle? { get }

    /// The URI of the ArcGIS vector tiled layer.
    /// - Note: See Also: ``ArcGISTiledLayer/init(url:)``, ``init(url:)``
    final public var url: URL? { get }

    /// The underlying vector tile cache or `nil` if no vector tile cache is present.
    ///
    /// If this layer was created from a vector tile cache or a local file URI, then this property will return the
    /// vector tile cache. If this layer was created from a remote URI, this property will return `nil`.
    /// - Note: See Also: ``init(vectorTileCache:itemResourceCache:)``
    final public var vectorTileCache: ArcGIS.VectorTileCache? { get }

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?
}

/// Provides information about the execution context where an Arcade console function is invoked.
/// - Note: See Also: `ArcadeConsoleMessageEvent`
/// - Since: 200.1
final public class ArcadeConsoleMessageContext {

    /// A dictionary of optional context information where Arcade console function is invoked.
    ///
    /// If this is an ``ArcadeProfile/attributeRuleConstraint`` or ``ArcadeProfile/attributeRuleCalculation``,
    /// expect ``information`` to include the following keys:
    /// * "ruleName" - The name of the attribute rule which invoked the Arcade console function.
    /// * "tableName" - The name of the ``ArcGISFeatureTable`` evaluating the attribute rule.
    final public var information: [String : String] { get }

    /// The ``ArcadeProfile`` which invoked the Arcade console function.
    ///
    /// Arcade console messages may be sent from different execution contexts, for example:
    /// * ``ArcadeProfile/attributeRuleConstraint`` indicates evaluation of an Attribute Rule Constraint.
    ///   See documentation for [Attribute Rule Constraint](https://pro.arcgis.com/en/pro-app/latest/help/data/geodatabases/overview/constraint-attribute-rules.htm).
    /// * ``ArcadeProfile/attributeRuleCalculation`` indicates evaluation of an Attribute Rule Calculation.
    ///   See documentation for [Attribute Rule Calculation](https://pro.arcgis.com/en/pro-app/latest/help/data/geodatabases/overview/calculation-attribute-rules.htm).
    /// * ``ArcadeProfile/labeling`` indicates evaluation of a ``LabelDefinition/expression`` or ``LabelAngle/angleExpression``.
    /// * ``ArcadeProfile/popup`` indicates evaluation of an expression used to populate popup fields.
    /// * ``ArcadeProfile/restricted`` indicates no optional functionality is allowed and is the preferred default for an ``ArcadeEvaluator``.
    /// * ``ArcadeProfile/unrestricted`` indicates optional functionalities are allowed and is the legacy default.
    final public var profile: ArcGIS.ArcadeProfile { get }
}

/// The result from the successful evaluation of an Arcade Expression.
/// - Since: 200.1
final public class ArcadeEvaluationResult {

    /// The result of a successful evaluation.
    ///
    /// The result could be one of the following types:
    /// * `Bool`
    /// * `Double`
    /// * `Int`
    /// * `String`
    /// * `Date`
    /// * `Array`
    /// * `Dictionary`
    /// * `GeoElement`
    final public var result: Any? { get }

    /// Cast the result of an evaluation to another type using the arcade casting rules.
    ///
    /// Attempts to cast to the required type using the arcade casting rules. Arcade does not throw
    /// exceptions when its casting fails, instead it returns a `nil` value, or `nan` in the case of casting to a number.
    /// - Parameter type: The type to cast to.
    /// - Returns: An object of the requested type or `nil`.
    final public func result(as type: ArcGIS.ArcadeExpressionReturnType) -> Any?
}

extension ArcadeEvaluationResult : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.ArcadeEvaluationResult, rhs: ArcGIS.ArcadeEvaluationResult) -> Bool
}

/// This object allows you to evaluate an ``ArcadeExpression`` under a given ``ArcadeProfile``.
///
/// This Object allows you to set up, execute and query information about an Arcade script. For more general information on
/// Arcade and its usages  we refer you to the [Arcade online documentation](https://links.esri.com/arcade/).
///
/// To construct the ArcadeEvaluator object you need to supply an
/// ``ArcadeExpression`` along with an ``ArcadeProfile``. ArcadeExpression
/// is an object that contains the Arcade script plus some additional
/// metadata while ``ArcadeProfile`` specifies availability of profile
/// variables and limits what functions are available.
///
/// The basic workflow is:
/// * Construct an ArcadeEvaluator object using ``ArcadeExpression`` and ``ArcadeProfile``.
/// * Query information about a script.
/// * Insert the required profile values into a dictionary.
/// * Call ArcadeEvaluator.evaluateAsync.
/// * Use the returned ``ArcadeEvaluationResult``.
///
/// From an ``ArcadeEvaluator`` object you can query information to determine
/// * Which profile variables are accessed by the script.
/// * Which attributes are used by a particular profile variable.
/// * If the script is considered stable.
///
/// Not all scripts use all the profiles variables. ``requiredProfileVariables`` returns an
/// array of the names of the profile variables used in the current script. Possible uses include:
/// * Informing dependency analysis to determine which scripts need to run when a value of a profile variable changes.
/// * Minimizing expensive calculation of unneeded profile variables.
///
/// `ArcadeEvaluator.attributes(forVariableNamed:in:)` lets you dig deeper to determine
/// which attributes are required on a specific profile variable. If you are
/// querying a subset of attributes when querying a feature, use this information
/// to ensure the profile variable will have the attributes it requires.
///
/// ``isStable`` property indicates if the given script will
/// return the same value for an identical set of profile variables. For
/// this to be `true` a script must avoid using unstable builtin
/// functions such as now() or random().
///
/// ``isStable`` can be combined with the knowledge of the used profile variables
/// to construct caches of results. This lets you avoid running scripts when
/// repeated calls with the same profiles variables will not alter the evaluation result.
/// - Since: 200.1
final public class ArcadeEvaluator : ArcGIS.Loadable {

    /// Creates an ArcadeEvaluator object
    /// - Parameters:
    ///   - expression: The Arcade expression to be evaluated.
    ///   - profile: The Arcade profile under which the expression will be evaluated.
    public convenience init(expression: ArcGIS.ArcadeExpression, profile: ArcGIS.ArcadeProfile)

    /// The Arcade expression of the Arcade evaluator.
    final public var expression: ArcGIS.ArcadeExpression { get }

    /// Is a script is considered stable.
    ///
    /// A script is considered stable if the script will return the same result given the same inputs.
    /// There are certain functions listed below that will return different values on each evaluation. Use of these functions means the script
    /// is not considered stable.
    ///
    /// Arcade functions that stop a script being considered stable:
    /// * Now.
    /// * Today.
    /// * TimeStamp.
    /// * Random.
    /// * Guid.
    /// * NextSequence.
    final public var isStable: Bool { get }

    /// The Arcade profile under which the script should evaluate.
    final public var profile: ArcGIS.ArcadeProfile { get }

    /// An array of strings containing the names of all profile variables used in the script.
    final public var requiredProfileVariables: [String] { get }

    /// An array of attributes used in the script for a given profile variable.
    ///
    /// To fully support the wildcard expansion in the expects statement, calculation of used attributes on a profile variable requires an object that can supply a full set of attribute names.
    /// - Parameters:
    ///   - variableName: The name of the profile variable whose used attributes are required.
    ///   - source: A ``FeatureTable`` from which we can obtain a list of all attribute names for the profile variable.
    /// - Returns: The task object representing the asynchronous retrieval of the attributes looked up on a profile variable in the script.
    /// The value of the task result is an `Array`<String> object.
    final public func attributes(forVariableNamed variableName: String, in source: ArcGIS.FeatureTable) async throws -> [String]

    /// An array of attributes used in the script for a given profile variable.
    ///
    /// To fully support the wildcard expansion in the expects statement, calculation of used attributes on a profile variable requires an object that can supply a full set of attribute names.
    /// - Parameters:
    ///   - variableName: The name of the profile variable whose used attributes are required.
    ///   - source: A ``GeoElement`` from which we can obtain a list of all attribute names for the profile variable.
    /// - Returns: The task object representing the asynchronous retrieval of the attributes looked up on a profile variable in the script.
    /// The value of the task result is an `Array`<String> object.
    final public func attributes(forVariableNamed variableName: String, in source: ArcGIS.GeoElement) async throws -> [String]

    /// Evaluate the script using the supplied profile variables.
    ///
    /// Each entry of the profileVariables dictionary is placed into the
    /// interpreter as a value accessible throughout the script. The
    /// name and type of these should comply with
    /// the profile the Arcade evaluator has been constructed with.
    /// Values are not persisted across evaluations, meaning all required profile
    /// variables must be supplied with each evaluation.
    ///
    /// Each value of a key/value pair in the dictionary is converted to a
    /// type understood by the interpreter.
    ///
    /// Values in the dictionary can be any of the following types
    /// * `String`.
    /// * Numbers, integer and floating point types of various sizes. Arcade uses doubles for all internal calculations.
    /// * Boolean.
    /// * `Date`.
    /// * ``Geometry``.
    /// * ``GeoElement`` (or anything derived from it such as ``Feature``,  ``ENCFeature``).
    /// * ``FeatureTable``, see `FeatureTable.Type`.
    /// * `Dictionary`, String to supported type.
    /// * ``Geodatabase``.
    /// * ``ServiceGeodatabase``.
    /// * ``GeoModel`` (or anything derived from it such as ``Map`` or ``Scene``).
    /// * ``Location``.
    ///
    ///
    /// To be explicit on the conversions of compound types.
    /// * ``GeoElement`` types are converted to Arcade Feature type.
    /// * ``Location`` is  converted to an Arcade Feature type.
    /// * ``FeatureTable`` types are converted to Arcade FeatureSet type.
    /// * ``Geodatabase`` is converted to Arcade FeatureSetCollection type.
    /// * ``ServiceGeodatabase`` is converted to Arcade FeatureSetCollection type.
    /// * ``GeoModel`` is converted to Arcade FeatureSetCollection type.
    /// - Parameter profileVariables: The profile variables for the script as key/value pairs.
    /// - Returns: The task object representing the asynchronous evaluation of an Arcade
    /// script. The value of the task result is an ``ArcadeEvaluationResult`` object.
    final public func evaluate(withProfileVariables profileVariables: [String : Any]) async throws -> ArcGIS.ArcadeEvaluationResult

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An Arcade expression object, containing an expression, a name, a return type and a title.
///
/// An ArcadeExpression object gathers an Arcade script expression together with:
/// * The expected return type
/// * The name that a map author uses to refer to it
/// * The title that the author uses to describe the expression
/// - Since: 200.1
final public class ArcadeExpression : ArcGIS.JSONSerializable {

    /// Creates a new ArcadeExpression object
    /// - Parameters:
    ///   - expression: The Arcade expression to be evaluated.
    ///   - title: The title of the expression
    ///   - name: The name of the expression
    ///   - returnType: Specify the type to cast the evaluated value to.
    public convenience init(expression: String, title: String = "", name: String = "", returnType: ArcGIS.ArcadeExpressionReturnType = .automatic)

    /// The Arcade expression string.
    final public var expression: String { get }

    /// The name that the author uses to refer to the expression.
    ///
    /// If not set explicitly, then the default is an empty name string.
    final public var name: String { get }

    /// The expected return type of the expression.
    ///
    /// If the Arcade expression evaluates to a result which differs from ``ArcadeExpressionReturnType``
    /// then the result will be cast to the expected return type.
    /// If no sensible cast can be carried out then the result will be `nil`.
    final public var returnType: ArcGIS.ArcadeExpressionReturnType { get }

    /// The title that the author uses to describe the expression.
    ///
    /// If not set explicitly, then the default is an empty title string.
    final public var title: String { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension ArcadeExpression : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.ArcadeExpression, rhs: ArcGIS.ArcadeExpression) -> Bool
}

/// The expected type of the result calculated by an expression described within an ``ArcadeExpression``.
/// - Since: 200.1
public enum ArcadeExpressionReturnType {

    /// The return type of the expression will be automatically determined based on the script calculation.
    ///
    /// The return type is determined by the return value of the script.
    /// Different paths through the script might result in different result types.
    /// For example, depending on input values,
    /// it might return a number, a string, a date or an array.
    case automatic

    /// The return type is expected to be a floating-point number.
    case double

    /// The return type is expected to be a string.
    case string

    /// The return type is expected to be a dictionary of key/value pairs.
    case dictionary

    /// The return type is expected to be any of the other ``ArcadeExpressionReturnType`` types.
    ///
    /// 'any' implies that the application evaluating the expression will need to check the result for its type and use the value appropriately.
    case any

    /// The return type is expected to be a boolean value of `true` or `false`.
    case boolean

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ArcadeExpressionReturnType, b: ArcGIS.ArcadeExpressionReturnType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ArcadeExpressionReturnType : Equatable {
}

extension ArcadeExpressionReturnType : Hashable {
}

/// An expression script using the Arcade language.
///
/// The Arcade label expression property must contain a syntactically correct Arcade script
/// expression.
///
/// An example expression that combines text with a field value is
///
/// "State: " + $feature.State_Name
///
/// Note that quotes are needed around the literal text.
/// See https://links.esri.com/arcade for full documentation on the Arcade
/// scripting language and its function library.
///
/// Any Arcade functions allowed for the <b>Labeling profile</b> can be used in a
/// label arcade expression.
/// Other functions (for example, FeatureSet functions) are potentially too slow
/// to be used in a dynamic label evaluation.
/// Warning: If the expression attempts to use attributes which don't exist then no label will be produced.
/// This is distinct from the attribute existing but having a `nil` or empty value,
/// which can form part of the produced text label.
/// - Since: 200.1
final public class ArcadeLabelExpression : ArcGIS.LabelExpression {

    /// Creates a label arcade expression object using the ``ArcadeExpression/expression``.
    /// - Parameter arcadeExpression: An ``ArcadeExpression`` containing the Arcade expression script to use.
    public convenience init(arcadeExpression: ArcGIS.ArcadeExpression)

    /// Creates a label arcade expression object with a specified Arcade expression script string.
    /// - Parameter arcadeString: The Arcade expression script string.
    public convenience init(arcadeString: String = "")
}

/// The execution context a script will run under.
///
/// The Arcade profile specifies the context under which a script should be executed. This allows the script
/// writer to program against a set of known profile variables and functionality restrictions that are appropriate
/// for their use case. This includes the set of expected return types.
///
/// It is erroneous to try to use restricted functionality for instance the use of FeatureSets while working in the
/// labeling profile. Often the restrictions are applied due to performance considerations.
///
/// This API does not check that the required profile variables are present for evaluation within a
/// certain profile, nor does it check that the return type is the expected type. The `ArcadeEvaluationResult.result(as:)`
/// method converts the type of the evaluation result using Arcade casting rules.
/// - Since: 200.1
public enum ArcadeProfile {

    /// Usage of any optional feature is blocked. Prefer this as your default.
    case restricted

    /// All optional functionality is allowed. The default profile due to compatibility reasons, prefer ArcadeProfile.restricted as default.
    case unrestricted

    /// Alias profile
    ///
    /// Alias profile functionality restrictions apply, only Alias profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case alias

    /// Attribute Rule Calculation profile.
    ///
    /// Attribute Rule Calculation profile functionality restrictions apply, only  Attribute Rule Calculation profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case attributeRuleCalculation

    /// Attribute Rule Constraint profile
    ///
    /// Attribute Rule Constraint profile functionality restrictions apply, only Attribute Rule Constraint profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case attributeRuleConstraint

    /// Attribute Rule Validation profile
    ///
    /// Attribute Rule profile functionality restrictions apply, only Attribute Rule profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case attributeRuleValidation

    /// Form Constraint profile
    ///
    /// Form Constraint profile functionality restrictions apply, only Form Constraint profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case constraint

    /// Dashboard Formatting profile
    ///
    /// Dashboard Formatting profile functionality restrictions apply, only Dashboard Formatting profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case dashboardFormatting

    /// Dashboard Data profile
    ///
    /// Dashboard Data profile functionality restrictions apply, only Dashboard Data profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case dashboardData

    /// Dictionary Renderer profile
    ///
    /// Dictionary Renderer profile functionality restrictions apply, only Dictionary Renderer profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case dictionaryRenderer

    /// Feature Z profile
    ///
    /// Feature Z profile functionality restrictions apply, only Feature Z profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case featureZ

    /// Field Calculation profile
    ///
    /// Field Calculation profile functionality restrictions apply, only Field Calculation profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case fieldCalculation

    /// Field Mapping profile
    ///
    /// Field Mapping profile functionality restrictions apply, only Field Mapping profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case fieldMapping

    /// Geoanalytics profile
    ///
    /// Geoanalytics profile functionality restrictions apply, only Geoanalytics profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case geoanalytics

    /// Labeling profile
    ///
    /// Labeling profile functionality restrictions apply, only Labeling profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case labeling

    /// Layout profile
    ///
    /// Layout profile functionality restrictions apply, only Layout profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case layout

    /// Measure Visualization profile
    ///
    /// Measure Visualization profile functionality restrictions apply, only Measure Visualization profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case measureVisualization

    /// Popup profile
    ///
    /// Popup functionality profile restrictions apply, only Popup profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case popup

    /// Velocity profile
    ///
    /// Velocity profile functionality restrictions apply, only Velocity profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case velocity

    /// Visualization profile
    ///
    /// Visualization profile functionality restrictions apply, only Visualization profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case visualization

    /// Geotrigger Notification profile
    ///
    /// Geotrigger Notification profile functionality restrictions apply, only Geotrigger Notification profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case geotriggerNotification

    /// Form Calculation profile
    ///
    /// Form Calculation profile functionality restrictions apply, only Form Calculation profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case formCalculation

    /// Task profile
    ///
    /// Task profile functionality restrictions apply, only Task profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case task

    /// Popup Element profile
    ///
    /// Popup Element profile functionality restrictions apply, only Popup Element profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case popupElement

    /// Location Update Constraint profile
    ///
    /// Location Update Constraint profile functionality restrictions apply, only Location Update Constraint profile variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case locationUpdateConstraint

    /// Quick Capture profile
    ///
    /// Quick Capture functionality restrictions apply, only Quick Capture variables should be made available. See  [Arcade profile documentation](https://developers.arcgis.com/arcade/profiles/).
    case quickCapture

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ArcadeProfile, b: ArcGIS.ArcadeProfile) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ArcadeProfile : Equatable {
}

extension ArcadeProfile : Hashable {
}

/// Defines an area unit of measurement.
///
/// The area unit class is derived from the unit class.
/// - Note: See Also: ``Unit``
/// - Since: 200.1
final public class AreaUnit : ArcGIS.Unit {

    /// Defines a list of the most commonly-used units of area measurement.
    /// These values can be used to create instances
    /// of ``AreaUnit``, as an alternative to using well-known IDs (WKIDs).
    /// In addition to the units in this enumeration, you can also use less commonly-used units, by passing a WKID of an
    /// area unit to the inherited `Unit.fromWKID(_:)` factory method.
    /// The function ``Unit/wkid`` returns the WKID of the unit.
    /// - Note: See Also: `Unit.objectType`
    public enum ID {

        /// Indicates an area measurement in acres.
        /// This unit has a WKID of 109402.
        case acres

        /// Indicates an area measurement in hectares.
        /// This unit has a WKID of 109401.
        case hectares

        /// Indicates an area measurement in square centimeters.
        /// This unit has a WKID of 109451.
        case squareCentimeters

        /// Indicates an area measurement in square decimeters.
        /// This unit has a WKID of 109450.
        case squareDecimeters

        /// Indicates an area measurement in square feet.
        /// This unit has a WKID of 109405.
        case squareFeet

        /// Indicates an area measurement in square kilometers.
        /// This unit has a WKID of 109414.
        case squareKilometers

        /// Indicates an area measurement in square meters.
        /// This unit has a WKID of 109404.
        case squareMeters

        /// Indicates an area measurement in square millimeters.
        /// This unit has a WKID of 109452.
        case squareMillimeters

        /// Indicates an area measurement in square statute miles.
        /// This unit has a WKID of 109439.
        case squareMiles

        /// Indicates an area measurement in square yards.
        /// This unit has a WKID of 109442.
        case squareYards

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.AreaUnit.ID, b: ArcGIS.AreaUnit.ID) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a unit given its known id.
    /// - Parameter areaID: The known id of the unit.
    public convenience init(areaID: ArcGIS.AreaUnit.ID)

    /// Creates an area unit given a linear unit.
    ///
    /// Creates a unit given a linear unit.
    /// - Parameter linearUnit: The linear unit.
    public convenience init(linearUnit: ArcGIS.LinearUnit)

    /// The ``ID`` of the given Area unit.
    final public var areaID: ArcGIS.AreaUnit.ID? { get }

    /// Converts a value in another UOM into this UOM.
    /// - Parameters:
    ///   - unit: The UOM to convert from.
    ///   - area: The value to convert.
    /// - Returns: The value in the this UOM or `nan` if the conversion fails.
    final public func convert(from unit: ArcGIS.AreaUnit, area: Double) -> Double

    /// Converts a value in this UOM into another UOM.
    /// - Parameters:
    ///   - unit: The UOM to convert to.
    ///   - area: The value to convert.
    /// - Returns: The value in the target UOM or `nan` if the conversion fails.
    final public func convert(to unit: ArcGIS.AreaUnit, area: Double) -> Double

    /// Converts a square meter value to this UOM.
    /// - Parameter area: The value to convert.
    /// - Returns: The value in this UOM or `nan` if the conversion fails.
    final public func fromSquareMeters(area: Double) -> Double

    /// Converts a value in this UOM to square meters.
    /// - Parameter area: The value to convert.
    /// - Returns: The value in square meters or `nan` if the conversion fails.
    final public func toSquareMeters(area: Double) -> Double
}

extension AreaUnit {

    /// An area unit representing square meters.
    public static let squareMeters: ArcGIS.AreaUnit

    /// An area unit representing square kilometers.
    public static let squareKilometers: ArcGIS.AreaUnit

    /// An area unit representing square feet.
    public static let squareFeet: ArcGIS.AreaUnit

    /// An area unit representing square miles.
    public static let squareMiles: ArcGIS.AreaUnit
}

extension AreaUnit.ID : Equatable {
}

extension AreaUnit.ID : Hashable {
}

/// An object that represents a geodatabase attachment type.
/// - Since: 200.1
final public class Attachment {

    /// The content type of the attachment.
    final public var contentType: String { get }

    /// Fetches the attachment's data.
    final public var data: Data { get async throws }

    /// `true` if the attachment data has been retrieved.
    final public var hasFetchedData: Bool { get }

    /// The id of the attachment.
    final public var id: Int { get }

    /// The name of the attachment.
    final public var name: String { get }

    /// The size of the attachment's data.
    final public var size: Int { get }
}

/// The direction to synchronize attachments as part of geodatabase sync task.
/// - Since: 200.1
public enum AttachmentSyncDirection {

    /// There is no specified attachment sync direction.
    case noSync

    /// The attachment changes are uploaded only.
    case upload

    /// The attachment changes are both uploaded and downloaded.
    case bidirectional

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.AttachmentSyncDirection, b: ArcGIS.AttachmentSyncDirection) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension AttachmentSyncDirection : Equatable {
}

extension AttachmentSyncDirection : Hashable {
}

/// Represents a pop-up element of type attachments that is displayed in a pop-up for a geoelement.
/// - Note: See Also: `PopupElement.Type`, ``PopupElement``
/// - Since: 200.1
final public class AttachmentsPopupElement : ArcGIS.PopupElement {

    /// Indicates how to display the attachments. If `list` is specified, attachments show as links. If `preview` is specified, attachments expand to the width of the pop-up. Setting the value to `auto` allows applications to choose the most suitable default experience for their application.
    /// - Note: See Also: ``AttachmentsPopupElement``
    public enum DisplayType {

        /// Show attachments as links.
        case list

        /// Attachments expand to the width of the pop-up.
        case preview

        /// Allows applications to choose the most suitable default experience for their application.
        case auto

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.AttachmentsPopupElement.DisplayType, b: ArcGIS.AttachmentsPopupElement.DisplayType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new attachments pop-up element with the given ``DisplayType-swift.enum``.
    /// - Parameter displayType: Indicates how to display the attachments.
    public convenience init(displayType: ArcGIS.AttachmentsPopupElement.DisplayType = .auto)

    /// A string value describing the element in detail. Can be an empty string.
    final public var description: String

    /// Indicates how to display the attachments.
    /// If `list` is specified, attachments show as links. If `preview` is specified, attachments expand to the width of the pop-up. Setting the value to `auto` allows applications to choose the most suitable default experience for their application.
    final public var displayType: ArcGIS.AttachmentsPopupElement.DisplayType

    /// A string value indicating what the element represents. Can be an empty string.
    final public var title: String
}

extension AttachmentsPopupElement {

    /// The list of attachments.
    ///
    /// This property will be empty if ``PopupElement/isEvaluated`` is `false`.
    final public var attachments: [ArcGIS.PopupAttachment] { get async throws }
}

extension AttachmentsPopupElement.DisplayType : Equatable {
}

extension AttachmentsPopupElement.DisplayType : Hashable {
}

/// A class that contains value of attribute's parameter.
///
/// Class holding a single attribute parameter value for an NA tasks.
/// - Note: See Also: ``TravelMode``
/// - Since: 200.1
final public class AttributeParameterValue {

    /// Creates a attribute parameter instance.
    ///
    /// Creates a attribute parameter value.
    public convenience init()

    /// Attribute's name.
    /// - Note: See Also: `String`
    final public var attributeName: String

    /// Parameter's name.
    /// - Note: See Also: `String`
    final public var parameterName: String

    /// Parameter's value.
    final public var parameterValue: Any?
}

/// The manager of requests for secure resources made by the application.
///
/// The authentication manager provides:
/// * ArcGIS and network challenge handlers for authentication challenges. For example, you can write
/// code in an authentication challenge handler to prompt the user for credential information, create a credential,
/// and use it to continue with the challenge.
/// * The credential stores are available for storing the ArcGIS and network credentials that are automatically
/// checked when your application attempts to connect to secured resources.
/// - Since: 200.1
final public class AuthenticationManager {

    /// The handler that is called for ArcGIS authentication challenges that occur during requests made
    /// by ArcGIS.
    final public var arcGISAuthenticationChallengeHandler: ArcGIS.ArcGISAuthenticationChallengeHandler?

    /// The handler that is called for network authentication challenges that occur during requests made
    /// by ArcGIS.
    final public var networkAuthenticationChallengeHandler: ArcGIS.NetworkAuthenticationChallengeHandler?

    /// The network credential store used by ArcGIS for requests that must be
    /// authenticated with network credentials.
    ///
    /// Use ``setNetworkCredentialStore(_:)`` to set a new value.
    final public var networkCredentialStore: ArcGIS.NetworkCredentialStore { get }

    /// Storage for ``ArcGISCredential`` objects. The credential store is checked for a matching credential before
    /// sending requests or issuing authentication challenges.
    final public var arcGISCredentialStore: ArcGIS.ArcGISCredentialStore

    /// Sets the network credential store used by ArcGIS for requests that must be authenticated
    /// with network credentials.
    /// - Parameter networkCredentialStore: The network credential store to set on the environment.
    final public func setNetworkCredentialStore(_ networkCredentialStore: ArcGIS.NetworkCredentialStore) async
}

/// A background grid defines the default color and context grid for display behind a map or scene surface.
///
/// The background grid determines what an empty `MapView` or scene ``Surface`` looks like. An instance of this class can
/// be used to set a default backdrop that a ``Map`` or ``Scene`` will display on top of.
/// - Note: See Also: `MapView.backgroundGrid`, ``Surface/backgroundGrid``, ``Map/backgroundColor``
/// - Since: 200.1
final public class BackgroundGrid {

    /// Creates a background grid with the specified properties.
    /// - Parameters:
    ///   - backgroundColor: The color of the background.
    ///   - lineColor: The color of the grid lines.
    ///   - lineWidth: The width of the grid lines in device-independent pixels (DIP).
    ///   - size: The size of the grid squares in device-independent pixels (DIP).
    public convenience init(backgroundColor: UIColor = .init(white: 192/255, alpha: 1), lineColor: UIColor = .black, lineWidth: CGFloat = 0.1, size: CGFloat = 20)

    /// The background color of the grid.
    ///
    /// The default value is gray - RGBA(192,192,192,255).
    final public var backgroundColor: UIColor

    /// `true` if grid lines are visible on the ``backgroundColor``, `false` otherwise.
    ///
    /// If this value is `true`, grid lines will display on the ``backgroundColor``. If this value
    /// is `false`, the ``backgroundColor`` will display without the grid lines.
    /// The default value is `true`.
    final public var isVisible: Bool

    /// The color of the grid lines.
    ///
    /// The default value is black - RGBA(0,0,0,255).
    final public var lineColor: UIColor

    /// The width of the grid lines in device-independent pixels (DIP).
    ///
    /// This value must be greater than or equal to 0. Setting the grid line width to 0 will make grid lines invisible.
    /// The default value is 0.1.
    final public var lineWidth: CGFloat

    /// The size of each grid square in device-independent pixels (DIP).
    ///
    /// The default value is 20 x 20 pixels.
    final public var size: CGFloat
}

/// A type that handles when background events are finished for a `URLSession`.
public protocol BackgroundURLSessionEventsHandler {

    /// Tells the handler that all messages enqueued for a session have been delivered. This
    /// is specific for the background `URLSession` that is used internally by the
    /// ``ArcGISURLSession``.
    /// For discussion on this see the documentation on the function
    /// `urlSessionDidFinishEvents(forBackgroundURLSession` found on `URLSessionDelegate`:
    /// https://developer.apple.com/documentation/foundation/urlsessiondelegate/1617185-urlsessiondidfinishevents
    func backgroundURLSessionDidFinishEvents()
}

/// Intended-usage types for barriers.
/// - Since: 200.1
public enum BarrierType {

    /// A restriction barrier type.
    case restriction

    /// A cost adjustment barrier type.
    case costAdjustment

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.BarrierType, b: ArcGIS.BarrierType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension BarrierType : Equatable {
}

extension BarrierType : Hashable {
}

/// An abstract base stretch renderer object which is derived from a raster renderer object.
/// - Note: See Also: ``RasterRenderer``
/// - Since: 200.1
public class BaseStretchRenderer : ArcGIS.RasterRenderer {

    /// The status of whether to estimate statistics or not when it's not available from the data source.
    public var estimatesStatistics: Bool { get }

    /// The gamma values.
    public var gammas: [Double] { get }

    /// The stretch parameters.
    public var stretchParameters: ArcGIS.StretchParameters? { get }
}

/// A basemap is a non-editable layer that provides background, or reference information, in your map or scene.
///
/// A basemap provides a background of geographical context for the content you display in a map or scene.
/// It provides a visual reference to help orient users and a framework on which you can overlay
/// operational layers, perform analysis, and visualize geographic information. The content of
/// a basemap is typically static and does not change frequently.
///
/// A basemap is composed of a collection of base layers (``baseLayers``) and reference layers
/// (``referenceLayers``). Base layers are displayed at the bottom of a map or scene, and
/// reference layers are displayed at the top, with the ``GeoModel/operationalLayers`` between them.
///
/// Typically, you construct a basemap using a basemap style:
/// * Use image tile basemap styles for satellite imagery and hillshade.
/// * Use vector tile basemap styles such as streets navigation, light gray canvas, and OpenStreetMap (OSM).
/// * Create custom basemap styles with your own colors, glyphs, and fonts using the [ArcGIS Vector Tile Style Editor](https://developers.arcgis.com/documentation/mapping-apis-and-services/tools/vector-tile-style-editor/).
///
/// See ``Style`` for the full range of the basemap styles provided by Esri. Basemap styles allow
/// you to take advantage of geographically load-balanced services and monitor usage with API keys or
/// named users. See [Basemap layers](https://developers.arcgis.com/documentation/mapping-apis-and-services/maps/basemap-layers/) for more information.
///
/// If your app works offline, you can construct a local basemap from a tiled layer using a
/// ``TileCache``, such as a tile package (.tpk, .tpkx, .vtpk) or a compact cache, stored on the device.
/// - Note: See Also: ``init(baseLayers:referenceLayers:)``
/// - Since: 200.1
final public class Basemap : ArcGIS.APIKeyResource, ArcGIS.JSONSerializable, ArcGIS.Loadable {

    /// The list of basemap styles.
    ///
    /// This is used to determine which basemap to use.
    /// These basemaps are secured and require either an APIKey or named user to access them.
    public enum Style {

        /// A composite basemap with satellite imagery of the world (raster) as the base layer and labels (vector) as the reference layer.
        case arcGISImagery

        /// A raster basemap with satellite imagery of the world as the base layer.
        case arcGISImageryStandard

        /// A vector basemap with labels for the world as the reference layer. Designed to be overlaid on ``arcGISImageryStandard``.
        case arcGISImageryLabels

        /// A vector basemap for the world featuring a light neutral background style with minimal colors as the base layer and labels as the reference layer.
        case arcGISLightGray

        /// A vector basemap for the world featuring a light neutral background style with minimal colors as the base layer.
        case arcGISLightGrayBase

        /// A vector basemap with labels for the world as the reference layer. Designed to be overlaid on  light neutral backgrounds such as the ``arcGISLightGrayBase`` style.
        case arcGISLightGrayLabels

        /// A vector basemap for the world featuring a dark neutral background style with minimal colors as the base layer and labels as the reference layer.
        case arcGISDarkGray

        /// A vector basemap for the world featuring a dark neutral background style with minimal colors as the base layer.
        case arcGISDarkGrayBase

        /// A vector basemap with labels for the world as the reference layer. Designed to be overlaid on dark neutral backgrounds such as the ``arcGISDarkGrayBase`` style.
        case arcGISDarkGrayLabels

        /// A vector basemap for the world featuring a custom navigation map style.
        case arcGISNavigation

        /// A vector basemap for the world featuring a 'dark mode' version of the ``arcGISNavigation`` style, using the same content.
        case arcGISNavigationNight

        /// A vector basemap for the world featuring a classic Esri street map style.
        case arcGISStreets

        /// A vector basemap for the world featuring a custom 'night time' street map style.
        case arcGISStreetsNight

        /// A composite basemap with elevation hillshade (raster) and a classic Esri street map style (vector) as the base layers.
        case arcGISStreetsRelief

        /// A composite basemap with elevation hillshade (raster) and classic Esri topographic map style including a relief map (vector) as the base layers.
        case arcGISTopographic

        /// A composite basemap with ocean data of the world (raster) as the base layer and labels (vector) as the reference layer.
        case arcGISOceans

        /// A raster basemap with ocean data of the world as the base layer.
        case arcGISOceansBase

        /// A vector basemap with labels for the world as the reference layer. Designed to be overlaid on ``arcGISOceansBase``.
        case arcGISOceansLabels

        /// A composite basemap with elevation hillshade (raster), minimal map content like water and land fill, water lines and roads (vector)
        /// as the base layers and minimal map content like populated place names, admin and water labels with boundary lines (vector) as the reference layer.
        case arcGISTerrain

        /// A vector basemap with minimal map content like water and land fill, water lines and roads as the base layer.
        case arcGISTerrainBase

        /// A vector basemap with minimal map content like populated place names, admin and water labels with boundary lines as the
        /// reference layer. Designed to be overlaid on ``arcGISTerrainBase`` and hillshade.
        case arcGISTerrainDetail

        /// A vector basemap for the world in a style that is optimized to display special areas of
        /// interest (AOIs) that have been created and edited by Community Maps contributors.
        case arcGISCommunity

        /// A composite basemap with elevation hillshade (raster) and the world featuring a geopolitical style
        /// reminiscent of a school classroom wall map (vector) as the base layers.
        case arcGISChartedTerritory

        /// A vector basemap presented in the style of hand-drawn, colored pencil cartography.
        case arcGISColoredPencil

        /// A vector basemap for the world featuring a dark background with glowing blue symbology inspired by science-fiction and futuristic themes.
        case arcGISNova

        /// A composite basemap with elevation hillshade (raster) and the look of 18th and 19th century antique maps
        /// in the modern world of multi-scale mapping (vector) as the base layers.
        case arcGISModernAntique

        /// A vector basemap inspired by the art and advertising of the 1950's that presents a unique design option to the ArcGIS basemaps.
        case arcGISMidcentury

        /// A vector basemap in black & white design with halftone patterns, red highlights, and stylized fonts to depict a unique "newspaper" styled theme.
        case arcGISNewspaper

        /// A raster basemap with elevation hillshade. Designed to be used as a backdrop for topographic, soil, hydro, landcover
        /// or other outdoor recreational maps.
        case arcGISHillshadeLight

        /// A raster basemap with world hillshade (Dark) is useful in building maps that provide terrain context while highlighting feature layers and labels.
        case arcGISHillshadeDark

        /// A vector basemap in the classic Esri street map style, using a relief map as the base layer. This is a transparent basemap
        /// so it is recommended to use it along with a hillshade (raster) layer or adjust the ``BackgroundGrid`` of the `GeoView`.
        case arcGISStreetsReliefBase

        /// A vector basemap in the classic Esri topographic map style, using a relief map as the base layer. This is a transparent basemap
        /// so it is recommended to use it along with a hillshade (raster) layer or adjust the ``BackgroundGrid`` of the `GeoView`.
        case arcGISTopographicBase

        /// A vector basemap in a geopolitical style reminiscent of a school classroom wall map as the base layer.
        /// This is a transparent basemap so it is recommended to use it along with a hillshade (raster) layer or adjust the
        /// ``BackgroundGrid`` of the `GeoView`.
        case arcGISChartedTerritoryBase

        /// A vector basemap in the style of 18th and 19th century antique maps in the modern world of multi-scale mapping as the base layer.
        /// This is a transparent basemap so it is recommended to use it along with a hillshade (raster) layer or adjust the ``BackgroundGrid``
        /// of the `GeoView`.
        case arcGISModernAntiqueBase

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri and rendered using Open Street Map (OSM) cartography.
        case osmStandard

        /// A composite basemap that uses elevation as an artistic hillshade (raster) and Open Street Map (OSM) data hosted by Esri.
        /// It is rendered similarly to the Esri Street Map (with Relief) and uses a cartographic style (vector) as the base layer.
        case osmStandardRelief

        /// A vector basemap is a version of Open Street Map (OSM) data hosted by Esri and rendered using Esri Street Map cartographic style.
        case osmStandardReliefBase

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri and rendered using Esri Street Map style.
        case osmStreets

        /// A composite basemap with elevation as an artistic hillshade (raster) and Open Street Map (OSM) data hosted by Esri and
        /// rendered similarly to the Esri Street Map (with Relief) cartographic style (vector) as the base layers.
        case osmStreetsRelief

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri and rendered using light neutral style with minimal
        /// colors as the base layer and labels as the reference layer.
        case osmLightGray

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri and rendered using light neutral style with minimal
        /// colors as the base layer.
        case osmLightGrayBase

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri. Contains only labels as the reference layer. Designed to be overlaid on light neutral styles
        /// with minimal colors such as ``osmLightGrayBase``.
        case osmLightGrayLabels

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri and rendered using dark neutral style with minimal colors
        /// as the base layer and labels as the reference layer.
        case osmDarkGray

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri and rendered using dark neutral style with minimal colors as the base layer.
        case osmDarkGrayBase

        /// A vector basemap version of Open Street Map (OSM) data hosted by Esri. Contains only labels as the reference layer. Designed to be overlaid on dark neutral styles with minimal colors such as ``osmDarkGrayBase``.
        case osmDarkGrayLabels

        /// A vector basemap with Open Street Map (OSM) data hosted by Esri. It is rendered similarly to the Esri Street Map (with Relief) and uses a
        /// cartographic style as the base layer. This is a transparent basemap so it is recommended to use it along with a hillshade (raster)
        /// layer or adjust the ``BackgroundGrid`` of the `GeoView`.
        case osmStreetsReliefBase

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Basemap.Style, b: ArcGIS.Basemap.Style) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a basemap with a single base layer.
    /// - Parameter baseLayer: A layer object.
    /// - Precondition: Layer cannot already be part of a map or scene.
    public convenience init(baseLayer: ArcGIS.Layer)

    /// Creates a basemap with collections of base and reference layers.
    /// - Parameters:
    ///   - baseLayers: A collection of layers that serve as base layers.
    ///   - referenceLayers: A collection of layers that serve as reference layers.
    public convenience init(baseLayers: [ArcGIS.Layer] = [], referenceLayers: [ArcGIS.Layer] = [])

    /// Creates a basemap with a portal item of type ``PortalItem/Kind-swift.enum/webMap``.
    ///
    /// The ``PortalItem`` automatically loads when the ``Basemap`` loads. If the loaded ``Item`` is
    /// not a portal item of type ``PortalItem/Kind-swift.enum/webMap``, the basemap fails to load.
    /// - Parameter item: A web map ``PortalItem``.
    public convenience init(item: ArcGIS.Item)

    /// Creates a basemap with a ``Style``. These basemaps are secured and access requires either an API key or a named user.
    /// - Parameter style: The basemap style.
    /// - Note: See Also: ``Style``
    public convenience init(style: ArcGIS.Basemap.Style)

    /// Creates a basemap with the URI.
    ///
    /// If the specified URI is a portal item URL (see ``PortalItem/init(url:)`` for the supported URL formats), the underlying ``PortalItem`` will be created and accessible through ``item``.
    /// - Parameter url: URI of the basemap, commonly the URL of a web map portal item.
    /// - Note: See Also: ``PortalItem``, ``PortalItem/init(url:)``, ``item``
    public convenience init?(url: URL)

    /// The collection of base layers in this basemap.
    ///
    /// Base layers are drawn beneath all other layers in the ``Map`` or ``Scene``. They are designed to
    /// provide a visual reference to help orient the user. Aerial imagery, terrain, and streets are
    /// examples of basemap layers. The collection can be empty but it is never `nil`.
    ///
    /// This collection is specific to this basemap so you cannot reuse a collection coming from another
    /// ``Basemap``.
    /// - Note: See Also: ``Layer``, `Array`, `Array.init(valueType:)`, ``GeoModel/operationalLayers``
    final public var baseLayers: [ArcGIS.Layer] { get }

    /// Adds a sequence of `Layer` values to the end of the `baseLayers` property.
    /// - Parameter newBaseLayers: The new `Layer` values to append.
    final public func addBaseLayers<S>(_ newBaseLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Adds a `Layer` value to the end of the `baseLayers` property.
    /// - Parameter newBaseLayer: The new `Layer` value to append.
    final public func addBaseLayer(_ newBaseLayer: ArcGIS.Layer)

    /// Inserts a collection of `Layer` values into the `baseLayers` property at the specified position.
    /// - Parameters:
    ///   - newBaseLayers: The new `Layer` values to insert.
    ///   - index: The position at which to insert the new `Layer` values.
    final public func insertBaseLayers<C>(_ newBaseLayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.Layer

    /// Inserts a `Layer` value into the `baseLayers` property at the specified position.
    /// - Parameters:
    ///   - newBaseLayer: The new `Layer` value to insert.
    ///   - index: The position at which to insert the new `Layer` value.
    final public func insertBaseLayer(_ newBaseLayer: ArcGIS.Layer, at index: Int)

    /// Removes all values from the `baseLayers` property.
    final public func removeAllBaseLayers()

    /// Removes a sequence of `Layer` values from the `baseLayers` property.
    /// - Parameter baseLayers: The `Layer` values to remove.
    final public func removeBaseLayers<S>(_ baseLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Removes a `Layer` value from the `baseLayers` property.
    /// - Parameter baseLayer: The `Layer` value to remove.
    final public func removeBaseLayer(_ baseLayer: ArcGIS.Layer)

    /// The portal item associated with this basemap.
    /// - Note: See Also: ``Basemap``
    final public var item: ArcGIS.Item? { get }

    /// The name of this basemap.
    final public var name: String

    /// The collection of reference layers in this basemap.
    ///
    /// Reference layers are drawn on top all other layers in the ``Map`` or ``Scene`` to display
    /// information such as boundaries, labels, and traffic networks. The collection can be empty but it
    /// is never `nil`.
    ///
    /// This collection is specific to this basemap so you cannot reuse a collection coming from another
    /// ``Basemap``.
    /// - Note: See Also: ``Layer``, `Array`, `Array.init(valueType:)`, ``GeoModel/operationalLayers``, ``baseLayers``
    final public var referenceLayers: [ArcGIS.Layer] { get }

    /// Adds a sequence of `Layer` values to the end of the `referenceLayers` property.
    /// - Parameter newReferenceLayers: The new `Layer` values to append.
    final public func addReferenceLayers<S>(_ newReferenceLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Adds a `Layer` value to the end of the `referenceLayers` property.
    /// - Parameter newReferenceLayer: The new `Layer` value to append.
    final public func addReferenceLayer(_ newReferenceLayer: ArcGIS.Layer)

    /// Inserts a collection of `Layer` values into the `referenceLayers` property at the specified position.
    /// - Parameters:
    ///   - newReferenceLayers: The new `Layer` values to insert.
    ///   - index: The position at which to insert the new `Layer` values.
    final public func insertReferenceLayers<C>(_ newReferenceLayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.Layer

    /// Inserts a `Layer` value into the `referenceLayers` property at the specified position.
    /// - Parameters:
    ///   - newReferenceLayer: The new `Layer` value to insert.
    ///   - index: The position at which to insert the new `Layer` value.
    final public func insertReferenceLayer(_ newReferenceLayer: ArcGIS.Layer, at index: Int)

    /// Removes all values from the `referenceLayers` property.
    final public func removeAllReferenceLayers()

    /// Removes a sequence of `Layer` values from the `referenceLayers` property.
    /// - Parameter referenceLayers: The `Layer` values to remove.
    final public func removeReferenceLayers<S>(_ referenceLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Removes a `Layer` value from the `referenceLayers` property.
    /// - Parameter referenceLayer: The `Layer` value to remove.
    final public func removeReferenceLayer(_ referenceLayer: ArcGIS.Layer)

    /// The URI of this basemap.
    /// - Note: See Also: ``Basemap``
    final public var url: URL? { get }

    /// Clones this instance of ``Basemap`` and its members.
    ///
    /// All objects referenced by the basemap, such as layers or portal item, are copied as well.
    /// - Returns: A new ``Basemap`` with the same values as the current ``Basemap``.
    final public func clone() -> Self

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension Basemap.Style : Equatable {
}

extension Basemap.Style : Hashable {
}

/// An key that provides access to Bing services.
/// - Since: 200.1
@frozen public struct BingKey : RawRepresentable, Hashable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: String

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    public init?(_ rawValue: String)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = String
}

extension BingKey : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension BingKey : Sendable {
}

/// Displays Bing maps layers.
///
/// A Bing maps layer displays map content from a Bing Maps web service, providing access to
/// static map tiles and imagery metadata.
///
/// Map style and culture can be customized prior to
/// loading the layer.
///
/// Functional characteristics
///
/// Bing maps require an API key from Microsoft. There are two ways to set this key:
/// * By providing an ArcGIS portal configured with a Bing Maps key. For more information, see
///   ["How to install a Microsoft Bing Key"](https://blogs.esri.com/esri/supportcenter/2014/01/27/how-to-install-a-microsoft-bing-key-and-access-the-imagery-from-the-add-basemap-window/)
/// * By providing a Bing Maps key directly for this layer. For more information, see
///   ["Getting a Bing Maps Key"](https://msdn.microsoft.com/en-us/library/ff428642.aspx)
///
/// A Bing maps layer will fail to load if it does not have a Bing map key or a Portal from
/// where it can get the Bing map key. In this situation, you can set the
/// ``key`` and call ``Loadable/retryLoad()``.
///
/// Bing maps layers do not support identify, query, selection, or time.
///
/// To use the ``BingMapsLayer`` you must adhere to
/// [Microsoft's Mobile Brand Guidelines](https://links.esri.com/runtime/bing_guidelines).
///
/// Performance characteristics
/// Bing maps layers perform similarly to other tiled layers. Raster tiles are fetched from
/// Bing's servers on demand.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class BingMapsLayer : ArcGIS.ServiceImageTiledLayer {

    /// The list of Bing maps layer styles.
    ///
    /// This is used to determine the Bing maps layer style.
    /// - Note: See Also: ``BingMapsLayer/init(key:style:)``
    public enum Style {

        /// A Bing aerial layer.
        case aerial

        /// A Bing hybrid layer (aerial with labels).
        case hybrid

        /// A Bing road layer.
        case road

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.BingMapsLayer.Style, b: ArcGIS.BingMapsLayer.Style) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a Bing maps layer object.
    ///
    /// Use this function to create a Bing maps layer.
    /// - Parameters:
    ///   - key: The Bing maps key.
    ///   - style: The type of Bing maps layer.
    public convenience init(key: ArcGIS.BingKey, style: ArcGIS.BingMapsLayer.Style)

    /// Creates a Bing maps layer object with the API key coming from the supplied Portal.
    ///
    /// Use this function to create a Bing maps layer.
    /// - Parameters:
    ///   - portal: A portal with a bingKey.
    ///   - style: The type of Bing maps layer.
    /// - Note: See Also: ``Portal``
    public convenience init(portal: ArcGIS.Portal, style: ArcGIS.BingMapsLayer.Style)

    /// The Bing maps key for a Bing maps layer.
    /// - Note: See Also: `String`
    final public var key: ArcGIS.BingKey?

    /// The locale of the Bing maps layer.
    /// - Note: See Also: `String`
    final public var locale: Locale

    /// The Portal the layer will load its Bing Maps API key from.
    /// - Note: See Also: ``Portal``
    final public var portal: ArcGIS.Portal? { get }

    /// The style for the Bing maps layer.
    ///
    /// The style for the layer.
    final public var style: ArcGIS.BingMapsLayer.Style { get }
}

extension BingMapsLayer.Style : Equatable {
}

extension BingMapsLayer.Style : Hashable {
}

/// A blend renderer object which is derived from a hillshade renderer object.
/// - Note: See Also: ``RasterRenderer``
/// - Since: 200.1
final public class BlendRenderer : ArcGIS.HillshadeRenderer {

    /// Creates a blend renderer.
    /// - Parameters:
    ///   - elevationRaster: The elevation data, ``Raster``. Can be `nil`.
    ///   - outputMinValues: `Array` of double. Output stretch values, one for each band. Can be `nil`.
    ///   - outputMaxValues: `Array` of double. Output stretch values, one for each band. Can be `nil`.
    ///   - sourceMinValues: `Array` of double. Input stretch values, one for each band. Can be `nil`.
    ///   - sourceMaxValues: `Array` of double. Input stretch values, one for each band. Can be `nil`.
    ///   - noDataValues: `Array` of double. NoData values, one for each band. Can be `nil`.
    ///   - gammas: `Array` of double. Gamma adjustment. Can be `nil`.
    ///   - colorRamp: The color ramp object.
    ///   - altitude: Altitude angle of the light source.
    ///   - azimuth: Azimuth angle of the light source, measured clockwise from north.
    ///   - slopeType: ``HillshadeRenderer/SlopeType-swift.enum``
    ///   - zFactor: Factor to convert z unit to x,y unit, default is 1.
    ///   - pixelSizeFactor: Pixel size factor, default is 1.
    ///   - pixelSizePower: Pixel size power value, default is 1.
    ///   - outputBitDepth: Output bit depth, default is 8-bit.
    public convenience init(elevationRaster: ArcGIS.Raster?, outputMinValues: [Double], outputMaxValues: [Double], sourceMinValues: [Double], sourceMaxValues: [Double], noDataValues: [Double], gammas: [Double], colorRamp: ArcGIS.ColorRamp?, altitude: Double, azimuth: Double, slopeType: ArcGIS.HillshadeRenderer.SlopeType?, zFactor: Double = 1, pixelSizeFactor: Double = 1, pixelSizePower: Double = 1, outputBitDepth: Int = 8)

    /// The color ramp for creating the blend renderer.
    final public var colorRamp: ArcGIS.ColorRamp { get }

    /// The elevation raster, ``Raster``.
    final public var elevationRaster: ArcGIS.Raster? { get }

    /// Gamma adjustments.
    final public var gammas: [Double] { get }

    /// NoData values.
    final public var noDataValues: [Double] { get }

    /// Output maximum stretch values.
    final public var outputMaxValues: [Double] { get }

    /// Output minimum stretch values.
    final public var outputMinValues: [Double] { get }

    /// Maximum source stretch values.
    final public var sourceMaxValues: [Double] { get }

    /// Minimum source stretch values.
    final public var sourceMinValues: [Double] { get }
}

/// A geographic or time location for quick navigate.
/// - Note: See Also: ``init(name:viewpoint:)``
/// - Since: 200.1
public struct Bookmark : Hashable {

    /// The name of the bookmark.
    public var name: String

    /// The viewpoint representing the bookmark.
    public var viewpoint: ArcGIS.Viewpoint?

    /// Creates an instance with the given name and viewpoint.
    /// - Parameters:
    ///   - name: The name.
    ///   - viewpoint: The viewpoint.
    public init(name: String, viewpoint: ArcGIS.Viewpoint? = nil)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.Bookmark, b: ArcGIS.Bookmark) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A type that specifies how a callout is supposed to be placed on a `GeoView`.
/// An implementation detail of callouts; do not use this protocol directly.
/// - Since: 200.1
public struct CalloutPlacement : Equatable {
}

extension CalloutPlacement {

    /// Creates a callout placement to display a callout on top of the location display.
    public static func locationDisplay() -> ArcGIS.CalloutPlacement

    /// Creates a callout placement for a specific location on a geo view.
    /// - Parameter location: The location for which to display the callout for.
    /// - Parameter offset: The offset in screen coordinates from the geographical location in
    /// which to place the callout.
    /// - Parameter allowsOffsetRotation: Specifies whether the screen offset
    /// is rotated with the geo view. This is useful if you are showing
    public static func location(_ location: ArcGIS.Point, offset: CGPoint = .zero, allowsOffsetRotation: Bool = false) -> ArcGIS.CalloutPlacement

    /// Creates a callout placement to display a callout for a particular geo element.
    /// - Parameters:
    ///   - geoElement: The geo element to display the callout for.
    ///   - tapLocation: The location that the user tapped that caused the callout to be shown.
    public static func geoElement(_ geoElement: ArcGIS.GeoElement, tapLocation: ArcGIS.Point? = nil) -> ArcGIS.CalloutPlacement

    /// The geo element, if any, that is associated with this callout placement.
    public var geoElement: ArcGIS.GeoElement? { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.CalloutPlacement, rhs: ArcGIS.CalloutPlacement) -> Bool
}

/// A camera on a view.
/// - Since: 200.1
public struct Camera {

    /// Creates an instance with the given latitude, longitude, altitude,
    /// heading, pitch, and roll.
    /// - Parameters:
    ///   - latitude: The latitude of the camera position in degrees.
    ///   - longitude: The longitude of the camera position in degrees.
    ///   - altitude: The altitude of the camera position in meters.
    ///   - heading: The heading of the camera.
    ///   - pitch: The pitch of the camera. The value must be from 0 to 180 and represents the angle applied to the camera when rotating around its Y axis in the East, North, Up (ENU) ground reference frame. 0 is looking straight down towards the center of the earth, 180 looking straight up towards the sky. Negative pitches are not allowed and the values do not wrap around. If the behavior of a negative pitch is required, then the corresponding transformation with positive pitch can be set instead. For example if heading:0 pitch:-20 roll:0 is required then heading:180 pitch:20 roll:180 can be used instead.
    ///   - roll: The roll of the camera.
    public init(latitude: Double, longitude: Double, altitude: Double, heading: Double, pitch: Double, roll: Double)

    /// Creates an instance with the given location, heading, pitch, and roll.
    /// - Parameters:
    ///   - location: A point geometry containing the location and altitude at which to place the camera.
    ///   - heading: The heading of the camera.
    ///   - pitch: The pitch of the camera. The value must be from 0 to 180 and represents the angle applied to the camera when rotating around its Y axis in the East, North, Up (ENU) ground reference frame. 0 is looking straight down towards the center of the earth, 180 looking straight up towards the sky. Negative pitches are not allowed and the values do not wrap around. If the behavior of a negative pitch is required, then the corresponding transformation with positive pitch can be set instead. For example if heading:0 pitch:-20 roll:0 is required then heading:180 pitch:20 roll:180 can be used instead.
    ///   - roll: The roll of the camera.
    /// - Precondition: `!location.isEmpty`
    public init(location: ArcGIS.Point, heading: Double, pitch: Double, roll: Double)

    /// Creates an instance with the given look at point, distance, heading,
    /// pitch, and roll.
    /// - Parameters:
    ///   - lookingAt: A point geometry containing the location for the camera to look at.
    ///   - distance: The distance of the camera from the look at point.
    ///   - heading: The heading of the camera.
    ///   - pitch: The pitch of the camera. The value must be from 0 to 180 and represents the angle applied to the camera when rotating around its Y axis in the East, North, Up (ENU) ground reference frame. 0 is looking straight down towards the center of the earth, 180 looking straight up towards the sky. Negative pitches are not allowed and the values do not wrap around. If the behavior of a negative pitch is required, then the corresponding transformation with positive pitch can be set instead. For example if heading:0 pitch:-20 roll:0 is required then heading:180 pitch:20 roll:180 can be used instead.
    ///   - roll: The roll of the camera.
    /// - Precondition: `!lookingAt.isEmpty`
    public init(lookingAt: ArcGIS.Point, distance: Double, heading: Double, pitch: Double, roll: Double)

    /// Creates an instance with the given transformation matrix.
    /// - Parameter transformationMatrix: The ``TransformationMatrix`` used to create the camera. The ``TransformationMatrix`` describes the camera's location and the direction it is looking. Using this constructor with the location provided by ARKit/ARCore is necessary for enabling augmented reality.
    /// - Precondition: `!transformationMatrix.translationX.isZero && !transformationMatrix.translationX.isNaN`
    /// - Precondition: `!transformationMatrix.translationY.isZero && !transformationMatrix.translationY.isNaN`
    /// - Precondition: `!transformationMatrix.translationZ.isZero && !transformationMatrix.translationZ.isNaN`
    public init(transformationMatrix: ArcGIS.TransformationMatrix)
}

extension Camera {

    /// The heading of the camera.
    /// - Note: See Also: ``Camera``
    public var heading: Double { get }

    /// The location of the camera.
    /// - Note: See Also: ``Camera``, ``Point``
    public var location: ArcGIS.Point { get }

    /// The pitch of the camera.
    ///
    /// The pitch value must be from 0 to 180 and represents the angle applied to the
    /// camera when rotating around its Y axis in the East, North, Up (ENU) ground reference frame. 0 is looking straight
    /// down towards the center of the earth, 180 looking straight up towards the sky. Negative
    /// pitches are not allowed and the values do not wrap around. If the behavior of a negative pitch is required, then the
    /// corresponding transformation with positive pitch can be set instead. For example if heading:0 pitch:-20 roll:0 is
    /// required then heading:180 pitch:20 roll:180 can be used instead.
    /// - Note: See Also: ``Camera``
    public var pitch: Double { get }

    /// The roll of the camera.
    /// - Note: See Also: ``Camera``
    public var roll: Double { get }

    /// The camera's ``TransformationMatrix``. It does not matter if the camera was created
    /// with a ``TransformationMatrix``, the camera's location and orientation will
    /// be converted into a ``TransformationMatrix``.
    /// - Note: See Also: ``Camera``
    public var transformationMatrix: ArcGIS.TransformationMatrix { get }
}

extension Camera {

    /// Creates a copy of the camera with the altitude adjusted.
    /// - Parameter distance: The altitude delta to apply to the output camera.
    /// - Returns: A copy of the camera with an elevation delta adjusted by the parameter delta_altitude.
    /// - Note: See Also: ``Camera``
    public func elevated(by distance: Double) -> ArcGIS.Camera

    /// Creates a copy of the camera with the location changed.
    /// - Parameter location: The location to move the output camera to.
    /// - Returns: A copy of the camera with the location changed.
    /// - Note: See Also: ``Camera``
    /// - Precondition: `!location.isEmpty`
    public func moved(to location: ArcGIS.Point) -> ArcGIS.Camera

    /// Creates a copy of the camera with the position moved in the direction of a target point by a given distance
    /// - Parameters:
    ///   - target: The point location towards which the camera will move.
    ///   - distance: The distance in meters the output camera will be moved.
    /// - Returns: A copy of the camera with the position moved
    /// - Note: See Also: ``Camera``
    /// - Precondition: `!target.isEmpty`
    public func moved(toward target: ArcGIS.Point, by distance: Double) -> ArcGIS.Camera

    /// Creates a copy of the camera with the position moved by a given distance in the direction the camera is facing.
    /// - Parameter distance: The distance in meters the output camera will be moved.
    /// - Returns: A copy of the camera with the position moved.
    /// - Note: See Also: ``Camera``
    public func movedForward(by distance: Double) -> ArcGIS.Camera

    /// Creates a copy of the camera with the heading and pitch rotated from a give target point by a given delta angles in degrees
    /// - Parameters:
    ///   - target: The point location around which the camera will move.
    ///   - headingDelta: The delta angle in degrees by which the output camera heading will be rotated around the target_point
    ///   - pitchDelta: The delta angle in degrees by which the output camera pitch will be rotated around the target_point
    ///   - rollDelta: The delta angle in degrees by which the output camera roll will be rotated around the target_point
    /// - Returns: A copy of the camera with the position moved
    /// - Note: See Also: ``Camera``
    /// - Precondition: `!target.isEmpty`
    public func rotated(around target: ArcGIS.Point, headingDelta: Double, pitchDelta: Double, rollDelta: Double) -> ArcGIS.Camera

    /// Creates a copy of the camera with a change in pitch, heading and roll to the given angles in degrees
    /// - Parameters:
    ///   - heading: The angle in degrees to which the output camera heading will be rotated
    ///   - pitch: The angle in degrees to which the output camera pitch will be rotated. The value must be from 0 to 180 and represents the angle applied to the camera when rotating around its Y axis in the East, North, Up (ENU) ground reference frame. 0 is looking straight down towards the center of the earth, 180 looking straight up towards the sky. Negative pitches are not allowed and the values do not wrap around. If the behavior of a negative pitch is required, then the corresponding transformation with positive pitch can be set instead. For example if heading:0 pitch:-20 roll:0 is required then heading:180 pitch:20 roll:180 can be used instead.
    ///   - roll: The angle in degrees to which the output camera roll will be rotated
    /// - Returns: A copy of the camera with the position moved
    /// - Note: See Also: ``Camera``
    public func rotatedTo(heading: Double, pitch: Double, roll: Double) -> ArcGIS.Camera

    /// Creates a copy of the camera with the position moved in the direction of a target point by a given zoom factor.
    /// - Parameters:
    ///   - target: The point location towards which the camera will zoom.
    ///   - factor: The factor the output camera will be moved.
    /// - Returns: A copy of the camera with the position moved.
    /// - Note: See Also: ``Camera``
    /// - Precondition: `!target.isEmpty`
    public func zoomed(toward target: ArcGIS.Point, by factor: Double) -> ArcGIS.Camera
}

extension Camera : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Camera, rhs: ArcGIS.Camera) -> Bool
}

/// An base class for all camera controllers.
/// - Since: 200.1
public class CameraController {
}

/// A certificate network credential.
/// - Since: 200.1
public struct CertificateCredential : Hashable {

    /// The certificate data.
    public let data: Data

    /// The password to access the certificate.
    public let password: String

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.CertificateCredential, b: ArcGIS.CertificateCredential) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension CertificateCredential : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

/// An error that can occur when importing a certificate.
/// - Since: 200.1
public struct CertificateImportError : RawRepresentable, Error, Hashable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: OSStatus

    /// Creates an instance with the given raw value. This initializer will fail if the specified
    /// raw value represents a success status.
    /// - Parameter rawValue: An `OSStatus` resulting from system calls to import a certificate.
    public init?(rawValue: OSStatus)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = OSStatus
}

extension CertificateImportError {

    /// The user name or passphrase provided is not correct.
    public static let invalidPassword: ArcGIS.CertificateImportError

    /// Unable to decode the provided data.
    public static let invalidData: ArcGIS.CertificateImportError
}

/// A class break object used to categorize a group of values that fall within a range of values.
///
/// The ``ClassBreak`` is used to categorize a group of values that fall within a range defined by
/// ``minValue`` and ``maxValue`` properties. A value is determined to be within
/// this range if it is greater than the ``minValue`` but less than or equal to the
/// ``maxValue``. When written as an algebraic equation, it would look like
/// (``minValue`` < value <= ``maxValue``).
///
///  For example, assume you wanted to create a set of ``ClassBreak`` categories based on the following integers
///  (0, 0, 1, 1, 2, 4, 6, 6, 7, 10).
///
///  The following table would be helpful in defining the ``ClassBreak`` range settings
///  <table>
///  <tr>
///  <th>categorized group of values</th>
///  <th>count</th>
///  <th>label</th>
///  <th>minValue</th>
///  <th>maxValue</th>
///  </tr>
///  <tr>
///  <th>0</th>
///  <th>2</th>
///  <th>none</th>
///  <th>-1</th>
///  <th>0</th>
///  </tr>
///  <tr>
///  <th>1-2</th>
///  <th>3</th>
///  <th>one to two</th>
///  <th>0</th>
///  <th>2</th>
///  </tr>
///  <tr>
///  <th>3-5</th>
///  <th>1</th>
///  <th>three to five</th>
///  <th>2</th>
///  <th>5</th>
///  </tr>
///  <tr>
///  <th>6-10</th>
///  <th>4</th>
///  <th>six to ten</th>
///  <th>5</th>
///  <th>10</th>
///  </tr>
///  </table>
/// - Since: 200.1
final public class ClassBreak : ArcGIS.JSONSerializable {

    /// Creates a new class break object with alternate symbols.
    ///
    /// A class break can have alternate symbols to the primary symbol. Alternate symbols allow you to tailor the visualization of class break at different scales by selecting different symbol for different scales.
    /// Alternate symbols are supported only when class break's primary symbol and other symbols in alternate symbol list are of type ``MultilayerSymbol`` and have ``SymbolReferenceProperties`` defining valid min max scales at which the symbol becomes visible.
    /// Renderer will pick only one symbol at a given map scale. If primary symbol's scale range falls within the map's scale, primary symbol is used.
    /// If not, then symbols in alternate symbols list are iterated through and first symbol matching the current map scale is picked for rendering.
    /// A symbol becomes visible if the map scale is less than or equal to symbol's minimum scale and greater than symbol's maximum scale.
    /// For more information on Scale-based symbol classes and alternate symbols see the following documentation:
    /// https://pro.arcgis.com/en/pro-app/latest/help/mapping/layer-properties/scale-based-symbol-classes.htm
    /// - Parameters:
    ///   - description: A description of the class break. "Cities with a population under 100,000", for example.
    ///   - label: A label for the class break. "0 - 100000", for example.
    ///   - minValue: The minimum value of the range that defines the break.
    ///   - maxValue: The maximum value of the range that defines the break.
    ///   - symbol: A symbol used to represent elements in the class break.
    ///   - alternateSymbols: The alternate symbols for the class break. Only ``MultilayerSymbol`` are supported as alternates.
    public convenience init(description: String = "", label: String = "", minValue: Double = .nan, maxValue: Double = .nan, symbol: ArcGIS.Symbol? = nil, alternateSymbols: [ArcGIS.Symbol] = [])

    /// The alternate symbols for the class break's primary symbol. Symbols in this list should be of type ``MultilayerSymbol`` and must have ``SymbolReferenceProperties`` set with valid minimum and maximum scale at which symbol becomes visible. Renderer will pick only one symbol at a given map scale. If primary symbol's scale range falls within the map's scale, primary symbol is used. If not, then symbols in alternate symbols list are iterated through and first symbol matching the current map scale is picked for rendering. A symbol becomes visible if the map scale is less than or equal to symbol's minimum scale and greater than symbol's maximum scale.
    final public var alternateSymbols: [ArcGIS.Symbol] { get }

    /// Adds a sequence of `Symbol` values to the end of the `alternateSymbols` property.
    /// - Parameter newAlternateSymbols: The new `Symbol` values to append.
    final public func addAlternateSymbols<S>(_ newAlternateSymbols: S) where S : Sequence, S.Element == ArcGIS.Symbol

    /// Adds a `Symbol` value to the end of the `alternateSymbols` property.
    /// - Parameter newAlternateSymbol: The new `Symbol` value to append.
    final public func addAlternateSymbol(_ newAlternateSymbol: ArcGIS.Symbol)

    /// Inserts a collection of `Symbol` values into the `alternateSymbols` property at the specified position.
    /// - Parameters:
    ///   - newAlternateSymbols: The new `Symbol` values to insert.
    ///   - index: The position at which to insert the new `Symbol` values.
    final public func insertAlternateSymbols<C>(_ newAlternateSymbols: C, at index: Int) where C : Collection, C.Element == ArcGIS.Symbol

    /// Inserts a `Symbol` value into the `alternateSymbols` property at the specified position.
    /// - Parameters:
    ///   - newAlternateSymbol: The new `Symbol` value to insert.
    ///   - index: The position at which to insert the new `Symbol` value.
    final public func insertAlternateSymbol(_ newAlternateSymbol: ArcGIS.Symbol, at index: Int)

    /// Removes all values from the `alternateSymbols` property.
    final public func removeAllAlternateSymbols()

    /// Removes a sequence of `Symbol` values from the `alternateSymbols` property.
    /// - Parameter alternateSymbols: The `Symbol` values to remove.
    final public func removeAlternateSymbols<S>(_ alternateSymbols: S) where S : Sequence, S.Element == ArcGIS.Symbol

    /// Removes a `Symbol` value from the `alternateSymbols` property.
    /// - Parameter alternateSymbol: The `Symbol` value to remove.
    final public func removeAlternateSymbol(_ alternateSymbol: ArcGIS.Symbol)

    /// A description of the class break. "Cities with a population under 100,000", for example.
    final public var description: String

    /// A label for the class break. "0 - 100000", for example.
    final public var label: String

    /// The maximum value of the range that defines the break.
    final public var maxValue: Double

    /// The minimum value of the range that defines the break.
    final public var minValue: Double

    /// A symbol used to represent elements in the class break.
    final public var symbol: ArcGIS.Symbol?

    /// Clones the ``ClassBreak``.
    /// - Returns: A new ``ClassBreak`` with the same values as the current ``ClassBreak``.
    final public func clone() -> Self

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension ClassBreak : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.ClassBreak, rhs: ArcGIS.ClassBreak) -> Bool
}

extension ClassBreak : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// A Class Breaks Renderer object.
/// - Since: 200.1
final public class ClassBreaksRenderer : ArcGIS.Renderer {

    /// The classification method used to generate class breaks.
    /// - Note: See Also: ``ClassBreaksRenderer``
    public enum ClassificationMethod {

        /// Defined interval classification.
        case definedInterval

        /// Equal interval classification.
        case equalInterval

        /// Geometrical interval classification.
        case geometricalInterval

        /// Natural breaks classification.
        case naturalBreaks

        /// Quantile classification.
        case quantile

        /// Standard deviation classification.
        case standardDeviation

        /// Manual classification.
        case manual

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ClassBreaksRenderer.ClassificationMethod, b: ArcGIS.ClassBreaksRenderer.ClassificationMethod) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The different types of normalization.
    /// - Note: See Also: ``ClassBreaksRenderer``
    public enum NormalizationType {

        /// Normalize by field.
        case byField

        /// Normalize by a log.
        case byLog

        /// Normalize by percent of total.
        case byPercentOfTotal

        /// Do not normalize.
        case noNormalization

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ClassBreaksRenderer.NormalizationType, b: ArcGIS.ClassBreaksRenderer.NormalizationType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new class breaks renderer object.
    /// - Parameters:
    ///   - fieldName: The field name.
    ///   - classBreaks: An `Array` containing ``ClassBreak`` types.
    public convenience init(fieldName: String = "", classBreaks: [ArcGIS.ClassBreak] = [])

    /// The renderer's background fill symbol.
    final public var backgroundFillSymbol: ArcGIS.Symbol?

    /// Returns a list of all the class breaks in this renderer.
    final public var classBreaks: [ArcGIS.ClassBreak] { get }

    /// Adds a sequence of `ClassBreak` values to the end of the `classBreaks` property.
    /// - Parameter newClassBreaks: The new `ClassBreak` values to append.
    final public func addClassBreaks<S>(_ newClassBreaks: S) where S : Sequence, S.Element == ArcGIS.ClassBreak

    /// Adds a `ClassBreak` value to the end of the `classBreaks` property.
    /// - Parameter newClassBreak: The new `ClassBreak` value to append.
    final public func addClassBreak(_ newClassBreak: ArcGIS.ClassBreak)

    /// Inserts a collection of `ClassBreak` values into the `classBreaks` property at the specified position.
    /// - Parameters:
    ///   - newClassBreaks: The new `ClassBreak` values to insert.
    ///   - index: The position at which to insert the new `ClassBreak` values.
    final public func insertClassBreaks<C>(_ newClassBreaks: C, at index: Int) where C : Collection, C.Element == ArcGIS.ClassBreak

    /// Inserts a `ClassBreak` value into the `classBreaks` property at the specified position.
    /// - Parameters:
    ///   - newClassBreak: The new `ClassBreak` value to insert.
    ///   - index: The position at which to insert the new `ClassBreak` value.
    final public func insertClassBreak(_ newClassBreak: ArcGIS.ClassBreak, at index: Int)

    /// Removes all values from the `classBreaks` property.
    final public func removeAllClassBreaks()

    /// Removes a sequence of `ClassBreak` values from the `classBreaks` property.
    /// - Parameter classBreaks: The `ClassBreak` values to remove.
    final public func removeClassBreaks<S>(_ classBreaks: S) where S : Sequence, S.Element == ArcGIS.ClassBreak

    /// Removes a `ClassBreak` value from the `classBreaks` property.
    /// - Parameter classBreak: The `ClassBreak` value to remove.
    final public func removeClassBreak(_ classBreak: ArcGIS.ClassBreak)

    /// The renderer's classification method.
    final public var classificationMethod: ArcGIS.ClassBreaksRenderer.ClassificationMethod { get }

    /// The renderer's default label.
    final public var defaultLabel: String

    /// The renderer's default symbol.
    final public var defaultSymbol: ArcGIS.Symbol?

    /// The renderer's field name.
    final public var fieldName: String

    /// The renderer's min value.
    final public var minValue: Double

    /// The renderer's normalization field.
    final public var normalizationField: String

    /// The renderer's normalization total.
    final public var normalizationTotal: Double

    /// The renderer's normalization type.
    final public var normalizationType: ArcGIS.ClassBreaksRenderer.NormalizationType
}

extension ClassBreaksRenderer.ClassificationMethod : Equatable {
}

extension ClassBreaksRenderer.ClassificationMethod : Hashable {
}

extension ClassBreaksRenderer.NormalizationType : Equatable {
}

extension ClassBreaksRenderer.NormalizationType : Hashable {
}

/// A class that contains settings that are used when solving a ``ClosestFacilityTask``.
///
/// The ``ClosestFacilityParameters`` class contains all inputs for the ``ClosestFacilityTask``, as well as settings such as
/// the impedance attribute, accumulate and restriction attributes, backtrack (u-turn) policy, etc.
/// - Note: See Also: ``ClosestFacilityTask``
/// - Since: 200.1
final public class ClosestFacilityParameters {

    /// Accumulate attribute names.
    ///
    /// The accumulate attribute names e.g. "Minutes", "Miles", etc.
    /// Accumulate attributes are useful when more information other than the default impedance attribute is required.
    /// - Note: See Also: `Array`
    final public var accumulateAttributeNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `accumulateAttributeNames` property.
    /// - Parameter newAccumulateAttributeNames: The new `String` values to append.
    final public func addAccumulateAttributeNames<S>(_ newAccumulateAttributeNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `accumulateAttributeNames` property.
    /// - Parameter newAccumulateAttributeName: The new `String` value to append.
    final public func addAccumulateAttributeName(_ newAccumulateAttributeName: String)

    /// Inserts a collection of `String` values into the `accumulateAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newAccumulateAttributeNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertAccumulateAttributeNames<C>(_ newAccumulateAttributeNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `accumulateAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newAccumulateAttributeName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertAccumulateAttributeName(_ newAccumulateAttributeName: String, at index: Int)

    /// Removes all values from the `accumulateAttributeNames` property.
    final public func removeAllAccumulateAttributeNames()

    /// Removes a sequence of `String` values from the `accumulateAttributeNames` property.
    /// - Parameter accumulateAttributeNames: The `String` values to remove.
    final public func removeAccumulateAttributeNames<S>(_ accumulateAttributeNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `accumulateAttributeNames` property.
    /// - Parameter accumulateAttributeName: The `String` value to remove.
    final public func removeAccumulateAttributeName(_ accumulateAttributeName: String)

    /// The default cutoff value to stop traversing.
    final public var defaultImpedanceCutoff: Double

    /// The default number of target facilities to find.
    final public var defaultTargetFacilityCount: Int

    /// Directions distance units.
    ///
    /// Describes the unit of measurement for the length of directions.
    /// Default value ``UnitSystem/metric`` will be returned on error.
    /// - Note: See Also: ``UnitSystem``
    final public var directionsDistanceUnits: ArcGIS.UnitSystem

    /// Directions language e.g. "en-US".
    ///
    /// The ISO language code of the directions language to be set.
    /// If an unsupported language is set, an exception will occur at solve time in `ClosestFacilityTask.solveClosestFacility(using:)` method.
    /// - Note: See Also: `String`
    final public var directionsLanguage: String

    /// Directions style.
    ///
    /// The directions setting to generate directions designed for different kind of applications.
    /// Default value ``DirectionsStyle/desktop`` will be returned on error.
    /// - Note: See Also: ``DirectionsStyle``
    final public var directionsStyle: ArcGIS.DirectionsStyle

    /// Output spatial reference.
    ///
    /// All route's geometries will be returned in this spatial reference in the even of a successful solve.
    /// - Note: See Also: ``SpatialReference``
    final public var outputSpatialReference: ArcGIS.SpatialReference?

    /// Whether or not turn-by-turn directions for the closest facility routes are to be returned.
    final public var returnsDirections: Bool

    /// Whether or not to return the point barriers used in the closest facility task.
    final public var returnsPointBarriers: Bool

    /// Whether or not to return the polygon barriers used in the closest facility task.
    final public var returnsPolygonBarriers: Bool

    /// Whether or not to return the polyline barriers used in the closest facility task.
    final public var returnsPolylineBarriers: Bool

    /// Whether or not return routes are to be returned.
    ///
    /// Enabled by default. Can be returned in the event of a successful solve.
    final public var returnsRoutes: Bool

    /// Route shape type.
    ///
    /// The enumeration value for the output shape type e.g. straight line shape, `true` shape, or no shape.
    /// Default value `nil` will be returned on error.
    /// - Note: See Also: ``RouteShapeType``
    final public var routeShapeType: ArcGIS.RouteShapeType?

    /// Start time.
    ///
    /// Expects time in the time zone of first ``Stop``.
    /// - Note: See Also: `Date`
    final public var startDate: Date?

    /// Start time usage.
    ///
    /// Default value ``StartTimeUsage/departureTime`` will be returned on error.
    /// - Note: See Also: ``StartTimeUsage``
    final public var startTimeUsage: ArcGIS.StartTimeUsage

    /// The travel direction for the closest facility computation (to or from facility).
    ///
    /// Default value ``TravelDirection/fromFacility`` will be returned on error.
    /// - Note: See Also: ``TravelDirection``
    final public var travelDirection: ArcGIS.TravelDirection

    /// Travel mode.
    ///
    /// Travel mode that will be used for closest facility's solving.
    /// List of supported travel modes can be obtained from ``ClosestFacilityTaskInfo/travelModes`` method.
    /// - Note: See Also: ``TravelMode``
    final public var travelMode: ArcGIS.TravelMode?

    /// Clears facilities.
    ///
    /// Clears facilities that were set by `ClosestFacilityParameters.setFacilities(_:)` or `ClosestFacilityParameters.setFacilities(fromFeaturesIn:queryParameters:)`.
    final public func clearFacilities()

    /// Clears incidents.
    ///
    /// Clears incidents that were set by `ClosestFacilityParameters.setIncidents(_:)` or `ClosestFacilityParameters.setIncidents(fromFeaturesIn:queryParameters:)`.
    final public func clearIncidents()

    /// Clears point barriers.
    ///
    /// Clears point barriers that were set by `ClosestFacilityParameters.setPointBarriers(_:)` or `ClosestFacilityParameters.setPointBarriers(fromFeaturesIn:queryParameters:)`.
    final public func clearPointBarriers()

    /// Clears polygon barriers.
    ///
    /// Clears polygon barriers that were set by `ClosestFacilityParameters.setPolygonBarriers(_:)` or `ClosestFacilityParameters.setPolygonBarriers(fromFeaturesIn:queryParameters:)`.
    final public func clearPolygonBarriers()

    /// Clears polyline barriers.
    ///
    /// Clears polyline barriers that were set by `ClosestFacilityParameters.setPolylineBarriers(_:)` or `ClosestFacilityParameters.setPolylineBarriers(fromFeaturesIn:queryParameters:)`.
    final public func clearPolylineBarriers()

    /// Clones the ``ClosestFacilityParameters``.
    /// - Returns: A new ``ClosestFacilityParameters`` with the same values as the current ``ClosestFacilityParameters``.
    final public func clone() -> Self

    /// Gets the search where clause from the specified network dataset's source feature class.
    /// - Parameter sourceName: The name of the network dataset's source feature class to retrieve the where clause from.
    /// - Returns: A `String` where clause.
    final public func searchWhereClause(fromSourceNamed sourceName: String) -> String

    /// Sets facilities.
    ///
    /// The set of facilities loaded as network locations during analysis.
    /// - Parameter facilities: An `Array` of ``Facility`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``Facility``
    final public func setFacilities<S>(_ facilities: S) where S : Sequence, S.Element == ArcGIS.Facility

    /// Sets the facilities from the features in specified feature table.  The feature table can be either local or online.
    /// The feature table must be of geometry type point.  Attributes from the feature table are mapped to the properties
    /// on the facilities objects generated from the specified feature table.  The where clause set in the query parameters
    /// will be applied to the feature table.  If an online feature table is specified the table will not be queried for
    /// features until Solve is called.
    ///
    /// Sets facilities by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setFacilities(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets incidents.
    ///
    /// The set of incidents loaded as network locations during analysis.
    /// - Parameter incidents: An `Array` of ``Incident`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``Incident``
    final public func setIncidents<S>(_ incidents: S) where S : Sequence, S.Element == ArcGIS.Incident

    /// Sets the incidents from the features in specified feature table.  The feature table can be either local or online.
    /// The feature table must be of geometry type point.  Attributes from the feature table are mapped to the properties
    /// on the incidents objects generated from the specified feature table.  The where clause set in the query parameters
    /// will be applied to the feature table.  If an online feature table is specified the table will not be queried for
    /// features until Solve is called.
    ///
    /// Sets incidents by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setIncidents(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets point barriers.
    /// - Parameter pointBarriers: An `Array` of ``PointBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PointBarrier``
    final public func setPointBarriers<S>(_ pointBarriers: S) where S : Sequence, S.Element == ArcGIS.PointBarrier

    /// Sets the point barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type point.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    ///
    /// Sets point barriers by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPointBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets polygon barriers.
    /// - Parameter polygonBarriers: An `Array` of ``PolygonBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PolygonBarrier``
    final public func setPolygonBarriers<S>(_ polygonBarriers: S) where S : Sequence, S.Element == ArcGIS.PolygonBarrier

    /// Sets the polygon barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type polygon.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    ///
    /// Sets polygon barriers by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPolygonBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets polyline barriers.
    /// - Parameter lineBarriers: An `Array` of ``PolylineBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PolylineBarrier``
    final public func setPolylineBarriers<S>(_ lineBarriers: S) where S : Sequence, S.Element == ArcGIS.PolylineBarrier

    /// Sets the polyline barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type polyline.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    ///
    /// Sets polyline barriers by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPolylineBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets a search where clause on the specified network dataset's source feature class.  Only features satisfying the
    /// where clause for the specified feature class will be used to locate facilities or incidents on the network during the
    /// solve operation.  If a where clause is not set all network features are used.
    /// - Parameters:
    ///   - searchWhereClause: The search where clause
    ///   - sourceName: The name of the network dataset's source feature class the where clause will be applied to.
    final public func setSearchWhereClause(_ searchWhereClause: String, forSourceNamed sourceName: String)
}

/// A class that contains the output results from a ``ClosestFacilityTask``.
///
/// The closest facility result contains all necessary output from a successfully-
/// completed `ClosestFacilityTask.solveClosestFacility(using:)`. This includes collection of routes,
/// barriers and messages.
/// - Note: See Also: ``ClosestFacilityTask``, `ClosestFacilityTask.solveClosestFacility(using:)`
/// - Since: 200.1
final public class ClosestFacilityResult {

    /// Directions language.
    ///
    /// The language used to generate driving directions text instructions.
    /// - Note: See Also: `String`
    final public var directionsLanguage: String { get }

    /// Array of the facilities used to calculate the closest facility.
    /// - Note: See Also: `Array`, ``Facility``
    final public var facilities: [ArcGIS.Facility] { get }

    /// Array of the incidents from which to calculate the closest facility.
    /// - Note: See Also: `Array`, ``Incident``
    final public var incidents: [ArcGIS.Incident] { get }

    /// Messages.
    ///
    /// Messages received when solve is completed. If a route cannot be solved, the message
    /// returned by the server identifies the route that could not be solved.
    /// - Note: See Also: `Array`, `String`
    final public var messages: [String] { get }

    /// Array of the point barriers.
    ///
    /// Barriers are only returned if the returnPointBarriers property of ``ClosestFacilityParameters`` is `true`.
    /// - Note: See Also: `Array`, ``PointBarrier``, ``ClosestFacilityParameters``
    final public var pointBarriers: [ArcGIS.PointBarrier] { get }

    /// Array of the polygon barriers.
    ///
    /// Barriers are only returned if the returnPolygonBarriers property of ``ClosestFacilityParameters`` is `true`.
    /// - Note: See Also: `Array`, ``PolygonBarrier``, ``ClosestFacilityParameters``
    final public var polygonBarriers: [ArcGIS.PolygonBarrier] { get }

    /// Array of the polyline barriers.
    ///
    /// Barriers are only returned if the returnPolylineBarriers property of ``ClosestFacilityParameters`` is `true`.
    /// - Note: See Also: `Array`, ``PolylineBarrier``, ``ClosestFacilityParameters``
    final public var polylineBarriers: [ArcGIS.PolylineBarrier] { get }

    /// Gets facility costs.
    /// - Parameters:
    ///   - attributeName: The name of attribute.
    ///   - facilityIndex: The index of facility.
    /// - Returns: An `Array` of double.
    /// - Note: See Also: `Array`
    final public func costs(forAttributeNamed attributeName: String, ofFacilityAtIndex facilityIndex: Int) -> [Double]

    /// Gets an ordered list of facility indexes for a given incident index.
    ///
    /// The first element in the list is the index of the closest facility, the second element is the next closest, etc.
    /// Multiple properties can effect the number of facilities returned for each incident.
    /// - Parameter incidentIndex: The index of incident.
    /// - Returns: The ordered array of facility indexes at a given incident index.
    /// - Note: See Also: `Array`
    final public func rankedIndexesOfFacilities(forIncidentAtIndex incidentIndex: Int) -> [Int]

    /// Gets route.
    /// - Parameters:
    ///   - facilityIndex: The index of facility.
    ///   - incidentIndex: The index of incident.
    /// - Returns: A ``ClosestFacilityRoute`` between specified facility and incident.
    /// - Note: See Also: ``ClosestFacilityRoute``
    final public func route(toFacilityAtIndex facilityIndex: Int, fromIncidentAtIndex incidentIndex: Int) -> ArcGIS.ClosestFacilityRoute?
}

/// A class that contains the output from a solving closest task for a single result.
///
/// The solving closest route contains all necessary output from a successfully-
/// completed `ClosestFacilityTask.solveClosestFacility(using:)`. This includes the cost, geometry, and
/// additional metadata specific to the resulting route solution (e.g.,
/// route directions, local start/end time, etc.).
/// - Note: See Also: ``ClosestFacilityTask``, `ClosestFacilityTask.solveClosestFacility(using:)`
/// - Since: 200.1
final public class ClosestFacilityRoute {

    /// Arrival curb approach.
    ///
    /// Default value ``CurbApproach/eitherSide`` will be returned on error.
    /// - Note: See Also: ``CurbApproach``
    final public var arrivalCurbApproach: ArcGIS.CurbApproach? { get }

    /// Departure curb approach.
    /// - Note: See Also: ``CurbApproach``
    final public var departureCurbApproach: ArcGIS.CurbApproach? { get }

    /// Direction maneuver.
    ///
    /// The list of turn-by-turn directions for this route.
    /// Can be empty array in case if ``ClosestFacilityParameters/returnsDirections`` is `false`.
    /// - Note: See Also: `Array`, ``DirectionManeuver``, ``ClosestFacilityParameters/returnsDirections``
    final public var directionManeuvers: [ArcGIS.DirectionManeuver] { get }

    /// End time.
    ///
    /// A `nil` if departure/arrival time was not specified in ``ClosestFacilityParameters``.
    /// - Note: See Also: `Date`, ``ClosestFacilityParameters``
    final public var endDate: Date? { get }

    /// The time zone shift for the end date.
    ///
    /// Value of the time zone shift for end date, in seconds.
    /// - Note: See Also: `Date`, ``endDate``
    final public var endDateShift: TimeInterval { get }

    /// Route's geometry.
    ///
    /// The geometry for the full route (polyline) in case if ``ClosestFacilityParameters/returnsRoutes`` is `true`.
    /// - Note: See Also: ``Polyline``
    final public var routeGeometry: ArcGIS.Polyline? { get }

    /// Start time.
    ///
    /// A `nil` if departure/arrival time was not specified in ``ClosestFacilityParameters``.
    /// - Note: See Also: `Date`, ``ClosestFacilityParameters``
    final public var startDate: Date? { get }

    /// The time zone shift for the start date.
    ///
    /// Value of the time zone shift for start date, in seconds.
    /// - Note: See Also: `Date`, ``startDate``
    final public var startDateShift: TimeInterval { get }

    /// Total length in meters.
    ///
    /// The total length of a closest facility route (meters).
    final public var totalLength: Measurement<UnitLength> { get }

    /// The total time for the route.
    ///
    /// The total time in seconds calculated for the route. In order to get this value, time attribute should be set in as impedance or accumulate attribute in parameters object.
    final public var totalTime: TimeInterval { get }

    /// The travel time for the route.
    ///
    /// Travel time is total amount of travel time in seconds, excluding added time from incident/facility added costs (if specified).
    final public var travelTime: TimeInterval { get }

    /// Gets cost.
    ///
    /// Returns the associated cost for this attribute name.
    /// - Parameter attributeName: The name of the attribute name e.g. "Minutes" or "TravelTime".
    /// - Returns: A value of cost.
    final public func cost(forAttributeNamed attributeName: String) -> Double
}

/// A class that implements the closest facility task.
///
/// The closest facility task class uses a transportation network to measure the cost of traveling between incidents
/// and facilities and determines which are nearest to one other.
/// When finding closest facilities, you can specify how many to find and whether the direction of travel is toward or
/// away from them.
/// - Note: See Also: ``Loadable``
/// - Since: 200.1
final public class ClosestFacilityTask : ArcGIS.APIKeyResource, ArcGIS.Loadable {

    /// Creates a closest facility task with path to geodatabase.
    /// - Parameters:
    ///   - databaseURL: A path to geodatabase.
    ///   - networkName: A network name.
    public convenience init(databaseURL: URL, networkName: String)

    /// Creates a closest facility task with transportation network dataset.
    /// - Parameter dataset: A transportation network dataset.
    /// - Note: See Also: ``TransportationNetworkDataset``
    public convenience init(dataset: ArcGIS.TransportationNetworkDataset)

    /// Creates a closest facility task with URL.
    ///
    /// Creates a closest facility task.
    /// - Parameter url: An URL to online routing services.
    public convenience init(url: URL)

    /// Closest facility task info.
    ///
    /// Information about this closest facility task.
    /// For a closest facility task using an online service, this will involve a network call.
    /// - Note: See Also: ``ClosestFacilityTaskInfo``
    final public var info: ArcGIS.ClosestFacilityTaskInfo? { get }

    /// Transportation network dataset.
    /// - Note: See Also: ``TransportationNetworkDataset``
    final public var transportationNetworkDataset: ArcGIS.TransportationNetworkDataset? { get }

    /// The URL of online service.
    /// - Note: See Also: `String`
    final public var url: URL? { get }

    /// Creates default parameters.
    ///
    /// Retrieves the default parameters as defined by the service.
    /// - Returns: A ``ClosestFacilityParameters`` type.
    /// - Note: See Also: ``ClosestFacilityParameters``
    final public func makeDefaultParameters() async throws -> ArcGIS.ClosestFacilityParameters

    /// Solves a closest facility passing in a parameters object.
    ///
    /// Executes the ``ClosestFacilityParameters`` defined for this ``ClosestFacilityTask``
    /// and returns a ``ClosestFacilityResult`` containing the results.
    /// - Parameter closestFacilityParameters: The closest facility parameters.
    /// - Returns: A ``ClosestFacilityResult`` type.
    /// - Note: See Also: ``ClosestFacilityParameters``
    final public func solveClosestFacility(using closestFacilityParameters: ArcGIS.ClosestFacilityParameters) async throws -> ArcGIS.ClosestFacilityResult

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A description of the transportation network to which a closest facility task
/// is bound.
/// - Note: See Also: ``ClosestFacilityTask``
/// - Since: 200.1
public struct ClosestFacilityTaskInfo {
}

extension ClosestFacilityTaskInfo {

    /// Accumulate attribute names.
    /// - Note: See Also: `Array`, `String`
    public var accumulateAttributeNames: [String] { get }

    /// Cost attributes.
    /// - Note: See Also: `Dictionary`
    public var costAttributes: [String : ArcGIS.CostAttribute] { get }

    /// Default impedance cutoff.
    ///
    /// An impedance cutoff is a value for the impedance beyond which facilities should not be found.
    public var defaultImpedanceCutoff: Double { get }

    /// Default target facility count.
    public var defaultTargetFacilityCount: Int { get }

    /// Default travel mode's name.
    /// - Note: See Also: `String`
    public var defaultTravelModeName: String { get }

    /// Directions distance text units.
    ///
    /// Default value ``UnitSystem/metric`` will be returned on error.
    /// - Note: See Also: ``UnitSystem``
    public var directionsDistanceUnits: ArcGIS.UnitSystem { get }

    /// Directions language.
    ///
    /// The language of the output directions e.g. "en-US".
    /// - Note: See Also: `String`
    public var directionsLanguage: String { get }

    /// Directions style.
    ///
    /// The directions setting to generate directions designed for different kind of applications.
    /// Default value ``DirectionsStyle/desktop`` will be returned on error.
    /// - Note: See Also: ``DirectionsStyle``
    public var directionsStyle: ArcGIS.DirectionsStyle { get }

    /// Whether the underlying network dataset supports the returning of directions
    ///
    /// For services prior to ArcGIS 10.8, this value will be `nil`.
    /// - Note: See Also: ``NetworkDirectionsSupport``
    public var directionsSupport: ArcGIS.NetworkDirectionsSupport? { get }

    /// Maximum locating distance is the furthest distance in meters that Network Analyst searches when locating or relocating a point onto the network.
    ///
    /// The search looks for suitable edges or junctions and snaps the point to the nearest one.
    /// If a suitable location isn't found within the maximum locating distance, the object is marked as unlocated.
    public var maxLocatingDistance: Measurement<UnitLength> { get }

    /// Network name.
    /// - Note: See Also: `String`
    public var networkName: String { get }

    /// Output spatial reference.
    ///
    /// The spatial reference that will be used for output geometry during closest facility solving.
    /// - Note: See Also: ``SpatialReference``
    public var outputSpatialReference: ArcGIS.SpatialReference? { get }

    /// Restriction attributes.
    ///
    /// The names of set restriction attributes e.g. "Oneway".
    /// - Note: See Also: `Dictionary`
    public var restrictionAttributes: [String : ArcGIS.RestrictionAttribute] { get }

    /// Route shape type.
    ///
    /// The enumeration value for the output shape type e.g.straight line shape, `true` shape, or no shape.
    /// Default value `nil` will be returned on error.
    /// - Note: See Also: ``RouteShapeType``
    public var routeShapeType: ArcGIS.RouteShapeType? { get }

    /// Start time.
    ///
    /// A `nil` if a start time was not set.
    /// - Note: See Also: `Date`
    public var startDate: Date? { get }

    /// Start time usage.
    ///
    /// Default value ``StartTimeUsage/departureTime`` will be returned on error.
    /// - Note: See Also: ``StartTimeUsage``
    public var startTimeUsage: ArcGIS.StartTimeUsage { get }

    /// Array of supported languages.
    ///
    /// Supported languages of the output directions.
    /// - Note: See Also: `Array`, `String`
    public var supportedLanguages: [String] { get }

    /// Array of supported restriction usage parameter values.
    ///
    /// Array of special string values for restriction usage, such as Avoid_High.
    /// - Note: See Also: `Array`, `String`
    public var supportedRestrictionUsageParameterValues: [String] { get }

    /// Travel direction.
    ///
    /// Default value ``TravelDirection/fromFacility`` will be returned on error.
    /// - Note: See Also: ``TravelDirection``
    public var travelDirection: ArcGIS.TravelDirection { get }

    /// Array of travel modes.
    /// - Note: See Also: `Array`, ``TravelMode``
    public var travelModes: [ArcGIS.TravelMode] { get }
}

/// A `Codable` wrapper around a `JSONSerializable` object.
///
/// An example where this could be helpful would be if the JSON data of a `JSONSerializable` object needed to be stored and retrieved
/// later to restore the state of that object.
/// - Since: 200.1
@propertyWrapper public struct CodableJSONSerializable<Value> where Value : ArcGIS.JSONSerializable {

    /// The type that conforms to `JSONSerializable`.
    public var wrappedValue: Value

    public init(wrappedValue: Value)
}

extension CodableJSONSerializable : Decodable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

extension CodableJSONSerializable : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension CodableJSONSerializable : Hashable where Value : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension CodableJSONSerializable : Equatable where Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.CodableJSONSerializable<Value>, b: ArcGIS.CodableJSONSerializable<Value>) -> Bool
}

/// An object that represents a coded value found in ``CodedValueDomain``.
/// - Since: 200.1
final public class CodedValue {

    /// The code of the coded value.
    final public var code: Any? { get }

    /// The name of the coded value.
    final public var name: String { get }
}

/// An object that describes a ``CodedValue`` to be created.
///
/// Creation of domains is currently only supported on mobile geodatabases,
/// either created in ArcGIS Pro or via `Geodatabase.createEmpty(fileURL:)`.
/// - Since: 200.1
final public class CodedValueDescription {

    /// Creates a new coded value description object with the specified name and value.
    /// - Parameters:
    ///   - name: The coded value's name.
    ///   - value: The coded value's value.
    public convenience init(name: String, value: Any)

    /// The coded value's name.
    final public var name: String

    /// The coded value's value.
    ///
    /// For fields that utilize a coded value domain, the field type must match the type
    /// of the coded values.
    final public var value: Any
}

/// An object that specifies an explicit set of values for a ``Field``.
/// - Since: 200.1
final public class CodedValueDomain : ArcGIS.Domain {

    /// The coded values of this domain.
    final public var codedValues: [ArcGIS.CodedValue] { get }
}

/// An object that describes a ``CodedValueDomain`` to be created.
///
/// Creation of domains is currently only supported on mobile geodatabases,
/// either created in ArcGIS Pro or via `Geodatabase.createEmpty(fileURL:)`.
/// - Since: 200.1
final public class CodedValueDomainDescription : ArcGIS.DomainDescription {

    /// Creates a new coded value domain description object with the specified name and coded values.
    /// - Parameters:
    ///   - name: The coded value domain's name.
    ///   - fieldType: The coded value domain's field type.
    ///   - values: The coded value domain's coded values.
    public convenience init(name: String, fieldType: ArcGIS.FieldType, values: [ArcGIS.CodedValueDescription])

    /// The coded value domain's coded values.
    ///
    /// For fields that utilize a coded value domain, the field type must match the type
    /// of the coded values.
    final public var values: [ArcGIS.CodedValueDescription] { get }
}

/// The color ramp object.
///
/// This object is used to represent a color ramp object.
/// - Since: 200.1
final public class ColorRamp {

    /// The list of predefined color ramp types.
    public enum Preset {

        /// Elevation color ramp.
        case elevation

        /// DEM (for screen display) color ramp.
        case demScreen

        /// DEM (light color) color ramp.
        case demLight

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ColorRamp.Preset, b: ArcGIS.ColorRamp.Preset) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a color ramp with predefined color ramp type and size.
    /// - Parameters:
    ///   - preset: The predefined color ramp type.
    ///   - size: Size of the color ramp. A typical value is 256.
    /// - Precondition: `size > 0`
    public convenience init(preset: ArcGIS.ColorRamp.Preset, size: Int)
}

extension ColorRamp.Preset : Equatable {
}

extension ColorRamp.Preset : Hashable {
}

/// The colormap object.
///
/// This object is used to represent a colormap object.
/// - Since: 200.1
final public class Colormap {

    /// Creates a colormap with specified colors.
    /// - Parameter colors: An array of colors.
    public convenience init(colors: [UIColor])
}

/// A colormap renderer object which is derived from a raster renderer object.
/// - Note: See Also: ``RasterRenderer``
/// - Since: 200.1
final public class ColormapRenderer : ArcGIS.RasterRenderer {

    /// Creates a raster colormap renderer.
    /// - Parameter colormap: Colormap object.
    public convenience init(colormap: ArcGIS.Colormap?)

    /// Creates a raster colormap renderer.
    /// - Parameter colors: An `Array` of `UIColor`.
    public convenience init(colors: [UIColor])

    /// The colormap object.
    final public var colormap: ArcGIS.Colormap? { get }
}

/// Defines a set of symbols that make up a single symbol.
///
/// Composite symbol contains an `Array` of symbols that can be used to compose
/// more complex symbols.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
final public class CompositeSymbol : ArcGIS.Symbol {

    /// Creates a composite symbol object.
    /// - Parameter symbols: Collection of symbols.
    public convenience init(symbols: [ArcGIS.Symbol] = [])

    /// The symbols contained in the composite symbol.
    final public var symbols: [ArcGIS.Symbol] { get }

    /// Adds a sequence of `Symbol` values to the end of the `symbols` property.
    /// - Parameter newSymbols: The new `Symbol` values to append.
    final public func addSymbols<S>(_ newSymbols: S) where S : Sequence, S.Element == ArcGIS.Symbol

    /// Adds a `Symbol` value to the end of the `symbols` property.
    /// - Parameter newSymbol: The new `Symbol` value to append.
    final public func addSymbol(_ newSymbol: ArcGIS.Symbol)

    /// Inserts a collection of `Symbol` values into the `symbols` property at the specified position.
    /// - Parameters:
    ///   - newSymbols: The new `Symbol` values to insert.
    ///   - index: The position at which to insert the new `Symbol` values.
    final public func insertSymbols<C>(_ newSymbols: C, at index: Int) where C : Collection, C.Element == ArcGIS.Symbol

    /// Inserts a `Symbol` value into the `symbols` property at the specified position.
    /// - Parameters:
    ///   - newSymbol: The new `Symbol` value to insert.
    ///   - index: The position at which to insert the new `Symbol` value.
    final public func insertSymbol(_ newSymbol: ArcGIS.Symbol, at index: Int)

    /// Removes all values from the `symbols` property.
    final public func removeAllSymbols()

    /// Removes a sequence of `Symbol` values from the `symbols` property.
    /// - Parameter symbols: The `Symbol` values to remove.
    final public func removeSymbols<S>(_ symbols: S) where S : Sequence, S.Element == ArcGIS.Symbol

    /// Removes a `Symbol` value from the `symbols` property.
    /// - Parameter symbol: The `Symbol` value to remove.
    final public func removeSymbol(_ symbol: ArcGIS.Symbol)
}

/// An enumeration of the various status values for a connection.
///
/// This describes the status of an object that attempts to maintain a persistent connection.
/// - Note: See Also: ``DynamicEntityDataSource``
/// - Since: 200.1
public enum ConnectionStatus {

    /// The connection is not open. This is the initial state of the connection.
    case disconnected

    /// A connection with the remote endpoint has been initiated but is not yet complete.
    case connecting

    /// The connection is open. This is the initial state after the handshake has been completed.
    case connected

    /// The connection has failed.
    case failed

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ConnectionStatus, b: ArcGIS.ConnectionStatus) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ConnectionStatus : Equatable {
}

extension ConnectionStatus : Hashable {
}

/// A network logger that provides debug log messages to the system log and console app.
/// - Since: 200.1
final public class ConsoleNetworkLogger : ArcGIS.NetworkLogger {

    /// The currently running logging task. This needs to be provided by the network logger to
    /// support the default implementation of methods to start and stop logging.
    final public var loggingTask: Task<Void, Never>?

    final public var shouldLogResponseData: Bool

    public init(shouldLogResponseData: Bool = false)

    /// Logs the details of a data task request. The default implementation of this method does nothing.
    /// - Parameter details: The details of the request that will be sent.
    final public func logDataTaskRequest(_ details: ArcGIS.DataTaskRequestDetails)

    /// Logs details of a data task result. The default implementation of this method does nothing.
    /// - Parameters:
    ///   - details: The details about the result of the request.
    final public func logDataTaskResult(_ details: ArcGIS.DataTaskResultDetails)

    /// Logs details of a download task request. The default implementation of this method
    /// does nothing.
    /// - Parameters:
    ///   - details: The details about the request that will be sent.
    final public func logDownloadTaskRequest(_ details: ArcGIS.DownloadTaskRequestDetails)

    /// Logs the details of a download task result. The default implementation of this method
    /// does nothing.
    /// - Parameters:
    ///   - details: The details about the result of the request.
    final public func logDownloadTaskResult(_ details: ArcGIS.DownloadTaskResultDetails)
}

/// An object that defines a contingency.
/// - Since: 200.1
final public class Contingency : Identifiable {

    /// The contingency's unique id.
    final public var id: Int { get }

    /// A boolean indicating if the contingency is retired or not.
    ///
    /// When a contingency is retired, it means that its presence in existing data is acceptable,
    /// but that it should not be presented as an option when editing. It is typically used to
    /// express that a value is no longer valid, such as using asbestos as a building material.
    final public var isRetired: Bool { get }

    /// The subtype to which this contingency is applied.
    final public var subtype: ArcGIS.FeatureSubtype? { get }

    /// The contingency's values.
    ///
    /// Returns a dictionary of field names to the value defined for that field in this contingency.
    final public var values: [String : ArcGIS.ContingentValue] { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = Int
}

/// An object that defines a contingency constraint violation.
/// - Since: 200.1
final public class ContingencyConstraintViolation {

    /// The different types of contingency constraint violations.
    public enum Kind {

        /// A warning violation.
        case warning

        /// An error violation
        case error

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ContingencyConstraintViolation.Kind, b: ArcGIS.ContingencyConstraintViolation.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The field group whose contingencies are in violation.
    final public var fieldGroup: ArcGIS.FieldGroup { get }

    /// The type of violation. If editing is restrictive, it will be an error, otherwise it will be a warning.
    final public var kind: ArcGIS.ContingencyConstraintViolation.Kind { get }
}

extension ContingencyConstraintViolation.Kind : Equatable {
}

extension ContingencyConstraintViolation.Kind : Hashable {
}

/// An object that indicates any domain value is allowed in a contingency.
/// - Since: 200.1
final public class ContingentAnyValue : ArcGIS.ContingentValue {
}

/// An object that defines a coded value specified in a contingency.
/// - Since: 200.1
final public class ContingentCodedValue : ArcGIS.ContingentValue {

    /// The allowed coded value.
    final public var codedValue: ArcGIS.CodedValue { get }
}

/// An object that indicates a `nil` value is allowed in a contingency.
/// - Since: 200.1
final public class ContingentNullValue : ArcGIS.ContingentValue {
}

/// An object that defines a min and max range specified in a contingency.
/// - Since: 200.1
final public class ContingentRangeValue : ArcGIS.ContingentValue {

    /// The maximum allowed value.
    final public var maxValue: Any { get }

    /// The minimum allowed value.
    final public var minValue: Any { get }
}

/// An object that defines possible field values for fields participating in contingent field groups.
/// - Since: 200.1
public class ContingentValue {
}

/// An object that defines a contingent values definition.
/// - Since: 200.1
final public class ContingentValuesDefinition : ArcGIS.Loadable {

    /// A collection of field groups participating in this contingent values definition.
    final public var fieldGroups: [ArcGIS.FieldGroup] { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An object that defines possible values for a field in the context of the contingent field groups it participates in.
/// - Since: 200.1
final public class ContingentValuesResult {

    /// An array of contingent values that satisfy all field groups the array participates in.
    ///
    /// If the field only participates in a single field group, this array will be empty.
    final public var contingentValuesAllGroups: [ArcGIS.ContingentValue] { get }

    /// A dictionary of field group names to arrays of possible contingent values for that field group.
    final public var contingentValuesByFieldGroup: [String : [ArcGIS.ContingentValue]] { get }
}

/// Converts between Points and formatted coordinate notation
/// strings such as decimal degrees; degrees, minutes, and seconds;
/// U.S. National Grid (USNG); and Military Grid Reference System
/// (MGRS).
/// - Since: 200.1
public enum CoordinateFormatter {

    /// Indicates the location of a point relative to a GARS cell.
    public enum GARSConversionMode {

        /// Represents a GARS cell by the coordinate of its south-west corner.
        case lowerLeft

        /// Represents a GARS cell by the coordinate of its center.
        case center

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.CoordinateFormatter.GARSConversionMode, b: ArcGIS.CoordinateFormatter.GARSConversionMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Supported formats for representing latitude-longitude
    /// geographical coordinates as a string.
    public enum LatitudeLongitudeFormat {

        /// The geographical coordinates are represented in decimal degrees.
        case decimalDegrees

        /// The geographical coordinates are represented in degrees and decimal minutes.
        case degreesDecimalMinutes

        /// The geographical coordinates are represented in degrees and minutes and decimal seconds.
        case degreesMinutesSeconds

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.CoordinateFormatter.LatitudeLongitudeFormat, b: ArcGIS.CoordinateFormatter.LatitudeLongitudeFormat) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Determines the lettering scheme and treatment of coordinates
    /// at 180 degrees longitude when converting MGRS coordinates.
    public enum MGRSConversionMode {

        /// The choice of MGRS lettering scheme is based on the datum and
        /// ellipsoid of the spatial reference provided. Spatial references with
        /// new datums (e.g. WGS 84) assume new lettering scheme (AA
        /// scheme). This is equivalent to
        /// ``new180InZone60``. Spatial references with older
        /// datums (e.g. Clarke 1866, Bessel 1841, Clarke 1880) assume old
        /// lettering scheme (AL scheme). This is equivalent to
        /// ``old180InZone60``.  When converted, points with
        /// longitude of exactly 180deg are placed in zone 60.
        case automatic

        /// The MGRS notation uses the new lettering scheme (AA scheme) and,
        /// when converted, places points with longitude of 180deg in zone 01.
        case new180InZone01

        /// The MGRS notation uses the new lettering scheme (AA scheme) and,
        /// when converted, places points with longitude of 180deg in zone 60.
        case new180InZone60

        /// The MGRS notation uses the old lettering scheme (AL scheme) and,
        /// when converted, places points with longitude of 180deg in zone 01.
        case old180InZone01

        /// The MGRS notation uses the old lettering scheme (AL scheme) and,
        /// when converted, places points with longitude of 180deg in zone 60.
        case old180InZone60

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.CoordinateFormatter.MGRSConversionMode, b: ArcGIS.CoordinateFormatter.MGRSConversionMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Determines how latitude is designated in UTM notation.
    ///
    /// Within a single longitudinal zone within the UTM system, two points
    /// share the same grid position: one in the northern hemisphere and one
    /// in the south. Two schemes are used to resolve this ambiguity.  In
    /// the first, the point is designated a latitude band, identified with
    /// letters C through X (omitting I and O). In the second, in place of
    /// the latitude band, a hemisphere indicator (N or S) is used.
    public enum UTMConversionMode {

        /// The letter after the UTM zone number represents a latitudinal band
        /// (C through X, omitting I and O).
        case latitudeBandIndicators

        /// The letter after the UTM zone number represents a hemisphere (N or
        /// S).
        case northSouthIndicators

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.CoordinateFormatter.UTMConversionMode, b: ArcGIS.CoordinateFormatter.UTMConversionMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Returns a formatted coordinate in Global Area Reference System (GARS) notation
    /// representing the given point's location.
    ///
    /// The point must have a spatial reference.
    /// Returns `nil` on error.
    /// - Parameter point: The location to be represented in GARS notation.
    /// - Returns: A GARS notation string representing the GARS cell containing the
    /// given point.
    public static func garsString(from point: ArcGIS.Point) -> String

    /// Returns a formatted coordinate in World Geographic Reference System (GEOREF) notation
    /// representing the given point's location.
    ///
    /// The precision value controls the number of digits used to represent
    /// the fractional part of coordinate's latitude and longitude,
    /// expressed in minutes. For example:
    /// precision | Example output         | Angular precision | Approx precision*
    /// ---------- | ---------------------- | ----------------- | -----------------
    /// 0         | MKML5056               | 1min              | 2km
    /// 1         | MKML5056               | 1min              | 2km
    /// 2         | MKML5056               | 1min              | 2km
    /// 3         | MKML502566             | 0.1min            | 200m
    /// 4         | MKML50285665           | 0.01min           | 20m
    /// 5         | MKML5028256652         | 0.001min          | 2m
    /// At the equator to 1 significant figure.
    /// The 'precision' should be in the interval [0, 9].
    /// The point must have a spatial reference.
    /// Returns `nil` on error.
    /// - Parameters:
    ///   - point: The location to be represented in GEOREF notation.
    ///   - precision: The precision with which to represent the coordinate.
    /// - Returns: A GEOREF notation string representing the position of the given point.
    public static func geoRefString(from point: ArcGIS.Point, precision: Int) -> String

    /// Returns a formatted coordinate in latitude-longitude notation representing
    /// the given point's location.
    ///
    /// The latitude-longitude string contains a space separating the latitude
    /// from the longitude value, and the characters 'N' or 'S', and 'E' and 'W',
    /// to indicate the hemisphere of each value. The string also contains spaces
    /// separating the components (degrees, minutes, seconds) of each value.
    /// The precision of the output is controlled by both the 'format' and
    /// 'decimal_places' parameters. For example:
    /// decimal_places | format                                            | Example output               | Angular precision | Approx precision*
    /// -------------- | ------------------------------------------------- | ---------------------------- | ----------------- | -----------------
    /// 0              | ``LatitudeLongitudeFormat/decimalDegrees``        | 056N 0003W                   | 1deg              | 100km
    /// 1              | ``LatitudeLongitudeFormat/decimalDegrees``        | 55.9N 003.2W                 | 0.1deg            | 10km
    /// 2              | ``LatitudeLongitudeFormat/decimalDegrees``        | 55.94N 003.16W               | 0.01deg           | 1km
    /// 3              | ``LatitudeLongitudeFormat/decimalDegrees``        | 55.944N 003.162W             | 0.001deg          | 100m
    /// 0              | ``LatitudeLongitudeFormat/degreesDecimalMinutes`` | 55 057N 003 010W             | 1min              | 2km
    /// 1              | ``LatitudeLongitudeFormat/degreesDecimalMinutes`` | 55 56.7N 003 09.7W           | 0.1min            | 200m
    /// 2              | ``LatitudeLongitudeFormat/degreesDecimalMinutes`` | 55 56.65N 003 09.72W         | 0.01min           | 20m
    /// 3              | ``LatitudeLongitudeFormat/degreesDecimalMinutes`` | 55 56.650N 003 09.717W       | 0.001min          | 2m
    /// 0              | ``LatitudeLongitudeFormat/degreesMinutesSeconds`` | 55 56 039N 003 09 043W       | 1sec              | 30m
    /// 1              | ``LatitudeLongitudeFormat/degreesMinutesSeconds`` | 55 56 39.1N 003 09 43.0W     | 0.1sec            | 3m
    /// 2              | ``LatitudeLongitudeFormat/degreesMinutesSeconds`` | 55 56 39.12N 003 09 43.03W   | 0.01sec           | 300mm
    /// 3              | ``LatitudeLongitudeFormat/degreesMinutesSeconds`` | 55 56 39.123N 003 09 43.034W | 0.001sec          | 30mm
    /// At the equator to 1 significant figure.
    /// 'decimal_places' should be in the interval [0, 16].
    /// The point must have a spatial reference.
    /// Returns `nil` on error.
    /// - Parameters:
    ///   - point: The location to be represented as a formatted latitude-longitude string.
    ///   - format: The mode to use when formatting the latitude-longitude string.
    ///   - decimalPlaces: The number of decimal places to use.
    /// - Returns: A string representing the latitude-longitude of the
    /// given point.
    /// - Note: See Also: ``LatitudeLongitudeFormat``
    public static func latitudeLongitudeString(from point: ArcGIS.Point, format: ArcGIS.CoordinateFormatter.LatitudeLongitudeFormat, decimalPlaces: Int) -> String

    /// Returns a formatted coordinate in Military Grid Reference System (MGRS)
    /// notation representing the given point's location.
    ///
    /// For an explanation of the different modes for interpreting an MGRS
    /// notation string, please see ``MGRSConversionMode``. Note that the
    /// choice between zone 01 and 60 has an impact only when generating the
    /// MGRS notation string for a point with longitude of exactly 180deg.
    /// The precision value controls the number of digits used to represent each
    /// numerical easting and northing value within the MGRS string. For example:
    /// precision | add_spaces | Example output     | Approx precision
    /// ---------- | ---------- | ------------------ | ----------------
    /// 0         | `false`      | 30UVG              | 100km
    /// 1         | `false`      | 30UVG89            | 10km
    /// 2         | `false`      | 30UVG8999          | 1km
    /// 3         | `false`      | 30UVG898998        | 100m
    /// 4         | `false`      | 30UVG89889988      | 10m
    /// 5         | `false`      | 30UVG8988499881    | 1m
    /// 0         | `true`       | 30U VG             | 100km
    /// 1         | `true`       | 30U VG 8 9         | 10km
    /// 2         | `true`       | 30U VG 89 99       | 1km
    /// 3         | `true`       | 30U VG 898 998     | 100m
    /// 4         | `true`       | 30U VG 8988 9988   | 10m
    /// 5         | `true`       | 30U VG 89884 99881 | 1m
    /// The 'precision' should be in the interval [0, 8].
    /// The point must have a spatial reference.
    /// Returns `nil` on error.
    /// - Parameters:
    ///   - point: The location to be represented in MGRS notation.
    ///   - conversionMode: The mode to use for the returned MGRS notation string.
    ///   - precision: The precision with which to represent the coordinate.
    ///   - addSpaces: If `false`, the generated string contains no spaces. If `true`, a space separates the grid zone designator, the 100km square identifier, and the numerical easting and northing values.
    /// - Returns: An MGRS notation string representing the position of the given point.
    public static func mgrsString(from point: ArcGIS.Point, conversionMode: ArcGIS.CoordinateFormatter.MGRSConversionMode, precision: Int, addSpaces: Bool) -> String

    /// Parses a coordinate in Global Area Reference System (GARS) notation, and
    /// returns a Point representing that location.
    ///
    /// The spatial reference provided must have an ellipsoid and
    /// datum matching those used by the source of the GARS string.
    /// If no spatial reference is provided, it is assumed the GARS string
    /// is referenced to WGS 84.
    /// The GARS string must not contain any whitespace.
    /// <table>
    /// <tr><th>GARS notation examples
    /// <tr><td>354ND
    /// <tr><td>354ND22
    /// </table>
    /// Returns `nil` on error, including when the given string is not valid
    /// GARS notation.
    /// - Parameters:
    ///   - coordinates: The GARS notation string for the coordinate.
    ///   - spatialReference: A spatial reference that defines the datum and ellipsoid referenced by the GARS coordinate.
    ///   - conversionMode: Select whether the returned point's location represents the south-west corner of the GARS cell the coordinate lies within, or its center.
    /// - Returns: A point with the location from the GARS string in the
    /// spatial reference provided.
    public static func point(fromGARSString coordinates: String, spatialReference: ArcGIS.SpatialReference?, conversionMode: ArcGIS.CoordinateFormatter.GARSConversionMode) -> ArcGIS.Point?

    /// Parses a coordinate in World Geographic Reference System (GEOREF) notation,
    /// and returns a Point representing that location.
    ///
    /// The spatial reference provided must have an ellipsoid and
    /// datum matching those used by the source of the GEOREF string.
    /// If no spatial reference is provided, it is assumed the GEOREF string
    /// is referenced to WGS 84.
    /// The GEOREF string may contain leading and trailing whitespace.
    /// <table>
    /// <tr><th>GEOREF notation examples
    /// <tr><td>MKML5056
    /// <tr><td>MKML50285665
    /// </table>
    /// Returns `nil` on error, including when the given string is not valid
    /// GEOREF notation.
    /// - Parameters:
    ///   - coordinates: The GEOREF notation string for the coordinate.
    ///   - spatialReference: A spatial reference that defines the datum and ellipsoid referenced by the GEOREF coordinate.
    /// - Returns: A point with the location from the GEOREF string in the
    /// spatial reference provided.
    public static func point(fromGeoRefString coordinates: String, spatialReference: ArcGIS.SpatialReference?) -> ArcGIS.Point?

    /// Parses a coordinate in latitude-longitude notation, and returns a Point
    /// representing that location. The coordinate may use decimal degrees, degrees
    /// and decimal minutes, or degrees, minutes, and seconds format.
    ///
    /// The spatial reference provided must have an ellipsoid and datum
    /// matching those used by the source of the latitude-longitude
    /// string.
    /// If no spatial reference is provided, it is assumed the latitude-longitude
    /// coordinates are referenced to WGS 84.
    /// <table>
    /// <caption>Supported characters</caption>
    /// <tr><th>Symbol             <th>Character <th>Name                        <th>Unicode number <th>HTML code
    /// <tr><td rowspan="7">Degree <td>*         <td>Asterisk                    <td>U+002A         <td>&#42;
    /// <tr>                       <td>^         <td>Circumflex Accent           <td>U+005E         <td>&#94;
    /// <tr>                       <td>~         <td>Tilde                       <td>U+007E         <td>&#126;
    /// <tr>                       <td>         <td>Degree Sign                 <td>U+00B0         <td>&#176;
    /// <tr>                       <td>         <td>Masculine Ordinal Indicator <td>U+00BA         <td>&#186;
    /// <tr>                       <td>         <td>Ring Above                  <td>U+02DA         <td>&#730;
    /// <tr>                       <td>         <td>Superscript Zero            <td>U+2070         <td>&#8304;
    /// <tr><td rowspan="3">Minute <td>'         <td>Apostrophe                  <td>U+0027         <td>&#39;
    /// <tr>                       <td>         <td>Right Single Quotation Mark <td>U+2019         <td>&#8127;
    /// <tr>                       <td>         <td>Prime                       <td>U+2032         <td>&#8242;
    /// <tr><td rowspan="4">Second <td>"         <td>Quotation Mark              <td>U+0022         <td>&#34;
    /// <tr>                       <td>         <td>Double Acute Accent         <td>U+02DD         <td>&#733;
    /// <tr>                       <td>         <td>Right Double Quotation Mark <td>U+201D         <td>&#8221;
    /// <tr>                       <td>         <td>Double Prime                <td>U+2033         <td>&#8243;
    /// </table>
    /// The latitude-longitude string may contain leading and trailing
    /// whitespace, and may also contain a space, comma, or vertical bar symbol to
    /// separate the latitude from the longitude. It may also contain the characters
    /// 'N', 'S', 'E' and 'W', or use a minus (-) symbol to indicate the hemisphere of
    /// each value.
    /// <table>
    /// <tr><th>Latitude-longitude notation examples
    /// <tr><td>55 56 39.123N 003 09 43.034W
    /// <tr><td>555639N 30943W
    /// <tr><td>55~56.65205', -003~09.71723'
    /// <tr><td>55.9442008* | -3.1619539*
    /// </table>
    /// Returns `nil` on error, including when the given string cannot be
    /// interpreted.
    /// - Parameters:
    ///   - coordinates: The latitude-longitude notation string for the coordinate.
    ///   - spatialReference: A spatial reference that defines the datum and ellipsoid referenced by the latitude-longitude coordinate.
    /// - Returns: A point with the location from the coordinate string in the
    /// spatial reference provided.
    public static func point(fromLatitudeLongitudeString coordinates: String, spatialReference: ArcGIS.SpatialReference?) -> ArcGIS.Point?

    /// Parses a coordinate in Military Grid Reference System (MGRS) notation, and
    /// returns a Point representing that location.
    ///
    /// The spatial reference provided must have an ellipsoid and datum
    /// matching those used by the source of the MGRS string.
    /// If no spatial reference is provided, it is assumed the MGRS string
    /// is referenced to WGS 84.
    /// For an explanation of the different modes for interpreting an MGRS
    /// notation string, please see ``MGRSConversionMode``. Note that the
    /// choice between zone 01 and 60 has no impact when reading from an
    /// MGRS notation string.
    /// The MGRS string can contain leading and trailing whitespace and can
    /// have whitespace between the grid zone designator, the 100km square
    /// identifier, and the numerical eastings and northings.
    /// <table>
    /// <tr><th>MGRS notation examples
    /// <tr><td>30UVG898998
    /// <tr><td>30UVG 89885 99877
    /// </table>
    /// Returns `nil` on error, including when the given string is not valid
    /// MGRS notation.
    /// - Parameters:
    ///   - coordinates: The MGRS notation string for the coordinate.
    ///   - spatialReference: A spatial reference that defines the datum and ellipsoid referenced by the MGRS coordinate.
    ///   - conversionMode: The mode used by the given MGRS coordinates.
    /// - Returns: A point with the location from the MGRS string in the
    /// spatial reference provided.
    /// - Note: See Also: ``MGRSConversionMode``
    public static func point(fromMGRSString coordinates: String, spatialReference: ArcGIS.SpatialReference?, conversionMode: ArcGIS.CoordinateFormatter.MGRSConversionMode) -> ArcGIS.Point?

    /// Parses a coordinate in United States National Grid (USNG) notation, and
    /// returns a Point representing that location.
    ///
    /// The spatial reference provided must have an ellipsoid and datum
    /// matching those used by the source of the USNG string.
    /// If no spatial reference is provided and the USNG string is suffixed
    /// with "(NAD 27)", it is assumed the USNG string is referenced to
    /// NAD 27.
    /// If no spatial reference is provided and no such suffix exists, it is
    /// assumed the USNG string is referenced to WGS 84.
    /// The USNG string can contain leading and trailing whitespace and can
    /// have whitespace between the grid zone designator, the 100km square
    /// identifier and the numerical eastings and northings.
    /// <table>
    /// <tr><th>USNG notation examples
    /// <tr><td>13TFJ 23 59
    /// <tr><td>13TFJ2374159574
    /// </table>
    /// Returns `nil` on error, including when the given string is not valid
    /// USNG notation.
    /// - Parameters:
    ///   - coordinates: The USNG notation string for the coordinate.
    ///   - spatialReference: A spatial reference that defines the datum and ellipsoid referenced by the USNG coordinate.
    /// - Returns: A point with the location from the USNG string in the
    /// spatial reference provided.
    /// - Note: See Also: ``MGRSConversionMode``
    public static func point(fromUSNGString coordinates: String, spatialReference: ArcGIS.SpatialReference?) -> ArcGIS.Point?

    /// Parses a coordinate in Universal Transverse Mercator (UTM) notation, and
    /// returns a Point representing that location.
    ///
    /// The spatial reference provided must have an ellipsoid and datum
    /// matching those used by the source of the UTM string.
    /// If no spatial reference is provided, it is assumed the UTM string is
    /// referenced to WGS 84.
    /// The UTM string can contain leading and trailing whitespace and can
    /// have whitespace between the zone and latitude designator and the
    /// numerical eastings and northings.
    /// <table>
    /// <tr><th>UTM notation examples
    /// <tr><td>30U 489885 6199877
    /// <tr><td>30U4898856199877
    /// <tr><td>30N 489885 6199877 (using N/S indicator)
    /// <tr><td>489885.32,6199877.36,30U (this form supports sub-meter precision)
    /// </table>
    /// Returns `nil` on error, including when the given string is not valid
    /// UTM notation.
    /// - Parameters:
    ///   - coordinates: The UTM notation string for the coordinate.
    ///   - spatialReference: A spatial reference that defines the datum and ellipsoid referenced by the UTM coordinate.
    ///   - conversionMode: The latitude notation scheme used by the given UTM coordinate, either a latitudinal band, or a hemisphere designator.
    /// - Returns: A point with the location from the UTM string in the
    /// spatial reference provided.
    /// - Note: See Also: ``MGRSConversionMode``
    public static func point(fromUTMString coordinates: String, spatialReference: ArcGIS.SpatialReference?, conversionMode: ArcGIS.CoordinateFormatter.UTMConversionMode) -> ArcGIS.Point?

    /// Returns a formatted coordinate in United States National Grid (USNG)
    /// notation representing the given point's location.
    ///
    /// The precision value controls the number of digits used to represent each
    /// numerical easting and northing value within the USNG string. For example:
    /// precision | add_spaces | Example output         | Approx precision
    /// ---------- | ---------- | ---------------------- | ----------------
    /// 0         | `false`      | 13TFJ                  | 100km
    /// 1         | `false`      | 13TFJ25                | 10km
    /// 2         | `false`      | 13TFJ2359              | 1km
    /// 3         | `false`      | 13TFJ237595            | 100m
    /// 4         | `false`      | 13TFJ23745951          | 10m
    /// 5         | `false`      | 13TFJ2374359512        | 1m
    /// 0         | `true`       | 13T FJ                 | 100km
    /// 1         | `true`       | 13T FJ 2 5             | 10km
    /// 2         | `true`       | 13T FJ 23 59           | 1km
    /// 3         | `true`       | 13T FJ 237 595         | 100m
    /// 4         | `true`       | 13T FJ 2374 5951       | 10m
    /// 5         | `true`       | 13T FJ 23743 59512     | 1m
    /// 4       | `false`      | 13TFJ23795929 (NAD 27) | 10m
    /// 2       | `true`       | 13T FJ 23 59 (NAD 27)  | 1km
    /// When the point's spatial reference is based on NAD 27.
    /// The 'precision' should be in the interval [0, 8].
    /// The point must have a spatial reference.
    /// Returns `nil` on error.
    /// - Parameters:
    ///   - point: The coordinate to be represented in MGRS notation.
    ///   - precision: The precision with which to represent the coordinate.
    ///   - addSpaces: If `false`, the generated string contains no spaces. If `true`, a space separates the grid zone designator, the 100km square identifier, and the numerical easting and northing values.
    /// - Returns: A USNG notation string representing the position of the given point.
    public static func usngString(from point: ArcGIS.Point, precision: Int, addSpaces: Bool) -> String

    /// Returns a formatted coordinate in Universal Transverse Mercator (UTM)
    /// notation representing the given point's location.
    ///
    /// Example output for a point in the southern hemisphere:
    /// utm_conversion_mode                          | add_spaces          | Example output
    /// -------------------------------------------- | ------------------- | -------------------
    /// ``UTMConversionMode/latitudeBandIndicators`` | `false`               | 30U4898846199881
    /// ``UTMConversionMode/latitudeBandIndicators`` | `true`                | 30U 489884 6199881
    /// ``UTMConversionMode/northSouthIndicators``   | `false`               | 30N4898846199881
    /// ``UTMConversionMode/northSouthIndicators``   | `true`                | 30N 489884 6199881
    /// The point must have a spatial reference.
    /// Returns `nil` on error.
    /// - Parameters:
    ///   - point: The coordinate to be represented in UTM notation.
    ///   - conversionMode: The latitude notation scheme to use in the returned UTM notation string, either a latitudinal band, or a hemisphere designator.
    ///   - addSpaces: If `false`, the generated string contains no spaces. If `true`, a space separates the UTM zone and latitude designator, and each numerical easting and northing value.
    /// - Returns: A UTM notation string representing the position of the given point.
    public static func utmString(from point: ArcGIS.Point, conversionMode: ArcGIS.CoordinateFormatter.UTMConversionMode, addSpaces: Bool) -> String
}

extension CoordinateFormatter.GARSConversionMode : Equatable {
}

extension CoordinateFormatter.GARSConversionMode : Hashable {
}

extension CoordinateFormatter.LatitudeLongitudeFormat : Equatable {
}

extension CoordinateFormatter.LatitudeLongitudeFormat : Hashable {
}

extension CoordinateFormatter.MGRSConversionMode : Equatable {
}

extension CoordinateFormatter.MGRSConversionMode : Hashable {
}

extension CoordinateFormatter.UTMConversionMode : Equatable {
}

extension CoordinateFormatter.UTMConversionMode : Hashable {
}

/// A structure that describes a transportation network cost attribute.
/// - Since: 200.1
final public class CostAttribute {

    /// Types of unit for network attributes.
    public enum Unit {

        /// A inches attribute unit.
        case inches

        /// A feet attribute unit.
        case feet

        /// A yards attribute unit.
        case yards

        /// A miles attribute unit.
        case miles

        /// A millimeters attribute unit.
        case millimeters

        /// A centimeters attribute unit.
        case centimeters

        /// A decimeters attribute unit.
        case decimeters

        /// A meters attribute unit.
        case meters

        /// A kilometers attribute unit.
        case kilometers

        /// A nautical miles attribute unit.
        case nauticalMiles

        /// A decimal degrees attribute unit.
        case decimalDegrees

        /// A seconds attribute unit.
        case seconds

        /// A minutes attribute unit.
        case minutes

        /// An hours attribute unit.
        case hours

        /// A days attribute unit.
        case days

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.CostAttribute.Unit, b: ArcGIS.CostAttribute.Unit) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Parameters.
    ///
    /// Cost attribute's parameters.
    /// - Note: See Also: `Dictionary`
    final public var parameterValues: [String : Any] { get }

    /// Unit.
    ///
    /// Cost attribute's unit.
    /// - Note: See Also: ``Unit-swift.enum``
    final public var unit: ArcGIS.CostAttribute.Unit? { get }
}

extension CostAttribute.Unit : Equatable {
}

extension CostAttribute.Unit : Hashable {
}

/// A cubic Bezier curve for use in a multipart geometry.
/// - Since: 200.1
final public class CubicBezierSegment : ArcGIS.Segment {

    /// Creates a bezier segment based on a start and end point and two control points at tangents to the start and end points.
    ///
    /// The spatial reference parameter is used if the points have a `nil` spatial reference. If more than one
    /// spatial reference is supplied (as a parameter or as a property of a ``Point`` parameter), they must all be
    /// equal.
    ///
    /// The z-value and m-value of the start and end points (if present) are used in the
    /// ``CubicBezierSegment``. The z-value and m-value of the control points (if present) are ignored.
    /// - Parameters:
    ///   - startPoint: The start point of the segment.
    ///   - controlPoint1: A point tangent to the start of the segment.
    ///   - controlPoint2: A point tangent to the end of the segment.
    ///   - endPoint: The end point of the segment.
    ///   - spatialReference: A spatial reference to use for the segment if the points do not have spatial references set.
    /// - Precondition: All spatial references provided must be the same.
    /// - Precondition: !startPoint.isEmpty
    /// - Precondition: !endPoint.isEmpty
    public convenience init(startPoint: ArcGIS.Point, controlPoint1: ArcGIS.Point, controlPoint2: ArcGIS.Point, endPoint: ArcGIS.Point, spatialReference: ArcGIS.SpatialReference? = nil)

    /// A point tangent to the start of the segment.
    final public var controlPoint1: ArcGIS.Point { get }

    /// A point tangent to the end of the segment.
    final public var controlPoint2: ArcGIS.Point { get }
}

/// The curb approach type.
/// - Since: 200.1
public enum CurbApproach {

    /// An either side curb approach.
    case eitherSide

    /// A left side curb approach.
    case leftSide

    /// A right side curb approach.
    case rightSide

    /// A no U-Turn curb approach.
    case noUTurn

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.CurbApproach, b: ArcGIS.CurbApproach) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension CurbApproach : Equatable {
}

extension CurbApproach : Hashable {
}

/// A ``LocationDataSource`` that can be driven by a user-defined provider of location data.
/// This can be useful if you have location data coming in from some custom source and you
/// would like that data in the form of a ``LocationDataSource`` so that it can interface
/// with other parts of the API.
final public class CustomLocationDataSource<Provider> : ArcGIS.LocationDataSource where Provider : ArcGIS.LocationProvider {

    /// The current provider being used by the data source.
    final public var currentProvider: Provider? { get }

    /// Initializes a ``CustomLocationDataSource``.
    /// - Remark: The `makeProvider` closure parameter is called when the data source is started.
    /// If the `makeProvider` closure throws, then that same error is rethrown by ``LocationDataSource/start()``.
    /// - Parameter makeProvider: A closure that can create a location provider that will provide locations
    /// and headings to the datasource.
    public convenience init(_ makeProvider: @escaping () async throws -> Provider)
}

/// A custom tiled layer type that displays tiled map services and cached image services.
/// - Since: 200.1
final public class CustomTiledLayer : ArcGIS.ImageTiledLayer {

    /// Creates a custom tiled layer with the provided details.
    /// - Parameters:
    ///   - tileInfo: The tile info that specifies the tiling scheme used by the layer.
    ///   - fullExtent: The full extent of the layer.
    ///   - dataProvider: A closure that provides the data for each tile key that is passed in.
    /// - Remark: The `dataProvider` closure parameter is called when a new tile is requested and the data should be
    /// provided for that tile. If the data is `nil`, the tile will be represented as a no data tile.
    public convenience init(tileInfo: ArcGIS.TileInfo = defaultTileInfo, fullExtent: ArcGIS.Envelope = defaultFullExtent, dataProvider: @escaping (ArcGIS.TileKey) async throws -> Data?)
}

/// A Geometric effect object that transforms the representation of a line using a pattern of dashes and gaps.
///
/// Transforms the representation of a line using a pattern of dashes and gaps. Dashes are the symbolized portion
/// of the stroke and gaps are the unsymbolized portion. An `Array` of dash and gap distances (DIP values greater than 0)
/// provides a template to be repeated throughout the line. A basic template consists of two distance values: the first
/// defines the length of each dash and the second defines the length of each gap. More complex effects can be created by
/// defining a template of multiple dashes and gaps. Template values are read as dash distance followed by gap distance
/// throughout the pattern. Templates that contain an odd number of values will maintain the dash-gap pattern by restarting
/// at the beginning of the template. A template of '3 2 1', for example, will be rendered as '3(dash) 2(gap) 1(dash) 3(gap)
/// 2(dash) 1(gap) ...'. The default template is an empty `Array`, which renders a solid line.
/// - Since: 200.1
final public class DashGeometricEffect : ArcGIS.GeometricEffect {

    /// Creates a dash geometric effect using the provided template to define dashes and gaps.
    ///
    /// Transforms the representation of a line using a pattern of dashes and gaps. Dashes are the symbolized portion
    /// of the stroke and gaps are the unsymbolized portion. An `Array` of dash and gap distances (non-negative DIP values)
    /// provides a template to be repeated throughout the line. A basic template consists of two distance values: the first
    /// defines the length of each dash and the second defines the length of each gap. More complex effects can be created by
    /// defining a template of multiple dashes and gaps. Template values are read as dash distance followed by gap distance
    /// throughout the pattern. Templates that contain an odd number of values will maintain the dash-gap pattern by restarting
    /// at the beginning of the template. A template of '3 2 1', for example will be rendered as '3(dash) 2(gap) 1(dash) 3(gap)
    /// 2(dash) 1(gap) ...'. The default template is an empty `Array`, which renders a solid line. If any value in the dash pattern
    /// is negative, the function will throw an exception.
    /// - Parameter dashTemplate: An `Array` of doubles defining dash and gap distances (DIPs) for the geometric effect.
    /// - Precondition: Dash template values must be non-negative.
    public convenience init(dashTemplate: [Double] = [])

    /// The template that defines dashes and gaps for the geometric effect.
    ///
    /// Transforms the representation of a line using a pattern of dashes and gaps. Dashes are the symbolized portion
    /// of the stroke and gaps are the unsymbolized portion. An `Array` of dash and gap distances (non-negative DIP values)
    /// provides a template to be repeated throughout the line. A basic template consists of two distance values: the first
    /// defines the length of each dash and the second defines the length of each gap. More complex effects can be created by
    /// defining a template of multiple dashes and gaps. Template values are read as dash distance followed by gap distance
    /// throughout the pattern. Templates that contain an odd number of values will maintain the dash-gap pattern by restarting
    /// at the beginning of the template. A template of '3 2 1', for example will be rendered as '3(dash) 2(gap) 1(dash) 3(gap)
    /// 2(dash) 1(gap) ...'. The default template is an empty `Array`, which renders a solid line. Adding any negative values
    /// to the collection returned by this function will cause an exception, as only values >= 0 are allowed in dash patterns.
    final public var dashTemplate: [Double] { get }

    /// Adds a sequence of `Double` values to the end of the `dashTemplate` property.
    /// - Parameter newDashTemplate: The new `Double` values to append.
    final public func addDashTemplate<S>(_ newDashTemplate: S) where S : Sequence, S.Element == Double

    /// Adds a `Double` value to the end of the `dashTemplate` property.
    /// - Parameter newDashTemplate: The new `Double` value to append.
    final public func addDashTemplate(_ newDashTemplate: Double)

    /// Inserts a collection of `Double` values into the `dashTemplate` property at the specified position.
    /// - Parameters:
    ///   - newDashTemplate: The new `Double` values to insert.
    ///   - index: The position at which to insert the new `Double` values.
    final public func insertDashTemplate<C>(_ newDashTemplate: C, at index: Int) where C : Collection, C.Element == Double

    /// Inserts a `Double` value into the `dashTemplate` property at the specified position.
    /// - Parameters:
    ///   - newDashTemplate: The new `Double` value to insert.
    ///   - index: The position at which to insert the new `Double` value.
    final public func insertDashTemplate(_ newDashTemplate: Double, at index: Int)

    /// Removes all values from the `dashTemplate` property.
    final public func removeAllDashTemplate()

    /// Removes a sequence of `Double` values from the `dashTemplate` property.
    /// - Parameter dashTemplate: The `Double` values to remove.
    final public func removeDashTemplate<S>(_ dashTemplate: S) where S : Sequence, S.Element == Double

    /// Removes a `Double` value from the `dashTemplate` property.
    /// - Parameter dashTemplate: The `Double` value to remove.
    final public func removeDashTemplate(_ dashTemplate: Double)
}

/// A type that is able to intercept requests and results from a data task.
/// - Since: 200.1
public protocol DataTaskInterceptor {

    /// Intercepts a request and returns a disposition that specifies an action
    /// to take for the intercepted request. The default implementation returns
    /// a disposition of
    /// ``RequestInterceptionDisposition/performOriginalRequest``.
    func interceptRequest(details: ArcGIS.DataTaskRequestDetails) async -> ArcGIS.RequestInterceptionDisposition<(Data, URLResponse), Error>

    /// Intercepts the result of a request and returns a disposition that
    /// specifies an action to take for the intercepted result. The default
    /// implementation returns a disposition of
    /// ``RequestInterceptionDisposition/sendResult(_:)``.
    func interceptResult(details: ArcGIS.DataTaskResultDetails) async -> ArcGIS.ResultInterceptionDisposition<(Data, URLResponse), Error>
}

/// A type that contains details about a data task request.
public protocol DataTaskRequestDetails : ArcGIS.TaskDetails {

    /// The request that will be sent.
    var request: URLRequest { get }
}

/// A type that contains details about the result of a data task.
public protocol DataTaskResultDetails : ArcGIS.TaskDetails {

    /// The original request that went out to the network.
    var originalRequest: URLRequest { get }

    /// The current request was used to receive the current result.
    /// This value is typically the same as the ``originalRequest`` except when the server has
    /// responded to the original request with a redirect to a different URL. The underlying
    /// system (`URLSession`) may choose to add additional headers the original request as well.
    /// These header values would show up in this property.
    var currentRequest: URLRequest { get }

    /// The result of the `currentRequest`.
    var result: Result<(Data, URLResponse), Error> { get }
}

/// Represents a function to convert between two coordinate systems.
///
/// This is the base class for classes used to transform coordinates between spatial
/// references that have different datums. The inverse of the datum transformation,
/// used to transform in the opposite direction, may be accessed using a member
/// function.
///
/// A datum transformation has a name property intended to be suitable for display,
/// such as when displaying a list of available transformations to an end user.
///
/// You can get a list of suitable transformations for a given input and output spatial
/// reference using methods of the ``TransformationCatalog`` class. Some transformations
/// require that certain Projection Engine data files be present on the local file system.
/// The property ``isMissingProjectionEngineFiles`` indicates whether
/// any of the files are missing. The complete list of necessary files is available using
/// the ``GeographicTransformationStep/projectionEngineFilenames`` or
/// ``HorizontalVerticalTransformationStep/projectionEngineFilenames`` properties.
///
/// In order for any Projection Engine files to be found, the data location must be set
/// first using the ``TransformationCatalog/projectionEngineDirectoryURL`` property.
///
/// A datum transformation object is immutable.
/// - Since: 200.1
public class DatumTransformation {

    /// The input ``SpatialReference``.
    public var inputSpatialReference: ArcGIS.SpatialReference? { get }

    /// Returns the inverse of this datum transformation.
    public var inverse: ArcGIS.DatumTransformation? { get }

    /// `true` if the dataset needed by the Projection Engine is missing from the local file system.
    public var isMissingProjectionEngineFiles: Bool { get }

    /// The name of the datum transformation.
    ///
    /// For multi-step transformations, the name contains the concatenated names of
    /// each step's transformation, separated by a plus sign '+'. If the transformation is
    /// inverted, the name starts with a tilde (~).
    public var name: String { get }

    /// The output ``SpatialReference``.
    public var outputSpatialReference: ArcGIS.SpatialReference? { get }
}

extension DatumTransformation : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.DatumTransformation, rhs: ArcGIS.DatumTransformation) -> Bool
}

extension DatumTransformation : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Renders geoelements using symbols generated from a ``DictionarySymbolStyle``.
///
/// The DictionaryRenderer applies symbols to features or graphics according
/// to a set of input attribute values. The symbol primitives and logic (rule engine) for
/// applying symbols is provided by an associated ``DictionarySymbolStyle``.
///
/// The ``DictionarySymbolStyle`` depends on attribute names to define the
/// symbology of each feature. The attributes reference different symbol components
/// in the style, which are assembled to create a complex symbol. In order to display
/// geoelements using the DictionaryRenderer, attributes in your data must either use
/// the expected attribute names or be mapped to the proper style attributes.
/// - Note: See Also: ``DictionarySymbolStyle``
/// - Since: 200.1
final public class DictionaryRenderer : ArcGIS.Renderer {

    /// Creates a new dictionary renderer object.
    /// - Parameters:
    ///   - dictionarySymbolStyle: The dictionary symbol style to be used with the renderer.
    ///   - symbologyFieldOverrides: A `Dictionary` containing `String` types.
    ///   - textFieldOverrides: A `Dictionary` containing `String` types.
    public convenience init(dictionarySymbolStyle: ArcGIS.DictionarySymbolStyle, symbologyFieldOverrides: [String : String] = [:], textFieldOverrides: [String : String] = [:])

    /// The dictionary symbol style to be applied by the renderer.
    final public var dictionarySymbolStyle: ArcGIS.DictionarySymbolStyle

    /// An arcade expression object with an expression for scaling symbols in a dictionary renderer.
    ///
    /// ``ArcadeExpression`` is evaluated at rendering time. If the expression is not valid or results in an invalid value, symbols will not be scaled and will display at their original size.
    /// For example to scale symbols based on attribute value, ArcadeExpression object's expression property can be set to something like `iif($feature.Symbol_Set == 40, 2.5, 1) //Scale symbol size 2.5 times when symbol_set is 40`.
    final public var scaleExpression: ArcGIS.ArcadeExpression?

    /// The map of a symbology attribute and its override used to fetch a symbol from the dictionary symbol style.
    ///
    /// A DictionarySymbolStyle uses a collection of expected attribute names to build a symbol based on input values. When
    /// initialized, fields in the input dataset are mapped to the expected attribute names using case-insensitive matching.
    /// If your data uses a different name for an expected symbol attribute, use the SymbologyFieldOverrides to map an expected field to the
    /// correct field in your data. You can also exclude an expected field by providing an empty string for it in the overrides.
    final public var symbologyFieldOverrides: [String : String] { get }

    /// Sets a value in the `symbologyFieldOverrides` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setSymbologyFieldOverrideValue(_ value: String?, forKey key: String)

    /// The map of a text attribute and its override used to fetch symbol text and placement from the dictionary symbol style.
    ///
    /// A DictionarySymbolStyle uses a collection of expected attribute names to build a symbol based on input values. When
    /// initialized, fields in the input dataset are mapped to the expected attribute names using case-insensitive matching.
    /// If your data uses a different name for an expected text attribute, use the TextFieldOverrides to map an expected field to the
    /// correct field in your data. You can also exclude an expected field by providing an empty string for it in the overrides.
    final public var textFieldOverrides: [String : String] { get }

    /// Sets a value in the `textFieldOverrides` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setTextFieldOverrideValue(_ value: String?, forKey key: String)
}

/// A dictionary symbol style object containing symbol primitives and rules for generating symbols from attribute values.
///
/// A ``DictionarySymbolStyle`` is created either from a style file on disk (an SQLite database with a .stylx extension, created with ArcGIS Pro)
/// or from a dictionary style file hosted on ArcGIS Online or an ArcGIS Enterprise portal (also referred to as a dictionary web style)
///
/// A ``DictionarySymbolStyle`` must contain a set of symbol primitives and a rule engine that
/// parses input fields. The ``DictionarySymbolStyle`` assembles new symbols based on the input attribute values.
/// ``DictionarySymbolStyle`` is often used to render symbols from a military specification (such as Mil2525D or App6B)
/// but can also be used with a custom style.
///
/// A DictionarySymbolStyle is used in conjunction with a ``DictionaryRenderer`` to symbolize geoelements in a
/// ``FeatureLayer`` or ``GraphicsOverlay``.
///
/// Esri builds and maintains some dictionary web styles according to the US and NATO military symbol specifications. These desktop and web styles are hosted online and are publicly available.
/// Refer to the [ArcGIS Online Dictionary Symbology Styles group](https://www.arcgis.com/home/group.html?id=07dd0bdb5ea441269a05a502508eb499&view=list&tags=military+symbology#content) for the latest versions of the styles available.
/// - Note: See Also: ``DictionaryRenderer``
/// - Since: 200.1
final public class DictionarySymbolStyle : ArcGIS.SymbolStyle {

    /// Creates a new dictionary symbol style object from a portal item. The portal item must contain a dictionary style.
    ///
    /// If you have the item id of a style file, you can search the portal to find the item using its item id.
    /// Use this constructor if you have a reference to a portal item.
    /// - Parameter portalItem: A ``PortalItem`` that contains a dictionary style.
    public convenience init(portalItem: ArcGIS.PortalItem)

    /// The collection of configuration settings for the custom dictionary style.
    final public var configurations: [ArcGIS.DictionarySymbolStyleConfiguration] { get }

    /// The name of the custom Arcade-based dictionary style. For older version style files, this is an empty string.
    final public var dictionaryName: String { get }

    /// The string list of attributes used to construct a symbol from the DictionarySymbolStyle.
    ///
    /// For example, mil2525d would include "identity", "symbolset", "symbolentity", and "modifier1", among
    /// many others. The newer Arcade-based styles define such attributes within the .stylx
    /// file as a JSON string.
    final public var symbologyFieldNames: [String] { get }

    /// The string list of attributes used to obtain text values for display with a symbol from a DictionarySymbolStyle.
    ///
    /// For example, mil2525d would include "combateffectiveness", "credibility", "reliability", and
    /// "staffcomment", among many others. The newer Arcade-based styles define such attributes within the .stylx
    /// file as a JSON string.
    final public var textFieldNames: [String] { get }

    /// Asynchronously returns a symbol based on the provided attributes.
    ///
    /// This function is useful for obtaining a single, multi-layer symbol from supplied
    /// attributes. This is commonly used to create symbols and graphics on-the-fly. For
    /// example, with mil2525d, you may want to obtain a symbol where "symbolset" is 40,
    /// "modifier1" is "Incident Qualifier : Accident", "echelon" is "Army", and so on.
    /// All of these key/value pairs can be used to obtain the specific symbol that
    /// you need. Once you have that symbol, you can apply it to a ``Graphic`` or ``Renderer``,
    /// obtain its swatch image, or serialize to JSON.
    /// If the DictionarySymbolStyle is not loaded then initiating this task will start the load cycle.
    /// - Parameter attributes: `Dictionary` of `String` type key and `Any` value. It is a key value pair for the attributes required to obtain symbol from the rule engine associated to Dictionary symbol style.
    /// - Returns: A ``Symbol``.
    final public func symbol(attributes: [String : Any]) async throws -> ArcGIS.Symbol

    override final public func load() async throws
}

extension DictionarySymbolStyle {

    /// Creates a dictionary symbol style instance with the specified .stylx file or using a web style item URL.
    /// - Parameter url: The URL to a .stylx file on disk or to a web style item.
    dynamic public convenience init(url: URL)
}

/// Configuration settings for a custom ``DictionarySymbolStyle``.
///
/// These configuration settings are returned from a DictionarySymbolStyle.
/// - Since: 200.1
final public class DictionarySymbolStyleConfiguration {

    /// The list of possible values for this configuration property.
    final public var domain: [Any] { get }

    /// A description of the configuration as defined by the style author.
    final public var info: String { get }

    /// The name of the property as defined by the style configuration.
    final public var name: String { get }

    /// The value of the configuration property.
    ///
    /// The configuration may be defined with a default value.
    final public var value: Any
}

/// A layer that can visualize dimension features data.
///
/// Dimension features are a special kind of annotation feature for showing specific lengths or distances on a map.
/// A dimension may indicate the length of a side of a building or land parcel,
/// or the distance between two features, such as a fire hydrant and the corner of a building.
/// They are described in detail in
/// ["Dimension"](https://pro.arcgis.com/en/pro-app/latest/help/data/dimensions/dimensions-in-arcgis-pro.htm).
///
/// Each Dimension feature has specific text and specific locations for its schematic lines and arrows.
///
/// Dimension features are not linked to other point, line or polygon features,
/// even if the dimension measurement was created to refer to one or more features.
///
/// You can construct a dimension layer using a feature table containing dimension features:
/// - An online ``ServiceFeatureTable`` that has a feature layer service type of
///   ``ArcGISFeatureLayerInfoServiceType/dimensionLayer``
/// - An offline ``GeodatabaseFeatureTable`` returned by the
///   ``Geodatabase/dimensionTables`` collection when a
///   ``GenerateGeodatabaseJob`` has completed
///
/// Dimension layers can be taken offline from a feature service hosted on ArcGIS Enterprise
/// 10.9 or later, using the ``GeodatabaseSyncTask``. Dimension layers are also supported in
/// mobile map packages or mobile geodatabases created in ArcGIS Pro 2.9 or later.
///
/// Dimension respects the reference scale defined by the map, so dimension will always be
/// presented to the user at the correct size and position, as defined by the dimension
/// author.
///
/// You cannot add, change, or delete a dimension feature. Any attempt produces a "Geodatabase table not
/// editable" (3016) error.
///
/// The ``featureTable`` associated with this ``DimensionLayer`` contains a set of attributes (fields,
/// in other words) that define ["dimensions"](https://pro.arcgis.com/en/pro-app/latest/help/data/dimensions/dimensions-in-arcgis-pro.htm).
/// These attributes, automatically added by ArcGIS Pro, are described in ["Dimension fields"](https://pro.arcgis.com/en/pro-app/latest/help/data/dimensions/manage-dimension-feature-class-properties.htm).
/// The author of the dimension layer may have also added additional fields. You can query and use any of these
/// attributes in a definition expression but you cannot change their value.
///
/// You do not have access to, and cannot change, the renderer or the styles used for rendering dimensions.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class DimensionLayer : ArcGIS.Layer {

    /// Creates a new dimension layer object from a feature service portal item.
    /// - Parameters:
    ///   - featureServiceItem: A feature service ``PortalItem``.
    ///   - layerID: The layer ID for which to create the layer.
    /// - Note: See Also: ``Layer/item``
    public convenience init(featureServiceItem: ArcGIS.Item, layerID: Int)

    /// Creates a dimension layer from a feature table containing dimension features.
    ///
    /// If the feature table does not contain dimension data then the DimensionLayer will fail to load.
    /// ``ArcGISFeatureTable/layerInfo`` and ``ArcGISFeatureLayerInfo/featureServiceType`` can be checked, to verify the
    /// feature type, before attempting to create a ``Layer``.
    /// - Parameter featureTable: The feature table, containing dimension features, used as the source of the dimension layer.
    /// - Note: See Also: ``ArcGISFeatureTable``
    public convenience init(featureTable: ArcGIS.ArcGISFeatureTable)

    /// Creates a new dimension layer from a feature service URI.
    ///
    /// If the specified URI is not a valid Feature Service endpoint, then it will fail to load.
    /// - Parameter url: The URI to the feature service layer.
    public convenience init(url: URL)

    /// The weight of dimension features when considered as barriers to labeling.
    ///
    /// The default is ``LabelBarrierWeight/high``.
    final public var barrierWeight: ArcGIS.LabelBarrierWeight

    /// An expression which is a SQL statement where clause to specify the subset of features to be displayed.
    ///
    /// The definition expression string uses the SQL-92 where clause syntax
    /// (https://en.wikipedia.org/wiki/SQL-92).
    /// The default value is an empty string, which will allow all dimension features
    /// in the data source to be used by the ``DimensionLayer``.
    /// - Warning: Be sure to escape special characters
    /// in the expression string as required for your platform. The DATE keyword expects
    /// the date format yyyy-mm-dd and the TIMESTAMP keyword expects the time stamp format
    /// yyyy-mm-dd hh:mm:ss. See the ArcGIS Blog article entitled "Querying Feature Services
    /// Date-Time Queries"
    /// (https://www.esri.com/arcgis-blog/products/api-rest/data-management/querying-feature-services-date-time-queries/)
    /// for more information.
    final public var definitionExpression: String

    /// The feature table associated with this layer.
    final public var featureTable: ArcGIS.ArcGISFeatureTable? { get }

    /// The layer ID that defines the layer within the feature service portal item.
    /// - Note: See Also: ``Layer/item``, ``layerID``
    final public var layerID: Int { get }

    /// The reference scale for the layer. If `nil`, there is no reference scale.
    ///
    /// The reference scale of the layer is the scale at which a client should view the layer
    /// for the schematic lines and text to appear at its authored size.
    ///
    /// If the client changes the viewing scale, then schematic lines and text will grow or shrink to keep a
    /// consistent size on the map (not the screen).
    ///
    /// For a valid layer, the reference scale will always be a finite value, greater than
    /// zero. Until the layer is loaded, the reference scale will be zero.
    final public var referenceScale: Double? { get }

    /// Returns a list of the currently selected features.
    final public var selectedFeatures: ArcGIS.FeatureQueryResult { get async throws }

    /// The URI of a feature service to define the layer.
    /// - Note: See Also: ``url``
    final public var url: URL? { get }

    /// Updates any selected features in the layer back to the un-selected state.
    final public func clearSelection()

    /// Resets the visibility of the layer's features back to the original visibility when loaded from the data source.
    final public func resetFeaturesVisible()

    /// Selects the given feature and adds it to the current list of
    /// selected features.
    /// - Parameter feature: The feature.
    final public func selectFeature(_ feature: ArcGIS.Feature)

    /// Selects the features in the list and adds them to the current list of
    /// selected features.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func selectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Selects the features that match the criteria in the ``QueryParameters`` object and
    /// adds them to the current list of selected features.
    /// - Parameters:
    ///   - parameters: The definition of the query to submit to the feature table.
    ///   - mode: Defines how the list of currently selected features will be updated with the features returned from the query.
    /// - Returns: A ``FeatureQueryResult``.
    @discardableResult
    final public func selectFeatures(using parameters: ArcGIS.QueryParameters, mode: ArcGIS.FeatureLayer.SelectionMode) async throws -> ArcGIS.FeatureQueryResult

    /// Sets the visibility of the given features.
    /// - Parameters:
    ///   - visible: `true` to show, `false` to hide.
    ///   - features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func setVisible<S>(_ visible: Bool, for features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Sets the visibility of the given feature.
    /// - Parameters:
    ///   - visible: `true` to show, `false` to hide.
    ///   - feature: The feature.
    final public func setVisible(_ visible: Bool, for feature: ArcGIS.Feature)

    /// Unselects the given feature and removes it from
    /// the current list of selected features.
    /// - Parameter feature: The feature.
    final public func unselectFeature(_ feature: ArcGIS.Feature)

    /// Unselects the features in the given list and
    /// removes them from the current list of selected features.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    final public func unselectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature
}

/// A class that contains description of directions event.
/// - Since: 200.1
final public class DirectionEvent {

    /// Estimated arrival time.
    ///
    /// The estimated arrival time for this segment of the route.
    /// - Note: See Also: `Date`
    final public var estimatedArrivalDate: Date? { get }

    /// The time zone shift (based on the event location) for the estimated arrival date.
    ///
    /// The time zone shift of estimated arrival date for this segment of the route.
    final public var estimatedArrivalDateShift: TimeInterval { get }

    /// Event's geometry.
    ///
    /// The geometry for the route direction.
    /// - Note: See Also: ``Point``
    final public var geometry: ArcGIS.Point? { get }

    /// Event messages.
    ///
    /// The detailed direction info passed back from a route solving operation.
    /// - Note: See Also: `Array`, `String`
    final public var messages: [String] { get }

    /// Event text.
    /// - Note: See Also: `String`
    final public var text: String { get }
}

/// A class that contains properties of directions maneuver.
/// - Since: 200.1
final public class DirectionManeuver {

    /// Type of direction maneuver.
    public enum Kind {

        /// A stop maneuver.
        case stop

        /// A moving straight.
        case straight

        /// A bear left.
        case bearLeft

        /// A bear right.
        case bearRight

        /// A turn left.
        case turnLeft

        /// A turn right.
        case turnRight

        /// A sharp turn left.
        case sharpLeft

        /// A sharp turn right.
        case sharpRight

        /// An u-turn.
        case uTurn

        /// A maneuver connected with a ferry.
        case ferry

        /// A maneuver via roundabout.
        case roundabout

        /// A merge of several highways.
        case highwayMerge

        /// An exit from highway.
        case highwayExit

        /// A change of highway.
        case highwayChange

        /// A straight at fork.
        case forkCenter

        /// A maneuver to the left at fork.
        case forkLeft

        /// A maneuver to the right at fork.
        case forkRight

        /// A departure.
        case depart

        /// A connected with trip planning.
        case tripItem

        /// An end of ferry transfer.
        case endOfFerry

        /// A maneuver to the right on ramp.
        case rampRight

        /// A maneuver to the left on ramp.
        case rampLeft

        /// A complex maneuver: turn left, then right.
        case turnLeftRight

        /// A complex maneuver: turn right, then left.
        case turnRightLeft

        /// A complex maneuver: turn right, then right.
        case turnRightRight

        /// A complex maneuver: turn left, then left.
        case turnLeftLeft

        /// A maneuver via pedestrian ramp.
        case pedestrianRamp

        /// A maneuver using elevator.
        case elevator

        /// A maneuver using escalator.
        case escalator

        /// A maneuver using stairs.
        case stairs

        /// A passing through a door.
        case doorPassage

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.DirectionManeuver.Kind, b: ArcGIS.DirectionManeuver.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The duration of the direction maneuver.
    ///
    /// The time this segment of the route will take to traverse.
    final public var duration: TimeInterval { get }

    /// Estimated arrive time.
    ///
    /// The estimated arrival time for this segment of the route.
    /// - Note: See Also: `Date`
    final public var estimatedArrivalDate: Date? { get }

    /// The time zone shift for the estimated arrive date.
    ///
    /// The time zone shift of the estimated arrival date for this segment of the route.
    final public var estimatedArrivalDateShift: TimeInterval { get }

    /// Direction events.
    ///
    /// The directions events i.e. passing state boundaries, etc. from the solve operation.
    /// - Note: See Also: `Array`, `String`
    final public var events: [ArcGIS.DirectionEvent] { get }

    /// The logical level at the start of the maneuver.
    ///
    /// For maneuvers that go up or down levels, such as going from floor 1 to floor 2 in a building's stairwell, the from-level value signifies the start level of the maneuver. For example, to go from floor 1 to floor 2, the from-level would be 1 and the to-level would be 2. If these values are in the source data, the directions engine can give a descriptive instruction for the maneuver, such as "go up the stairs." If the values are not provided, a -1 value is used, signifying that no levels are defined for maneuvers.
    final public var fromLevel: Int { get }

    /// A geometry that represents the maneuver type in directions, such as a left turn or traveling in a straight line.
    ///
    /// The geometry for the route direction.
    /// - Note: See Also: ``Geometry``
    final public var geometry: ArcGIS.Geometry? { get }

    /// Maneuver type.
    ///
    /// The maneuver used to perform this direction (E.g. Depart, Go Straight, etc).
    /// - Note: See Also: ``Kind-swift.enum``
    final public var kind: ArcGIS.DirectionManeuver.Kind? { get }

    /// Length in meters.
    ///
    /// The length of this segment of the route.
    final public var length: Measurement<UnitLength> { get }

    /// Maneuver messages.
    ///
    /// The detailed direction info passed back from a route solving operation.
    /// - Note: See Also: `Array`, `String`
    final public var messages: [ArcGIS.DirectionMessage] { get }

    /// Direction text.
    ///
    /// The textual representation of the direction (e.g. Turn right on Main Street).
    /// - Note: See Also: `String`
    final public var text: String { get }

    /// The logical level at the end of the maneuver.
    ///
    /// For maneuvers that go up or down levels, such as going from floor 1 to floor 2 in a building's stairwell, the to-level value signifies the ending level of the maneuver. For example, to go from floor 1 to floor 2, the from-level would be 1 and the to-level would be 2. If these values are in the source data, the directions engine can give a descriptive instruction for the maneuver, such as "go up the stairs." If the values are not provided, a -1 value is used, signifying that no levels are defined for maneuvers.
    final public var toLevel: Int { get }
}

extension DirectionManeuver.Kind : Equatable {
}

extension DirectionManeuver.Kind : Hashable {
}

/// A directions string.
/// - Since: 200.1
final public class DirectionMessage {

    /// Type of direction string.
    public enum Kind {

        /// A street name.
        case streetName

        /// An alternative street name.
        case alternativeName

        /// A signpost branch.
        case branch

        /// A signpost toward.
        case toward

        /// An intersected street name.
        case crossStreet

        /// A signpost exit.
        case exit

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.DirectionMessage.Kind, b: ArcGIS.DirectionMessage.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Direction string type.
    ///
    /// The type of the direction string.
    /// - Note: See Also: ``Kind-swift.enum``
    final public var kind: ArcGIS.DirectionMessage.Kind { get }

    /// Direction string text.
    ///
    /// The text for directions.
    /// - Note: See Also: `String`
    final public var text: String { get }
}

extension DirectionMessage.Kind : Equatable {
}

extension DirectionMessage.Kind : Hashable {
}

/// The network directions output type.
/// - Since: 200.1
public enum DirectionsStyle {

    /// The driving directions generated by this style are good for desktop/printing apps.
    case desktop

    /// The driving directions generated by this style are good for navigation applications.
    case navigation

    /// The driving directions generated by this style are good for campus routing.
    case campus

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.DirectionsStyle, b: ArcGIS.DirectionsStyle) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension DirectionsStyle : Equatable {
}

extension DirectionsStyle : Hashable {
}

/// Represents a type used for limiting which features are rendered.
///
/// Features filtered from display remain available for query and analysis.
/// Use display filter when only a subset of features needs to be visible while maintaining
/// access to all features.
/// - Note: See Also: ``ScaleDisplayFilterDefinition/filters``, ``ManualDisplayFilterDefinition/activeFilter``
/// - Since: 200.1
public class DisplayFilter {

    /// Creates a new ``DisplayFilter`` with the specified name and where clause.
    /// - Parameters:
    ///   - name: A descriptive name for this display filter.
    ///   - whereClause: A SQL expression that defines which features are rendered.
    public convenience init(name: String, whereClause: String)

    /// The identifier for this display filter.
    ///
    /// Use a unique name to identify this display filter when used in a webmap as a
    /// ``ManualDisplayFilterDefinition/activeFilter``.
    public var filterID: String { get }

    /// A descriptive name for this display filter.
    public var name: String

    /// A SQL expression that defines which features are rendered.
    ///
    /// The where clause string that is used as the ``whereClause`` should follow standard SQL syntax
    /// similar to what is discussed in the document
    /// [SQL reference for query expressions used in ArcGIS](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm).
    ///
    /// A where clause that is not valid for the data may result in no features being drawn
    /// when this display filter is applied either by ``ManualDisplayFilterDefinition/activeFilter``
    /// or by ``ScaleRangeDisplayFilter/maxScale``. Check the layer's ``LayerViewState`` for a
    /// ``LayerViewState/Status-swift.struct/warning``; if there is one, then there might be a ``LayerViewState/error``
    /// describing that the display filter's where clause is not valid.
    public var whereClause: String
}

/// Provides definition on how features are filtered from the display.
///
/// When ``FeatureLayer/displayFilterDefinition`` is not `nil`, only features that satisfy the currently applied
/// display filter are rendered.
/// Use this to improve data visualization or optimize rendering performance.
/// - Note: See Also: ``ManualDisplayFilterDefinition``, ``ScaleDisplayFilterDefinition``
/// - Since: 200.1
public class DisplayFilterDefinition {
}

/// Defines a set of symbols and their visible distance range.
///
/// Distance composite scene symbol contain symbols with distance ranges.
/// Based on distance from the camera the symbols are rendered or not. Note that the ranges
/// for each symbol are independent and may overlap.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
final public class DistanceCompositeSceneSymbol : ArcGIS.Symbol {

    /// Create a distance composite scene symbol object.
    ///
    /// Use this method to create an distance composite scene symbol which is a container of Symbols with distance
    /// display ranges. Each symbol add to the contained range collection can specify a minimum and maximum display distance.
    /// when a feature is render the distance from the camera will be check against the specified minimum and maximum range to
    /// determine the symbols visibility. Note that symbol ranges for the contained symbols are not exclusing so may overlap.
    public convenience init()

    /// The symbols distance ranges.
    final public var ranges: [ArcGIS.DistanceSymbolRange] { get }

    /// Adds a sequence of `DistanceSymbolRange` values to the end of the `ranges` property.
    /// - Parameter newRanges: The new `DistanceSymbolRange` values to append.
    final public func addRanges<S>(_ newRanges: S) where S : Sequence, S.Element == ArcGIS.DistanceSymbolRange

    /// Adds a `DistanceSymbolRange` value to the end of the `ranges` property.
    /// - Parameter newRange: The new `DistanceSymbolRange` value to append.
    final public func addRange(_ newRange: ArcGIS.DistanceSymbolRange)

    /// Inserts a collection of `DistanceSymbolRange` values into the `ranges` property at the specified position.
    /// - Parameters:
    ///   - newRanges: The new `DistanceSymbolRange` values to insert.
    ///   - index: The position at which to insert the new `DistanceSymbolRange` values.
    final public func insertRanges<C>(_ newRanges: C, at index: Int) where C : Collection, C.Element == ArcGIS.DistanceSymbolRange

    /// Inserts a `DistanceSymbolRange` value into the `ranges` property at the specified position.
    /// - Parameters:
    ///   - newRange: The new `DistanceSymbolRange` value to insert.
    ///   - index: The position at which to insert the new `DistanceSymbolRange` value.
    final public func insertRange(_ newRange: ArcGIS.DistanceSymbolRange, at index: Int)

    /// Removes all values from the `ranges` property.
    final public func removeAllRanges()

    /// Removes a sequence of `DistanceSymbolRange` values from the `ranges` property.
    /// - Parameter ranges: The `DistanceSymbolRange` values to remove.
    final public func removeRanges<S>(_ ranges: S) where S : Sequence, S.Element == ArcGIS.DistanceSymbolRange

    /// Removes a `DistanceSymbolRange` value from the `ranges` property.
    /// - Parameter range: The `DistanceSymbolRange` value to remove.
    final public func removeRange(_ range: ArcGIS.DistanceSymbolRange)
}

/// Used contain multiple symbols with distance ranges.
///
/// Distance composite symbol displays graphics with multiple symbols that may have distance ranges.
/// The range contains a minimum and maximum distance for rendering the symbol. Outside of that range
/// the symbol is not visible.
/// - Note: See Also: ``DistanceCompositeSceneSymbol``, ``DistanceSymbolRange``
/// - Since: 200.1
final public class DistanceSymbolRange {

    /// Create a distance symbol range object.
    ///
    /// Creates a Distance symbol range with just no symbol or no range properties.
    public convenience init()

    /// The maximum distance (in meters) of the distance symbol range. If `nil`, there is no maximum.
    ///
    /// The maximum distance (in meters) of the distance symbol range object.
    final public var maxDistance: Double?

    /// The minimum distance (in meters) of the distance symbol range. If `nil`, there is no minimum.
    ///
    /// The minimum distance (in meters) of the distance symbol range object.
    final public var minDistance: Double?

    /// The symbol (in meters) of the distance symbol range.
    ///
    /// The symbol ``Symbol`` of the distance symbol range object.
    final public var symbol: ArcGIS.Symbol?
}

extension DistanceSymbolRange {

    /// Create a distance symbol range object.
    /// - Remark: The symbol will only be visible when the camera is within the specified distance range.
    /// - Parameters:
    ///   - symbol: A symbol to set in the distance symbol range.
    ///   - minDistance: The minimum distance to set in the distance symbol range. The value should be
    ///   greater than or equal to zero. If `nil`, there is no minimum.
    ///   - maxDistance: The maximum distance to set in the distance symbol range. The value should be
    ///   greater than or equal to zero. If `nil`, there is no maximum.
    public convenience init(symbol: ArcGIS.Symbol, minDistance: Double? = nil, maxDistance: Double? = nil)
}

/// An object that represents the valid values for a ``Field``.
/// - Since: 200.1
public class Domain : ArcGIS.JSONSerializable {

    /// The field type of the domain.
    public var fieldType: ArcGIS.FieldType? { get }

    /// The name of the domain.
    public var name: String { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension Domain : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Domain, rhs: ArcGIS.Domain) -> Bool
}

extension Domain : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// An object that describes a domain to be created.
/// - Since: 200.1
public class DomainDescription {

    /// The field type of the domain to be created.
    ///
    /// Specifies the field type of the domain. Valid field types are ``FieldType/int16``, ``FieldType/int32``,
    /// ``FieldType/float32``, ``FieldType/float64``, and ``FieldType/date``. Additionally, for
    /// ``CodedValueDomainDescription``, ``FieldType/text`` is valid.
    public var fieldType: ArcGIS.FieldType? { get }

    /// The name of the domain to be created.
    ///
    /// Specifies the name of the domain. The domain name must be non-empty, consist only of alphanumeric characters and underscores,
    /// and cannot start with a number or an underscore.
    public var name: String { get }
}

/// A job to download an offline map area from an online map as part of the preplanned offline workflow.
///
/// Use this job to download the map content of a map area to your device so that you can work
/// offline without a network connection. Upon completion, the job's
/// ``DownloadPreplannedOfflineMapResult`` provides the offline map along with the details of
/// any errors incurred during the download process.
/// - Since: 200.1
final public class DownloadPreplannedOfflineMapJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// The directory path to the location of the mobile map package.
    ///
    /// The directory path is the path that was supplied as a parameter to the
    /// `OfflineMapTask.makeDownloadPreplannedOfflineMapJob(parameters:downloadDirectory:)`. The job will fail if the last directory
    /// in the path cannot be created or is not empty.
    final public var downloadDirectoryURL: URL { get }

    /// The online map used by this job.
    final public var onlineMap: ArcGIS.Map? { get }

    /// The preplanned map parameters used to create this job.
    final public var parameters: ArcGIS.DownloadPreplannedOfflineMapParameters { get }

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.DownloadPreplannedOfflineMapResult

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.DownloadPreplannedOfflineMapJob.Output, Error> { get async }
}

/// Parameters used for creating a ``DownloadPreplannedOfflineMapJob``.
/// - Since: 200.1
final public class DownloadPreplannedOfflineMapParameters {

    /// Different modes for how updates are obtained for a preplanned offline map area.
    public enum UpdateMode {

        /// No feature updates will be performed.
        case noUpdates

        /// Changes, including local edits, will be synced directly with the underlying feature services.
        ///
        /// This mode gives you full control over when you upload and download changes. However,
        /// performing a download sync places additional load on the backing feature service, so
        /// this approach does not scale well for larger deployments.
        ///
        /// This mode is available when the ``PreplannedMapArea/updateCapabilities`` include
        /// ``OfflineMapUpdateCapabilities/supportsSyncWithFeatureServices``.
        case syncWithFeatureServices

        /// Scheduled, read-only updates will be downloaded from the online map area and applied to the local mobile geodatabases.
        ///
        /// Updates are prepared on a regular schedule and cached for download by all users of the
        /// offline map area. Sharing a single set of cached updates, rather than performing
        /// individual sync operations, reduces the load on the back-end services. This approach is
        /// scalable for large deployments but does not support offline editing.
        ///
        /// This mode is available when the ``PreplannedMapArea/updateCapabilities`` include
        /// ``OfflineMapUpdateCapabilities/supportsScheduledUpdatesForFeatures``.
        case downloadScheduledUpdates

        /// Scheduled, read-only updates are downloaded from the online map area and applied to the local mobile geodatabases. Newly added features can also be uploaded to the feature service.
        ///
        /// This is an advanced workflow that improves the scalability of feature services. When
        /// available, applicable scheduled update packages are downloaded and merged into a
        /// local geodatabase. This allows for efficient downloading of changes. New features are
        /// uploaded using feature sync, which is an efficient operation in the feature service.
        ///
        /// Note that when the required update packages are not available, the local geodatabase will be
        /// replaced with a new copy. ``OfflineMapUpdatesInfo/mobileMapPackageReopenIsRequired``
        /// indicates that a new copy of a geodatabase will be downloaded. Local adds on your device
        /// must be uploaded to the feature service before the database can safely be replaced.
        ///
        /// Be aware that immediately following replacement, the new geodatabase may not contain the
        /// new features that have been synced up to the feature service, as this relies on a
        /// subsequent scheduled update to download to the client. The new features will be
        /// retrieved when the next scheduled update is downloaded and applied.
        ///
        /// This mode is available when the ``PreplannedMapArea/updateCapabilities`` include both
        /// ``OfflineMapUpdateCapabilities/supportsSyncWithFeatureServices`` and
        /// ``OfflineMapUpdateCapabilities/supportsScheduledUpdatesForFeatures`` and the feature
        /// services in your map support creating new features.
        case downloadScheduledUpdatesAndUploadNewFeatures

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.DownloadPreplannedOfflineMapParameters.UpdateMode, b: ArcGIS.DownloadPreplannedOfflineMapParameters.UpdateMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a download preplanned offline map parameters object.
    public convenience init()

    /// Creates a download preplanned offline map parameters object with the given offline map area.
    /// - Parameter preplannedMapArea: preplanned map area representing area to be downloaded for offline use.
    public convenience init(preplannedMapArea: ArcGIS.PreplannedMapArea)

    /// Indicates whether or not the download preplanned offline map job should continue running in the event of failure
    /// to take a layer offline.
    ///
    /// If this property is `true`, failure to take a layer or table offline will not fail the job, the failure will be
    /// exposed in the job result. If this property is `false`, failure to take a layer or table offline will fail the job
    /// and no more layers or tables will be taken offline. The layer or table's error will be available as the job's error.
    /// The default value is `true`.
    final public var continuesOnErrors: Bool

    /// Indicates whether or not a basemap will be included in the offline map.
    ///
    /// If you do not want a basemap in the offline map then set this property to `false`.
    ///
    /// After loading the offline map, your application can programmatically insert a basemap
    /// into the map. Note that, a programmatically inserted basemap will not be persisted in
    /// the map.
    ///
    /// If you want a basemap in the offline map then set this property to `true`. You can choose
    /// to either:
    /// * Download and use the basemap that is part of the ``PreplannedMapArea``. This is the
    ///   default.
    /// * Use the local basemap on the device by setting the
    ///   ``referenceBasemapDirectoryURL``
    ///
    /// The default value is `true`.
    final public var includesBasemap: Bool

    /// The offline map area that will be downloaded for offline use.
    final public var preplannedMapArea: ArcGIS.PreplannedMapArea?

    /// The path to a directory on the device where the local basemap file is located.
    ///
    /// Set this property to use a basemap which is already on the device (rather than
    /// downloading it). The directory should only be set when
    /// ``referenceBasemapFilename`` is defined.
    ///
    /// This property supports any directory specified as either:
    /// * An absolute path
    /// * A path relative to the parent directory of the generated mobile map package (see
    ///   downloadPath for `OfflineMapTask.makeDownloadPreplannedOfflineMapJob(parameters:downloadDirectory:)`)
    ///
    /// If the directory does not exist, or does not contain the specified basemap, the
    /// ``DownloadPreplannedOfflineMapJob`` will fail.
    ///
    /// Note that, the mobile map package will store either a relative or absolute path to the
    /// reference basemap file so that it can be opened in the future.
    ///
    /// A relative path typically begins with "." to denote the parent directory of the
    /// resulting mobile map package or ".." to move up one directory. The parent directory
    /// of the mobile map package will be set when calling
    /// `OfflineMapTask.makeGenerateOfflineMapJob(parameters:downloadDirectory:overrides:)`.
    ///
    /// For example, to download a mobile map package to
    ///  "[my root path]/my_offline_maps/my_mobile_map_package", which uses a reference basemap
    ///  in "[my root path]/other_maps/my_basemap.tpk", you would set the relative path as
    ///  follows:
    /// * ``DownloadPreplannedOfflineMapJob/downloadDirectoryURL`` to
    ///   "[my root path]/my_offline_maps/my_mobile_map_package"
    /// * ``referenceBasemapDirectoryURL`` to
    ///   "../other_maps"
    /// * ``referenceBasemapFilename`` to
    ///   "my_basemap.tpk"
    ///
    /// Note that, this property is ignored if
    /// ``includesBasemap`` is `false`.
    final public var referenceBasemapDirectoryURL: URL?

    /// The name of a local basemap file on the device which can be used rather than downloading an online basemap.
    ///
    /// The local basemap filename must end with .tpk, .tpkx or .vtpk since these are the supported file formats.
    /// This property can be read directly from settings applied by the author of the online web map
    /// (see ``OfflineSettings``) or set by user code to a file known to be on the device.
    /// This property will be populated from online settings when created with
    /// `OfflineMapTask.makeDefaultDownloadPreplannedOfflineMapParameters(preplannedMapArea:)`.
    ///
    /// If you wish to use the specified local basemap rather than downloading, you must also set
    /// ``referenceBasemapDirectoryURL``.
    ///
    /// If the directory does not exist, or does not contain the specified basemap filename, the ``DownloadPreplannedOfflineMapJob``
    /// will fail.
    ///
    /// The spatial reference of the reference basemap is used for the offline map when it is different to
    /// the online map's spatial reference.
    ///
    /// Note that this property is ignored if ``includesBasemap`` is `false`.
    /// - Note: See Also: ``OfflineSettings``
    final public var referenceBasemapFilename: String

    /// Describes how the offline map will obtain feature updates from the online service.
    ///
    /// The preplanned workflow offers three modes for updating the feature data in your offline
    /// map:
    /// * Sync feature changes directly with online feature services.
    /// * Download a set of scheduled update packages (geodatabase delta files that are cached on the
    ///   server) from the online map area.
    /// * Download scheduled updates from the online map area and upload new features to the feature service.
    ///
    /// To register your mobile geodatabases for syncing with online feature services, set this
    /// property to ``UpdateMode-swift.enum/syncWithFeatureServices``. Syncing allows you to
    /// upload as well as download changes, so this approach should be used when you need full
    /// control to edit your data. As you sync changes directly with the back-end services, you
    /// will receive the most up-to-date feature data available. This is the default mode if you
    /// construct the ``DownloadPreplannedOfflineMapParameters``.
    ///
    /// To download a set of cached updates (delta files) from the online map area, set this
    /// property to ``UpdateMode-swift.enum/downloadScheduledUpdates``. With this approach,
    /// updates are generated whenever the online map area is refreshed - for example according
    /// to its update schedule. Updates are prepared once and cached for download by all users
    /// of the offline map area. Sharing a single set of cached updates, rather than performing
    /// individual sync operations, reduces the load on the back-end services - this makes this
    /// approach scalable for large deployments. As updates are only downloaded, this approach
    /// can only be used with read-only workflows. The updates also reflect a snapshot of the
    /// feature data at the time the online map area was refreshed - rather than the most
    /// up-to-date information. The web map author must configure the online map to store
    /// cached updates for this approach.
    ///
    /// To use a hybrid approach where you download scheduled updates and upload new features,
    /// set this property to
    /// ``UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures``. This approach
    /// combines the scalability of downloading scheduled updates with the ability to collect
    /// and share data in the field. Note that this approach is strictly add only, meaning that
    /// you cannot delete or edit features once they have been uploaded to the feature service.
    ///
    /// If you use a ``updateMode-swift.property`` of
    /// ``UpdateMode-swift.enum/downloadScheduledUpdates`` or
    /// ``UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures``, with a web map
    /// that does not support scheduled updates, the resultant
    /// ``DownloadPreplannedOfflineMapJob`` will fail with an error `Error.code` of
    /// `CoreErrorCode.mappingScheduledUpdatesNotSupported`.
    final public var updateMode: ArcGIS.DownloadPreplannedOfflineMapParameters.UpdateMode
}

extension DownloadPreplannedOfflineMapParameters.UpdateMode : Equatable {
}

extension DownloadPreplannedOfflineMapParameters.UpdateMode : Hashable {
}

/// The result of a ``DownloadPreplannedOfflineMapJob``
///
/// When the job completes it returns the offline map and indicates whether any errors were incurred during the download process
/// (``hasErrors``). Examine the individual layer and table errors to identify the source
/// of the problem. For example, the loss of the online service, a layer or table may not be taken offline or export tiles has
/// not been enabled on the layer.
/// - Since: 200.1
final public class DownloadPreplannedOfflineMapResult {

    /// Indicates that there is at least one layer or table that could not be taken offline.
    ///
    /// To determine which layers or tables could not be taken offline examine the ``layerErrors``
    /// and the ``tableErrors``, respectively.
    final public var hasErrors: Bool { get }

    /// A dictionary of layers that could not be taken offline.
    ///
    /// Iterate through the dictionary to examine the error strings to determine why the layers failed to be taken offline.
    final public var layerErrors: [ArcGIS.LayerErrorKey : Error] { get }

    /// The mobile map package containing the requested offline map.
    final public var mobileMapPackage: ArcGIS.MobileMapPackage { get }

    /// The offline map containing the requested preplanned map area.
    final public var offlineMap: ArcGIS.Map { get }

    /// A dictionary of tables to errors for any tables that could not be taken offline.
    ///
    /// Iterate through the dictionary and examine the error strings to determine why the tables failed to be taken offline.
    final public var tableErrors: [ArcGIS.TableErrorKey : Error] { get }
}

/// A type that is able to intercept requests and results from a download task.
/// - Since: 200.1
public protocol DownloadTaskInterceptor {

    /// Intercepts a request and returns a disposition that specifies an action
    /// to take for the intercepted request. The default implementation returns
    /// a disposition of
    /// ``RequestInterceptionDisposition/performOriginalRequest``.
    func interceptRequest(details: ArcGIS.DownloadTaskRequestDetails) async -> ArcGIS.RequestInterceptionDisposition<URLResponse, Error>

    /// Intercepts the result of a request and returns a disposition that
    /// specifies an action to take for the intercepted result. The default
    /// implementation returns a disposition of
    /// ``ResultInterceptionDisposition/sendOriginalResult``.
    func interceptResult(details: ArcGIS.DownloadTaskResultDetails) async -> ArcGIS.ResultInterceptionDisposition<URLResponse, Error>
}

/// A value that provides information about a progress update of a download task.
/// - Since: 200.1
public struct DownloadTaskProgress : Hashable {

    /// The amount of data downloaded and written to the destination since the last progress update.
    public var downloaded: Measurement<UnitInformationStorage>

    /// The total amount of data downloaded and written to the destination.
    public var totalDownloaded: Measurement<UnitInformationStorage>

    /// The total amount of data expected to be downloaded.
    public var totalExpected: Measurement<UnitInformationStorage>?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.DownloadTaskProgress, b: ArcGIS.DownloadTaskProgress) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A type that contains details about a download task request.
public protocol DownloadTaskRequestDetails : ArcGIS.TaskDetails {

    /// The request that will be sent.
    var request: URLRequest { get }

    /// The location of the file that a successful download will be saved to.
    var destinationURL: URL { get }
}

/// A type that contains details about a download task result.
public protocol DownloadTaskResultDetails : ArcGIS.TaskDetails {

    /// The original request that went out to the network.
    var originalRequest: URLRequest { get }

    /// The current request was used to receive the current result.
    /// This value is typically the same as the ``originalRequest`` except when the server has
    /// responded to the original request with a redirect to a different URL. The underlying
    /// system (`URLSession`) may choose to add additional headers the original request as well.
    /// These header values would show up in this property.
    var currentRequest: URLRequest { get }

    /// The location of the file that a successful download will be saved to.
    var destinationURL: URL { get }

    /// The result of ``currentRequest``.
    var result: Result<URLResponse, Error> { get }
}

/// The status of drawing in the `GeoView`.
///
/// Use this status to determine whether the content of a view is still drawing or drawing is completed. The
/// drawing state of a `GeoView` can either be ``inProgress`` or ``completed``.
///
/// For example, when using `GeoView.exportImage()` to take a screen capture of the view's visible area, you
/// can use the draw status to determine whether the `GeoView` content has been rendered.
///
/// If you need to ensure that an individual layer has loaded and is visible, examine the ``LayerViewState``
/// returned by the `GeoView.viewState(for:)` method.
/// - Note: See Also: `GeoView`, ``LayerViewState``
/// - Since: 200.1
public enum DrawStatus {

    /// Drawing of the `GeoView` content is in progress.
    case inProgress

    /// Drawing of the `GeoView` content is complete.
    case completed

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.DrawStatus, b: ArcGIS.DrawStatus) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension DrawStatus : Equatable {
}

extension DrawStatus : Hashable {
}

/// An object that provides various information on how to render features in a feature layer.
/// - Since: 200.1
final public class DrawingInfo {

    /// The labeling info objects of this drawing info.
    final public var labelingInfo: [ArcGIS.LabelingInfo] { get }

    /// The renderer attached to this drawing info.
    final public var renderer: ArcGIS.Renderer? { get }

    /// `true` if symbols should be scaled.
    final public var scalesSymbols: Bool { get }

    /// `true` if labels should be shown.
    final public var showsLabels: Bool { get }

    /// The transparency.
    final public var transparency: Double { get }
}

/// A ``GeoElement`` that represents a real-world object received from a ``DynamicEntityDataSource``.
///
/// Dynamic entities are updated with data coming from a stream. These updates are referred to as observations and are
/// represented by the ``DynamicEntityObservation`` class. An observation is a static snapshot of the state of a dynamic
/// entity at a given time. This snapshot includes the associated dynamic entity's location (geometry) as well as all
/// its attributes. For example, an observation for a moving aircraft may include updates to attributes like speed,
/// altitude, and heading in addition to its updated location. While observations remain static, a dynamic entity
/// changes because it's essentially a pointer to the most recent observation.
///
/// The properties of a ``DynamicEntity``, such as its attributes and geometry, are updated when new observations are
/// received from the server. You should not cache the ``geometry`` or
/// ``attributes`` collection properties as they are completely replaced when a new observation is
/// received for the associated ``DynamicEntity``.
/// - Note: See Also: ``DynamicEntityLayer``
/// - Since: 200.1
final public class DynamicEntity : ArcGIS.GeoElement {

    /// Notification that ``DynamicEntity`` has changed.
    ///
    /// This event is raised any time an associated observation is received from a ``DynamicEntityDataSource`` or when
    /// an observation is purged from the local data cache.
    final public var changes: AsyncStream<ArcGIS.DynamicEntityChangedInfo> { get }

    /// A unique identifier for the ``DynamicEntity``.
    ///
    /// The entityId property uniquely identifies a ``DynamicEntity``.
    final public var id: Int { get }

    /// Gets the latest ``DynamicEntityObservation`` associated with this dynamic entity.
    ///
    /// The observation returned by this method represents a snapshot of the state of this dynamic entity at the time the observation was received.
    /// This method may return `nil` if the dynamic entity has been purged from the local data cache.
    /// - Note: See Also: ``DynamicEntityDataSource/PurgeOptions-swift.class``
    final public var latestObservation: ArcGIS.DynamicEntityObservation? { get }

    /// Gets the collection of ``DynamicEntityObservation`` objects associated with this dynamic entity.
    ///
    /// Use this method to get a collection of ``DynamicEntityObservation`` objects associated with this dynamic
    /// entity. Observations are associated with a dynamic entity through a shared track ID. For ``ArcGISStreamService``
    /// data sources, the track ID field is defined by the ``ArcGISStreamServiceInfo/trackIDField`` property.
    ///
    /// The returned observations are sorted from the most recent to the oldest.
    ///
    /// This method may return an empty collection if the dynamic entity has been purged from the local data cache.
    /// - Parameter maximumObservations: The maximum number of observations to return, including the latest.
    /// - Returns: An array of observations of a ``DynamicEntity``.
    /// - Note: See Also: ``ArcGISStreamServiceInfo``, ``DynamicEntityDataSource/PurgeOptions-swift.class``
    final public func observations(maximumObservations: Int) -> [ArcGIS.DynamicEntityObservation]

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    final public var attributes: [String : Any] { get }

    /// The geometry defines the shape and location of the ``GeoElement``.
    final public var geometry: ArcGIS.Geometry? { get }
}

/// Describes changes to a ``DynamicEntity`` sent by ``DynamicEntity/changes``.
///
/// An object of this type is sent as an argument to the ``DynamicEntity/changes``. This event is
/// raised whenever observations associated with an existing dynamic entity are received from the data source or purged
/// from the local data cache.
///
/// If the last observation has been purged from the local data cache, the ``dynamicEntityWasPurged``
/// property is set to `true`. This indicates that the dynamic entity has been purged and will receive no more associated
/// observations from the data source.
/// - Since: 200.1
public struct DynamicEntityChangedInfo {
}

extension DynamicEntityChangedInfo {

    /// Indicates whether the ``DynamicEntity`` itself has been purged.
    ///
    /// This flag is set when the last observation associated with this dynamic entity has been purged from the
    /// local data cache. In this case, the dynamic entity is also purged and will not be associated with any new
    /// observations received from the data source.
    ///
    /// Purge of a dynamic entity can be caused by exceeding the limits defined by ``DynamicEntityDataSource/purgeOptions-swift.property``
    /// or by an explicit call to `DynamicEntityDataSource.purgeAll()`.
    ///
    /// The default is `false`.
    public var dynamicEntityWasPurged: Bool { get }

    /// The purged ``DynamicEntityObservation``.
    ///
    /// If an observation associated with this dynamic entity was purged, this property contains the purged
    /// ``DynamicEntityObservation``.
    ///
    /// The default is `nil`, meaning no observation associated with this dynamic entity was purged.
    ///
    /// When a call to `DynamicEntityDataSource.purgeAll()` causes multiple observations for a dynamic entity to be
    /// purged, this property is set to the last purged observation of this dynamic entity and
    /// ``dynamicEntityWasPurged`` is set to `true`.
    public var purgedObservation: ArcGIS.DynamicEntityObservation? { get }

    /// The newly received ``DynamicEntityObservation``.
    ///
    /// When an observation associated with this dynamic entity is received from the data source, this property
    /// contains the received observation.
    ///
    /// The default is `nil`, meaning no observation associated with this dynamic entity was received.
    public var receivedObservation: ArcGIS.DynamicEntityObservation? { get }
}

/// A dynamic entity data source that streams observations to a client.
///
/// The ``DynamicEntityDataSource`` class is the base class for classes that stream dynamic entity data. The class
/// provides methods and properties that allow:
/// * maintenance of a persistent connection for streaming
/// * control over the storage of observations in its local data cache
/// * notification of received or purged observations
///
/// This class is used as the data source for a ``DynamicEntityLayer``.
/// - Note: See Also: ``ArcGISStreamService``
/// - Since: 200.1
public class DynamicEntityDataSource : ArcGIS.Loadable {

    /// The current network connection `Error`.
    ///
    /// This property is `nil` until an attempt to connect the data source is made. If a connection attempt
    /// succeeds, this property is set to `nil`. If a connection fails, this property contains the
    /// platform-specific error.
    ///
    /// If ``maximumReconnectionAttempts`` is greater than 0, this property will
    /// contain the exception that caused the data source to lose the connection.
    public var connectionError: Error? { get }

    /// The current network connection status of the ``DynamicEntityDataSource``.
    ///
    /// This property contains the state of the connection throughout the lifetime of the data source. The initial
    /// value of this property is ``ConnectionStatus/disconnected``.
    ///
    /// Notification of a change to the property is signaled through ``connectionStatus``.
    @ArcGIS.Streamed public var connectionStatus: ArcGIS.ConnectionStatus { get }

    public var $connectionStatus: AsyncStream<ArcGIS.ConnectionStatus> { get }

    /// The maximum number of attempts to reconnect after a connection fails.
    ///
    /// This property informs the data source to attempt reconnection if a connection is lost. When a connection fails,
    /// the data source attempts to reconnect the specified number of times waiting
    /// ``reconnectionInterval`` between attempts.
    ///
    /// If reconnection fails on the final attempt, ``connectionStatus`` is set to
    /// ``ConnectionStatus/failed`` and the ``connectionError`` is set to the platform specific
    /// connection error.
    ///
    /// The default value is 12. The first 2 connection attempts are made without waiting the specified
    /// ``reconnectionInterval`` between attempts.
    public var maximumReconnectionAttempts: Int

    /// A ``PurgeOptions-swift.class`` that defines when observations are purged from the local data cache.
    ///
    /// Data received from the ``DynamicEntityDataSource`` is stored in memory on the client and can grow quickly
    /// depending on the number of dynamic entities and frequency of updates. If purge options are not set appropriately,
    /// a data source may store too many observations in its local data cache and cause performance and memory
    /// issues for the application. Use the ``purgeOptions-swift.property`` property to control app data storage
    /// for the local cache.
    ///
    /// This property must be set before loading the data source and cannot be changed once the data source is loaded.
    ///
    /// By default, purge options are set to remove observations from the data cache when a maximum limit of 100,000
    /// observations is reached.
    ///
    /// Note that you can clear all observations from the cache using `DynamicEntityDataSource.purgeAll()`. This
    /// clears all data from the local data cache, but does not disconnect from the stream. Dynamic entities and
    /// observations will continue to be added to the local data cache as they come from the stream.
    public var purgeOptions: ArcGIS.DynamicEntityDataSource.PurgeOptions { get }

    /// Notification that a ``DynamicEntity`` was purged.
    ///
    /// This event is raised whenever the last observation associated with a dynamic entity was purged. When this
    /// happens, the ``DynamicEntity`` is also purged and will not be associated with any new observations streamed from
    /// the data source.
    ///
    /// This event will not be raised when all ``DynamicEntity`` objects are purged when calling
    /// `DynamicEntityDataSource.purgeAll()`.
    public var purgedEntities: AsyncStream<ArcGIS.DynamicEntityInfo> { get }

    /// Notification that a ``DynamicEntityObservation`` was purged.
    ///
    /// This event is raised when a limit defined in ``purgeOptions-swift.property`` was reached and a dynamic
    /// entity observation was purged from the local data cache.
    ///
    /// This event will not be raised when all observations in the local data cache are purged when calling
    /// `DynamicEntityDataSource.purgeAll()`.
    public var purgedObservations: AsyncStream<ArcGIS.DynamicEntityObservationInfo> { get }

    /// Notification that a new ``DynamicEntity`` was received.
    ///
    /// This event is raised when an observation was received that was not associated with any current ``DynamicEntity``
    /// in the local cache. In this case, a new ``DynamicEntity`` is created and this event is raised.
    public var receivedEntities: AsyncStream<ArcGIS.DynamicEntityInfo> { get }

    /// Notification that a new ``DynamicEntityObservation`` was received.
    ///
    /// This event is raised for every observation received from the stream. To listen to only observations
    /// associated with a specific dynamic entity, use ``DynamicEntity/changes``.
    public var receivedObservations: AsyncStream<ArcGIS.DynamicEntityObservationInfo> { get }

    /// The time (in seconds) to wait between attempts to reconnect.
    ///
    /// This property sets the amount of time delay between reconnection attempts after a connection fails. The default
    /// value is 10 seconds.
    /// - Note: See Also: ``maximumReconnectionAttempts``
    public var reconnectionInterval: TimeInterval

    /// Connects to a service that provides dynamic entity observations.
    ///
    /// Data does not start streaming from the dynamic entity data source until it's loaded and connected. Once the
    /// connection is successfully established, data begins to flow from the stream.
    ///
    /// Use this method to explicitly connect to the data source. This call loads the data source if it is not
    /// already loaded and then initiates a persistent connection to the service that provides the observation stream.
    /// When this method completes, the ``connectionStatus`` is set to connected or failed.
    ///
    /// Note that a data source connection is initiated implicitly if the data source is contained by a
    /// ``DynamicEntityLayer`` and added to a map or scene.
    public func connect() async throws

    /// Closes the connection to a service.
    ///
    /// Use this method to explicitly disconnect from a data source. When this method completes, the
    /// ``connectionStatus`` is set to disconnected or failed.
    ///
    /// If this method is called when a data source has a ``connectionStatus`` of connecting,
    /// the current connection attempt is cancelled.
    public func disconnect() async throws

    /// Removes all dynamic entity observations from the in-memory data cache as well as from the map or scene.
    ///
    /// Sometimes, a large number of dynamic entity observations can crowd the display and make information hard to
    /// interpret. Use this method to clear (purge) all dynamic entity observations to remove stale information and
    /// limit the amount of memory consumed. This does not disconnect you from the service, so new dynamic entity
    /// observations continue to display as they become available.
    ///
    /// The following ``DynamicEntityDataSource`` events will not be raised due to a call to this method:
    /// * ``purgedObservations``
    /// * ``purgedEntities``
    public func purgeAll() async throws

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

extension DynamicEntityDataSource {

    /// Purge options for a dynamic entity data source.
    ///
    /// Data received from a ``DynamicEntityDataSource`` is cached in memory on the client and can grow quickly depending on
    /// the number of dynamic entities and frequency of updates. Use this class and the ``DynamicEntityDataSource/purgeOptions-swift.property``
    /// property to control app storage in the local data cache.
    ///
    /// Properties on this object affect cached observations and should not be confused with similar options in
    /// ``TrackDisplayProperties`` which are applied on the ``DynamicEntityLayer`` and affect visibility of observations
    /// on a map or scene.
    ///
    /// By default, the maximum total number of observations stored is 100,000 with no limit to the number of observations
    /// per track and no observation age limit.
    /// - Since: 200.1
    final public class PurgeOptions {

        /// The maximum time (in seconds) an observation remains in the application.
        ///
        /// Observations older than the specified maximum duration are removed from the local data cache.
        ///
        /// The default value is 0.0 seconds which means the maximum duration is disabled and duration is not used to purge
        /// observations from the local data cache. Setting maximum duration to anything else below 1.0 defaults to 1.0.
        final public var maximumDuration: TimeInterval

        /// The maximum number of observations cached by the application.
        ///
        /// Use this property to limit the total number of observations cached in the local data cache without regard to the
        /// track the observations belong to.
        ///
        /// The default value is 100,000. A value of 0 disables the maximum observations purge option.
        final public var maximumObservations: Int

        /// The maximum number of observations per track.
        ///
        /// Use this property to limit the number of observations cached in the local data cache per unique track ID.
        ///
        /// The default value is 0 which means the maximum observations per track purge option is disabled.
        final public var maximumObservationsPerTrack: Int
    }
}

/// Provides details about a ``DynamicEntity`` that has been sent by `DynamicEntityDataSourceDynamicEntityReceivedEvent` or `DynamicEntityDataSourceDynamicEntityPurgedEvent`.
///
/// An object of this type is sent as an argument to the following ``DynamicEntityDataSource`` events:
/// * `DynamicEntityDataSourceDynamicEntityReceivedEvent`: raised by the data source when a new dynamic entity is
///   created in response to a received observation with a track ID that has not yet been encountered in this session.
/// * `DynamicEntityDataSourceDynamicEntityPurgedEvent`: raised by the data source when all observations associated
///   with a dynamic entity have been purged from the local data cache.
/// - Since: 200.1
public struct DynamicEntityInfo {
}

extension DynamicEntityInfo {

    /// The ``DynamicEntity`` that has been received from the data source or purged from the local data cache.
    public var dynamicEntity: ArcGIS.DynamicEntity { get }
}

/// A ``Layer`` that displays dynamic entity observations from real-time services.
///
/// A dynamic entity layer consumes ``DynamicEntityObservation`` objects streamed from a ``DynamicEntityDataSource``.
/// A ``DynamicEntityDataSource`` must be passed to the constructor of the layer. The layer manages the display of
/// observations as they are added to or removed from the data source's local cache.
///
/// A dynamic entity layer's ``TrackDisplayProperties`` allow you to control the display of previous observations by
/// setting a maximum number of observations to show, displaying a line that connects them (track line), and applying
/// renderers to the observations and/or track line.
///
/// As with other layers in the ArcGIS Maps SDK, display properties are managed with renderers. In the dynamic entity
/// layer, three renderers are used to control display of observations:
/// * ``renderer``: the main renderer property inherited from ``Layer`` is used to control the
///   display of the latest observation in a track. All renderer types are supported.
/// * ``TrackDisplayProperties/previousObservationRenderer``: used to control the display of previous observations in a
///   track. All renderer types are supported.
/// * ``TrackDisplayProperties/trackLineRenderer``: used to control the display of the track line between observations.
///   The track line renderer supports only ``SimpleRenderer`` (since the track line contains no attributes).
///
/// Labels in a dynamic entity layer are controlled through the inherited ``Layer`` labeling API. Labels only
/// appear on the latest observation in a track and are not placed on previous observations.
///
/// The dynamic entity layer has methods for selecting or unselecting dynamic entities and observations in the display.
/// When selecting a dynamic entity, the selection moves with the entity (the selection halo moves to the
/// latest observation in the track) as new observations are received from the stream. Since observations are static,
/// selected observations appear like any static ``GeoElement`` on the display.
///
/// Dynamic entity layer also supports identify behavior in a map view or scene view. Be aware that the identify results
/// from this layer consist entirely of ``DynamicEntityObservation`` objects. Use the
/// `DynamicEntityObservation.dynamicEntity` method to retrieve the ``DynamicEntity`` that the identified observation
/// is associated with.
/// - Since: 200.1
final public class DynamicEntityLayer : ArcGIS.Layer, ArcGIS.PopupSource {

    /// Creates a new dynamic entity layer from a ``DynamicEntityDataSource``.
    /// - Parameter dataSource: A ``DynamicEntityDataSource`` data source.
    public convenience init(dataSource: ArcGIS.DynamicEntityDataSource)

    /// The dynamic entity data source.
    final public var dataSource: ArcGIS.DynamicEntityDataSource { get }

    /// The collection of ``LabelDefinition`` objects for this layer.
    ///
    /// Dynamic entity layer supports labeling only on the latest observation of a track.
    final public var labelDefinitions: [ArcGIS.LabelDefinition] { get }

    /// Adds a sequence of `LabelDefinition` values to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinitions: The new `LabelDefinition` values to append.
    final public func addLabelDefinitions<S>(_ newLabelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Adds a `LabelDefinition` value to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinition: The new `LabelDefinition` value to append.
    final public func addLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition)

    /// Inserts a collection of `LabelDefinition` values into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinitions: The new `LabelDefinition` values to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` values.
    final public func insertLabelDefinitions<C>(_ newLabelDefinitions: C, at index: Int) where C : Collection, C.Element == ArcGIS.LabelDefinition

    /// Inserts a `LabelDefinition` value into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinition: The new `LabelDefinition` value to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` value.
    final public func insertLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition, at index: Int)

    /// Removes all values from the `labelDefinitions` property.
    final public func removeAllLabelDefinitions()

    /// Removes a sequence of `LabelDefinition` values from the `labelDefinitions` property.
    /// - Parameter labelDefinitions: The `LabelDefinition` values to remove.
    final public func removeLabelDefinitions<S>(_ labelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Removes a `LabelDefinition` value from the `labelDefinitions` property.
    /// - Parameter labelDefinition: The `LabelDefinition` value to remove.
    final public func removeLabelDefinition(_ labelDefinition: ArcGIS.LabelDefinition)

    /// `true` if labels should be displayed, `false` otherwise.
    ///
    /// Dynamic entity layer supports labeling only on the latest observation of a track.
    final public var labelsAreEnabled: Bool

    /// The ``Renderer`` used to display the latest observation of dynamic entities.
    final public var renderer: ArcGIS.Renderer?

    /// The scene properties for the dynamic entity layer.
    final public var sceneProperties: ArcGIS.LayerSceneProperties

    /// Gets all selected dynamic entities.
    final public var selectedDynamicEntities: [ArcGIS.DynamicEntity] { get }

    /// Gets all selected dynamic entity observations.
    final public var selectedDynamicEntityObservations: [ArcGIS.DynamicEntityObservation] { get }

    /// The track display properties.
    ///
    /// ``TrackDisplayProperties`` allow you to control the display of previous observations in a track by setting a
    /// maximum number of observations to show, displaying a line that connects them (track line), and applying
    /// renderers to the observations and/or track line.
    final public var trackDisplayProperties: ArcGIS.TrackDisplayProperties { get }

    /// Clears all selected dynamic entities and observations.
    ///
    /// Use this method to clear the list of selected ``DynamicEntity`` and ``DynamicEntityObservation`` objects and
    /// clear the visible selection halos from the map or scene view.
    final public func clearSelection()

    /// Selects the specified dynamic entities.
    ///
    /// Selecting a ``DynamicEntity`` does the following:
    /// * adds the dynamic entity to the current list of selected dynamic entities.
    /// * adds a visual selection halo around the latest observation of the dynamic entity. The selection halo is always
    ///   placed on the latest observation of the dynamic entity, so the selection halo moves as new observations
    ///   are received for the dynamic entity.
    /// - Parameter dynamicEntities: The dynamic entities to select.
    final public func selectDynamicEntities(_ dynamicEntities: [ArcGIS.DynamicEntity])

    /// Selects the given dynamic entity and adds it to the current list of selected dynamic entities.
    ///
    /// Selecting a ``DynamicEntity`` does the following:
    /// * adds the dynamic entity to the current list of selected dynamic entities.
    /// * adds a visual selection halo around the latest observation of the dynamic entity. The selection halo is always
    ///   placed on the latest observation of the dynamic entity, so the selection halo moves as new observations
    ///   are received for the dynamic entity.
    /// - Parameter dynamicEntity: The dynamic entity to select.
    final public func selectDynamicEntity(_ dynamicEntity: ArcGIS.DynamicEntity)

    /// Selects the given dynamic entity observation and adds it to the current list of selected observations.
    ///
    /// Selecting a ``DynamicEntityObservation`` does the following:
    /// * adds the ``DynamicEntityObservation`` to the current list of selected dynamic entity observations.
    /// * adds a visual selection halo around the static ``DynamicEntityObservation``.
    ///
    /// Use `DynamicEntityLayer.selectDynamicEntity(_:)` to achieve dynamic selection of the latest observation in a track.
    /// - Parameter dynamicEntityObservation: The dynamic entity observation to select.
    final public func selectDynamicEntityObservation(_ dynamicEntityObservation: ArcGIS.DynamicEntityObservation)

    /// Selects the given dynamic entity observations and adds them to the current list of selected observations.
    ///
    /// Selecting a ``DynamicEntityObservation`` does the following:
    /// * adds the ``DynamicEntityObservation`` to the current list of selected dynamic entity observations.
    /// * adds a visual selection halo around the static ``DynamicEntityObservation``.
    ///
    /// Use `DynamicEntityLayer.selectDynamicEntity(_:)` to achieve dynamic selection of the latest observation in a track.
    /// - Parameter dynamicEntityObservations: The dynamic entity observations to select.
    final public func selectDynamicEntityObservations(_ dynamicEntityObservations: [ArcGIS.DynamicEntityObservation])

    /// Unselects the specified dynamic entities and removes them from the current list of selected dynamic entities.
    /// - Parameter dynamicEntities: The dynamic entities to remove from the selection.
    final public func unselectDynamicEntities(_ dynamicEntities: [ArcGIS.DynamicEntity])

    /// Unselects the given dynamic entity and removes it from the current list of selected dynamic entities.
    /// - Parameter dynamicEntity: The dynamic entity to be unselected.
    final public func unselectDynamicEntity(_ dynamicEntity: ArcGIS.DynamicEntity)

    /// Unselects the given dynamic entity observation and removes it from the current list of selected observations.
    /// - Parameter dynamicEntityObservation: The dynamic entity observation to be unselected.
    final public func unselectDynamicEntityObservation(_ dynamicEntityObservation: ArcGIS.DynamicEntityObservation)

    /// Unselects the given dynamic entity observations and removes them from the current list of selected observations.
    /// - Parameter dynamicEntityObservations: The dynamic entity observations to be unselected.
    final public func unselectDynamicEntityObservations(_ dynamicEntityObservations: [ArcGIS.DynamicEntityObservation])

    /// The pop-up definition.
    ///
    /// The ``PopupDefinition`` associated with the popup source.
    final public var popupDefinition: ArcGIS.PopupDefinition?

    /// A flag indicating whether the ``PopupDefinition`` defined on the ``PopupSource`` is enable / disable.
    final public var popupsAreEnabled: Bool
}

/// A ``GeoElement`` that represents a static observation of a ``DynamicEntity`` received from a ``DynamicEntityDataSource``.
///
/// Dynamic entity observations are objects streamed by a ``DynamicEntityDataSource``. Each observation is a snapshot of
/// the state of a ``DynamicEntity`` at a given point in time.
///
/// Observations are stored in a local data cache as they are received from the data source. Observations may be purged
/// from the local data cache according to ``DynamicEntityDataSource/PurgeOptions-swift.class``.
///
/// Multiple observations may be associated with a single ``DynamicEntity`` (via a shared track ID). These observations
/// may be retrieved using `DynamicEntity.observations(maximumObservations:)`. The most current observation of a ``DynamicEntity`` may be
/// retrieved using `DynamicEntity.latestObservation`.
///
/// Observations may also be retrieved by identifying observations on a map or scene, or by handling events
/// directly from the ``DynamicEntityDataSource``.
/// - Note: See Also: ``DynamicEntity``
/// - Since: 200.1
final public class DynamicEntityObservation : ArcGIS.GeoElement, Identifiable {

    /// Gets the ``DynamicEntity`` associated with this observation.
    ///
    /// Use this method to retrieve the ``DynamicEntity`` associated with this observation.
    ///
    /// This method returns `nil` if the associated ``DynamicEntity`` has been purged from the local data cache, which
    /// happens when all observations associated with a dynamic entity have been purged.
    final public var dynamicEntity: ArcGIS.DynamicEntity? { get }

    /// A unique identifier for the ``DynamicEntityObservation``.
    ///
    /// The ID uniquely identifies a `DynamicEntityObservation` and is useful in the case of notification events.
    final public var id: Int { get }

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    final public var attributes: [String : Any] { get }

    /// The geometry defines the shape and location of the ``GeoElement``.
    final public var geometry: ArcGIS.Geometry? { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = Int
}

/// Provides details about a ``DynamicEntityObservation`` that has been received from the data source or purged from the local data cache.
///
/// An object of this type is sent as an argument to the following ``DynamicEntityDataSource`` events:
/// * ``DynamicEntityDataSource/receivedObservations``: raised by the data source when a new dynamic
///   entity observation is received.
/// * ``DynamicEntityDataSource/purgedObservations``: raised by the data source when an observation is
///   purged from local data cache due to a limit defined by ``DynamicEntityDataSource/purgeOptions-swift.property``.
/// - Note: See Also: ``DynamicEntityDataSource/PurgeOptions-swift.class``
/// - Since: 200.1
public struct DynamicEntityObservationInfo {
}

extension DynamicEntityObservationInfo {

    /// The ``DynamicEntityObservation`` that has been received from the data source or purged from the local data cache.
    public var observation: ArcGIS.DynamicEntityObservation { get }
}

/// A ENC cell object.
///
/// A single ENC (Electronic Navigational Chart) data source.
/// - Note: See Also: ``ENCLayer``
/// - Since: 200.1
final public class ENCCell : ArcGIS.Loadable {

    /// Creates an ENC cell using an ENC dataset.
    /// - Parameter dataset: The ENC dataset object previously obtained from an ENCExchangeSet.
    /// - Note: See Also: ``ENCCell``
    public convenience init(dataset: ArcGIS.ENCDataset)

    /// Creates an ENC cell from the specified path.
    ///
    /// ``init(dataset:)`` is the correct method of constructing an ENC cell delivered as part of an exchange set.
    /// When an ENC cell is constructed from the path directly, updates (*.001, *.002, etc.) that are part of the associated exchange set
    /// (if there is one) will not be applied.
    /// - Parameter fileURL: The path to the S-57/ENC (extension .000) file.
    /// - Note: See Also: ``ENCCell``
    public convenience init(fileURL: URL)

    /// The ENC dataset associated with the ENC cell, or `nil` if the ENC cell was loaded from a path.
    final public var dataset: ArcGIS.ENCDataset? { get }

    /// The path of the ENC cell. Throws if the ENC cell is already loaded.
    ///
    /// This can be used to reload the cell.
    final public var fileURL: URL? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// Defines an ENC dataset object.
/// - Since: 200.1
final public class ENCDataset {

    /// Creates an ENC dataset object.
    public convenience init()

    /// The description of the ENC dataset.
    final public var description: String { get }

    /// The extent of the ENC dataset.
    final public var extent: ArcGIS.Envelope? { get }

    /// Informs whether the data set is authorized
    ///
    /// If the underlying data is S-57, then this function returns `true`.
    final public var isAuthorized: Bool { get }

    /// The name of the ENC dataset.
    final public var name: String { get }

    /// The volume name of the ENC dataset.
    final public var volumeName: String { get }
}

/// An ENC Display Categories object. Contains three categories.
/// - Since: 200.1
final public class ENCDisplayCategories {

    /// Whether the S-52 "displaybase" display category is enabled.
    ///
    /// "displaybase" contains a subset of the objects in "standard".
    final public var displayBaseIsEnabled: Bool

    /// Whether the S-52 "other" display category is enabled.
    ///
    /// The "other" category contains all objects that are not enabled by default in "Standard Display".
    final public var otherDisplayIsEnabled: Bool

    /// Whether the S-52 "standard" display category is enabled.
    ///
    /// Once an object has been added to or removed from display, the display is no longer showing the "Standard Display".
    /// This will not be reflected by this property.
    final public var standardDisplayIsEnabled: Bool
}

/// An ENC Display Settings object. Contains other settings.
/// - Since: 200.1
final public class ENCDisplaySettings {

    /// The ENCMarinerSettings object.
    ///
    /// Here apply to all ENC layers.
    final public var marinerSettings: ArcGIS.ENCMarinerSettings { get }

    /// The ENCTextGroupVisibilitySettings object.
    final public var textGroupVisibilitySettings: ArcGIS.ENCTextGroupVisibilitySettings { get }

    /// The ENCViewingGroupSettings object.
    final public var viewingGroupSettings: ArcGIS.ENCViewingGroupSettings { get }
}

/// Defines an ENC environment settings object.
///
/// Contains functions that are global and affect the ENC environment.
/// - Since: 200.1
final public class ENCEnvironmentSettings {

    /// An ENC Display Settings handle, which allows selection of mariner, viewing group, and text group visibility settings.
    final public var displaySettings: ArcGIS.ENCDisplaySettings { get }

    /// The path to ENC resource files.
    ///
    /// The resource path must be set before ENC content can be used.
    final public var resourceURL: URL?

    /// The path where SENC files will be stored.
    ///
    /// SENC is an acronym for System Electronic Navigational Chart. ENC data is converted into an internal
    /// SENC format for optimal chart display.
    /// Subsequent loads of an ENC cell or exchange set will ignore the underlying cells (.000 files). Runtime
    /// will instead read from the internal SENC files directly.
    final public var sencDataURL: URL?
}

extension ENCEnvironmentSettings {

    /// The singleton instance of ENC environment settings.
    /// - Remark: These settings apply to all ENC layers.
    final public class var shared: ArcGIS.ENCEnvironmentSettings { get }
}

/// Defines an ENC exchange set object.
/// - Since: 200.1
final public class ENCExchangeSet : ArcGIS.Loadable {

    /// Creates an ENC exchange set object.
    /// - Parameter paths: The paths to ENC exchange sets to be loaded.
    public convenience init(paths: [URL])

    /// The ENC datasets that are part of the exchange set.
    ///
    /// ENC exchange sets consist of one or more datasets and a catalog.
    /// The exchange set's datasets can be used to create ``ENCCell`` objects, which can be used to
    /// create ``ENCLayer`` objects for display in a map.
    final public var datasets: [ArcGIS.ENCDataset] { get }

    /// An `Array` of the paths of the ENC exchange set.
    ///
    /// An ENC exchange set can be loaded with the path to a single exchange set and zero or more update exchange sets.
    /// If an exchange set which only contains updates is loaded, the corresponding exchange set with the base
    /// cells must be loaded simultaneously.
    final public var paths: [URL] { get }

    /// The path to the ENC exchange set's Readme file.
    final public var readmeURL: URL? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// Defines an ENC feature object.
/// - Since: 200.1
final public class ENCFeature : ArcGIS.GeoElement {

    /// The acronym of the ENC feature.
    final public var acronym: String { get }

    /// The description of the ENC feature.
    final public var description: String { get }

    /// Gets the description of some ENC feature acronym, given the acronym string as the key.
    /// - Parameter acronym: The attribute acronym.
    /// - Returns: A `String` containing the description of the given acronym. If that acronym does not exist, this function returns the key passed in.
    final public func attributeDescription(forAcronym acronym: String) -> String

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    final public var attributes: [String : Any] { get }

    /// The geometry defines the shape and location of the ``GeoElement``.
    final public var geometry: ArcGIS.Geometry? { get }
}

/// A layer that displays ENC data.
///
/// Electronic navigational charts (ENC) are georeferenced vector datasets for the visualization and analysis of
/// hydrographic and maritime information. This API supports ENC that conform to the International
/// Hydrographic Organization (IHO) S-57 standard.
///
/// Functional characteristics
/// ENC layer supports identify and selection but does not support query or time. ENC layers cannot be displayed in a scene.
///
/// Performance characteristics
/// ENC layers differ from other layer types in that ENC content is cached in an internal collection of SENC files.
/// When an ENC layer is displayed, only the content in the SENC files is referenced. SENC files are produced when
/// an ENC cell is read for the first time and updated as update sets are applied. You can set the path to the SENC
/// storage directory with the ``ENCEnvironmentSettings/sencDataURL`` property. SENC files are in a binary format that
/// is not intended to be shared between platforms or versions of this API.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class ENCLayer : ArcGIS.Layer {

    /// Creates a new ENC layer from an ENC cell.
    /// - Parameter encCell: The ENC cell ``ENCCell`` used as the source of the ENC layer.
    public convenience init(encCell: ArcGIS.ENCCell)

    /// Returns the ENC cell object associated with the ENC layer.
    ///
    /// Use this method to obtain a reference to the ENC cell held by the layer.
    final public var cell: ArcGIS.ENCCell { get }

    /// Clears / Unselects a previously selected ENC feature (if any).
    final public func clearSelection()

    /// Selects an ENC feature.
    ///
    /// Only one ENC feature can be selected at a time.
    /// Note that some ENC features are rendered as multiple objects on the map - for example,
    /// a soundings feature might consist of many individual measurements, each of which will be
    /// highlighted when the feature is selected.
    /// - Parameter feature: The ENC feature ``ENCFeature`` to be selected.
    final public func select(_ feature: ArcGIS.ENCFeature)
}

extension ENCLayer {

    /// Creates a new ENC layer from an ENC cell.
    /// - Parameter cell: The ``ENCCell`` used as the source of the ENC layer.
    public convenience init(cell: ArcGIS.ENCCell? = nil)
}

/// An ENC Mariner Settings object.
/// - Since: 200.1
final public class ENCMarinerSettings {

    /// The list of area features symbolization settings.
    ///
    /// This is used to specify whether areas should be symbolized with plain or traditional symbols.
    public enum AreaSymbolizationType {

        /// Use plain symbols.
        case plain

        /// Use traditional symbols.
        case symbolized

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ENCMarinerSettings.AreaSymbolizationType, b: ArcGIS.ENCMarinerSettings.AreaSymbolizationType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A switch between S-52 color schemes.
    ///
    /// The S-52 standard allows for switching between three color modes.
    public enum ColorScheme {

        /// Day.
        case day

        /// Dusk.
        case dusk

        /// Night.
        case night

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ENCMarinerSettings.ColorScheme, b: ArcGIS.ENCMarinerSettings.ColorScheme) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A switch between units for depth.
    ///
    /// Change the unit of depth for soundings and contours.
    public enum DisplayDepthUnits {

        /// Meters.
        case meters

        /// Feet.
        case feet

        /// Fathoms.
        case fathoms

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ENCMarinerSettings.DisplayDepthUnits, b: ArcGIS.ENCMarinerSettings.DisplayDepthUnits) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of point features symbolization settings.
    ///
    /// This is used to specify whether point features should be symbolized with simplified or paperchart symbols.
    public enum PointSymbolizationType {

        /// Use simplified symbols.
        case simplified

        /// Use Paperchart symbols.
        case paperChart

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ENCMarinerSettings.PointSymbolizationType, b: ArcGIS.ENCMarinerSettings.PointSymbolizationType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The area symbolization type (plain/symbolized). This controls the line symbol style for areas.
    ///
    /// "Symbolized" area symbolization renders area symbols using the traditional paper chart symbology. Plain
    /// reduces clutter.
    final public var areaSymbolizationType: ArcGIS.ENCMarinerSettings.AreaSymbolizationType

    /// The color scheme (day/dusk/night). This affects the color scheme used on all layers in the map.
    ///
    /// Defaults to 'day'
    final public var colorScheme: ArcGIS.ENCMarinerSettings.ColorScheme

    /// The deep water contour depth in meters.
    ///
    /// This must be greater than or equal to the safety contour value. An exception will be thrown otherwise.
    /// When four (rather than two) depth shades are used, this controls the boundary between safe and deep areas.
    /// Defaults to 30 meters
    final public var deepContour: Double

    /// The ENC display categories object, which contains categories base, standard, and other.
    ///
    /// The actual status for individual objects within a category may be inconsistent with the setting for the category.
    /// All categories are enabled by default.
    final public var displayCategories: ArcGIS.ENCDisplayCategories { get }

    /// The display depth units (meters/feet/fathoms).
    ///
    /// Defaults to 'meters'
    final public var displayDepthUnits: ArcGIS.ENCMarinerSettings.DisplayDepthUnits

    /// Whether to show the depth contour labels, includes safety contour label.
    ///
    /// Defaults to `true`, meaning the depth contour labels will be displayed.
    final public var displaysContourLabels: Bool

    /// The display isolated dangers in shallow water setting (`true`/`false`).
    ///
    /// Defaults to `false`, meaning isolated dangers will not be shown in shallow water.
    final public var displaysIsolatedDangers: Bool

    /// The display low accuracy setting (`true`/`false`).
    ///
    /// Defaults to `true`, meaning vectors marked as 'low accuracy data' will be symbolized differently.
    /// When low accuracy is set to `false`, low accuracy data will be visually indistinguishable from other data.
    final public var displaysLowAccuracy: Bool

    /// Whether to display the national name attribute on S57 features.
    ///
    /// Defaults to `true`, meaning national names will be displayed.
    final public var displaysNOBJNM: Bool

    /// The display safety contour labels setting (`true`/`false`).
    ///
    /// Defaults to `true`, meaning the safety contour labels will be displayed.
    final public var displaysSafetyContourLabels: Bool

    /// Whether or not the settings indicate to display two depth shades.
    ///
    /// Defaults to `true`, meaning two rather than four depth shades will be used.
    final public var displaysTwoDepthShades: Bool

    /// Whether the 'SCAMIN' S-57 feature attribute will be used (`true`/`false`).
    ///
    /// If disabled, all ENC features will be rendered regardless of scale.
    final public var honorsSCAMIN: Bool

    /// S-52 point feature symbolization type (simplified/paperchart).
    ///
    /// Paperchart symbolization is based on traditional paper charts. Simplified symbols are more compact and visible.
    final public var pointSymbolizationType: ArcGIS.ENCMarinerSettings.PointSymbolizationType

    /// The depth of the safety contour in meters.
    ///
    /// The safety contour separates safe from unsafe areas.
    final public var safetyContour: Double

    /// The depth of the shallow contour in meters.
    ///
    /// This must be less than or equal to the safety contour value. An exception will be thrown otherwise.
    /// When four (rather than two) depth shades are used, this value controls the separation between shallow and unsafe areas.
    final public var shallowContour: Double

    /// Whether to symbolize data quality (M_QUAL) for S-57 features.
    ///
    /// Defaults to `false`, meaning quality of data will not be displayed.
    final public var symbolizesDataQuality: Bool

    /// Whether the shallow depth pattern will be symbolized (`true`/`false`).
    ///
    /// Defaults to `false`, meaning the shallow depth pattern will not be symbolized.
    final public var symbolizesShallowDepthPattern: Bool

    /// Resets all ENC Mariner Settings.
    final public func resetToDefaults()
}

extension ENCMarinerSettings.AreaSymbolizationType : Equatable {
}

extension ENCMarinerSettings.AreaSymbolizationType : Hashable {
}

extension ENCMarinerSettings.ColorScheme : Equatable {
}

extension ENCMarinerSettings.ColorScheme : Hashable {
}

extension ENCMarinerSettings.DisplayDepthUnits : Equatable {
}

extension ENCMarinerSettings.DisplayDepthUnits : Hashable {
}

extension ENCMarinerSettings.PointSymbolizationType : Equatable {
}

extension ENCMarinerSettings.PointSymbolizationType : Hashable {
}

/// An ENC Text Group Visibility Settings object.
/// - Since: 200.1
final public class ENCTextGroupVisibilitySettings {

    /// The "berth number" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 29, which includes OBJNAM from BERTHS and ACHBRT.
    final public var includesBerthNumber: Bool

    /// The "current velocity" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 30, which includes CURVEL.
    final public var includesCurrentVelocity: Bool

    /// The "geographic names" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 26, which includes OBJNAM from ACHARE, BRIDGE, BUAARE, BUISGL,
    /// DOCARE, FAIRWY, LNDARE, LNDMARK, LNDRGN, SEAARE, TIDEWY, and PILBOP.
    final public var includesGeographicNames: Bool

    /// The "height of islet or land feature" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 28, which includes HEIGHT of LNDARE.
    final public var includesHeightOfIsletOrLandFeature: Bool

    /// The "important text" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text groups 10 and 11.
    final public var includesImportantText: Bool

    /// The "light descriptions" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 23.
    final public var includesLightDescription: Bool

    /// The "magnetic variation and swept depth" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 27, which includes MAGVAR, VALMAG, SWPARE, and DRVAL1.
    final public var includesMagneticVariationAndSweptDepth: Bool

    /// The "names for position reporting" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 21.
    final public var includesNamesForPositionReporting: Bool

    /// The "nature of seabed" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 25 (SBDARE, NATSUR).
    final public var includesNatureOfSeabed: Bool

    /// The "note on chart data" text group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls text group 24.
    final public var includesNoteOnChartData: Bool

    /// Resets each S-52 text group property to its respective default.
    final public func resetToDefaults()
}

/// An ENC Viewing Group Settings object.
/// - Since: 200.1
final public class ENCViewingGroupSettings {

    /// The "all isolated dangers" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 13, which includes viewing groups 34050 and 34051.
    final public var includesAllIsolatedDangers: Bool

    /// The "archipelagic sea lanes" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 9, which includes viewing group 26260.
    final public var includesArchipelagicSeaLanes: Bool

    /// The "boundaries and limits" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 4, which includes viewing groups 23030, 26050, 26220, 26240, and 26250.
    final public var includesBoundariesAndLimits: Bool

    /// The "buoys, beacons, aids to navigation" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 3, which includes viewing groups 21020, 22200  22240, 27000,
    /// 27010, 27011, 27020, 27025, 27040, 27050, 27070, 27080, 27200, 27210, 27230, 27030, and 27060.
    final public var includesBuoysBeaconsAidsToNavigation: Bool

    /// The "buoys, beacons, structures" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 3.1, which includes viewing groups 21010, 21020,
    /// 22200 - 22240, 27000-27050, 27080, 27200  27230, 27030, and 27060.
    final public var includesBuoysBeaconsStructures: Bool

    /// The "chart scale boundaries" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 6, which includes viewing group 21030.
    final public var includesChartScaleBoundaries: Bool

    /// The "depth contours" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 15, which includes viewing group 33020.
    final public var includesDepthContours: Bool

    /// The "drying line" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 2, which includes viewing group 22010.
    final public var includesDryingLine: Bool

    /// The "lights" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 3.2, which includes viewing group 27070.
    final public var includesLights: Bool

    /// The "magnetic variation" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 14, which includes viewing group 31080.
    final public var includesMagneticVariation: Bool

    /// The "other miscellaneous" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 18, which includes viewing group 30000-39999.
    final public var includesOtherMiscellaneous: Bool

    /// The "prohibited and restricted areas" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 5, which includes viewing groups 2600, 26010, and 26040.
    final public var includesProhibitedAndRestrictedAreas: Bool

    /// The "seabed" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 16, which includes viewing groups 34010, 34020, and 33040.
    final public var includesSeabed: Bool

    /// The "ships' routing systems and ferry routes" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 8, which includes viewing groups 25010-25060.
    final public var includesShipsRoutingSystemsAndFerryRoutes: Bool

    /// The "spot soundings" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 11, which includes viewing group 33010.
    final public var includesSpotSoundings: Bool

    /// The "standard miscellaneous" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 10 under the "standard display" viewing group,
    /// which includes all objects not covered by viewing groups 20000-29999.
    final public var includesStandardMiscellaneous: Bool

    /// The "submarine cables and pipelines" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 12, which includes viewing groups 34030 and 34070.
    final public var includesSubmarineCablesAndPipelines: Bool

    /// The "tidal" view group setting (`true`/`false`).
    ///
    /// Per IHO S-52 Annex A, controls viewing group layer 17, which includes viewing groups 33050 and 33060.
    final public var includesTidal: Bool

    /// Resets all ENC viewing group properties.
    final public func resetToDefaults()
}

/// An object that provides the field names for the edit fields.
/// - Since: 200.1
final public class EditFieldsInfo {

    /// The name of the creation date field.
    final public var creationDateField: String { get }

    /// The name of the creator field.
    final public var creatorField: String { get }

    /// The name of the edit date field.
    final public var editDateField: String { get }

    /// The name of the editor field.
    final public var editorField: String { get }

    /// The name of the realm field.
    final public var realm: String { get }
}

/// The various types of edits.
/// - Since: 200.1
public enum EditOperation {

    /// An add operation.
    case add

    /// An update operation.
    case update

    /// A delete operation.
    case delete

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.EditOperation, b: ArcGIS.EditOperation) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension EditOperation : Equatable {
}

extension EditOperation : Hashable {
}

/// An object that represents the results of an attempt to push an update to a service.
/// - Since: 200.1
public class EditResult {

    /// `true` if the attempt to edit resulted in any errors.
    public var didCompleteWithErrors: Bool { get }

    /// The any error information about the edit.
    public var error: Error? { get }

    /// The global id of the row that was edited.
    ///
    /// When returned as a result of geodatabase sync (`GeodatabaseSyncTask.makeSyncGeodatabaseJob(syncDirection:rollbackOnFailure:geodatabase:)` then
    /// ``SyncGeodatabaseJob/result``) in a ``SyncLayerResult`` this property may return an empty string
    /// indicating a more general error with features in this table rather than an error specific to a single feature
    /// edit.
    public var globalID: String { get }

    /// The object id of the row that was edited.
    public var objectID: Int { get }

    /// The type of the operation applied to the row.
    public var operation: ArcGIS.EditOperation? { get }
}

/// An object that provides various information editor tracking.
/// - Since: 200.1
final public class EditorTrackingInfo {

    /// `true` if anonymous users are allowed to delete features.
    final public var allowsAnonymousToDelete: Bool { get }

    /// `true` if anonymous users are allowed to update features.
    final public var allowsAnonymousToUpdate: Bool { get }

    /// `true` if users other than the owner are allowed to delete.
    final public var allowsOthersToDelete: Bool { get }

    /// `true` if users other than the owner are allowed to update.
    final public var allowsOthersToUpdate: Bool { get }

    /// `true` if editor tracking is enabled.
    final public var editorTrackingIsEnabled: Bool { get }

    /// `true` if ownership access control is enabled.
    final public var ownershipBasedAccessControlIsEnabled: Bool { get }
}

/// Represents a Limited Error Raster Compression (LERC) elevation service that
/// is provided by the portal.
/// - Remark: Instances of this struct are provided by
/// ``PortalHelperServices/defaultElevationServices``.
/// - Since: 200.1
public struct ElevationServiceInfo : Hashable, Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public struct ID : Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// A type of layer for an elevation service.
    public struct LayerType : Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// An identifying string for the service.
    public let id: ArcGIS.ElevationServiceInfo.ID

    /// A string indicating the layer type for the service.
    public let layerType: ArcGIS.ElevationServiceInfo.LayerType

    /// The URL of the service.
    public let url: URL

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ElevationServiceInfo, b: ArcGIS.ElevationServiceInfo) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ElevationServiceInfo.ID : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension ElevationServiceInfo.LayerType {

    /// An elevation service layer.
    public static let arcGISTiled: ArcGIS.ElevationServiceInfo.LayerType
}

/// An base class for all elevation sources.
///
/// A base class of implementations of elevation sources.  To use an elevation source you create an instance of a
/// derived class and set it in to a ``Surface`` in the ``Scene``. The combination of elevation sources within the
/// ``Surface`` generate a rendering surface on which data can be draped or offset from.
/// - Note: See Also: ``ArcGISTiledElevationSource``, ``Surface``
/// - Since: 200.1
public class ElevationSource : ArcGIS.Loadable {

    /// The "is enabled" state for the elevation source.
    ///
    /// The "is enabled" state of the elevation source object which indicates if this elevation source
    /// participates in the generation of the surface ``Surface``.
    /// - Note: See Also: `ElevationSource.Type`
    public var isEnabled: Bool

    /// The name for the elevation source.
    ///
    /// The name of the elevation source.
    public var name: String

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

/// An elliptic arc segment for use in a multipart geometry.
///
/// An elliptic arc is the portion of the boundary of a 2D ellipse that connects two points.
/// - Since: 200.1
final public class EllipticArcSegment : ArcGIS.Segment {

    /// Creates an elliptic arc based on parameters that define an ellipse and the portion of that ellipse that
    /// defines the arc.
    ///
    /// The spatial reference parameter is used if the center point parameter has a `nil` spatial reference. If both
    /// spatial references are supplied, they must be equal.
    ///
    /// The z-value and m-value of the center point (if present) are ignored. Use
    /// ``init(startPoint:endPoint:rotationAngle:isMinor:isCounterClockwise:semiMajorAxis:minorMajorRatio:spatialReference:)``
    /// to create an ``EllipticArcSegment`` with end points with z-value and/or m-value.
    /// - Parameters:
    ///   - centerPoint: The center point of the embedded ellipse.
    ///   - rotationAngle: The angle in radians by which the major axis of the embedded ellipse is rotated from the x-axis.
    ///   - semiMajorAxis: The length of the semi-major axis of the embedded ellipse in the units of the spatial reference.
    ///   - minorMajorRatio: The ratio of the length of the semi-minor axis to the length of the semi-major axis of the embedded ellipse.
    ///   - startAngle: The parametric angle in radians of the start of the arc relative to the major axis of the embedded ellipse.
    ///   - centralAngle: The parametric angle in radians measuring the span of the arc from ``startAngle`` to ``endAngle``.
    ///   - spatialReference: A spatial reference to use for the segment if the center point parameter does not have a spatial reference set.
    /// - Precondition: All spatial references provided must be the same.
    public convenience init(centerPoint: ArcGIS.Point, rotationAngle: Double, semiMajorAxis: Double, minorMajorRatio: Double, startAngle: Double, centralAngle: Double, spatialReference: ArcGIS.SpatialReference? = nil)

    /// Creates an elliptic arc segment from the given start and end points, and other parameters that define an ellipse.
    ///
    /// The z-value and m-value of the start and end points (if present) are used in the ``EllipticArcSegment``.
    ///
    /// To maintain the given startPoint and endPoint in the new segment, the other parameters may be adjusted if
    /// required. Such adjustments are made according to the [Scalable Vector Graphics 1.1
    /// Specification, Appendix F.6.5](https://www.w3.org/TR/SVG11/implnote.html#ArcConversionEndpointToCenter). If
    /// these cannot be adjusted sufficiently, an arc represented with a straight line is returned.
    /// - Parameters:
    ///   - startPoint: The start point of the segment.
    ///   - endPoint: The end point of the segment.
    ///   - rotationAngle: The angle in radians by which the major axis of the embedded ellipse is rotated from the x-axis.
    ///   - isMinor: `true` if ``centralAngle`` of the segment is less than PI.
    ///   - isCounterClockwise: `true` if the direction of the segment, from start point to end point, proceeds in a counterclockwise direction, otherwise `false`.
    ///   - semiMajorAxis: The length of the semi-major axis of the embedded ellipse in the units of the spatial reference.
    ///   - minorMajorRatio: The ratio of the length of the semi-minor axis to the length of the semi-major axis of the embedded ellipse.
    ///   - spatialReference: A spatial reference to use for the segment if the points do not have spatial references set.
    /// - Precondition: All spatial references provided must be the same.
    /// - Precondition: !startPoint.isEmpty
    /// - Precondition: !endPoint.isEmpty
    public convenience init(startPoint: ArcGIS.Point, endPoint: ArcGIS.Point, rotationAngle: Double, isMinor: Bool, isCounterClockwise: Bool, semiMajorAxis: Double, minorMajorRatio: Double, spatialReference: ArcGIS.SpatialReference? = nil)

    /// The center point of the ellipse that this segment is defined upon.
    final public var centerPoint: ArcGIS.Point { get }

    /// The parametric angle in radians measuring the span of the arc from ``startAngle`` to ``endAngle``.
    ///
    /// A positive value corresponds to a counterclockwise arc sweep.
    ///
    /// This value is always between -2*PI and 2*PI, these limits indicating this arc forms a complete ellipse in
    /// either clockwise or counterclockwise direction.
    final public var centralAngle: Double { get }

    /// The parametric angle in radians of the end of the arc relative to the major axis of the embedded ellipse.
    ///
    /// A positive value corresponds to a counterclockwise rotation from the major axis.
    final public var endAngle: Double { get }

    /// Indicates if this arc is a portion of the boundary of a 2D circle.
    ///
    /// An elliptic arc is circular if the ellipse upon which it is based is a circle, meaning the lengths of its
    /// major and minor axes are equal.
    ///
    /// Use `EllipticArcSegment.makeCircular(centerPoint:radius:startAngle:centralAngle:spatialReference:)` and
    /// `EllipticArcSegment.makeCircular(startPoint:endPoint:interiorPoint:spatialReference:)` to create circular arcs.
    final public var isCircular: Bool { get }

    /// Indicates if the direction of the segment, from start point to end point, proceeds in a counterclockwise direction.
    final public var isCounterClockwise: Bool { get }

    /// The ratio of the length of the semi-minor axis to the semi-major axis.
    final public var minorMajorRatio: Double { get }

    /// The angle in radians by which the major axis of the ellipse this segment is based upon is rotated from the x-axis.
    final public var rotationAngle: Double { get }

    /// The length of the longer of the two axes of the ellipse upon which this arc is based.
    ///
    /// The semi-major axis always lies on the line between 0 and PI radians.
    ///
    /// The length is in the units of the spatial reference.
    final public var semiMajorAxis: Double { get }

    /// The length of the shorter of the two axes of the ellipse upon which this arc is based.
    ///
    /// The semi-minor axis always lies on the line between PI/2 and 3*PI/2 radians.
    ///
    /// The length is in the units of the spatial reference.
    final public var semiMinorAxis: Double { get }

    /// The parametric angle in radians of the start of the arc relative to the major axis of the embedded ellipse.
    ///
    /// A positive value corresponds to a counterclockwise rotation from the major axis.
    final public var startAngle: Double { get }

    /// Creates an ``EllipticArcSegment`` that is a partial circle shape from the center point and radius of the
    /// embedded circle, and the start and central angle around that circle.
    ///
    /// The z-value and m-value of the center point (if present) are ignored. Use
    /// `EllipticArcSegment.makeCircular(startPoint:endPoint:interiorPoint:spatialReference:)`
    /// to create a circular ``EllipticArcSegment`` with end points with z-value and/or m-value.
    /// - Parameters:
    ///   - centerPoint: The center point of the embedded circle.
    ///   - radius: The distance from the center of the embedded circle to its perimeter.
    ///   - startAngle: The parametric angle in radians of the start of the arc relative to the major axis of the embedded ellipse.
    ///   - centralAngle: The parametric angle in radians measuring the span of the arc from ``startAngle`` to ``endAngle``.
    ///   - spatialReference: The spatial reference of the new segment.
    /// - Returns: A new ``EllipticArcSegment`` with the given center point, radius, start and central angles, and
    /// spatial reference, where ``isCircular`` is `true`.
    /// - Precondition: All spatial references provided must be the same.
    final public class func makeCircular(centerPoint: ArcGIS.Point, radius: Double, startAngle: Double, centralAngle: Double, spatialReference: ArcGIS.SpatialReference? = nil) -> ArcGIS.EllipticArcSegment

    /// Creates an ``EllipticArcSegment`` from start, end, and interior points that is a partial circle shape.
    ///
    /// The z-value and m-value of the start and end points (if present) are used in the circular
    /// ``EllipticArcSegment``. The z-value and m-value of the interior point (if present) are ignored.
    /// - Parameters:
    ///   - startPoint: The start point of the segment.
    ///   - endPoint: The end point of the segment.
    ///   - interiorPoint: A point along the circular arc, between the start and end points.
    ///   - spatialReference: The spatial reference of the new segment.
    /// - Returns: A new ``EllipticArcSegment`` with the given start, through and end point, and spatial reference, where
    /// ``isCircular`` is `true`.
    /// - Precondition: All spatial references provided must be the same.
    /// - Precondition: !startPoint.isEmpty
    /// - Precondition: !endPoint.isEmpty
    final public class func makeCircular(startPoint: ArcGIS.Point, endPoint: ArcGIS.Point, interiorPoint: ArcGIS.Point, spatialReference: ArcGIS.SpatialReference? = nil) -> ArcGIS.EllipticArcSegment
}

/// A geometry that represents a rectangular shape.
///
/// An ``Envelope`` is an axis-aligned box described by the coordinates of the lower left corner
/// and the coordinates of the upper right corner. They are commonly used to represent the spatial extent
/// covered by layers or other geometries, or to define an area of interest. They can be used as the
/// geometry for a graphic and as an input for many spatial operations. Although they both represent
/// a geographic area, an ``Envelope`` is distinct from a ``Polygon``, and they cannot always be used
/// interchangeably.
///
/// New instances of ``Envelope`` are defined by specifying a minimum and maximum x-coordinate and minimum
/// and maximum y-coordinate, and a ``SpatialReference``. Optionally, a minimum and maximum z-value can be
/// specified to define the depth of the envelope.
/// - Note: See Also: ``Geometry``
/// - Since: 200.1
final public class Envelope : ArcGIS.Geometry {

    /// Creates an envelope from any two points.
    ///
    /// The spatial reference of the points must be the same. The spatial reference of the result envelope comes from the points.
    /// If the values for min parameters are bigger than max parameters then they are re-ordered. The resulting envelope always has min less than or equal to max.
    /// - Parameters:
    ///   - min: The minimal values for the envelope.
    ///   - max: The maximum values for the envelope.
    /// - Note: See Also: ``Point``
    /// - Precondition: `min.spatialReference == max.spatialReference`
    public convenience init(min: ArcGIS.Point, max: ArcGIS.Point)

    /// The center point for the envelope.
    ///
    /// Creates a new Point.
    /// - Note: See Also: ``Point``
    final public var center: ArcGIS.Point { get }

    /// The height for the envelope.
    final public var height: Double { get }

    /// The width for the envelope.
    final public var width: Double { get }

    /// The x maximum value for the envelope.
    final public var xMax: Double { get }

    /// The x minimum value for the envelope.
    final public var xMin: Double { get }

    /// The y maximum value for the envelope.
    final public var yMax: Double { get }

    /// The y minimum value for the envelope.
    final public var yMin: Double { get }
}

extension Envelope {

    /// The depth for the envelop or `nil` if the envelope does not have
    /// z-values.
    final public var depth: Double? { get }

    /// The z maximum value for the envelope.
    ///
    /// A value of `nil` indicates that the geometry does not have a z maximum value.
    final public var zMax: Double? { get }

    /// The z minimum value for the envelope.
    ///
    /// A value of `nil` indicates that the geometry does not have a z minimum value.
    final public var zMin: Double? { get }

    /// The m maximum value for the envelope.
    ///
    /// A value of `nil` indicates that the geometry does not have a m maximum value.
    final public var mMax: Double? { get }

    /// The m minimum value for the envelope.
    ///
    /// A value of `nil` indicates that the geometry does not have a m minimum value.
    final public var mMin: Double? { get }

    /// Creates an envelope with min/max values and a spatial reference.
    /// - Parameters:
    ///   - xMin: The x minimum value for the envelope.
    ///   - yMin: The y minimum value for the envelope.
    ///   - xMax: The x maximum value for the envelope.
    ///   - yMax: The y maximum value for the envelope.
    ///   - zMin: The z minimum value for the envelope. The default is `nil`.
    ///   - zMax: The z maximum value for the envelope. The default is `nil`.
    ///   - mMin: The m minimum value for the envelope. The default is `nil`.
    ///   - mMax: The m maximum value for the envelope. The default is `nil`.
    ///   - spatialReference: The spatial reference for the envelope. The default is `nil`.
    public convenience init(xMin: Double, yMin: Double, xMax: Double, yMax: Double, zMin: Double? = nil, zMax: Double? = nil, mMin: Double? = nil, mMax: Double? = nil, spatialReference: ArcGIS.SpatialReference? = nil)

    /// Creates an envelope with a center point, width, height, and depth.
    /// - Remark: The spatial reference of the resulting envelope comes from the
    /// center point.
    /// - Parameters:
    ///   - center: The center point for the envelope.
    ///   - width: The width of the envelope around the center point.
    ///   - height: The height of the envelope around the center point.
    ///   - depth: The depth of the envelope around the center point. The
    ///   default value is `nil`.
    public convenience init(center: ArcGIS.Point, width: Double, height: Double, depth: Double? = nil)

    /// Creates an envelope based on the *x* range, *y* range, *z* range, and
    /// *m* range values with a spatial reference.
    /// - Parameters:
    ///   - xRange: The *x* range for the envelope.
    ///   - yRange: The *y* range for the envelope.
    ///   - zRange: The *z* range for the envelope or `nil`.
    ///   - mRange: The *m* range for the envelope or `nil`.
    ///   - spatialReference: The spatial reference for the envelope or `nil`.
    public convenience init(xRange: ClosedRange<Double>, yRange: ClosedRange<Double>, zRange: ClosedRange<Double>? = nil, mRange: ClosedRange<Double>? = nil, spatialReference: ArcGIS.SpatialReference? = nil)
}

extension Envelope : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    final public var description: String { get }
}

/// The envelope builder object is used to create an envelope.
/// - Since: 200.1
final public class EnvelopeBuilder : ArcGIS.GeometryBuilder<ArcGIS.Envelope> {

    /// Creates a envelope builder from a envelope.
    /// - Parameter envelope: The envelope.
    public convenience init(envelope: ArcGIS.Envelope)

    /// Creates a envelope builder.
    /// - Parameter spatialReference: The builder's spatial reference.
    public convenience init(spatialReference: ArcGIS.SpatialReference? = nil)

    /// The center point for the envelope builder.
    ///
    /// Creates a new Point that must be destroyed.
    /// - Note: See Also: ``Point``
    final public var center: ArcGIS.Point { get }

    /// The height for the envelope builder.
    ///
    /// The width for the envelope builder.
    final public var height: Double { get }

    /// The m maximum value for the envelope.
    final public var mMax: Double

    /// The m minimum value for the envelope.
    final public var mMin: Double

    /// The width for the envelope builder.
    final public var width: Double { get }

    /// The x maximum value for the envelope.
    final public var xMax: Double

    /// The x minimum value for the envelope.
    final public var xMin: Double

    /// The y maximum value for the envelope.
    final public var yMax: Double

    /// The y minimum value for the envelope.
    final public var yMin: Double

    /// The z maximum value for the envelope.
    final public var zMax: Double

    /// The z minimum value for the envelope.
    final public var zMin: Double

    /// Centers the envelope over the given point.
    /// - Parameter point: The point to center on.
    final public func center(at point: ArcGIS.Point)

    /// Adjust the envelope's aspect ratio to match the ratio of the given width and height.
    ///
    /// The operation preserves the center of the envelope and only increases either height or width, not both.
    /// If the new width would be greater than the old, the width is changed and the height remains the same.
    /// If the new width would be less than or equal to the old, the height is changed and the width remains the same.
    /// - Parameters:
    ///   - width: A width.
    ///   - height: A height.
    final public func changeAspectRatio(width: Double, height: Double)

    /// Finds the union of this envelope and the given envelope and updates the envelope builder with the result.
    /// - Parameter other: Another envelope to union with.
    final public func formUnion(_ other: ArcGIS.Envelope)

    /// Finds the union of this envelope and the given point and updates the envelope builder with the result.
    /// - Parameter point: A point to union with.
    final public func formUnion(_ point: ArcGIS.Point)

    /// Offsets the envelope by the given offsets for the x and y dimension.
    /// - Parameters:
    ///   - x: The number of units to move the envelope on the x axis.
    ///   - y: The number of units to move the envelope on the y axis.
    final public func offsetBy(x: Double, y: Double)

    /// Set the m-values for the envelope.
    /// - Parameters:
    ///   - min: The m minimum value for the envelope.
    ///   - max: The m maximum value for the envelope.
    final public func setM(min: Double, max: Double)

    /// Set the x,y coordinates for the envelope.
    /// - Parameters:
    ///   - xMin: The x minimum value for the envelope.
    ///   - yMin: The y minimum value for the envelope.
    ///   - xMax: The x maximum value for the envelope.
    ///   - yMax: The y maximum value for the envelope.
    final public func setXAndY(xMin: Double, yMin: Double, xMax: Double, yMax: Double)

    /// Set the z-values for the envelope.
    /// - Parameters:
    ///   - min: The z minimum value for the envelope.
    ///   - max: The z maximum value for the envelope.
    final public func setZ(min: Double, max: Double)
}

extension EnvelopeBuilder {

    /// The depth for the envelop builder or `nil` if the envelope builder does
    /// not have z-values.
    final public var depth: Double? { get }

    /// Creates an envelope builder with a center point, width, height, and
    /// depth.
    /// - Parameters:
    ///   - center: The center point for the envelope.
    ///   - width: The width of the envelope around the center point.
    ///   - height: The height of the envelope around the center point.
    ///   - depth: The depth of the envelope around the center point. The
    ///   default value is `nil`.
    public convenience init(center: ArcGIS.Point, width: Double, height: Double, depth: Double? = nil)

    /// Expands the envelope by the given factor at the anchor point.
    /// - Parameters:
    ///   - factor: The zoom factor to apply to all axes. A value less than `1`
    ///   zooms in and a value greater than `1` zooms out.
    ///   - anchor: The point at which to anchor the expansion. If `nil`,
    ///   ``EnvelopeBuilder/center`` is used as the anchor point.
    final public func expand(by factor: Double, anchor: ArcGIS.Point? = nil)

    /// Normalizes the envelope to the passed in envelope.
    /// - Parameter envelope: The envelope to normalize against. If `nil`, the
    /// envelope is normalized to be within the bounds of
    /// ``GeometryBuilder/spatialReference``.
    final public func normalize(to envelope: ArcGIS.Envelope? = nil)
}

/// Enumerates options for downloading an Esri vector tiled basemap service.
///
/// When taking an Esri vector tiled basemap service offline (e.g. to create a ``VectorTileCache`` on your device),
/// you can choose from different versions of the service depending on your use case.
///
/// Primary considerations are the download speed and the size of the resulting .vtpk file. Among other things, file
/// size is influenced by the amount of fonts downloaded from the service. Esri vector tiled basemap layers make use
/// of fonts as part of their style resources - see the
/// [Vector Tile Style documentation](https://developers.arcgis.com/rest/services-reference/enterprise/vector-tile-style.htm).
/// When you take a vector tiled layer offline, these fonts are downloaded as part of the ``VectorTileCache``.
///
/// Esri services also offer an alternative version with a reduced font package size which will reduce the download
/// size of a vtpk by around 80 Mb. You can view a set of vector tile styles which use the reduced font services
/// [https://www.arcgis.com/home/group.html?id=c61ab1493fff4b84b53705184876c9b0](here). If you are
/// creating a web map that is only intended for taking maps offline and not for online-viewing, these "for export"
/// versions of the services are recommended.
///
/// This enumeration describes options for controlling which set of fonts are downloaded. Note that these options
/// only apply to Esri vector tile basemap services.
/// - Since: 200.1
public enum EsriVectorTilesDownloadOption {

    /// The complete set of vector tile resources for the original service, including the full set of fonts, will be downloaded.
    ///
    /// Downloading all font resources increases the download size of a .vtpk. However, this
    /// option ensures that the offline vector tile layer displays the same as the original online service.
    case useOriginalService

    /// An alternative service that uses a reduced set of font resources, supporting a limited set of language characters, will be downloaded.
    ///
    /// Downloading the smaller set of font resources reduces the download size of a .vtpk by around 80 Mb. This
    /// omits the large Arial Unicode font, that is used to support many characters for the full world basemap. This
    /// makes this option unsuitable for some locales or when your offline vector tiled layer includes certain
    /// character sets. For example, this option will not display Chinese, Japanese, Thai, Korean or Georgian
    /// characters. You should confirm that this option is suitable for your specific use-case.
    ///
    /// You can view a set of vector tile styles which use the reduced font services
    /// [here](https://www.arcgis.com/home/group.html?id=c61ab1493fff4b84b53705184876c9b0). This option
    /// is not recommended for Esri basemap services that do not have an equivalent "for export" version.
    case useReducedFontsService

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.EsriVectorTilesDownloadOption, b: ArcGIS.EsriVectorTilesDownloadOption) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension EsriVectorTilesDownloadOption : Equatable {
}

extension EsriVectorTilesDownloadOption : Hashable {
}

/// A job that estimates the size of a tile cache from a service.
/// - Note: See Also: ``Job``, ``ExportTileCacheJob``
/// - Since: 200.1
final public class EstimateTileCacheSizeJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.EstimateTileCacheSizeResult

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.EstimateTileCacheSizeJob.Output, Error> { get async }
}

/// The result of an ``EstimateTileCacheSizeJob``.
/// - Since: 200.1
final public class EstimateTileCacheSizeResult {

    /// The size of the tile cache (tile package, .tpk or .tpkx file) in bytes.
    final public var fileSize: Int { get }

    /// The number of tiles in the tile cache.
    final public var tileCount: Int { get }
}

/// Expiration details, that indicate whether a given package is out of date.
///
/// Expiration details can indicate that the package in question:
/// * Is still valid
/// * Has expired and should be used with caution (see ``Kind-swift.enum/allowExpiredAccess``)
/// * Has expired and can no longer be used (see ``Kind-swift.enum/preventExpiredAccess``)
/// - Since: 200.1
public struct Expiration : Hashable {

    /// Enumerates the possible types of expiration.
    public enum Kind {

        /// The expiration is provided for warning purposes only. The package can still be used.
        case allowExpiredAccess

        /// The expiration is mandatory and the package can no longer be used - for example, it will fail to load.
        case preventExpiredAccess

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Expiration.Kind, b: ArcGIS.Expiration.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The date and time when the package will expire.
    ///
    /// This property is in Unix time (milliseconds since Epoch) using UTC.
    public let date: Date?

    /// Indicates that the current package has expired.
    ///
    /// This property shows whether the given package was expired at the time it was loaded.
    /// Subsequent checks can be made by performing a comparison of the current time against ``date``.
    public let isExpired: Bool

    /// An accompanying message which provides contextual information when the package has expired.
    ///
    /// The message could indicate the reasons for expiration or where an up-to-date version of the data
    /// can be obtained from. The author of the package may have configured the message to contain raw text,
    /// hyperlinks or HTML.
    ///
    /// The message can be empty.
    public let message: String

    /// The type of expiration for the given package.
    ///
    /// This property indicates what expiration entails for a given package. That is, when the
    /// package expires:
    /// * It is out-of-date but can still be used (see ``Kind-swift.enum/allowExpiredAccess``)
    /// * It can no longer be used and will fail to load
    ///   (see ``Kind-swift.enum/preventExpiredAccess``)
    public let kind: ArcGIS.Expiration.Kind

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.Expiration, b: ArcGIS.Expiration) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension Expiration.Kind : Equatable {
}

extension Expiration.Kind : Hashable {
}

/// An error denoting a resource is past its expiry date.
/// - Since: 200.1
public struct ExpirationError : Error {
}

extension ExpirationError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ExpirationError, b: ArcGIS.ExpirationError) -> Bool
}

/// A job that exports a tile cache (.tpk or .tpkx) from a service.
/// - Note: See Also: ``Job``, ``EstimateTileCacheSizeJob``
/// - Since: 200.1
final public class ExportTileCacheJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.TileCache

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.ExportTileCacheJob.Output, Error> { get async }
}

/// Parameters used for creating an ``ExportTileCacheJob``.
/// - Since: 200.1
final public class ExportTileCacheParameters {

    /// Creates a new export tile cache parameters instance.
    public convenience init()

    /// Area of interest geometry. May be set to `nil` to specify retrieval of the full tile cache extent.
    ///
    /// The supported geometry types for the area of interest are ``Envelope`` and ``Polygon``. The area of interest must have a spatial reference.
    /// Where a ``Polygon`` is supplied, tiles will be filtered according to the polygon geometry, which
    /// can help reduce the size of the resulting tile package. Note that the filtered set of tiles may vary, depending on
    /// the underlying service.
    final public var areaOfInterest: ArcGIS.Geometry?

    /// The compression quality.
    ///
    /// Compression quality is a value from 0 to 100 or `nan`. A lower number reduces the size of the exported tile package, but reduces the quality. This applies to JPEG format tiles.
    /// If the value is `nan` the service will use its default compression quality. The default compression value for the service is accessible on the services metadata under ``TileInfo/compressionQuality``.
    final public var compressionQuality: Float

    /// Level IDs.
    final public var levelIDs: [Int] { get }

    /// Adds a sequence of `Int` values to the end of the `levelIDs` property.
    /// - Parameter newLevelIDs: The new `Int` values to append.
    final public func addLevelIDs<S>(_ newLevelIDs: S) where S : Sequence, S.Element == Int

    /// Adds an `Int` value to the end of the `levelIDs` property.
    /// - Parameter newLevelID: The new `Int` value to append.
    final public func addLevelID(_ newLevelID: Int)

    /// Inserts a collection of `Int` values into the `levelIDs` property at the specified position.
    /// - Parameters:
    ///   - newLevelIDs: The new `Int` values to insert.
    ///   - index: The position at which to insert the new `Int` values.
    final public func insertLevelIDs<C>(_ newLevelIDs: C, at index: Int) where C : Collection, C.Element == Int

    /// Inserts an `Int` value into the `levelIDs` property at the specified position.
    /// - Parameters:
    ///   - newLevelID: The new `Int` value to insert.
    ///   - index: The position at which to insert the new `Int` value.
    final public func insertLevelID(_ newLevelID: Int, at index: Int)

    /// Removes all values from the `levelIDs` property.
    final public func removeAllLevelIDs()

    /// Removes a sequence of `Int` values from the `levelIDs` property.
    /// - Parameter levelIDs: The `Int` values to remove.
    final public func removeLevelIDs<S>(_ levelIDs: S) where S : Sequence, S.Element == Int

    /// Removes an `Int` value from the `levelIDs` property.
    /// - Parameter levelID: The `Int` value to remove.
    final public func removeLevelID(_ levelID: Int)

    /// Clones the ``ExportTileCacheParameters``.
    /// - Returns: A new ``ExportTileCacheParameters`` with the same values as the current ``ExportTileCacheParameters``.
    final public func clone() -> Self
}

/// A task used to export a tile cache (.tpk or .tpkx). Use this in conjunction with a map or image service to generate and download tile packages.
///
/// To confirm whether a map or image service supports exporting tiles, check:
/// * ``ArcGISMapServiceInfo/allowsExportTiles`` property for the legacy compact format (.tpk)
/// * ``ArcGISMapServiceInfo/allowsExportTileCacheCompactV2`` property for the compact version
///   2 format (.tpkx)
///
/// See ``TileCache`` for information on creating a layer from a local tile cache.
///
/// When using Esri provided image basemaps (such as the World Imagery basemap, see
/// ``Basemap/Style/arcGISImagery``) an
/// [alternative service](https://www.arcgis.com/home/group.html?id=3a890be7a4b046c7840dc4a0446c5b31#overview)
/// which supports exporting tiles may be used instead. For example, the World Imagery Service
/// (https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer) will be
/// exported using a corresponding export-enabled service
/// (https://tiledbasemaps.arcgis.com/arcgis/rest/services/World_Imagery/MapServer).
///
/// Similarly, when using elevation data from Esri (such as Terrain 3D), an
/// [alternative service](https://www.arcgis.com/home/group.html?id=3a890be7a4b046c7840dc4a0446c5b31#overview)
/// that supports exporting tiles may be used instead. For example, the Terrain 3D
/// (https://elevation3d.arcgis.com/ArcGIS/rest/services/WorldElevation3D/Terrain3D/ImageServer) will be
/// exported using a corresponding export-enabled service
/// (https://tiledbasemaps.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer). The resulting
/// tile cache can then be used to create an offline ``ArcGISTiledElevationSource`` in a scene.
///
/// Note that these export-enabled services are not intended for use as an online basemap or elevation
/// source, and should only be used for exporting tiles for offline use. The export-enabled services
/// require authentication to export tiles.
/// - Note: See Also: ``init(url:)``, ``TileCache/StorageFormat-swift.enum``
/// - Since: 200.1
final public class ExportTileCacheTask : ArcGIS.APIKeyResource, ArcGIS.Loadable {

    /// Create an export tile cache task from a URL.
    ///
    /// The map or image service must support tile cache export.
    /// - Parameter url: The URL of an ArcGIS REST service that supports tile cache export.
    public convenience init(url: URL)

    /// The task's ``ArcGISMapServiceInfo``
    ///
    /// If created with a URL, this property will be populated after the task
    /// has been loaded. Before then, `nil` will be returned.
    ///
    /// In the case of Esri provided image basemaps or elevation sources, the meta-data will be for
    /// the export-enabled version of the service.
    final public var mapServiceInfo: ArcGIS.ArcGISMapServiceInfo? { get }

    /// The task's service URL.
    ///
    /// This property is only writable when the task is in load status `LoadStatus.notLoaded`.
    final public var url: URL { get }

    /// Creates and returns ``ExportTileCacheParameters``.
    ///
    /// This function is asynchronous because it makes use of the service metadata to build an
    /// ``ExportTileCacheParameters`` object. Calling the function will trigger load of the
    /// ``ExportTileCacheTask``, unless it's already loaded.
    ///
    /// The supported geometry types for the area of interest are ``Envelope`` and ``Polygon``.
    /// The area of interest must have a spatial reference. When a ``Polygon`` is supplied,
    /// tiles will be filtered according to the polygon geometry, which can help reduce the
    /// size of the resulting tile package. Note that the filtered set of tiles may vary,
    /// depending on the underlying service.
    ///
    /// The value of min_scale must be larger than the value of max_scale, unless they are 0.
    /// A min_scale value of 0 will result in this method choosing the services smallest level
    /// number, typically level 0.
    ///
    /// Similarly, a max_scale of 0 will result in the services largest level number being
    /// used, representing the closest in view being visible when taken offline. If min_scale
    /// is between the scales of tile levels the previous smallest level is used.
    ///
    /// If max_scale is between tile levels the next level is taken to ensure it is displayed.
    /// For example a simple service has 4 levels: level 0 scale 2000000; level 1 scale
    /// 1000000; level 2 scale 500000; level 3 scale 250000.
    ///
    /// A min_scale of 0 and max_scale of 0 selects all levels 0,1,2,3.
    ///
    /// A min_scale of 750000 (between levels 1 and 2) and a max_scale of 25000 (at level 3)
    /// will select levels 1,2,3.
    ///
    /// A min_scale of 0 and a max_scale 750000 (between 1 and 2) will select levels 0,1,2.
    ///
    /// A min_scale of 1000000 and a max_scale of 0 will select all levels from 1 onwards
    /// 1,2,3.
    ///
    /// Be careful when combining a large extent or a wide range of scales, this can result in
    /// the export failing due to exceeding the services maximum export tile count.
    /// - Parameters:
    ///   - areaOfInterest: A ``Geometry`` specifying the area to be exported. Must be non-`nil`.
    ///   - minScale: The map scale '1:min_scale' which determines how far out to take offline. Can be 0 for the furthest out.
    ///   - maxScale: The map scale '1:max_scale' which determines how far in to take offline. Can be 0 for the closest in the service allows.
    /// - Returns: An ``ExportTileCacheParameters``.
    final public func makeDefaultExportTileCacheParameters(areaOfInterest: ArcGIS.Geometry, minScale: Double? = nil, maxScale: Double? = nil) async throws -> ArcGIS.ExportTileCacheParameters

    /// Return a new estimate tile cache size job.
    /// - Parameter parameters: Export tile cache parameters to be used in estimating.
    /// - Returns: A new ``EstimateTileCacheSizeJob``.
    final public func makeEstimateTileCacheSizeJob(parameters: ArcGIS.ExportTileCacheParameters) -> ArcGIS.EstimateTileCacheSizeJob

    /// Return a new export tile cache job.
    ///
    /// The resulting job will export tiles from the service, which is referenced by the
    /// ``url`` property (or its export-enabled alternative), to a local
    /// tile cache at the downloadFilePath. The format of the tile cache is determined by the
    /// file extension supplied in the downloadFilePath parameter.
    ///
    /// If the download file path ends with ".tpk", the tile cache will use the legacy compact
    /// format.
    ///
    /// If the download file path ends with ".tpkx", the tile cache will use the current
    /// compact version 2 format.
    ///
    /// If the service does not support exporting tiles, the job will fail with
    /// `CoreErrorCode.mappingTileExportNotEnabled`.
    ///
    /// If a .tpkx format was requested, but the format is not supported by the service, the
    /// job will fail with `CoreErrorCode.mappingTileCacheCompactV2ExportNotEnabled`.
    /// - Parameters:
    ///   - parameters: Export tile cache parameters to be used in exporting.
    ///   - downloadFileURL: Downloaded tile cache file path that ends with .tpk or .tpkx, depending on the desired format.
    /// - Returns: A new ``ExportTileCacheJob``.
    final public func makeExportTileCacheJob(parameters: ArcGIS.ExportTileCacheParameters, downloadFileURL: URL) -> ArcGIS.ExportTileCacheJob

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A job that exports vector tiles from a service.
/// The job can also export an item resource cache from a portal item.
/// - Note: See Also: ``Job``
/// - Since: 200.1
final public class ExportVectorTilesJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// The path that the downloaded vector tile style is saved to. If this job was created with
    /// `ExportVectorTilesTask.makeExportVectorTilesJob(parameters:downloadFileURL:)`, this will be an empty string.
    final public var itemResourceCacheURL: URL? { get }

    /// The parameters used to create this job.
    final public var parameters: ArcGIS.ExportVectorTilesParameters { get }

    /// The path that the downloaded vector tile cache is saved to. If this job was created with
    /// `ExportVectorTilesTask.makeExportStyleResourceCacheJob(itemResourceCacheURL:)`, this will be an empty string.
    final public var vectorTileCacheURL: URL? { get }

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.ExportVectorTilesResult

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.ExportVectorTilesJob.Output, Error> { get async }
}

/// Parameters for creating the ``ExportVectorTilesJob``.
/// - Since: 200.1
final public class ExportVectorTilesParameters {

    /// Creates a new export vector tiles parameters instance.
    public convenience init()

    /// Area of interest geometry. May be set to `nil` to specify retrieval of the full vector tiles extent.
    ///
    /// The supported geometry types for the area of interest are ``Envelope`` and ``Polygon``. The area of interest must have a spatial reference.
    /// Where a ``Polygon`` is supplied, tiles will be filtered according to the polygon geometry, which
    /// can help reduce the size of the resulting tile package. Note that the filtered set of tiles may vary, depending on
    /// the underlying service.
    final public var areaOfInterest: ArcGIS.Geometry?

    /// Describes how Esri vector tiled basemap layers will be downloaded.
    ///
    /// This property lets you choose how to download Esri vector tiled basemap layers. This
    /// property only applies when taking an Esri vector tile basemap service offline.
    ///
    /// When taking an Esri vector tiled basemap service offline (e.g. to create a ``VectorTileCache`` on your device),
    /// you can choose from different versions of the service depending on your use case.
    ///
    /// Primary considerations are the download speed and the size of the resulting .vtpk file. Among other things,
    /// file size is influenced by the number of fonts downloaded from the service. Esri vector tiled basemap layers
    /// use fonts as part of their style resources - see the
    /// [vector-tile-style
    /// documentation](https://developers.arcgis.com/rest/services-reference/enterprise/vector-tile-style.htm). When you take a vector tiled layer offline, these fonts are downloaded as part of the
    /// ``VectorTileCache``.
    ///
    /// Esri services also offer an alternative version with a reduced font package size. This omits the large Arial
    /// Unicode font, which greatly reduces the download size. You can view the set of reduced font vector tile services
    /// [here](https://www.arcgis.com/home/group.html?id=c61ab1493fff4b84b53705184876c9b0).
    ///
    /// * If you choose ``EsriVectorTilesDownloadOption/useOriginalService``, the full set of resources used by the original
    /// online service, including all fonts, will be downloaded. This increases the download size of the
    /// ``VectorTileCache`` but ensures that the offline layer will display the same as the original online data.
    ///
    /// * If you choose ``EsriVectorTilesDownloadOption/useReducedFontsService``, the smaller set of fonts used by
    /// the alternative, for export, version of the service will be downloaded. This reduces the download size of
    /// the ``VectorTileCache`` but is not suitable for all locales or when your offline vector tiled layer includes
    /// certain language characters. For example, this option will not display Chinese, Japanese, Thai, Korean or
    /// Georgian characters. If an alternative, for export version of the service cannot be found, the original
    /// service will be used.
    ///
    /// The default value is ``EsriVectorTilesDownloadOption/useOriginalService``.
    final public var esriVectorTilesDownloadOption: ArcGIS.EsriVectorTilesDownloadOption

    /// Clones the ``ExportVectorTilesParameters``.
    /// - Returns: A new ``ExportVectorTilesParameters`` with the same values as the current ``ExportVectorTilesParameters``.
    final public func clone() -> Self
}

extension ExportVectorTilesParameters {

    /// The maximum level of detail at which the vector tiles are going to be
    /// exported.
    /// - Remark: This represents the maximum level of detail to export. The
    /// vector tile export will always take levels 0 and all in between levels
    /// up to and including the value of max level. The larger the level, the
    /// more tiles will be included. The default value is `nil`, which indicates
    /// that there is no maximum level.
    final public var maxLevel: Int?
}

/// The result of an ``ExportVectorTilesJob``.
/// - Since: 200.1
final public class ExportVectorTilesResult {

    /// The item resource cache result of a successful export vector titles job. For vector tiles, this contains a custom style.
    final public var itemResourceCache: ArcGIS.ItemResourceCache? { get }

    /// The vector tile cache result of a successful export vector tiles job. This result will be `nil` if the item cache resource alone is returned.
    final public var vectorTileCache: ArcGIS.VectorTileCache? { get }
}

/// A task used to export vector tiles and optionally a portal item's vector tile style resources.
///
/// Vector tiles are exported as a vector tile package (.vtpk) file, see ``VectorTileCache``.
///
/// A portal item can contain a custom style resources overriding the vector tile services
/// default style and this can be checked with ``hasStyleResources``.
/// The custom style is exported separately as an ``ItemResourceCache``.
///
/// The export vector tiles task can be initialized with a URL using
/// ``init(url:)``. The URL can be to:
/// * A vector tile server that ends in "VectorTileServer" and is the rest end-point used to
///   export vector tile packages. The vector tile service must be enabled for export or the
///   task will fail to load.
/// * A portal item for a vector tile service or a vector tiled layer with a custom style
///   applied
/// * A vector basemap layer created using a ``Basemap/Style``
///
/// Alternatively a ``PortalItem``, referencing a vector tile service or a custom style for a
/// vector tiled layer, can be used with
/// ``init(portalItem:)``.
///
/// When using Esri provided vector basemaps that do not support exporting tiles (such as the
/// ArcGIS streets basemap - see ``Basemap/Style/arcGISStreets``), an alternative service that
/// supports exporting tiles will be used instead.
/// - Since: 200.1
final public class ExportVectorTilesTask : ArcGIS.APIKeyResource, ArcGIS.Loadable {

    /// Initialize an export vector tiles task with a portal item of type ``PortalItem/Kind-swift.enum/vectorTileService``.
    ///
    /// If the portal item is not of type ``PortalItem/Kind-swift.enum/vectorTileService`` the task will
    /// fail to load.
    ///
    /// The portal item will reference a vector tile service and once the task is loaded the
    /// property ``url`` will be populated to the backing service.
    ///
    /// This portal item can also contain custom style resources see
    /// ``hasStyleResources`` which can additionally be exported as
    /// ``ItemResourceCache``.
    /// - Parameter portalItem: A portal item instance
    public convenience init(portalItem: ArcGIS.PortalItem)

    /// Initialize an export vector tiles task with a URL to a vector tile service.
    ///
    /// The URL can be for:
    /// * A vector tile server that ends in "VectorTileServer" and is the rest end-point used
    ///   to export vector tile packages. The vector tile service must be enabled for export
    ///   or the task will fail to load.
    /// * A portal item for a vector tile service or a vector tiled layer with a custom style
    ///   applied
    /// * A vector basemap layer created using a ``Basemap/Style``
    ///
    /// If the URL represents a ``PortalItem`` that can be used to download vector tiles or
    /// style resources, the ``portalItem`` property will be populated
    /// when the task is loaded.
    /// - Parameter url: The URL of a service or portal item to be used for exporting vector tiles.
    public convenience init(url: URL)

    /// Indicates if the task's portal item has any associated style resources that override the default style of the vector tile service.
    ///
    /// This property will be set to `true` if the export vector tile task has been loaded and
    /// the task's portal item has style resources.
    /// The portal item's style resources override the default style of the vector tile service and
    /// can be exported as ``ItemResourceCache``.
    final public var hasStyleResources: Bool { get }

    /// The task's portal item which must be of type ``PortalItem/Kind-swift.enum/vectorTileService``.
    ///
    /// This property can only be set when the task is load status `LoadStatus.notLoaded` or `LoadStatus.failedToLoad`
    /// If the portal item is not of type ``PortalItem/Kind-swift.enum/vectorTileService`` the task will fail to load.
    /// A vector tile service can be referenced by an item in a portal of type ``PortalItem/Kind-swift.enum/vectorTileService``.
    /// This item can also contain custom style resources see ``hasStyleResources`` which
    /// can be exported as ``ItemResourceCache``.
    final public var portalItem: ArcGIS.PortalItem? { get }

    /// The URL for exporting vector tiles.
    ///
    /// This property can be the URL of:
    /// * A vector tile server that ends in "VectorTileServer" and is the rest end-point used
    ///   to export vector tile packages. The vector tile service must be enabled for export
    ///   or the task will fail to load.
    /// * A portal item for a vector tile service or a vector tiled layer with a custom style
    ///   applied
    /// * A vector basemap layer created using a ``Basemap/Style``
    ///
    /// If the URL represents a ``PortalItem`` that can be used to download vector tiles or
    /// style resources, the ``portalItem`` property will be populated
    /// when the task is loaded.
    final public var url: URL? { get }

    /// The task's ``VectorTileSourceInfo`` representing the source metadata for a vector tile service.
    final public var vectorTileSourceInfo: ArcGIS.VectorTileSourceInfo? { get }

    /// Creates and returns the default parameters for the export vector tile task.
    ///
    /// This function is asynchronous because it makes use of the service metadata to populate the ``ExportVectorTilesParameters`` object.
    /// Calling this function will trigger the ``ExportVectorTilesTask`` to be loaded, unless it is already loaded.
    ///
    /// The supported geometry types for the area of interest are ``Envelope`` and ``Polygon``. The area of interest must have a spatial reference.
    /// Where a ``Polygon`` is supplied, tiles will be filtered according to the polygon geometry, which
    /// can help reduce the size of the resulting tile package. Note that the filtered set of tiles may vary, depending on
    /// the underlying service.
    ///
    /// A max_scale of 0 will include all levels of detail of the service.
    /// Be careful when you provide a large area of interest or a small max_scale value as this could result in a large number of tiles being requested.
    /// If the number of tiles requested exceeds the service's maximum export tile count the ``ExportVectorTilesJob`` will fail.
    /// - Parameters:
    ///   - areaOfInterest: a ``Geometry`` specifying the area of vector tiles to be exported. Must not be `nil`.
    ///   - maxScale: the map scale '1:max_scale' which determines how far in to export the vector tiles. Set the value to 0 to include all levels of detail in the service.
    /// - Returns: The ``ExportVectorTilesParameters``.
    final public func makeDefaultExportVectorTilesParameters(areaOfInterest: ArcGIS.Geometry, maxScale: Double? = nil) async throws -> ArcGIS.ExportVectorTilesParameters

    /// Return a new export vector tiles job that will download a custom style from a portal item as an item resource cache.
    ///
    /// The job will return the item resource cache without a vector tile cache.
    /// This is useful when a number of different styles are applied to the same
    /// underlying vector tile service. This avoids exporting multiple copies of the same tiles.
    /// - Parameter itemResourceCacheURL: The file path where the vector style file will be saved on disk.
    /// - Returns: A new ``ExportVectorTilesJob``.
    final public func makeExportStyleResourceCacheJob(itemResourceCacheURL: URL) -> ArcGIS.ExportVectorTilesJob

    /// Returns a new export vector tiles job that can be used to generate and download a vector tile package containing the vector tiles specified by the parameters (``ExportVectorTilesParameters``).
    /// - Parameters:
    ///   - parameters: specifying which tiles to include in the vector tile package.
    ///   - downloadFileURL: The file path where the vector tiles will be saved on disk, including the desired file name ending with the .vtpk file extension.
    /// - Returns: A new ``ExportVectorTilesJob`` to export the vector tiles from a service.
    final public func makeExportVectorTilesJob(parameters: ArcGIS.ExportVectorTilesParameters, downloadFileURL: URL) -> ArcGIS.ExportVectorTilesJob

    /// Return a new export vector tiles job that can be used to generate and download a vector tile package and return a custom style as an item.
    /// resource cache.
    /// - Parameters:
    ///   - parameters: specifying which tiles to include in the vector tile package.
    ///   - vectorTileCacheURL: The file path where the vector tiles will be saved on disk, including the desired file name ending with the .vtpk file extension.
    ///   - itemResourceCacheURL: The directory path where the style file will be saved on disk.
    /// - Returns: A new ``ExportVectorTilesJob`` to export the vector tiles from a service.
    final public func makeExportVectorTilesJob(parameters: ArcGIS.ExportVectorTilesParameters, vectorTileCacheURL: URL, itemResourceCacheURL: URL) -> ArcGIS.ExportVectorTilesJob

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// Represents a pop-up element of type expression that defines a pop-up element with an Arcade expression.
/// - Note: See Also: `PopupElement.Type`, ``PopupElement``
/// - Since: 200.1
final public class ExpressionPopupElement : ArcGIS.PopupElement {

    /// Creates a new expression pop-up element with the given expression.
    ///
    /// Refer to [Popup Element](https://developers.arcgis.com/arcade/profiles/popup-element/) for more details.
    /// - Parameter popupExpression: An Arcade expression that defines the pop-up element. The return type will always be `dictionary` which must follow the Web Map Specification for a popupElement.
    public convenience init(popupExpression: ArcGIS.PopupExpression? = nil)

    /// The Arcade expression that defines the pop-up element.
    final public var popupExpression: ArcGIS.PopupExpression?
}

/// Details of an extension license.
/// - Since: 200.1
final public class ExtensionLicense {

    /// The date the extension license expires.
    final public var expirationDate: Date { get }

    /// `true` if the extension license is permanent, `false` otherwise.
    ///
    /// Typically this returns `true` for a license string with 'none' for the
    /// expiration date field.
    final public var isPermanent: Bool { get }

    /// The name of the extension license.
    ///
    /// This is the name of the extension embedded in the license string.
    final public var name: String { get }

    /// The ``License/Status-swift.enum`` of the extension license.
    final public var status: ArcGIS.License.Status { get }
}

/// A class that represents a facility.
///
/// Facilities represent locations that can serve as the starting point or ending point of
/// a closest facility analysis, for example, a fire station or a hospital.
/// The ``Facility`` class contains one of location inputs for the ``ClosestFacilityTask``.
/// The ``ClosestFacilityTask`` will create a route between facilities and incidents.
/// - Note: See Also: ``ClosestFacilityTask``, ``Incident``
/// - Since: 200.1
final public class Facility {

    /// Creates a facility instance with point.
    ///
    /// Creates a facility.
    /// - Parameter point: A point.
    /// - Note: See Also: ``Point``
    public convenience init(point: ArcGIS.Point)

    /// Curb approach.
    ///
    /// Default value ``CurbApproach/eitherSide`` will be returned on error.
    /// - Note: See Also: ``CurbApproach``
    final public var curbApproach: ArcGIS.CurbApproach?

    /// Current bearing in degrees.
    ///
    /// Current bearing in degrees, measured clockwise from `true` north. Typical values are 0 to 360 or `nan`,
    /// negative values will be subtracted from 360 (e.g. -15 => 345), values greater than 360 will be have 360
    /// subtracted from them (e.g. 385 => 25). For this property to be used the bearing tolerance also has to be set.
    final public var currentBearing: Double

    /// Current bearing tolerance in degrees. Valid values are 0 to 180 or `nan`.
    final public var currentBearingTolerance: Double

    /// Distance to network location in meters.
    ///
    /// The distance to network location in meters can be populated by closest facility task.
    final public var distanceToNetworkLocation: Measurement<UnitLength> { get }

    /// The geometry of a facility.
    ///
    /// Gets facility's location using geographical point.
    /// - Note: See Also: ``Point``
    final public var geometry: ArcGIS.Point? { get }

    /// Facility ID.
    ///
    /// This is a caller supplied foreign key that can be used to associate output facilities with input facilities.
    /// - Note: See Also: `ClosestFacilityParameters.setFacilities(fromFeaturesIn:queryParameters:)`, ``ClosestFacilityResult/facilities``
    final public var id: Int

    /// Impedance cutoff.
    ///
    /// It's a value for the impedance beyond which facilities should not be found.
    final public var impedanceCutoff: Double

    /// Location status.
    ///
    /// Facility location's status can be populated by closest facility task.
    /// Default value ``LocationStatus/notLocated`` will be returned on error.
    /// - Note: See Also: ``LocationStatus``
    final public var locationStatus: ArcGIS.LocationStatus { get }

    /// Facility's name.
    ///
    /// Facility's name to be reported in driving directions.
    /// - Note: See Also: `String`
    final public var name: String

    /// Navigation latency in seconds.
    final public var navigationLatency: TimeInterval

    /// Navigation speed in meters per second.
    final public var navigationSpeed: Double

    /// Network location.
    ///
    /// The facility's location on the network that can be populated by closest facility task.
    /// Set to `nil` for resetting a network location.
    /// - Note: See Also: ``NetworkLocation``
    final public var networkLocation: ArcGIS.NetworkLocation?

    /// Gets added cost.
    ///
    /// Returns added cost value for given impedance or accumulate attribute.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: The value of added cost.
    final public func addedCost(forAttributeNamed attributeName: String) -> Double

    /// Clones the ``Facility``.
    /// - Returns: A new ``Facility`` with the same values as the current ``Facility``.
    final public func clone() -> Self

    /// Sets added cost.
    ///
    /// Sets added cost value for given impedance or accumulate attribute.
    /// - Parameters:
    ///   - addedCost: The added cost.
    ///   - attributeName: The name of attribute.
    final public func setAddedCost(_ addedCost: Double, forAttributeNamed attributeName: String)
}

/// Defines the properties of the layer that contains facilities for a floor-aware map or scene.
///
/// The layer contains the footprints of managed facilities. A facility represents any
/// occupiable structure, such as an office or campus building, retail setting, or industrial structure.
/// Facilities have one or more floor levels and are optionally grouped into sites.
/// - Note: See Also: ``GeoModelFloorDefinition``
/// - Since: 200.1
final public class FacilityLayerDefinition : ArcGIS.JSONSerializable {

    /// Creates a new ``FacilityLayerDefinition`` object with the specified ``Layer/id-swift.property``, facility id attribute field, facility name attribute field, and site id attribute field.
    /// - Parameters:
    ///   - layerID: An ID that specifies a layer in the map or scene that contains facilities.
    ///   - facilityIDField: The name of the attribute field that contains a facility feature's unique identifier.
    ///   - nameField: The name of the attribute field that contains a facility feature's name.
    ///   - siteIDField: The name of the attribute field that contains a facility feature's site identifier (a foreign key to the layer that contains sites).
    public convenience init(layerID: ArcGIS.Layer.ID, facilityIDField: String, nameField: String, siteIDField: String)

    /// The name of the attribute field that contains a facility feature's unique identifier.
    final public var facilityIDField: String { get }

    /// An ID that specifies a layer in the map or scene that contains facilities. The layer provides access to facility features for floor filtering.
    final public var layerID: ArcGIS.Layer.ID { get }

    /// The name of the attribute field that contains each facility feature's name.
    final public var nameField: String { get }

    /// The name of the attribute field that contains a facility feature's site identifier (a foreign key to the Site layer).
    final public var siteIDField: String { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

/// A representation of a real-world geographic entity.
///
/// Features are composed of both a geometry (point, polyline, or polygon) and attributes. The geometry
/// represents the location and shape of the real-world entity; the attributes (key-value pairs) represent
/// the fields and values that describe the entity. Examples of features include roads, fire hydrants, and
/// property boundaries. Applications can access features from a feature layer or a feature collection to
/// visualize the feature's geographic and attribute information, execute spatial queries, perform analyses,
/// or make edits to the feature's data directly. Feature attribute values can be changed, but attribute definitions cannot be added,
/// deleted, or modified.
///
/// Features are typically persisted in a data source (such as a feature service, geodatabase, shapefile,
/// GeoJSON file, or GeoPackage) and have a common attribute schema. Features can also be stored directly in
/// a feature collection in a map or scene. A feature collection groups logically related tables of features
/// that may have different schema, geometry types, and symbology. See ``FeatureCollectionLayer`` for more
/// information.
///
/// ``Feature`` is the base class for ``ArcGISFeature``. ArcGIS features are stored in ArcGIS
/// specific data sources such as ``GeodatabaseFeatureTable`` and ``ServiceFeatureTable``.
/// - Note: See Also: ``ArcGISFeature``, ``ArcGISFeatureTable``, ``GeoPackageFeatureTable``, ``OGCFeatureCollectionTable``, ``ShapefileFeatureTable``, ``WFSFeatureTable``, ``FeatureCollectionTable``
/// - Since: 200.1
public class Feature : ArcGIS.GeoElement {

    /// The ``FeatureTable`` that this feature belongs to.
    weak public var table: ArcGIS.FeatureTable? { get }

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    public var attributes: [String : Any] { get }

    public func setAttributeValue(_ value: Any?, forKey key: String)

    /// The geometry defines the shape and location of the ``GeoElement``.
    public var geometry: ArcGIS.Geometry?
}

extension Feature {

    /// Resets the attributes and geometry to the values in the data source.
    /// - Remark: Discards any in-memory changes to the feature that have not been
    /// applied to the table, and reloads the feature geometry and all attributes.
    /// - Returns: A Boolean value indicating if the geometry or attributes were updated.
    @discardableResult
    public func refresh() -> Bool
}

/// An object that represents a feature collection.
/// - Since: 200.1
final public class FeatureCollection : ArcGIS.JSONSerializable, ArcGIS.Loadable {

    /// Create a feature collection object.
    public convenience init()

    /// Creates a feature collection object from a set of feature collection tables.
    /// - Parameter featureCollectionTables: An `Array` of ``FeatureCollectionTable``.
    /// - Note: See Also: ``tables``
    public convenience init(featureCollectionTables: [ArcGIS.FeatureCollectionTable])

    /// Creates a feature collection object from an item.
    /// - Parameter item: An ``Item`` (only ``PortalItem`` are supported).
    /// - Note: See Also: ``item``
    public convenience init(item: ArcGIS.Item)

    /// The item the feature collection has been created from.
    ///
    /// For internal use only. May be used after saving the feature collection as a new portal item.
    /// - Note: See Also: ``init(item:)``
    final public var item: ArcGIS.Item?

    /// The feature collection tables of a feature collection.
    final public var tables: [ArcGIS.FeatureCollectionTable] { get }

    /// Adds a sequence of `FeatureCollectionTable` values to the end of the `tables` property.
    /// - Parameter newTables: The new `FeatureCollectionTable` values to append.
    final public func addTables<S>(_ newTables: S) where S : Sequence, S.Element == ArcGIS.FeatureCollectionTable

    /// Adds a `FeatureCollectionTable` value to the end of the `tables` property.
    /// - Parameter newTable: The new `FeatureCollectionTable` value to append.
    final public func addTable(_ newTable: ArcGIS.FeatureCollectionTable)

    /// Inserts a collection of `FeatureCollectionTable` values into the `tables` property at the specified position.
    /// - Parameters:
    ///   - newTables: The new `FeatureCollectionTable` values to insert.
    ///   - index: The position at which to insert the new `FeatureCollectionTable` values.
    final public func insertTables<C>(_ newTables: C, at index: Int) where C : Collection, C.Element == ArcGIS.FeatureCollectionTable

    /// Inserts a `FeatureCollectionTable` value into the `tables` property at the specified position.
    /// - Parameters:
    ///   - newTable: The new `FeatureCollectionTable` value to insert.
    ///   - index: The position at which to insert the new `FeatureCollectionTable` value.
    final public func insertTable(_ newTable: ArcGIS.FeatureCollectionTable, at index: Int)

    /// Removes all values from the `tables` property.
    final public func removeAllTables()

    /// Removes a sequence of `FeatureCollectionTable` values from the `tables` property.
    /// - Parameter tables: The `FeatureCollectionTable` values to remove.
    final public func removeTables<S>(_ tables: S) where S : Sequence, S.Element == ArcGIS.FeatureCollectionTable

    /// Removes a `FeatureCollectionTable` value from the `tables` property.
    /// - Parameter table: The `FeatureCollectionTable` value to remove.
    final public func removeTable(_ table: ArcGIS.FeatureCollectionTable)

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension FeatureCollection {

    /// Saves this feature collection as a new feature collection item on the specified portal with
    /// the given title in the given folder.
    ///
    /// Once completed, the feature collection's `item` property will be populated with the new portal
    /// item. Note that if the feature collection already has a valid item property (either because
    /// the feature collection was created using an item or was previously saved), that property will
    /// be replaced with a new item, effectively 'duplicating' the feature collection on the portal.
    /// - Parameters:
    ///   - portal: The portal to save the feature collection to.
    ///   - title: The title of the feature collection.
    ///   - folder: The folder in which to save the feature collection. If `nil` is passed it will
    ///   be added to the user's root folder.
    ///   - description: The description of the feature collection.
    ///   - thumbnail: The thumbnail of the feature collection. The recommended thumbnail image size
    ///   is 200 pixels wide by 133 pixels high. Acceptable image formats are PNG, GIF, and JPEG with
    ///   a maximum file size of 1 MB.
    ///   - tags: The tags to be associated with the newly created portal item.
    final public func save(to portal: ArcGIS.Portal, title: String, folder: ArcGIS.PortalFolder? = nil, description: String = "", thumbnail: UIImage? = nil, tags: [String] = []) async throws

    /// Updates this feature collection back to the item it originated from.
    ///
    /// Upon completion, the item's data will have been updated with the feature collection. An error
    /// will occur if the feature collection does not have a valid `item` property. A feature collection
    /// has a valid item property if it was created using ``FeatureCollection/init(item:)``, or has
    /// been previously saved as a new item using ``FeatureCollection/save(to:title:folder:description:thumbnail:tags:)``.
    final public func update() async throws
}

/// A layer that can visualize a feature collection.
///
/// A feature collection groups logically-related tables of features even though they may have
/// different schema, geometry types, and symbology. A feature collection layer allows multiple
/// tables with different schemas to be managed as a group.
///
/// Functional characteristics
/// Sketch information (called Map Notes in ArcGIS Online), may contain points, lines, polygons,
/// and associated text to describe things in the map. Because they have different schema and
/// geometry types, these features are stored in several distinct tables. A feature collection layer
/// allows these tables to be rendered and managed as a group.
///
/// A feature collection can be saved in the map or as a stand-alone portal item. If you need to
/// share the feature collection between several maps, it's best to store it as a separate portal
/// item. If you need to make frequent (near real-time) edits to features in a collection, consider
/// storing these in a feature service instead, because the feature collection is not refreshed
/// until the map or portal item is reloaded. If features are used by a single map or are not
/// subject to frequent updates, it might be best to store them directly in the map. Edits made to
/// features stored in a map will be saved when the map is saved. Edits made to features stored in
/// a portal item (and loaded into a map, for example) must be explicitly saved to the original
/// portal item.
///
/// Performance characteristics
/// Feature collection layers are designed to display a moderate amount of feature data (hundreds
/// or thousands of features). They are ideal for sharing data that is not subject to frequent
/// updates among several clients.
///
/// As full feature information is cached locally in a geodatabase and features are drawn natively,
/// this layer type offers excellent display performance when zooming and panning the map, within
/// the extent of cached features.
///
/// Downloading features to the device may require extensive network usage and local device storage
/// space. After the features are present on the client, the app no longer needs to make requests
/// for the data. App memory usage increases with the number and complexity of the features in the
/// collection.
/// - Note: See Also: ``Layer``, ``FeatureCollection``
/// - Since: 200.1
final public class FeatureCollectionLayer : ArcGIS.Layer {

    /// Creates a new feature collection layer object.
    /// - Parameter featureCollection: The feature collection to initialize this layer with.
    public convenience init(featureCollection: ArcGIS.FeatureCollection)

    /// The feature collection associated with this layer.
    final public var featureCollection: ArcGIS.FeatureCollection { get }

    /// The feature layers associated with this layer.
    @ArcGIS.Streamed final public var layers: [ArcGIS.FeatureLayer] { get }

    final public var $layers: AsyncStream<[ArcGIS.FeatureLayer]> { get }
}

/// An object that represents a feature collection table.
/// - Since: 200.1
final public class FeatureCollectionTable : ArcGIS.FeatureTable, ArcGIS.FeatureSet {

    /// Create a feature collection table object from an object implementing the ``FeatureSet``.
    ///
    /// The object will be populated with the contents of the feature set passed in.
    /// Be aware that this constructor may take some time to complete depending on how many features are in the feature set.
    /// - Parameter featureSet: An object that implements the ``FeatureSet``.
    public convenience init(featureSet: ArcGIS.FeatureSet)

    /// Create a feature collection table object populated with some geo elements.
    ///
    /// The geometry type and spatial reference will be inferred from the geo-elements passed in.
    /// Be aware that this constructor may take some time to complete depending on how many geo-elements are passed in.
    /// - Parameters:
    ///   - geoElements: An `Array` of objects that implement the ``GeoElement``. Contents of the `Array` will be copied.
    ///   - fields: An `Array` of type ``Field``. Contents of the `Array` will be copied. Can be `nil`.
    /// - Precondition: `!geoElements.isEmpty`
    public convenience init(geoElements: [some ArcGIS.GeoElement], fields: [ArcGIS.Field])

    /// The layer info of the feature collection table.
    final public var layerInfo: ArcGIS.ArcGISFeatureLayerInfo? { get }

    /// The renderer for the feature collection table.
    final public var renderer: ArcGIS.Renderer?

    /// Sets the symbol override for the given feature in the feature collection table.
    /// - Parameters:
    ///   - symbol: The symbol. Can be `nil`.
    ///   - feature: The feature to set the symbol override for.
    final public func setSymbolOverride(_ symbol: ArcGIS.Symbol?, for feature: ArcGIS.Feature)

    /// Gets the symbol override for the given feature in the feature collection table.
    /// - Parameter feature: The feature to retrieve the symbol override for.
    /// - Returns: A ``Symbol``. `nil` is returned if an error occurs.
    final public func symbolOverride(for feature: ArcGIS.Feature) -> ArcGIS.Symbol?

    /// Returns the feature iterator.
    /// - Returns: An `AnySequence` that returns ``Feature`` types.
    final public func features() -> AnySequence<ArcGIS.Feature>
}

extension FeatureCollectionTable {

    /// Create a feature collection table object.
    /// - Parameters:
    ///   - fields: The fields that the table will contain.
    ///   - geometryType: The type of geometry that will be held in this table.
    ///   - spatialReference: The spatial reference of the features that will be held in this table.
    ///   - hasZ: Boolean specifying whether the table supports geometries with Z values.
    ///   - hasM: Boolean specifying whether the table supports geometries with M values.
    public convenience init(fields: [ArcGIS.Field], geometryType: ArcGIS.Geometry.Type, spatialReference: ArcGIS.SpatialReference, hasZ: Bool = false, hasM: Bool = false)

    /// Create a feature collection table object.
    /// - Parameters:
    ///   - fields: The fields that the table will contain.
    ///   - hasZ: Boolean specifying whether the table supports geometries with Z values.
    ///   - hasM: Boolean specifying whether the table supports geometries with M values.
    public convenience init(fields: [ArcGIS.Field], hasZ: Bool = false, hasM: Bool = false)
}

/// An object that represents the results of an attempt to push an feature update to a feature service.
/// - Since: 200.1
final public class FeatureEditResult : ArcGIS.EditResult {

    /// A list of edit results for any attachment changes.
    final public var attachmentResults: [ArcGIS.EditResult] { get }
}

/// Geotrigger fence data created from features.
///
/// The features that create a ``FeatureFenceParameters`` provide a set of geometries (and
/// attributes) that define targets for the ``Geotrigger``. For example, if the condition is
/// "notify me when my position comes within 50 meters of one of my target areas", the
/// fence data are "my target areas" and each ``Feature`` is one target area.
///
/// Create a ``FeatureFenceParameters`` using a ``FeatureTable``. The features can have point,
/// line, or polygon geometry. For points and lines, you must also supply a
/// ``FenceParameters/bufferDistance``. Each feature in the table represents a single fence.
///
/// You can filter features using attributes or geometry by supplying a where clause. For
/// example, you could further refine "my target areas" to be "my target areas that
/// are open and are in California".
///
/// The number of features fetched by querying an online table is limited by the layer's
/// ``ArcGISFeatureLayerInfo/maxRecordCount``. Service feature tables that support pagination
/// (``ArcGISFeatureLayerInfo/supportsPagination``) are not subject to the maximum feature count
/// limit.
///
/// A ``FenceGeotrigger`` can also take into account floors within buildings. If the feature
/// table used to create the ``FeatureFenceParameters`` is referenced by a ``FeatureLayer`` that
/// is ``FloorAware``, and the ``LocationDataSource`` used to create the ``GeotriggerFeed``
/// includes ``Location/SourcePropertyKey/floor`` information, then fences will only be
/// entered when they are intersected by a ``Location`` on the correct floor. If the fence or
/// location data does not include valid floor information, the floor is ignored and the fence
/// is entered when it is intersected by the location.
///
/// A floor aware feature layer or table must be part of a ``GeoModel`` that includes a valid
/// ``GeoModelFloorDefinition``. All layers and tables that are used by the floor definition
/// are loaded when the ``GeotriggerMonitor`` is started.
///
/// A ``Location`` can contain floor property as part of
/// ``Location/additionalSourceProperties``. This is populated automatically by
/// ``IndoorsLocationDataSource``, or can be supplied as part of your own implementation.
/// - Since: 200.1
final public class FeatureFenceParameters : ArcGIS.FenceParameters {

    /// Creates a ``FeatureFenceParameters`` using all of the features in the ``FeatureTable``.
    /// - Parameters:
    ///   - featureTable: The ``FeatureTable`` that contains the features to use in the ``FeatureFenceParameters``.
    ///   - bufferDistance: A buffer distance in meters to apply to the features when checking if a ``FenceGeotrigger`` condition is met.
    public convenience init(featureTable: ArcGIS.FeatureTable, bufferDistance: Double = 0)

    /// The geometry that can be used to spatially filter fences.
    ///
    /// This needs to be either an ``Envelope`` or ``Polygon``. Use this to define which features in the ``FeatureTable``
    /// are to be used as fences by defining an area of interest. If this property is `nil` we will use the full extent
    /// of the feature table.
    final public var areaOfInterest: ArcGIS.Geometry?

    /// The ``FeatureTable`` that contains the features to use in the ``FeatureFenceParameters``.
    ///
    /// This table can be shared with a ``FeatureLayer/featureTable``.
    /// This property will be `nil` if the ``FeatureLayer`` within a web map could not be found.
    final public var featureTable: ArcGIS.FeatureTable? { get }

    /// A where clause that defines the features from the ``FeatureTable`` to use as fences.
    ///
    /// The string that is used as the ``whereClause`` should follow standard SQL syntax similar
    /// to what is discussed in the document
    /// [SQL reference for query expressions used in ArcGIS](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm).
    ///
    /// The number of features fetched by querying an online table is limited by the layer's
    /// ``ArcGISFeatureLayerInfo/maxRecordCount``. Service feature tables that support pagination
    /// (``ArcGISFeatureLayerInfo/supportsPagination``) are not subject to the maximum feature count limit.
    final public var whereClause: String
}

/// A layer that can visualize vector/feature data.
///
/// Feature layers can display ``Feature`` data from online sources such as ``ServiceFeatureTable``,
/// ``WFSFeatureTable`` or ``OGCFeatureCollectionTable`` source, and offline sources such as
/// ``GeodatabaseFeatureTable``, ``ShapefileFeatureTable``, or ``GeoPackageFeatureTable``. You can
/// construct a feature layer object using these sources or you can obtain it directly from a map or
/// scene's collection of ``GeoModel/operationalLayers``.
///
/// Feature layers can also be used to store features associated with a utility network. To display features
/// in a ``FeatureCollectionTable``, use ``FeatureCollectionLayer`` instead.
///
/// Feature layers can be used to display, select, and query features in a layer. Individual features can be
/// queried and filtered based on spatial queries or SQL queries. String comparisons for features queried
/// in service feature tables are case insensitive.
///
/// If the underlying feature service or table supports editing, you can use it with a feature layer as a
/// basis for editing geometry, attributes, and attachments.
///
/// The features in a feature layer are retrieved as needed by the app. Features can be downloaded from a
/// sync-enabled feature service when the device is connected and cached locally for use when the device is
/// offline. Edits can then be synchronized back to the service.
///
/// Functional characteristics
///
/// The following sources can be rendered using a feature layer:
/// * Feature service - backed by a ``ServiceFeatureTable``. The feature data from the service is
///   cached locally in the table. New features are retrieved automatically when you navigate
///   the map. The local table cache is discarded when the layer is disposed. If sync is
///   enabled, features can be created, edited, and synchronized back to the server.
/// * Geodatabase - backed by a ``GeodatabaseFeatureTable``. The geodatabase can be a replica of
///   a feature service, which allows synchronizing with the feature service, or taking the
///   content of a feature service offline. Use ``GeodatabaseSyncTask`` to synchronize the
///   geodatabase with the service. The geodatabase can also be a mobile geodatabase created
///   by ArcGIS Pro. These geodatabases cannot be synced and use a default renderer.
/// * Shapefile - backed by a ``ShapefileFeatureTable``. Use a feature layer to show the
///   contents of a shapefile (.shp).
/// * Geopackage - backed by a ``GeoPackageFeatureTable``. This uses a feature layer to render
///   the tables in a GeoPackage (.gpkg). A GeoPackage is a data source that conforms to the
///   [OGC GeoPackage specification](https://www.ogc.org/standards/geopackage).
///   Geopackage feature tables can be edited and saved, but do not support sync, because there
///   is no backing feature service. This API supports GeoPackage versions 1.0, 1.1, and
///   1.2.
/// * Web Feature Service (WFS) - backed by a ``WFSFeatureTable``. You can populate the table using
///   ``QueryParameters`` or raw XML-encoded GetFeature queries. A WFS feature table only supports the manual
///   cache feature request mode. This API supports [OGC WFS](https://www.ogc.org/standards/wfs)
///   versions 2.0.0 and 2.0.2. WFS server implementations are inconsistent in how they expect coordinates to be
///   formatted. Some return and expect coordinates in (x,y) order, while others expect (y,x). This API anticipates the order but you can configure it with the ``WFSFeatureTable/axisOrder`` and
///   ``WFSFeatureTable/filterAxisOrder``.
/// * OGC API Features - Backed by an ``OGCFeatureCollectionTable``. You can populate the table using
///   ``QueryParameters``. An OCG feature collection table only supports the manual cache feature request mode.
///   This API supports [OGC API - Features - Part 1](https://docs.opengeospatial.org/is/17-069r3/17-069r3.html)
///   and [OGC API - Features - Part 2](https://docs.opengeospatial.org/is/18-058/18-058.html).
///
/// The features displayed in a ``FeatureLayer`` are automatically projected to match the map or scene's
/// ``GeoModel/spatialReference``, if necessary. Local tables cannot be projected automatically.
///
/// ``FeatureLayer`` does not expose every value defined in the web map or web scene specification.
/// You can obtain a dictionary of unsupported values from `FeatureLayer.unsupportedJSON`. The
/// ``FeatureLayer`` also provides `FeatureLayer.unknownJSON` to return JSON that is not recognized in
/// the web map or web scene specification.
///
/// Performance characteristics
///
/// The feature layer offers excellent display performance when zooming and panning the map within the extent of
/// locally cached features. This is because features are drawn natively and full feature information is cached
/// locally in a geodatabase, shapefile, or GeoPackage. Querying features is also efficient, enabling app functions
/// such as real-time updates of query results in a map.
///
/// Initially, a local cache must be created. The initial download to the device may require extensive network
/// usage and subsequent local device storage. App memory usage increases with the number and complexity of the
/// features cached. You can eliminate the network usage by provisioning the cache directly to the device in
/// advance.
///
/// If the feature layer's ``FeatureTable`` is backed by a service it has three feature request modes
/// (``FeatureRequestMode``) that control how and when features are requested from the service:
/// * On interaction cache - Features are requested automatically for the visible map or scene
///   extent. As the user pans and zooms, features are cached locally. If the user returns to
///   an area where features have already been loaded, the table won't need to download those
///   features again.
/// * Manual cache - Features are manually populated using a call to
///   `ServiceFeatureTable.populateFromService(using:clearCache:outFields:)`.
///   Once populated, all queries are made against the local table only.
///   `ServiceFeatureTable.populateFromService(using:clearCache:outFields:)`
///   can be called again to retrieve more features from the service.
/// * On interaction, no cache - Features are requested automatically for the visible map
///   extent. As the user pans and zooms, features outside the visible extent are not cached
///   and must be downloaded again each time.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
public class FeatureLayer : ArcGIS.Layer, ArcGIS.FloorAware, ArcGIS.PopupSource, ArcGIS.TimeAware {

    /// Rendering modes available for feature layers.
    ///
    /// Represents the rendering mode for a feature layer.
    public enum RenderingMode {

        /// The rendering mode for the layer will be automatically chosen based on the geometry type and renderer.
        case automatic

        /// Static rendering mode. Only update features between zoom and pan operations in a retained mode.
        /// This mode is good for complex geometries or features to be rendered with cartographic quality symbology for example.
        /// It may also be suited for rendering features when low end graphics hardware is used.
        case `static`

        /// Dynamic rendering mode - Features will be updated as pan and zoom operations for a smoothly rendered display.
        /// This mode is not supported by all renderers. A heat map renderer is an example of a renderer not supported by the dynamic rendering mode.
        /// Unknown.
        case dynamic

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.FeatureLayer.RenderingMode, b: ArcGIS.FeatureLayer.RenderingMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Describes how to combine a feature selection request with the current selected features list.
    /// - Note: See Also: ``FeatureLayer``
    public enum SelectionMode {

        /// Appends the features to be selected with the current list of selected features.
        case add

        /// Replaces the current list of selected features with the features to be selected.
        case new

        /// Removes the features from the current list of selected features.
        case subtract

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.FeatureLayer.SelectionMode, b: ArcGIS.FeatureLayer.SelectionMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new feature layer object from a feature service portal item.
    ///
    /// The feature layer will fail to load if an invalid portal item is passed in.
    /// - Parameters:
    ///   - featureServiceItem: A feature service ``PortalItem``. The item's type must be ``PortalItem/Kind-swift.enum/featureService``.
    ///   - layerID: The layer id of an individual layer in the ArcGIS feature service represented by the item parameter.
    /// - Note: See Also: ``Layer/item``
    public convenience init(featureServiceItem: ArcGIS.Item, layerID: Int)

    /// Creates a new feature layer from a given ``FeatureTable``.
    ///
    /// Any of the inherited ``FeatureTable`` types can be used as the input parameter for this
    /// constructor except ``FeatureCollectionTable``.
    /// - Parameter featureTable: The feature table used as the data source of the feature layer.
    /// - Precondition: `!(featureTable is FeatureCollectionTable)`
    public convenience init(featureTable: ArcGIS.FeatureTable)

    /// Creates a new feature layer object from a feature layer or feature service portal item.
    ///
    /// If the portal item is a feature service, the ``FeatureLayer`` will be created from the first
    /// layer on the service.
    /// - Parameter item: A feature layer or feature service ``PortalItem``.
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// A SQL expression which limits the features available for query and display on the feature layer.
    ///
    /// The definition expression string should follow standard SQL syntax as detailed in the
    /// [SQL reference for query expressions used in ArcGIS](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm) document.
    public var definitionExpression: String

    /// Defines how features are filtered from the display.
    ///
    /// Use this property to reduce the number of features displayed in the map or scene view.
    /// The filter aims to improve data visualization and optimize rendering performance. It
    /// only affects the display of features so all features are still available for query methods such as
    /// `FeatureLayer.selectFeatures(using:mode:)`: Future<FeatureQueryResult>.
    /// - Note: See Also: ``ManualDisplayFilterDefinition``, ``ScaleDisplayFilterDefinition``
    public var displayFilterDefinition: ArcGIS.DisplayFilterDefinition?

    /// The feature table whose features are drawn on the map by this layer.
    public var featureTable: ArcGIS.FeatureTable? { get }

    /// The collection of ``LabelDefinition`` objects that define how labels are displayed.
    public var labelDefinitions: [ArcGIS.LabelDefinition] { get }

    /// Adds a sequence of `LabelDefinition` values to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinitions: The new `LabelDefinition` values to append.
    public func addLabelDefinitions<S>(_ newLabelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Adds a `LabelDefinition` value to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinition: The new `LabelDefinition` value to append.
    public func addLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition)

    /// Inserts a collection of `LabelDefinition` values into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinitions: The new `LabelDefinition` values to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` values.
    public func insertLabelDefinitions<C>(_ newLabelDefinitions: C, at index: Int) where C : Collection, C.Element == ArcGIS.LabelDefinition

    /// Inserts a `LabelDefinition` value into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinition: The new `LabelDefinition` value to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` value.
    public func insertLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition, at index: Int)

    /// Removes all values from the `labelDefinitions` property.
    public func removeAllLabelDefinitions()

    /// Removes a sequence of `LabelDefinition` values from the `labelDefinitions` property.
    /// - Parameter labelDefinitions: The `LabelDefinition` values to remove.
    public func removeLabelDefinitions<S>(_ labelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Removes a `LabelDefinition` value from the `labelDefinitions` property.
    /// - Parameter labelDefinition: The `LabelDefinition` value to remove.
    public func removeLabelDefinition(_ labelDefinition: ArcGIS.LabelDefinition)

    /// `true` if features in the layer are labelled, otherwise `false`.
    public var labelsAreEnabled: Bool

    /// The renderer specifies how the features are symbolized.
    public var renderer: ArcGIS.Renderer?

    /// The mode defines how the feature layer is rendered.
    ///
    /// ``RenderingMode-swift.enum/static`` mode is better suited for displaying large datasets (in terms of the
    /// number of vertices) and for complex symbology because it does not update the layer's display while
    /// pan/zoom operations are in progress.
    ///
    /// ``RenderingMode-swift.enum/dynamic`` mode is better suited for small datasets that update frequently
    /// or for better interactive experiences when the layer's display is updated continuously while pan/zoom
    /// operations are in progress.
    public var renderingMode: ArcGIS.FeatureLayer.RenderingMode

    /// `true` if the layer's symbols and labels honor the map's reference scale, otherwise `false`.
    ///
    /// If the map has a positive reference scale, and the layer honors it, then symbols and labels are drawn at
    /// their specified size when the viewing scale is the same as the reference scale. They will grow or shrink
    /// as the view zooms in or out, to keep the symbol a fixed size on the map.
    /// If the map has no reference scale, the reference scale is zero, or this feature layer's scaleSymbols
    /// property is `false`, then the symbols and labels will be drawn at their fixed screen size.
    public var scalesSymbols: Bool

    /// Properties that are applied when the layer is rendered in a 3D scene using a `SceneView` object.
    public var sceneProperties: ArcGIS.LayerSceneProperties

    /// Returns a collection of the currently selected features.
    public var selectedFeatures: ArcGIS.FeatureQueryResult { get async throws }

    /// The mode defines whether feature tiling is used to retrieve the features from the feature service.
    ///
    /// The default tiling mode is ``FeatureTilingMode/enabledWhenSupported``.
    /// - Note: See Also: ``FeatureTilingMode``
    public var tilingMode: ArcGIS.FeatureTilingMode

    /// Clears all selected features.
    public func clearSelection()

    /// Reset the visibility of all features back to their original state.
    public func resetFeaturesVisible()

    /// Reset the renderer back to the original renderer provided by the ``FeatureTable``.
    public func resetRenderer()

    /// Selects the given feature and adds it to the current collection of selected features.
    ///
    /// Selected features are rendered according to the `GeoView.selectionProperties`.
    /// - Parameter feature: The feature.
    public func selectFeature(_ feature: ArcGIS.Feature)

    /// Selects the given features and adds them to the current collection of selected features.
    ///
    /// Use the `FeatureLayer.selectedFeatures`: Future<FeatureQueryResult> to retrieve all of the selected features.
    /// - Parameter features: A collection of features to be selected. Contents of the `Array` are copied.
    public func selectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Selects the features that match the criteria in the ``QueryParameters`` object and adds them to the current collection of selected features.
    /// - Parameters:
    ///   - parameters: A query that defines features to select from the ``FeatureTable``.
    ///   - mode: Defines how the collection of currently selected features will be updated with the features returned from the query.
    /// - Returns: A ``FeatureQueryResult``.
    @discardableResult
    public func selectFeatures(using parameters: ArcGIS.QueryParameters, mode: ArcGIS.FeatureLayer.SelectionMode) async throws -> ArcGIS.FeatureQueryResult

    /// Sets the visibility of the given features.
    /// - Parameters:
    ///   - visible: `true` to show the features, otherwise `false`.
    ///   - features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    public func setVisible<S>(_ visible: Bool, for features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Sets the visibility of the given feature.
    /// - Parameters:
    ///   - visible: `true` to show the features, otherwise `false`.
    ///   - feature: The feature.
    public func setVisible(_ visible: Bool, for feature: ArcGIS.Feature)

    /// Unselects the given feature and removes it from the current collection of selected features.
    /// - Parameter feature: The feature.
    public func unselectFeature(_ feature: ArcGIS.Feature)

    /// Unselects the given features and removes them from the current collection of selected features.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    public func unselectFeatures<S>(_ features: S) where S : Sequence, S.Element == ArcGIS.Feature

    /// Defines the properties that allow a layer to be floor-aware.
    ///
    /// When a layer is configured as floor-aware, it has a ``floorDefinition`` property that defines
    /// properties that allow a layer to be floor-aware. When it is `nil` (default value) the specific layer
    /// does not support floor filtering.
    public var floorDefinition: ArcGIS.LayerFloorDefinition?

    /// The pop-up definition.
    ///
    /// The ``PopupDefinition`` associated with the popup source.
    public var popupDefinition: ArcGIS.PopupDefinition?

    /// A flag indicating whether the ``PopupDefinition`` defined on the ``PopupSource`` is enable / disable.
    public var popupsAreEnabled: Bool

    /// The full time extent of the object.
    @ArcGIS.Streamed public var fullTimeExtent: ArcGIS.TimeExtent? { get }

    public var $fullTimeExtent: AsyncStream<ArcGIS.TimeExtent?> { get }

    /// A flag indicating whether the object supports filtering its contents by time values with the extent set on the owning `GeoView`.
    public var supportsTimeFiltering: Bool { get }

    /// A flag indicating whether the object must use the time extent defined on the owning `GeoView` to filter its data.
    public var timeFilteringIsEnabled: Bool

    /// The suggested time slider step size for this time aware object.
    ///
    /// Can be `nil` if no time interval is suggested for this time aware object.
    public var timeInterval: ArcGIS.TimeValue? { get }

    /// The time offset applied to this object.
    /// The offset is subtracted from the time extent set on the owning `GeoView`.
    /// This allows for data from different periods of time to be compared.
    public var timeOffset: ArcGIS.TimeValue?
}

extension FeatureLayer {

    /// Unknown data from the source JSON.
    /// - Remark: Unknown JSON is a dictionary of values that was in the source JSON but was unparsed by this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    public var _unknownJSON: [String : Any] { get }

    /// Unsupported data from the source JSON.
    /// - Remark: Unsupported JSON is a dictionary of values that are supported by webmaps, but not exposed by this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    public var _unsupportedJSON: [String : Any] { get }
}

extension FeatureLayer.RenderingMode : Equatable {
}

extension FeatureLayer.RenderingMode : Hashable {
}

extension FeatureLayer.SelectionMode : Equatable {
}

extension FeatureLayer.SelectionMode : Hashable {
}

/// An object that represents the results of a feature query.
/// - Since: 200.1
final public class FeatureQueryResult : ArcGIS.FeatureSet {

    /// `true` if the query resulted in a larger number of features than what the transfer limit supports.
    final public var transferLimitWasExceeded: Bool { get }

    /// The fields of the feature set.
    /// - Note: See Also: `Array`, ``Field``
    final public var fields: [ArcGIS.Field] { get }

    /// The geometry type stored in this feature set.
    final public var geometryType: ArcGIS.Geometry.Type? { get }

    /// The spatial reference of the feature set.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// Returns the feature iterator.
    /// - Returns: An `AnySequence` that returns ``Feature`` types.
    final public func features() -> AnySequence<ArcGIS.Feature>
}

/// The feature request mode for a service feature table. It determines (1) whether features are cached locally (for quicker access by map and scene layers) and (2) whether queries are performed on the local cache or on the server.
/// - Since: 200.1
public enum FeatureRequestMode : CaseIterable {

    /// Indicates the feature table has not been loaded and the mode has yet to be set.
    case undefined

    /// The features are requested from the server as they are needed, in response to user or developer interaction with the layer (pan, zoom). Features are cached in the local table for the duration of the session. Queries are executed on the local cache or (if requested features are not resident in the cache) on the server. This mode is the default.
    ///
    /// In this mode, features have a minimum set of attributes, and feature geometries have no m-values even if m-values are defined by the service. This is an optimization for faster rendering. To access all attributes or access geometries that contain m-values, the features you get from a query must be loaded. You can load them yourself or request that the query method return them already loaded (see ``ServiceFeatureTable/QueryFeatureFields/loadAll``). For more information, see the class description for ``ServiceFeatureTable``.
    case onInteractionCache

    /// The features are always requested from the server and are never cached. This mode ensures that you are working against the latest data, but it has a high network bandwidth since it goes to the server for all interactions (pans, zooms, selects, or queries).
    ///
    /// In this mode, features have a minimum set of attributes, and feature geometries have no m-values even if m-values are defined by the service. This is an optimization for faster rendering. To access all attributes or access geometries that contain m-values, the features you get from a query must be loaded. You can load them yourself or request that the query method return them already loaded (see ``ServiceFeatureTable/QueryFeatureFields/loadAll``). For more information, see the class description for ``ServiceFeatureTable``.
    case onInteractionNoCache

    /// The features are requested from the server by an explicit call to `ServiceFeatureTable.populateFromService(using:clearCache:outFields:)`, which populates the local cache.  Queries performed on the table will be executed locally.
    ///
    /// In this mode, the features have all fields defined by the `Array` of `String` you pass to `ServiceFeatureTable.populateFromService(using:clearCache:outFields:)`.
    case manualCache

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.FeatureRequestMode, b: ArcGIS.FeatureRequestMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [ArcGIS.FeatureRequestMode]

    /// A collection of all values of this type.
    public static var allCases: [ArcGIS.FeatureRequestMode] { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension FeatureRequestMode : Equatable {
}

extension FeatureRequestMode : Hashable {
}

/// An instance that identifies the various capabilities of an ArcGIS Feature Service.
/// - Since: 200.1
@frozen public struct FeatureServiceCapabilities : OptionSet, Hashable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: Int

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: Int)

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = ArcGIS.FeatureServiceCapabilities

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = ArcGIS.FeatureServiceCapabilities

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int
}

extension FeatureServiceCapabilities {

    /// Indicates that the service supports creation of features.
    public static let create: ArcGIS.FeatureServiceCapabilities

    /// Indicates that the service supports deletion of features.
    public static let delete: ArcGIS.FeatureServiceCapabilities

    /// Indicates that the service allows features to be edited.
    public static let edit: ArcGIS.FeatureServiceCapabilities

    /// Indicates that the service supports querying of features.
    public static let query: ArcGIS.FeatureServiceCapabilities

    /// Indicates that the service supports synchronization.
    public static let sync: ArcGIS.FeatureServiceCapabilities

    /// Indicates that the service supports updating features.
    public static let update: ArcGIS.FeatureServiceCapabilities
}

extension FeatureServiceCapabilities : Sendable {
}

/// An object that represents the metadata for a Feature service layer.
///
/// You will get this object from ``ArcGISFeatureServiceInfo/layerInfos``.
/// - Note: See Also: ``ArcGISFeatureServiceInfo/layerInfos``
/// - Since: 200.1
final public class FeatureServiceLayerIDInfo : ArcGIS.IDInfo {

    /// The type of geometry that all the features in the layer possess.
    ///
    /// For point, multipoint, polyline or polygon feature layers, this will be the type of the feature's geometry.
    /// For annotation and dimension feature layers, this will be `Polygon.Type`
    /// (referring to the outline of the text graphic).
    /// For tables, this will be `nil`.
    final public var geometryType: ArcGIS.Geometry.Type? { get }

    /// Whether the features in the layer should be visible when loaded.
    final public var isVisibleByDefault: Bool { get }

    /// The maximum scale at which the layer's contents will be visible. If `nil`, there is no maximum.
    ///
    /// The layer is only visible when you are zoomed further out than the maxScale.
    final public var maxScale: Double? { get }

    /// The minimum scale at which the layer's contents will be visible. If `nil`, there is no minimum.
    ///
    /// The layer is only visible when you are zoomed further in than the minScale. However, zero indicates that there is no minScale restriction.
    final public var minScale: Double? { get }

    /// The type of data held in the layer on the service.
    ///
    /// Indicates the type of data contained in the layer,
    /// e.g., table row, geometric feature, annotation or dimension feature.
    final public var serviceType: ArcGIS.ArcGISFeatureLayerInfoServiceType? { get }
}

/// An enumeration of the session types that control how multiple users access branch versioned data.
///
/// Session typestransient and persistentlet you control how multiple viewers and editors access branch versioned
/// feature services. By default, a web map or web scene with branch versioned feature services
/// (a ``ServiceGeodatabase`` version) loads as a ``transient`` type; you can change this
/// type to ``persistent`` at the map or scene level when you load the map or scene.
///
/// When you switch the ``ServiceGeodatabase`` version being used via
/// `ServiceGeodatabase.switchToVersion(named:)`, a read operation is started on the new version before
/// releasing the previous version. If acquiring a shared lock on the new version fails (for example, if another
/// user is editing the version), an error is raised. This behavior allows you to keep the user connected to the
/// original version when the version they want is not yet available.
///
/// For descriptions of additional ways to manage multiple viewers and editors in branch versioned data, such as
/// using multiple tiers of editors, see the ArcGIS Pro discussion on
/// [branch version scenarios](https://pro.arcgis.com/en/pro-app/latest/help/data/geodatabases/overview/branch-version-scenarios.htm).
/// - Note: See Also: ``ServiceGeodatabase/sessionType``, ``LoadSettings/featureServiceSessionType``
/// - Since: 200.1
public enum FeatureServiceSessionType {

    /// A momentary session is used during queries and edit operations.
    ///
    /// This is the default session type. The server creates an exclusive lock upon an editor's
    /// `ServiceGeodatabase.applyEdits()` operation and holds the lock only for the duration that
    /// it takes that operation to occur. An exclusive lock prevents readers and editors from accessing
    /// (connecting to and viewing) the rows affected by the edit in the ``ServiceGeodatabase`` version
    /// during this time, but they can access (connect to, view, query, and edit) other rows in the
    /// ``ServiceGeodatabase`` version. Use the transient type when concurrency is more important than
    /// data consistency between queries or between concurrent users.
    case transient

    /// A session is held open as long as tables are actively reading or writing.
    ///
    /// * With a Read operation
    /// When a user starts a read operation, a shared lock is placed on the ``ServiceGeodatabase`` version
    /// at the beginning of the read operation. A shared lock allows multiple users using read operations
    /// to access the service feature table at the same time. The shared lock is kept until
    /// `ServiceGeodatabase.close()` or `ServiceGeodatabase.switchToVersion(named:)` methods
    /// are called. If the ``ServiceFeatureTable`` is in ``FeatureRequestMode/manualCache``, you can call `ServiceFeatureTable.clearCache(keepingLocalEdits:)` to end a read session.
    ///
    /// * With an Edit operation
    /// When a user starts an edit operation in the list below, an exclusive lock is placed on the affected
    /// ``ServiceFeatureTable`` at the beginning of the edit operation. An exclusive lock prevents all other
    /// users from connecting to the version. They cannot view, query, or edit that version.
    ///
    /// The lock is held until one of the following methods is called:
    /// * `ServiceFeatureTable.undoLocalEdits()`
    /// * `ServiceGeodatabase.undoLocalEdits()`
    /// * `ServiceFeatureTable.applyEdits()`
    /// * `ServiceGeodatabase.applyEdits()`
    ///
    /// If one or more read operations were already being performed on the ``ServiceFeatureTable`` when an
    /// edit operation began (if a shared lock was already in place), then the shared lock becomes an exclusive
    /// lock. When all edit operations are applied successfully, the exclusive lock returns to being a shared lock.
    ///
    /// A call to `ServiceGeodatabase.close()` will release an exclusive lock.
    ///
    /// Note that if the ``ServiceGeodatabase`` version requested is the default version, no exclusive lock will be acquired.
    ///
    /// Edit operations that trigger the locks described above:
    /// * `FeatureTable.add(_:)`
    /// * `FeatureTable.add(_:)`
    /// * `FeatureTable.delete(_:)`
    /// * `FeatureTable.delete(_:)`
    /// * `FeatureTable.update(_:)`
    /// * `FeatureTable.update(_:)`
    /// * `ArcGISFeature.addAttachment(named:contentType:data:)`
    /// * `ArcGISFeature.updateAttachment(_:name:contentType:data:)`
    /// * `ArcGISFeature.deleteAttachment(_:)`
    /// * `ArcGISFeature.deleteAttachments(_:)`
    case persistent

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.FeatureServiceSessionType, b: ArcGIS.FeatureServiceSessionType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension FeatureServiceSessionType : Equatable {
}

extension FeatureServiceSessionType : Hashable {
}

/// An interface for feature sets.
///
/// This interface encapsulates some common read-only operations that could be applied to various sets of features.
/// - Since: 200.1
public protocol FeatureSet {

    /// The fields of the feature set.
    /// - Note: See Also: `Array`, ``Field``
    var fields: [ArcGIS.Field] { get }

    /// The geometry type stored in this feature set.
    var geometryType: ArcGIS.Geometry.Type? { get }

    /// The spatial reference of the feature set.
    var spatialReference: ArcGIS.SpatialReference? { get }

    /// Returns the feature iterator.
    /// - Returns: An `AnySequence` that returns ``Feature`` types.
    func features() -> AnySequence<ArcGIS.Feature>
}

/// An object that provides a feature subtype.
/// - Since: 200.1
final public class FeatureSubtype {

    /// The feature subtype's code.
    final public var code: Any? { get }

    /// The domains associated with this feature subtype.
    final public var domains: [String : ArcGIS.Domain] { get }

    /// The fields defined for this feature subtype.
    ///
    /// A subset of ``FeatureTable/fields`` relevant to this feature subtype. This collection of ``Field`` may override properties
    /// defined in the ``FeatureTable/fields``. For example, ``Field/alias`` and ``Field/domain``.
    final public var fieldOverrides: [ArcGIS.Field] { get }

    /// The name of the feature subtype.
    final public var name: String { get }

    /// The prototype attributes associated with this feature subtype.
    final public var prototypeAttributes: [String : Any] { get }
}

/// A table of features that typically represents real-world objects such as fire hydrants, roads, and forests.
///
/// This is the base class for a number of different feature tables, such as ``ServiceFeatureTable``,
/// ``FeatureCollectionTable``, and ``GeoPackageFeatureTable``. You can create instances of these subclasses using
/// their constructors.
///
/// If the ``hasGeometry`` is `true`, you can display the features in a ``Map`` or ``Scene``. To do
/// this create a ``FeatureLayer`` from the feature table and add it to the ``Map`` or ``Scene`` collection of
/// operational layers (``GeoModel/operationalLayers``). The ``FeatureTable`` can also contain features that do
/// not have a geometry (``hasGeometry`` is `false`).
///
/// ``FeatureTable`` provides methods for spatial and attribute querying (for example,
/// `FeatureTable.queryFeatures(using:)`), and methods to add, update, and delete features (such
/// as `FeatureTable.add(_:)`, `FeatureTable.update(_:)`, and
/// `FeatureTable.delete(_:)`).
/// - Since: 200.1
public class FeatureTable : ArcGIS.Loadable, ArcGIS.PopupSource {

    /// Determines whether you can add a feature to a table.
    public var canAddFeature: Bool { get }

    /// Determines whether you can edit the geometry field in a table.
    public var canEditGeometry: Bool { get }

    /// A user-friendly name that can be displayed in the UI (for example, in a Table of Contents).
    ///
    /// If the table is displayed with a ``FeatureLayer``, the ``displayName`` is used as the
    /// ``Layer/name``.
    ///
    /// The default value is ``tableName``.
    public var displayName: String

    /// The geographic extent of features within the table.
    ///
    /// This is calculated differently for specific types and modes of feature tables:
    ///
    /// * ``ServiceFeatureTable``. If the feature request mode is ``FeatureRequestMode/manualCache`` the service
    /// feature table will return the extent of the features which have been cached. All other modes will return
    /// the extent of the layer/table defined by the service (from ``ArcGISFeatureLayerInfo/extent``). This can be
    /// used to determine the extent within which data can be edited.
    ///
    /// * ``GeodatabaseFeatureTable``. This returns the extent of the features which have been cached. This extent
    /// can grow as features are added or edited, but not shrink.
    public var extent: ArcGIS.Envelope? { get }

    /// The collection of ``Field`` objects representing the fields of the feature table.
    /// - Note: See Also: `Array`, ``Field``
    public var fields: [ArcGIS.Field] { get }

    /// The type of geometry of the features stored in this table.
    ///
    /// If ``hasGeometry`` is `false`, then the geometry type is `nil`.
    public var geometryType: ArcGIS.Geometry.Type? { get }

    /// `true` if the feature table supports geographic features, `false` otherwise.
    public var hasGeometry: Bool { get }

    /// `true` if the feature table supports geometries with M values, `false` otherwise.
    public var hasM: Bool { get }

    /// `true` if the feature table supports geometries with Z values, `false` otherwise.
    public var hasZ: Bool { get }

    /// `true` if this feature table is editable, `false` otherwise.
    ///
    /// Underlying file permissions (for subclasses such as ``ShapefileFeatureTable`` and
    /// ``GeodatabaseFeatureTable``) can be changed while the feature table is open. In these cases the value of
    /// this property may not be accurate.
    /// - Note: See Also: ``ArcGISFeatureTable``
    public var isEditable: Bool { get }

    /// The layer that displays this table, if any.
    ///
    /// The ``Layer`` type depends on how the feature table is created. For example, a ``Layer`` will be an
    /// ``AnnotationLayer`` if the ``FeatureTable`` is created from a table that supports annotation. See
    /// ``Layer`` for more information about the supported layer types.
    ///
    /// The layer will be `nil` if the feature table does not contain spatial features (where
    /// ``hasGeometry`` is `false`).
    weak public var layer: ArcGIS.Layer? { get }

    /// The number of features in the table.
    ///
    /// If all the features are stored in the local table, for example with a ``GeodatabaseFeatureTable`` or a
    /// ``ShapefileFeatureTable``, then the ``numberOfFeatures`` will return the full number of
    /// features.
    ///
    /// If the table is created from a service, for example, ``ServiceFeatureTable`` or ``WFSFeatureTable``, the
    /// ``numberOfFeatures`` will only return the number of features in the local table cache.
    /// You need to populate the local table cache to return a value for ``numberOfFeatures``.
    /// Do this by rendering the features in a ``Map`` or ``Scene`` with a ``FeatureLayer``, or by querying the
    /// feature table. Consider the feature table's ``FeatureRequestMode`` in both cases. See ``ServiceFeatureTable``
    /// or ``WFSFeatureTable`` for more information. If you want to return the full number of features in
    /// the service, execute `FeatureTable.queryFeatureCount(using:)` and pass "1=1" to the
    /// ``QueryParameters/whereClause``.
    public var numberOfFeatures: Int { get }

    /// The spatial reference of the table.
    ///
    /// A spatial reference defines how the coordinates of a feature's ``Geometry`` correspond to locations
    /// in the real world. For more information see the ``SpatialReference`` class or the
    /// [Spatial references](https://developers.arcgis.com/documentation/spatial-references/) documentation.
    public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The name of the table in the source dataset.
    public var tableName: String { get }

    /// Determines whether you can delete a feature from a table.
    /// - Parameter feature: The feature.
    /// - Returns: `true` if the feature can be deleted, `false` if the feature can't be deleted or an error occurred.
    public func canDelete(_ feature: ArcGIS.Feature) -> Bool

    /// Determines whether you can update a feature in a table.
    /// - Parameter feature: The feature.
    /// - Returns: `true` if the feature can be updated, `false` if the feature can't be updated or an error occurred.
    public func canUpdate(_ feature: ArcGIS.Feature) -> Bool

    /// Deletes a feature from the table.
    ///
    /// Deleting a feature from a ``GeodatabaseFeatureTable`` in a stand-alone mobile geodatabase created with ArcGIS Pro
    /// is not supported when the table participates in a controller dataset, such as a utility network or parcel fabric.
    /// Use `FeatureTable.canDelete(_:)` to determine if this operation is allowed.
    /// - Parameter feature: The feature.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func delete(_ feature: ArcGIS.Feature) async throws

    /// Deletes a collection of features from the table.
    /// - Parameter features: An `Array` of ``Feature``. Contents of the `Array` are copied.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func delete<S>(_ features: S) async throws where S : Sequence, S.Element == ArcGIS.Feature

    /// Retrieves the field with the given name.
    /// - Parameter fieldName: Name of the field.
    /// - Returns: A ``Field``.
    public func field(named fieldName: String) -> ArcGIS.Field?

    /// Creates a new feature with the provided attribute values and, optionally, geometry.
    ///
    /// The new feature is only available in memory at this point. Execute `FeatureTable.add(_:)`
    /// to commit the new ``Feature`` to the table.
    /// - Parameters:
    ///   - attributes: The attributes.
    ///   - geometry: The geometry.
    /// - Returns: A ``Feature``.
    /// - Precondition: `loadStatus == .loaded`
    public func makeFeature(attributes: [String : Any] = [:], geometry: ArcGIS.Geometry? = nil) -> ArcGIS.Feature

    /// Determines the minimum bounding envelope that contains features satisfying the provided query parameters.
    ///
    /// If no features meet the query criteria, an empty envelope is returned.
    /// - Parameter parameters: The parameters of the query.
    /// - Returns: A task that represents the asynchronous query of feature extent. The value of the task
    /// result contains an ``Envelope`` object.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func queryExtent(using parameters: ArcGIS.QueryParameters) async throws -> ArcGIS.Envelope

    /// Determines the count of features that satisfy the provided query parameters.
    /// - Parameter parameters: The parameters of the query.
    /// - Returns: The number of features that satisfy the query parameters.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func queryFeatureCount(using parameters: ArcGIS.QueryParameters) async throws -> Int

    /// Submits a query against the table.
    /// - Parameter parameters: Options for controlling the operation.
    /// - Returns: A ``FeatureQueryResult`` type.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func queryFeatures(using parameters: ArcGIS.QueryParameters) async throws -> ArcGIS.FeatureQueryResult

    /// Calculates values for the requested statistics.
    ///
    /// Statistics query parameters may also define fields on which results are grouped or sorted.
    /// - Parameter parameters: The parameters that define the statistics, fields, and features to be used for the query.
    /// - Returns: A task that represents the asynchronous query statistics operation. The value of the task
    /// result contains a ``StatisticsQueryResult`` object.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func queryStatistics(using parameters: ArcGIS.StatisticsQueryParameters) async throws -> ArcGIS.StatisticsQueryResult

    /// The pop-up definition.
    ///
    /// The ``PopupDefinition`` associated with the popup source.
    public var popupDefinition: ArcGIS.PopupDefinition?

    /// A flag indicating whether the ``PopupDefinition`` defined on the ``PopupSource`` is enable / disable.
    public var popupsAreEnabled: Bool

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

extension FeatureTable {

    /// Adds a feature to the table.
    /// - Remark: Adding a feature that contains a ``Geometry`` causes the geometry to become simplified. This may change a
    /// single part geometry to a multipart geometry, or round off X, Y, Z, and M coordinate values that are above
    /// the resolution set by the ``SpatialReference``.
    /// - Parameter feature: The feature being added to the table.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func add(_ feature: ArcGIS.Feature) async throws

    /// Adds a sequence of features to the table.
    /// - Parameter features: A sequence of features. The contents of the sequence are copied.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func add<S>(_ features: S) async throws where S : Sequence, S.Element == ArcGIS.Feature

    /// Updates a feature in the table.
    /// - Remark: If you update a feature that contains a ``Geometry``, the geometry becomes simplified. This may change a
    /// single part geometry to a multipart geometry, or round X, Y, Z, and M coordinate values that are above
    /// the resolution set by the ``SpatialReference``.
    /// - Parameter feature: The feature being updated in the table.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func update(_ feature: ArcGIS.Feature) async throws

    /// Updates a sequence of features in the table.
    /// - Parameter features: A sequence of features. The contents of the sequence are copied.
    /// - Note: See Also: ``FeatureServiceSessionType``
    public func update<S>(_ features: S) async throws where S : Sequence, S.Element == ArcGIS.Feature
}

/// The edit results of a specific ``FeatureTable``.
/// - Note: See Also: `ServiceGeodatabase.applyEdits()`
/// - Since: 200.1
final public class FeatureTableEditResult {

    /// The collection of edit results for the layer.
    final public var editResults: [ArcGIS.FeatureEditResult] { get }

    /// The feature table that was edited.
    final public var featureTable: ArcGIS.FeatureTable { get }
}

/// A dictionary key that wraps a feature table.
/// - Since: 200.1
public struct FeatureTableKey {

    /// The wrapped feature table.
    public let featureTable: ArcGIS.FeatureTable

    /// Creates a feature table key.
    /// - Parameter featureTable: The feature table to wrap as the dictionary key.
    public init(_ featureTable: ArcGIS.FeatureTable)
}

extension FeatureTableKey : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.FeatureTableKey, rhs: ArcGIS.FeatureTableKey) -> Bool
}

extension FeatureTableKey : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// An object that provides a template for creating a new feature.
/// - Since: 200.1
final public class FeatureTemplate {

    /// An enumeration of available drawing tools.
    public enum DrawingTool {

        /// Auto complete polygon.
        case autoCompletePolygon

        /// A circle.
        case circle

        /// A down arrow.
        case downArrow

        /// An ellipse.
        case ellipse

        /// A free hand.
        case freeHand

        /// A left arrow.
        case leftArrow

        /// A line.
        case line

        /// None.
        case noTool

        /// A point.
        case point

        /// A polygon.
        case polygon

        /// A rectangle.
        case rectangle

        /// A right arrow.
        case rightArrow

        /// A text.
        case text

        /// A triangle.
        case triangle

        /// An up arrow.
        case upArrow

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.FeatureTemplate.DrawingTool, b: ArcGIS.FeatureTemplate.DrawingTool) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The description of the feature template.
    final public var description: String { get }

    /// The feature template's drawing tool type.
    final public var drawingTool: ArcGIS.FeatureTemplate.DrawingTool? { get }

    /// The name of the feature template.
    final public var name: String { get }
}

extension FeatureTemplate {

    /// The prototype for creating a feature.
    final public var prototypeAttributes: [String : Any] { get }
}

extension FeatureTemplate.DrawingTool : Equatable {
}

extension FeatureTemplate.DrawingTool : Hashable {
}

/// Feature tiling modes available to feature layers. This determines how feature tiling is handled for each layer.
/// Using the default mode is highly recommended. As of now, only services based on service feature tables support feature tiling.
/// - Since: 200.1
public enum FeatureTilingMode {

    /// Use feature tiling whenever a service supports it. Feature tiling retrieves more features per layer from a service by making multiple, smaller requests to said service.
    /// Since each request gathers a portion of the total features, this allows more features to be rendered in the extent than what the maxRecordCount would normally allow.
    ///
    /// When in this mode, all rendering requests to services will use feature tiling unless the following applies: ``FeatureRequestMode`` is ``FeatureRequestMode/manualCache``,
    /// the service does not support coordinate quantization, or if the service does not support tile result types. This is the default mode.
    case enabledWhenSupported

    /// Feature tiling is disabled.
    ///
    /// When in this mode, feature tiling will not be used even if a service supports it. This reduces the number of requests sent by each layer.
    /// Disabling feature tiling results in less features returned from a service.
    case disabled

    /// Use feature tiling and request full resolution geometries when supported by the service. If the latter is not supported, ``enabledWhenSupported`` is used instead.
    ///
    /// This mode requires the service to support the edit quantization mode, which returns all vertices of the source geometry in a high resolution.
    /// Use this mode for workflows that benefit from precise geometry editing, such as snapping feature geometries, without loading the feature.
    /// This mode may impact performance due to the increase in network traffic.
    case enabledWithFullResolutionWhenSupported

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.FeatureTilingMode, b: ArcGIS.FeatureTilingMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension FeatureTilingMode : Equatable {
}

extension FeatureTilingMode : Hashable {
}

/// An object that defines a feature type.
/// - Since: 200.1
final public class FeatureType {

    /// The domains associated with this feature type.
    final public var domains: [String : ArcGIS.Domain] { get }

    /// The id of the feature type.
    final public var id: Any { get }

    /// The name of the feature type.
    final public var name: String { get }

    /// The feature templates associated with this feature type.
    final public var templates: [ArcGIS.FeatureTemplate] { get }
}

/// The spatial relationship that determines when a fence has been entered or exited.
///
/// When determining whether a feed entity has entered or exited a fence polygon, there are two
/// spatial operations that can be used:
///
/// * Intersects: the feed geometry must intersect the fence polygon.
/// * Contains: the feed geometry must be contained by the fence polygon.
///
/// These operations determine whether a fence polygon has been entered, and also when it has been exited (the feed
/// geometry no longer intersects or is no longer contained by the fence polygon). Because the contains condition is
/// more strict than intersects (a geometry can intersect another geometry without being contained by it) it tends
/// to result in fewer notifications when the two geometries are nearby. By using different combinations of these
/// rules for enter and exit, you can control the likelihood that notifications will be sent.
///
/// Note that when the feed geometry is a ``Point``, there is no difference between intersection and containment, so
/// both options behave the same. When using a ``LocationGeotriggerFeed``, set ``FenceGeotrigger/feedAccuracyMode-swift.property``
/// to ``FenceGeotrigger/FeedAccuracyMode-swift.enum/useGeometryWithAccuracy`` in order to create a polygon geometry that
/// accounts for the area of uncertainty around a ``Location/position``.
/// - Since: 200.1
public enum FenceEnterExitSpatialRelationship {

    /// The fence polygon is entered when it intersects a ``GeotriggerFeed`` entity and exited when it no longer intersects.
    ///
    /// This option tends to increase the number of notifications as an entity approaches a fence polygon. Use this
    /// option when you want to receive all possible notifications - for example, when you want to be warned that
    /// you are approaching a hazard.
    ///
    /// This option has no effect unless the feed entity geometry is a ``Polygon``. Set
    /// ``FenceGeotrigger/feedAccuracyMode-swift.property`` to ``FenceGeotrigger/FeedAccuracyMode-swift.enum/useGeometryWithAccuracy`` to
    /// create a polygon geometry that accounts for the area of uncertainty around a ``Location/position``.
    case enterIntersectsAndExitDoesNotIntersect

    /// The fence polygon is entered when it contains the entity from a ``GeotriggerFeed`` and exited when the entity is no longer contained.
    ///
    /// This option limits notifications to when the entity is fully within the fence polygon. Use this option to be
    /// certain you are within a given fence - for example when carrying out work within a specific land parcel.
    ///
    /// This option has no effect unless the feed entity geometry is a ``Polygon``. Set
    /// ``FenceGeotrigger/feedAccuracyMode-swift.property`` to
    /// ``FenceGeotrigger/FeedAccuracyMode-swift.enum/useGeometryWithAccuracy`` to create a polygon
    /// geometry that accounts for the area of uncertainty around a ``Location/position``.
    case enterContainsAndExitDoesNotContain

    /// The fence polygon is entered when it contains a ``GeotriggerFeed`` entity and exited when it no longer intersects.
    ///
    /// This option tends to minimize the number of notifications. The entity must be fully within the fence polygon
    /// to enter and must be fully outside to exit. This combination reduces the number of spurious notifications
    /// that occur as you move around the border of a fence. Use this option when you want to limit notifications -
    /// for example, when driving past properties on your way to a delivery address.
    ///
    /// This option has no effect unless the feed entity geometry is a ``Polygon``. Set
    /// ``FenceGeotrigger/feedAccuracyMode-swift.property`` to
    /// ``FenceGeotrigger/FeedAccuracyMode-swift.enum/useGeometryWithAccuracy`` in order to create a polygon
    /// geometry that accounts for the area of uncertainty around a ``Location/position``.
    case enterContainsAndExitDoesNotIntersect

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.FenceEnterExitSpatialRelationship, b: ArcGIS.FenceEnterExitSpatialRelationship) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension FenceEnterExitSpatialRelationship : Equatable {
}

extension FenceEnterExitSpatialRelationship : Hashable {
}

/// A ``Geotrigger`` that defines regions or fences to be monitored using a ``GeotriggerMonitor``.
///
/// You can monitor areas of interest with a ``FenceGeotrigger``, using spatial rules like enter
/// or exit. This type of operation is also known as "Geofencing".
///
/// Three main components comprise a ``FenceGeotrigger``:
/// * The ``GeotriggerFeed`` that is monitored for changes - usually the device location read
///   from a ``LocationDataSource``.
/// * The ``RuleType-swift.enum`` that describes the check that is performed with the feed and
///   fence data - for example, "enters within 50 meters of".
/// * The ``FenceParameters`` that the feed data are evaluated against. For example, a set
///   of polygon features representing areas of interest. The ``FenceParameters`` can cover
///   many features or graphics that are checked.
///
/// A ``FenceGeotrigger`` can also take into account floors within buildings. If the feature
/// table used to create the ``FeatureFenceParameters`` is referenced by a ``FeatureLayer`` that
/// is ``FloorAware``, and the ``LocationDataSource`` used to create the ``GeotriggerFeed``
/// includes ``Location/SourcePropertyKey/floor`` information, then fences will only be
/// entered when they are intersected by a ``Location`` on the correct floor. If the fence or
/// location data does not include valid floor information, the floor is ignored and the fence
/// is entered when it is intersected by the location.
///
/// A floor aware feature layer or table must be part of a ``GeoModel`` that includes a valid
/// ``GeoModelFloorDefinition``. All layers and tables that are used by the floor definition
/// are loaded when the ``GeotriggerMonitor`` is started.
///
/// A ``Location`` can contain floor property as part of
/// ``Location/additionalSourceProperties``. This is populated automatically by
/// ``IndoorsLocationDataSource``, or can be supplied as part of your own implementation.
/// - Since: 200.1
final public class FenceGeotrigger : ArcGIS.Geotrigger {

    /// Options that describe how a ``FenceGeotrigger`` uses accuracy information from a ``GeotriggerFeed``.
    ///
    /// This enumeration defines options for using accuracy information from a ``GeotriggerFeed`` to provide the
    /// ``Geometry`` for checking a ``Geotrigger`` condition. In particular, you can choose how to use the
    /// ``Location/horizontalAccuracy`` property to reflect the uncertainty around a fixed ``Location/position``. Due to
    /// various factors, GPS positions may be inaccurate, with ``Location/horizontalAccuracy`` representing a radius
    /// that defines the area containing the actual location. Spurious notifications may occur when the
    /// ``Location/position`` is inaccurate and is incorrectly reported as inside or outside of a fence. You can use the
    /// ``Location/horizontalAccuracy`` to account for that uncertainty.
    ///
    /// These values are used in conjunction with ``FenceGeotrigger/enterExitSpatialRelationship`` to affect
    /// when notifications are sent.
    public enum FeedAccuracyMode {

        /// The reported ``Geometry`` from a ``GeotriggerFeed`` is used.
        ///
        /// For a ``LocationGeotriggerFeed`` the point geometry from the ``Location/position``
        /// property is used.
        case useGeometry

        /// The reported ``Geometry`` from a ``GeotriggerFeed`` is used in conjunction with accuracy information.
        ///
        /// For a ``LocationGeotriggerFeed`` the point geometry from the ``Location/position``
        /// property is buffered by the ``Location/horizontalAccuracy`` to produce a
        /// polygon geometry.
        case useGeometryWithAccuracy

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.FenceGeotrigger.FeedAccuracyMode, b: ArcGIS.FenceGeotrigger.FeedAccuracyMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The rule or query that determines whether a ``FenceGeotrigger`` condition is met.
    public enum RuleType {

        /// Check whether objects from the ``GeotriggerFeed`` enter the ``FenceParameters``.
        case enter

        /// Check whether objects from the ``GeotriggerFeed`` exit the ``FenceParameters``.
        case exit

        /// Check whether objects from the ``GeotriggerFeed`` enter or exit the ``FenceParameters``.
        case enterOrExit

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.FenceGeotrigger.RuleType, b: ArcGIS.FenceGeotrigger.RuleType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Constructs ``FenceGeotrigger`` with an expression and a name.
    /// - Parameters:
    ///   - feed: The ``GeotriggerFeed`` that is monitored for changes.
    ///   - ruleType: The ``RuleType-swift.enum`` that describes the check that will be performed upon the feed data.
    ///   - fenceParameters: The ``FenceParameters`` that will be evaluated.
    ///   - messageExpression: The ``ArcadeExpression`` that will be evaluated to create a ``GeotriggerNotificationInfo/message``.
    ///   - name: The name for the ``FenceGeotrigger``.
    public convenience init(feed: ArcGIS.GeotriggerFeed, ruleType: ArcGIS.FenceGeotrigger.RuleType, fenceParameters: ArcGIS.FenceParameters, messageExpression: ArcGIS.ArcadeExpression? = nil, name: String = "")

    /// The spatial relationship that determines whether a fence polygon has been entered or exited.
    ///
    /// There are two spatial operations you can use to determine whether a feed entity has entered
    /// or exited a fence polygon.
    ///
    /// * Intersects: the feed geometry must intersect the fence polygon.
    /// * Contains: the feed geometry must be contained by the fence polygon.
    ///
    /// These operations determine whether a fence polygon has been entered, and also when it has been exited (the
    /// feed geometry no longer intersects or is no longer contained by the fence polygon). Because the contains
    /// condition is more strict that intersects (a geometry can intersect another geometry without being contained
    /// by it) it tends to result in fewer notifications when the two geometries are nearby. By using different
    /// combinations of these rules for enter and exit, you can control the likelihood that notifications will be
    /// sent.
    ///
    /// Note that when the feed geometry is a ``Point``, there is no difference between intersection and containment,
    /// so both options behave the same. When using a ``LocationGeotriggerFeed``, set
    /// ``feedAccuracyMode-swift.property`` to ``FeedAccuracyMode-swift.enum/useGeometryWithAccuracy`` in order
    /// to create a polygon geometry that accounts for the area of uncertainty around a ``Location/position``.
    ///
    /// The default value is ``FenceEnterExitSpatialRelationship/enterIntersectsAndExitDoesNotIntersect``.
    final public var enterExitSpatialRelationship: ArcGIS.FenceEnterExitSpatialRelationship

    /// Describes how a ``FenceGeotrigger`` uses accuracy information from a ``GeotriggerFeed``.
    ///
    /// This property controls how the accuracy information from a ``GeotriggerFeed`` is used to provide the
    /// ``Geometry`` for checking a ``Geotrigger`` condition. In particular, you can choose how to use the
    /// ``Location/horizontalAccuracy`` property to reflect the uncertainty around a fixed ``Location/position``.
    /// Due to various factors, GPS positions may be inaccurate, with ``Location/horizontalAccuracy`` representing a
    /// radius that defines the area containing the actual location. Spurious notifications may occur when the
    /// ``Location/position`` is inaccurate and is incorrectly reported as inside or outside of a fence. You can use
    /// the ``Location/horizontalAccuracy`` to account for that uncertainty.
    ///
    /// This property is used in conjunction with ``enterExitSpatialRelationship`` to affect
    /// when notifications are sent.
    ///
    /// The default value is ``FeedAccuracyMode-swift.enum/useGeometry``.
    ///
    /// Note that you can also use an ``ArcadeExpression`` with the
    /// ``LocationGeotriggerFeed/filter`` property to reject ``Location`` objects with a poor
    /// accuracy.
    final public var feedAccuracyMode: ArcGIS.FenceGeotrigger.FeedAccuracyMode

    /// The ``FenceParameters`` that will be evaluated.
    ///
    /// For example, a set of polygon features representing areas of interest. The
    /// ``FenceParameters`` can cover many features or graphics that will be checked.
    ///
    /// There are three types of ``FenceParameters``:
    /// * A ``FeatureFenceParameters`` that is constructed from a ``FeatureTable``.
    /// * A ``GraphicFenceParameters`` that is constructed from a list of ``Graphic`` objects.
    /// * A ``GraphicsOverlayFenceParameters`` that is constructed from a ``GraphicsOverlay``.
    final public var fenceParameters: ArcGIS.FenceParameters { get }

    /// The ``RuleType-swift.enum`` that describes the check performed with the feed and fence data.
    ///
    /// The rule controls the spatial query that will be used - for example "enter" or "exit".
    final public var ruleType: ArcGIS.FenceGeotrigger.RuleType
}

extension FenceGeotrigger.FeedAccuracyMode : Equatable {
}

extension FenceGeotrigger.FeedAccuracyMode : Hashable {
}

extension FenceGeotrigger.RuleType : Equatable {
}

extension FenceGeotrigger.RuleType : Hashable {
}

/// A ``GeotriggerNotificationInfo`` from a ``FenceGeotrigger``.
/// - Since: 200.1
final public class FenceGeotriggerNotificationInfo : ArcGIS.GeotriggerNotificationInfo {

    /// The type of ``FenceGeotrigger`` that was met.
    public enum NotificationType {

        /// The feed data has entered one of the fence geometries.
        case entered

        /// The feed data has exited one of the fence geometries.
        case exited

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.FenceGeotriggerNotificationInfo.NotificationType, b: ArcGIS.FenceGeotriggerNotificationInfo.NotificationType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The ``GeoElement`` from the fence data that meets the ``FenceGeotrigger`` condition.
    ///
    /// The ``GeoElement`` is one of the features or graphics from the ``FenceParameters`` used to create the
    /// ``FenceGeotrigger``. Inspect the ``GeoElement/attributes`` and ``GeoElement/geometry`` properties for more
    /// details.
    final public var fenceGeoElement: ArcGIS.GeoElement { get }

    /// The ``Geometry`` used for the fence that satisfies the ``FenceGeotrigger`` condition.
    ///
    /// The original geometry of the ``fenceGeoElement``, including
    /// any adjustments (such as applying buffers) and projected to WGS84. You can compare this with the
    /// ``Location/position`` of the corresponding ``GeotriggerNotificationInfo/feedLocation``.
    final public var fenceGeometry: ArcGIS.Geometry { get }

    /// A unique ID for the fence that triggered the notification info.
    ///
    /// This property will be consistent for all notifications for a given fence. For example,
    /// use this ID to group enter and exit events for a specific fence to display the current
    /// occupancy.
    ///
    /// You can combine this property with the ``GeotriggerNotificationInfo/feedEntityID`` to
    /// create an ID that groups all notifications for a given feed element and a specific
    /// fence. For example, use a concatenation of the two properties to display a list of areas
    /// of interest that are currently occupied and the details of who has entered them.
    ///
    /// To group events by the geotrigger, use the `Geotrigger.id`
    /// property.
    /// - Note: See Also: ``GeotriggerNotificationInfo/feedEntityID``, `Geotrigger.id`
    final public var fenceID: String { get }

    /// The type of rule that caused this ``FenceGeotriggerNotificationInfo``.
    final public var fenceNotificationType: ArcGIS.FenceGeotriggerNotificationInfo.NotificationType { get }
}

extension FenceGeotriggerNotificationInfo.NotificationType : Equatable {
}

extension FenceGeotriggerNotificationInfo.NotificationType : Hashable {
}

/// Geotrigger fence data required for a ``FenceGeotrigger``.
///
/// The ``FenceParameters`` defines all of the target geometries of a ``FenceGeotrigger``.
/// Typically, it is made up of many polygons that objects from the ``GeotriggerFeed`` can enter
/// or exit. However, if you set a ``bufferDistance``, point and line geometry
/// can also be used. For example, if the condition is "notify me when my position comes within
/// 50 meters of one of my target areas", the fence data would be "my target areas".
///
/// Fence data can be created as one of:
/// * ``FeatureFenceParameters``
/// * ``GraphicFenceParameters``
/// * ``GraphicsOverlayFenceParameters``
/// - Since: 200.1
public class FenceParameters {

    /// A buffer distance in meters to apply when checking if a ``FenceGeotrigger`` condition is met.
    ///
    /// For example, if the rule is "enters within 50 meters" you use a
    /// ``FenceGeotrigger/ruleType-swift.property`` of ``FenceGeotrigger/RuleType-swift.enum/enter`` and set this property to 50.
    ///
    /// Buffers are Geodetic and created using the following default values:
    /// * ``GeometryEngine/GeodeticCurveType/shapePreserving``
    /// * Max deviation = `nan`
    /// * ``LinearUnit/ID/meters``
    ///
    /// If your fences use point or polyline ``Geometry`` then you must set this property to a
    /// value greater than 0.
    public var bufferDistance: Double { get }
}

extension FenceParameters {

    /// Static factory function to create a ``FenceParameters`` object with a ``Graphic``.
    ///
    /// This method creates the appropriate type of ``FenceParameters`` based on the
    /// provided ``Graphic``.
    ///
    /// - Parameters:
    ///   - graphic: The ``Graphic`` used to create a ``FenceParameters`` object.
    ///   - bufferDistance: A buffer distance in meters to apply to the ``Graphic`` when checking if a ``Geotrigger`` condition is met.
    /// - Returns: A ``FenceParameters`` created from a ``Graphic``.
    public class func fromGraphic(_ graphic: ArcGIS.Graphic, bufferDistance: Double) -> ArcGIS.FenceParameters

    /// Static factory function to create a ``FenceParameters`` object with a ``Feature``.
    ///
    /// This method creates the appropriate type of ``FenceParameters`` based on the
    /// provided ``Feature``.
    ///
    /// - Parameters:
    ///   - feature: The ``Feature`` used to create a ``FenceParameters`` object.
    ///   - bufferDistance: A buffer distance in meters to apply to the ``Feature`` when checking if a ``Geotrigger`` condition is met.
    /// - Returns: A ``FenceParameters`` created from a ``Feature``.
    public class func fromFeature(_ feature: ArcGIS.Feature, bufferDistance: Double) -> ArcGIS.FenceParameters
}

/// An object that defines a field.
/// - Since: 200.1
final public class Field {

    /// Creates a new field object with the following parameters.
    /// - Parameters:
    ///   - type: Defines the type of field.
    ///   - name: Name of the field.
    ///   - alias: Alias of the field.
    ///   - length: Length of the field.
    ///   - domain: Domain for the field. Can be `nil`.
    ///   - isEditable: `true` if the field is editable.
    ///   - isNullable: `true` if the field is nullable.
    public convenience init(type: ArcGIS.FieldType, name: String, alias: String, length: Int = .zero, domain: ArcGIS.Domain? = nil, isEditable: Bool = true, isNullable: Bool = true)

    /// The field's alias.
    final public var alias: String { get }

    /// The field's domain.
    final public var domain: ArcGIS.Domain? { get }

    /// The field as not being editable.
    final public var isEditable: Bool { get }

    /// `true` if the field is nullable.
    final public var isNullable: Bool { get }

    /// The length of the field.
    final public var length: Int { get }

    /// The field's name.
    final public var name: String { get }

    /// The field's data type.
    /// - Warning: Shapefile fields of type date do not store a time.
    final public var type: ArcGIS.FieldType? { get }

    /// Populates the data members of this object from a JSON string.
    /// - Parameter json: The JSON string.
    /// - Returns: A ``Field``.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Serializes this object to a JSON string.
    /// - Returns: A `String`.
    final public func toJSON() -> String
}

/// An object that describes a ``Field`` to be created.
///
/// Creation of fields and tables is currently only supported on mobile geodatabases,
/// either created in ArcGIS Pro or via `Geodatabase.createEmpty(fileURL:)`.
/// - Since: 200.1
final public class FieldDescription {

    /// Creates a new field description object with the specified name and type.
    /// - Parameters:
    ///   - name: The field's name.
    ///   - fieldType: The field's data type.
    public convenience init(name: String, fieldType: ArcGIS.FieldType)

    /// The field's alias.
    ///
    /// The default value is an empty string.
    final public var alias: String

    /// The name of the domain to use on this field.
    ///
    /// The domain must already exist in the geodatabase (see `Geodatabase.makeDomain(description:)`).
    /// The default value of an empty string indicates that no domain should be used.
    final public var domainName: String

    /// The field's data type.
    final public var fieldType: ArcGIS.FieldType

    /// `true` if the field is editable.
    ///
    /// The default value is `true`.
    final public var isEditable: Bool

    /// `true` if the field is nullable.
    ///
    /// The default value is `true`.
    final public var isNullable: Bool

    /// The length of the field.
    ///
    /// The default value is 0. This only applies to text fields.
    final public var length: Int

    /// The field's name.
    ///
    /// Field names must be non-empty, consist only of alphanumeric characters and underscores,
    /// and cannot start with a number or an underscore.
    final public var name: String
}

/// An object that defines a field group.
/// - Since: 200.1
final public class FieldGroup {

    /// A collection of contingencies that define possible values for fields in this field group.
    ///
    /// It is possible for a field group to contain no contingencies (either because none were authored,
    /// or existing ones were deleted). In this scenario, the field group will offer no suggested values,
    /// and will not result in any violations.
    final public var contingencies: [ArcGIS.Contingency] { get }

    /// A boolean indicating whether fields in this field group are restricted to this field group's contingent values.
    final public var editingIsRestrictive: Bool { get }

    /// The collection of names of fields that participate in this field group.
    final public var fields: [String] { get }

    /// The name that uniquely identifies this field group.
    final public var name: String { get }
}

/// The different types of a row value variant.
/// - Since: 200.1
public enum FieldType {

    /// A 16-bit integer value.
    case int16

    /// A 32-bit integer value.
    case int32

    /// A 64-bit integer value.
    case int64

    /// A GUID value.
    case guid

    /// A float value.
    case float32

    /// A double value.
    case float64

    /// A date time value.
    /// - Warning: Shapefile formats do not store the time component.
    case date

    /// A string value.
    case text

    /// An object id value.
    case oid

    /// A global id value.
    case globalID

    /// A blob value.
    case blob

    /// A geometry value.
    case geometry

    /// A raster value.
    case raster

    /// An xml value.
    case xml

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.FieldType, b: ArcGIS.FieldType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension FieldType : Equatable {
}

extension FieldType : Hashable {
}

/// Represents a pop-up element of type fields that is displayed in a pop-up for a geoelement.
/// - Note: See Also: `PopupElement.Type`, ``PopupElement``
/// - Since: 200.1
final public class FieldsPopupElement : ArcGIS.PopupElement {

    /// Creates a new fields pop-up element with the given `Array` of ``PopupField``.
    /// - Parameter fields: An `Array` of ``PopupField`` objects defining how each field participates in the pop-up window.
    public convenience init(fields: [ArcGIS.PopupField] = [])

    /// A string value describing the element in detail. Can be an empty string.
    final public var description: String

    /// An `Array` of ``PopupField`` objects defining how each field participates in the pop-up window.
    final public var fields: [ArcGIS.PopupField] { get }

    /// Adds a sequence of `PopupField` values to the end of the `fields` property.
    /// - Parameter newFields: The new `PopupField` values to append.
    final public func addFields<S>(_ newFields: S) where S : Sequence, S.Element == ArcGIS.PopupField

    /// Adds a `PopupField` value to the end of the `fields` property.
    /// - Parameter newField: The new `PopupField` value to append.
    final public func addField(_ newField: ArcGIS.PopupField)

    /// Inserts a collection of `PopupField` values into the `fields` property at the specified position.
    /// - Parameters:
    ///   - newFields: The new `PopupField` values to insert.
    ///   - index: The position at which to insert the new `PopupField` values.
    final public func insertFields<C>(_ newFields: C, at index: Int) where C : Collection, C.Element == ArcGIS.PopupField

    /// Inserts a `PopupField` value into the `fields` property at the specified position.
    /// - Parameters:
    ///   - newField: The new `PopupField` value to insert.
    ///   - index: The position at which to insert the new `PopupField` value.
    final public func insertField(_ newField: ArcGIS.PopupField, at index: Int)

    /// Removes all values from the `fields` property.
    final public func removeAllFields()

    /// Removes a sequence of `PopupField` values from the `fields` property.
    /// - Parameter fields: The `PopupField` values to remove.
    final public func removeFields<S>(_ fields: S) where S : Sequence, S.Element == ArcGIS.PopupField

    /// Removes a `PopupField` value from the `fields` property.
    /// - Parameter field: The `PopupField` value to remove.
    final public func removeField(_ field: ArcGIS.PopupField)

    /// The formatted values for the fields defined in ``fields``.
    /// This property is populated when `Popup.evaluateExpressions()` is called.
    ///
    /// Dates and times are returned in the local timezone.
    ///
    /// If a field is part of a ``CodedValueDomain``, the ``CodedValue/name`` is returned.
    ///
    /// If ``PopupElement/isEvaluated`` is `false`, this property will return an empty collection.
    final public var formattedValues: [String] { get }

    /// The user-friendly display names for the fields defined in ``fields``.
    /// This property is populated when `Popup.evaluateExpressions()` is called.
    ///
    /// If ``PopupElement/isEvaluated`` is `false`, this property will return an empty collection.
    final public var labels: [String] { get }

    /// A string value indicating what the element represents. Can be an empty string.
    final public var title: String
}

/// An error denoting a file was not found.
/// - Since: 200.1
public struct FileNotFoundError : Error {

    /// The error details.
    public let details: String
}

extension FileNotFoundError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.FileNotFoundError, b: ArcGIS.FileNotFoundError) -> Bool
}

/// A base class for fill symbols. You would typically work with one or more sub-classes of this class.
///
/// Fill symbols are used with graphics which are based on a polygon geometry.
///
/// The fill symbol class is derived from the symbol class.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
public class FillSymbol : ArcGIS.Symbol {

    /// The color for the fill symbol.
    public var color: UIColor

    /// The outline of the fill symbol.
    public var outline: ArcGIS.LineSymbol?
}

/// A base class for fill symbol layers.
///
/// Fill symbol layers are components of symbols that cover areal geometries. They are most
/// often used in polygon symbols.
///
/// The following types of fill symbol layers are supported:
/// * ``SolidFillSymbolLayer`` fills polygonal geometry with a single solid color (that may
///   have a level of transparency applied)
/// * ``PictureFillSymbolLayer`` uses an image file (specified using a URI or image) to define
///   the fill
/// * ``HatchFillSymbolLayer`` defines a pattern of uniform parallel lines
/// - Since: 200.1
public class FillSymbolLayer : ArcGIS.SymbolLayer {
}

/// An interface that can be implemented by layers that support floor filtering.
///
/// The ``FloorAware`` interface is implemented by floor-aware layers such as ``FeatureLayer``. A floor-aware layer
/// is a layer that contains indoor GIS data representing features that can be located on a specific floor
/// of a building. When a layer is floor-aware, data can be filtered based on one or more floors.
/// - Since: 200.1
public protocol FloorAware {

    /// Defines the properties that allow a layer to be floor-aware.
    ///
    /// When a layer is configured as floor-aware, it has a ``floorDefinition`` property that defines
    /// properties that allow a layer to be floor-aware. When it is `nil` (default value) the specific layer
    /// does not support floor filtering.
    var floorDefinition: ArcGIS.LayerFloorDefinition? { get set }
}

/// A facility that contains one or more levels for a floor-aware map or scene.
///
/// A ``FloorFacility`` represents any structure, such as an office or campus building, retail setting,
/// or industrial structure. Facilities have one or more ``FloorLevel`` and are optionally contained within a ``FloorSite``.
/// You can get the facilities from the ``FloorManager`` associated with a floor-aware map or scene.
/// - Note: See Also: ``FloorManager/facilities``
/// - Since: 200.1
final public class FloorFacility : Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public struct ID : CustomStringConvertible, Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        public init?(_ rawValue: String)

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The facility geometry.
    final public var geometry: ArcGIS.Geometry? { get }

    /// The facility ID.
    final public var id: ArcGIS.FloorFacility.ID { get }

    /// The facility levels, sorted in ascending vertical order.
    final public var levels: [ArcGIS.FloorLevel] { get }

    /// The facility name.
    final public var name: String { get }

    /// The site the facility belongs to (optional).
    weak final public var site: ArcGIS.FloorSite? { get }
}

/// A floor level within a facility for a floor-aware map or scene.
///
/// A floor level describes the footprint of each occupiable floor contained in a ``FloorFacility``.
/// You can get the floor levels from the ``FloorManager`` associated with a floor-aware map or scene.
/// - Note: See Also: ``FloorManager/levels``
/// - Since: 200.1
final public class FloorLevel : Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public struct ID : CustomStringConvertible, Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        public init?(_ rawValue: String)

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The facility that contains the floor level.
    ///
    /// This property will be `nil` for orphan levels (those not contained in a facility).
    weak final public var facility: ArcGIS.FloorFacility? { get }

    /// The level geometry.
    final public var geometry: ArcGIS.Geometry? { get }

    /// The level ID.
    final public var id: ArcGIS.FloorLevel.ID { get }

    /// The level's visibility
    ///
    /// The level visibility, `true` if the level is visible; `false` otherwise.
    /// The default value is `true` in 3D and for the ground floor in 2D.
    final public var isVisible: Bool

    /// The level floor number in the facility.
    final public var levelNumber: Int { get }

    /// The level long name.
    final public var longName: String { get }

    /// The level short name.
    final public var shortName: String { get }

    /// The vertical order within the collection of levels for the facility.
    ///
    /// The default value is 0, which represents the ground floor.
    final public var verticalOrder: Int { get }
}

/// Manages the data displayed by a floor-aware map or scene, allowing filtering based on floor levels.
///
/// A ``FloorManager`` must be loaded before you can access its site, facility, and level properties.
/// When a map's floor manager is loaded, floor-aware layers display only data associated with the ground floor by default.
/// When a scene's floor manager is loaded, floor-aware layers display data from all floors by default.
/// You can filter the data displayed by floor-aware layers by toggling the ``FloorLevel/isVisible`` property of levels in the floor manager.
/// The ``FloorManager`` will fail to load if:
/// * The map/scene associated with the floor manager is not floor-aware.
/// * The mandatory facility or level layer doesn't exist.
/// * It is unable to get the facilities or levels from their respective layers.
/// * It is unable to get the sites from a specified site layer.
/// - Note: See Also: ``Map``
/// - Since: 200.1
final public class FloorManager : ArcGIS.Loadable {

    /// The facilities in the floor-aware map or scene. These are obtained from ``facilityLayer``
    ///
    /// This property is initialized after the ``FloorManager`` is loaded.
    final public var facilities: [ArcGIS.FloorFacility] { get }

    /// The layer containing features that represent facilities.
    ///
    /// This property is initialized after the ``FloorManager`` is loaded.
    final public var facilityLayer: ArcGIS.Layer? { get }

    /// The layer containing features that represent floor levels.
    ///
    /// This property is initialized after the ``FloorManager`` is loaded.
    final public var levelLayer: ArcGIS.Layer? { get }

    /// The floor levels in the floor-aware map or scene. These are obtained from ``levelLayer``
    ///
    /// This property is initialized after the ``FloorManager`` is loaded.
    final public var levels: [ArcGIS.FloorLevel] { get }

    /// The layer containing features that represent sites.
    ///
    /// This property is initialized after the ``FloorManager`` is loaded.
    final public var siteLayer: ArcGIS.Layer? { get }

    /// The sites in the floor-aware map or scene. These are obtained from ``siteLayer`` and sorted based on name.
    ///
    /// This property is initialized after the ``FloorManager`` is loaded.
    final public var sites: [ArcGIS.FloorSite] { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A site containing one or more facilities for a floor-aware map or scene.
///
/// A site is the largest space designation in the [ArcGIS Indoors Information Model](https://pro.arcgis.com/en/pro-app/latest/help/data/indoors/arcgis-indoors-information-model.htm) and is used to
/// represent an area such as a campus, a barrack, or an industrial site.
/// A site can contain multiple facilities.
/// You can get the collection of sites from the ``FloorManager`` associated with a floor-aware map or scene.
/// - Note: See Also: ``FloorManager/sites``
/// - Since: 200.1
final public class FloorSite : Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public struct ID : CustomStringConvertible, Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        public init?(_ rawValue: String)

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The collection of facilities contained within the site, sorted by name.
    final public var facilities: [ArcGIS.FloorFacility] { get }

    /// The site geometry.
    final public var geometry: ArcGIS.Geometry? { get }

    /// The site ID.
    final public var id: ArcGIS.FloorSite.ID { get }

    /// The site name.
    final public var name: String { get }
}

/// Adds raster datasets to a ``MosaicDatasetRaster`` by setting various
/// parameters including the use of frame and camera text files.
///
/// Mosaic datasets (via the ``MosaicDatasetRaster`` class) are used to manage,
/// display, serve, and share raster data. When you create a new mosaic dataset,
/// it is created as an empty container in a geodatabase to which you can add
/// raster data. The FrameCameraAddRastersParameters object provides the
/// mechanism to set various properties including the use of camera and frame text
/// files so that a raster can be added to a mosaic dataset via the
/// `MosaicDatasetRaster.addRasters(using:)` method.
///
/// Some of the parameters (aka. properties) on ``FrameCameraAddRastersParameters``
/// class that enable adding a raster into a mosaic dataset include specifying, the
/// file filter type (like .tif or .jpg) of the rasters that are to be included
/// (``AddRastersParameters/filter`` property), the directory location
/// (``AddRastersParameters/inputDirectoryURL`` property) of the raster files,
/// the minimum pixel cell size of the raster to be included
/// (``AddRastersParameters/minPixelSizeFactor`` property) and more.
///
/// Unique attributes of using the FrameCameraAddRastersParameters class rather
/// than the parent ``AddRastersParameters`` class have to do with defining
/// 'frame' and 'camera' text files which specify how a raster image was captured
/// from a satellite or aircraft. The frame and camera table files refers to a
/// single perspective imaging camera with an optical lens that can be modeled as a
/// pinhole. To define the frame table use the
/// ``framesFileURL`` property, see the ArcGIS Pro
/// document entitled 'Frames table schema'
/// (https://pro.arcgis.com/en/pro-app/help/data/imagery/frames-table-schema.htm)
/// for more information. To define the camera table use the
/// ``camerasFileURL`` property, see the ArcGIS Pro
/// document entitled 'Cameras table schema'
/// (https://pro.arcgis.com/en/pro-app/help/data/imagery/cameras-table-schema.htm)
/// for more information.
/// - Since: 200.1
final public class FrameCameraAddRastersParameters : ArcGIS.AddRastersParameters {

    /// Creates a frame camera add rasters parameters object.
    ///
    /// Creates a frame camera add rasters parameters object to be used for adding rasters to a mosaic dataset raster.
    public convenience init()

    /// The cameras file.
    ///
    /// This function sets the input cameras file.
    final public var camerasFileURL: URL?

    /// The frames file.
    ///
    /// This function sets the input frames file.
    final public var framesFileURL: URL?

    /// The status of sharing raster info.
    ///
    /// This function sets the status of sharing raster info.
    final public var sharesRasterInfo: Bool
}

/// Allows you to edit geometries in a ``GeometryEditor`` by using freehand gestures.
///
/// This tool is suitable for creating and editing ``Polygon`` and ``Polyline`` geometries. Each drag gesture
/// creates a new part of the ``Multipart`` geometry.
///
/// By default, this tool does not display vertices or mid-vertices.
/// This behavior can be customized with ``GeometryEditorTool/style``.
/// - Note: See Also: ``VertexTool``
/// - Since: 200.1
final public class FreehandTool : ArcGIS.GeometryEditorTool {

    /// Creates a new ``FreehandTool``.
    ///
    /// By default, this tool enables the creation, selection, transformation, and deletion interactions appropriate
    /// for creating and editing geometries using freehand gestures. This behavior can be customized with
    /// ``configuration``.
    public convenience init()

    /// Defines the set of interactive operations enabled when using this tool.
    ///
    /// By default, the ``configuration`` allows creation and selection of parts, transformation, and
    /// deletion operations.
    ///
    /// This tool ignores the ``InteractionConfiguration/allowsVertexCreation`` property.
    final public var configuration: ArcGIS.InteractionConfiguration
}

/// A ``Job`` that requests a feature service to generate a geodatabase file to be downloaded for offline use.
/// - Note: See Also: ``Job``, ``SyncGeodatabaseJob``
/// - Since: 200.1
final public class GenerateGeodatabaseJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.Geodatabase

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.GenerateGeodatabaseJob.Output, Error> { get async }
}

/// An object that represents the parameters to a generate method on a geodatabase sync task.
/// - Since: 200.1
final public class GenerateGeodatabaseParameters {

    /// Create a parameters object for use with the generate method on the geodatabase sync task.
    public convenience init()

    /// Specifies the direction for attachments to be synchronized.
    ///
    /// This parameter is available when the service resource sync capabilities includes supportsAttachmentsSyncDirection.
    /// This parameter defines how attachments will be synced and is only applicable if the feature service has attachments.
    /// ``AttachmentSyncDirection/bidirectional`` - Attachment edits can be both uploaded from the client and downloaded from the service when syncing.
    /// ``AttachmentSyncDirection/upload`` - Attachment edits can only be uploaded from the client when syncing.
    /// This is useful in cases where the data collector does not want to consume space with attachments from the service, but does need to collect new attachments.
    /// ``AttachmentSyncDirection/noSync`` - Attachment edits are never synced from either the client or the server.
    /// When ``returnsAttachments`` is set to `true`, you can set ``attachmentSyncDirection``
    /// to either ``AttachmentSyncDirection/bidirectional`` (default) or ``AttachmentSyncDirection/upload``.
    /// In this case, create replica includes attachments from the service.
    /// When ``returnsAttachments`` is set to `false`,
    /// you can set ``attachmentSyncDirection`` to either ``AttachmentSyncDirection/upload`` or ``AttachmentSyncDirection/noSync`` (default).
    /// In this case, the geodatabase does not include attachments from the service.
    /// Attachment sync direction is set during the `GeodatabaseSyncTask.makeGenerateGeodatabaseJob(parameters:downloadFileURL:)` operation and cannot be overridden
    /// during `GeodatabaseSyncTask.makeSyncGeodatabaseJob(parameters:geodatabase:)`.
    final public var attachmentSyncDirection: ArcGIS.AttachmentSyncDirection

    /// The geometry that is used to intersect the features in the service to replicate into the geodatabase.
    ///
    /// This is typically an envelope, but other geometry types can be used too. An intersects test will be used to determine which features are replicated.
    final public var extent: ArcGIS.Geometry?

    /// The list of layers and tables to include in the geodatabase if the sync model is layer.
    ///
    /// This must be populated with minimum of one valid layer id.
    /// For valid layers and tables see ``ArcGISFeatureServiceInfo/layerInfos`` and ``ArcGISFeatureServiceInfo/tableInfos``.
    /// You can also populate with all layers using `GeodatabaseSyncTask.makeDefaultGenerateGeodatabaseParameters(extent:)`
    final public var layerOptions: [ArcGIS.GenerateLayerOption] { get }

    /// Adds a sequence of `GenerateLayerOption` values to the end of the `layerOptions` property.
    /// - Parameter newLayerOptions: The new `GenerateLayerOption` values to append.
    final public func addLayerOptions<S>(_ newLayerOptions: S) where S : Sequence, S.Element == ArcGIS.GenerateLayerOption

    /// Adds a `GenerateLayerOption` value to the end of the `layerOptions` property.
    /// - Parameter newLayerOption: The new `GenerateLayerOption` value to append.
    final public func addLayerOption(_ newLayerOption: ArcGIS.GenerateLayerOption)

    /// Inserts a collection of `GenerateLayerOption` values into the `layerOptions` property at the specified position.
    /// - Parameters:
    ///   - newLayerOptions: The new `GenerateLayerOption` values to insert.
    ///   - index: The position at which to insert the new `GenerateLayerOption` values.
    final public func insertLayerOptions<C>(_ newLayerOptions: C, at index: Int) where C : Collection, C.Element == ArcGIS.GenerateLayerOption

    /// Inserts a `GenerateLayerOption` value into the `layerOptions` property at the specified position.
    /// - Parameters:
    ///   - newLayerOption: The new `GenerateLayerOption` value to insert.
    ///   - index: The position at which to insert the new `GenerateLayerOption` value.
    final public func insertLayerOption(_ newLayerOption: ArcGIS.GenerateLayerOption, at index: Int)

    /// Removes all values from the `layerOptions` property.
    final public func removeAllLayerOptions()

    /// Removes a sequence of `GenerateLayerOption` values from the `layerOptions` property.
    /// - Parameter layerOptions: The `GenerateLayerOption` values to remove.
    final public func removeLayerOptions<S>(_ layerOptions: S) where S : Sequence, S.Element == ArcGIS.GenerateLayerOption

    /// Removes a `GenerateLayerOption` value from the `layerOptions` property.
    /// - Parameter layerOption: The `GenerateLayerOption` value to remove.
    final public func removeLayerOption(_ layerOption: ArcGIS.GenerateLayerOption)

    /// The spatial reference that is used for the generated geodatabase.
    ///
    /// If this is `nil`, the Extent's spatial reference is used. If that is `nil` the feature services spatial reference is then used.
    final public var outSpatialReference: ArcGIS.SpatialReference?

    /// Indicates if attachments are added to the geodatabase.
    ///
    /// The default value is `false`. This parameter is only applicable if the feature service has attachments.
    final public var returnsAttachments: Bool

    /// The synchronization model that will be used generate a geodatabase.
    ///
    /// The default is sync model is Layer. Check the services supports the required sync model, see ``ArcGISFeatureServiceInfo/syncCapabilities``.
    /// - Note: See Also: ``ArcGISFeatureServiceInfo/syncCapabilities``, ``SyncCapabilities``
    final public var syncModel: ArcGIS.Geodatabase.SyncModel

    /// Specifies whether Annotation data is to be included from the service,
    /// when generating, or downloading to, an offline geodatabase.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// Annotation data can be optionally included when downloading from the service.
    ///
    /// Once this data is taken offline to a local geodatabase,
    /// any subsequent inserts, edits or deletions
    /// will NOT be applied to the server data when re-synchronized.
    /// If features linked to the annotation have been changed,
    /// the server WILL apply the feature-linked-annotation updates.
    /// Another download from the server will replace any
    /// offline inserts, edits or deletions of Annotation features.
    ///
    /// The default value is `true`. Annotation data will be included.
    ///
    /// ``SyncCapabilities/supportsAnnotations`` can be used to check
    /// whether Annotation data is available from the service.
    ///
    /// This property can be used at the same time as specifying
    /// other additional data types to be included.
    final public var syncsAnnotations: Bool

    /// Specifies whether Contingent Value data is to be included from the service,
    /// when generating, or synchronizing with, an offline geodatabase.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// Contingent Value data can be optionally included.
    ///
    /// The default value is `true`. Contingent Value data will be included.
    ///
    /// ``SyncCapabilities/supportsContingentValues`` can be used to check
    /// whether Contingent Value data is available from the service.
    ///
    /// This property can be used at the same time as specifying
    /// other additional data types to be included.
    final public var syncsContingentValues: Bool

    /// Specifies whether Dimension data is to be included from the service,
    /// when generating, or synchronizing with, an offline geodatabase.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// Dimension data can be optionally included.
    ///
    /// The default value is `true`. Dimension data will be included.
    ///
    /// ``SyncCapabilities/supportsDimensions`` can be used to check
    /// whether Dimension data is available from the service.
    ///
    /// This property can be used at the same time as specifying
    /// other additional data types to be included.
    final public var syncsDimensions: Bool

    /// Specifies the generation and synchronization mode of Utility Network data from the service
    /// to an offline geodatabase.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// Utility Network System data can be optionally included.
    ///
    /// When this property is set to something other than ``UtilityNetworkSyncMode/noSync``,
    /// `GeodatabaseSyncTask.makeDefaultGenerateGeodatabaseParameters(extent:)` will include
    /// all the data layers and tables in the feature service in the ``layerOptions``.
    /// Since only the feature layers' schema is required to support querying associations or tracing offline,
    /// their feature data may be filtered out by:
    /// * setting ``GenerateLayerOption/queryOption-swift.property`` to ``GenerateLayerOption/QueryOption-swift.enum/noneOrRelatedOnly``
    /// * specifying a ``GenerateLayerOption/whereClause``
    /// * setting ``GenerateLayerOption/usesGeometry`` to `true`
    /// Excluding data layers or including system layers of the feature service in the
    /// ``layerOptions`` will result in an error in the ``GenerateGeodatabaseJob``.
    ///
    /// Use ``SyncCapabilities`` to check which synchronization mode the feature service supports.
    /// If ``SyncCapabilities/supportsUtilityNetworkSystem`` is `true`, ``UtilityNetworkSyncMode/syncSystemTables``
    /// may be used. If ``SyncCapabilities/supportsUtilityNetworkTopology`` is also `true`,
    /// ``UtilityNetworkSyncMode/syncSystemAndTopologyTables`` may be used.
    ///
    /// Setting this property to something other than ``UtilityNetworkSyncMode/noSync``
    /// allows the ``UtilityNetwork`` query associations offline.
    /// Setting this property to ``SyncCapabilities/supportsUtilityNetworkTopology``
    /// also enables tracing offline. However, ``SyncCapabilities/supportsUtilityNetworkTopology`` does not allow
    /// editing the feature layers, which means ``syncModel`` must be set to ``Geodatabase/SyncModel-swift.enum/disabled``
    /// or such a combination will result in an error in the ``GenerateGeodatabaseJob``.
    ///
    /// <table>
    ///   <tr>
    ///     <th>Utility network sync mode (``UtilityNetworkSyncMode``)</th>
    ///     <th>Required sync capabilities (``SyncCapabilities``)</th>
    ///     <th>Enables utility network capabilities (``UtilityNetworkCapabilities``)</th>
    ///   </tr>
    ///   <tr>
    ///     <td>``UtilityNetworkSyncMode/noSync``</td>
    ///     <td>No sync capability required</td>
    ///     <td>No utility network capability enabled</td>
    ///   </tr>
    ///   <tr>
    ///     <td>``UtilityNetworkSyncMode/syncSystemTables``</td>
    ///     <td>``SyncCapabilities/supportsUtilityNetworkSystem``</td>
    ///     <td>``UtilityNetworkCapabilities/supportsQueryAssociations``</td>
    ///   </tr>
    ///   <tr>
    ///     <td>``UtilityNetworkSyncMode/syncSystemAndTopologyTables``</td>
    ///     <td>``SyncCapabilities/supportsUtilityNetworkSystem``, ``SyncCapabilities/supportsUtilityNetworkTopology``</td>
    ///     <td>``UtilityNetworkCapabilities/supportsQueryAssociations``, ``UtilityNetworkCapabilities/supportsTrace``</td>
    ///   </tr>
    /// </table>
    ///
    /// The default value is ``UtilityNetworkSyncMode/noSync``. Utility Network System data will not be included.
    ///
    /// This property can be used at the same time as specifying
    /// other additional data types to be included.
    final public var utilityNetworkSyncMode: ArcGIS.UtilityNetworkSyncMode

    /// Clones the ``GenerateGeodatabaseParameters``.
    /// - Returns: A new ``GenerateGeodatabaseParameters`` with the same values as the current ``GenerateGeodatabaseParameters``.
    final public func clone() -> Self
}

/// An object that is used in conjunction with ``GenerateGeodatabaseParameters`` to
/// identify what layers or tables to take offline.
///
/// This object allows you to set properties on a layer or table to specify what features to take offline.
/// - Since: 200.1
final public class GenerateLayerOption {

    /// Control which features for a layer or table are copied from the server when creating a geodatabase.
    public enum QueryOption {

        /// All features are copied from the server when creating a geodatabase.
        case all

        /// Combines with ``GenerateLayerOption/includesRelated``, if `false`
        /// then no features are copied from the server.
        /// If ``GenerateLayerOption/includesRelated`` is `true` then only features
        /// that are in a relationship are included.
        /// When used in conjunction with upload-only
        /// synchronization, this enables a faster upload scenario where new
        /// features are only sent to the server and none are downloaded.
        /// - Note: See Also: ``SyncDirection/upload``
        case noneOrRelatedOnly

        /// Combines with ``GenerateLayerOption/whereClause``
        /// and ``GenerateLayerOption/usesGeometry`` properties when
        /// copying features from the server to take offline.
        case useFilter

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GenerateLayerOption.QueryOption, b: ArcGIS.GenerateLayerOption.QueryOption) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new generate layer option instance with a given layer id for use with generate geodatabase on the geodatabase sync task.
    ///
    /// Creates a new instance with the supplied layer ID and the following values:
    /// * ``queryOption-swift.property`` = ``QueryOption-swift.enum/useFilter``
    /// * ``usesGeometry`` = `true`
    /// * ``includesRelated`` = `false`
    /// * ``whereClause`` = ""
    /// - Parameter layerID: A layer id in the service
    public convenience init(layerID: Int = .zero)

    /// Creates a new generate layer option instance for use with generate geodatabase on the geodatabase sync task.
    ///
    /// Creates a new instance with the supplied layer ID and includeRelated value and the
    /// following values:
    /// * ``queryOption-swift.property`` = ``QueryOption-swift.enum/noneOrRelatedOnly``
    /// * ``usesGeometry`` = `true`
    /// * ``whereClause`` = ""
    ///
    /// includeRelated only applies when the queryOption is none.
    /// - Parameters:
    ///   - layerID: A layer id in the service.
    ///   - includesRelated: Indicates if related rows should be included.
    public convenience init(layerID: Int, includesRelated: Bool)

    /// Creates a new generate layer option instance with the supplied layer id and where clause for use with generate geodatabase on the geodatabase sync task.
    ///
    /// Creates a new instance with the supplied layer ID and where clause and the following default values:
    /// - ``queryOption-swift.property`` = ``QueryOption-swift.enum/useFilter``
    /// - ``usesGeometry`` = `true`
    /// - ``includesRelated`` = `false`
    /// - Parameters:
    ///   - layerID: A layer id in the service
    ///   - whereClause: a where clause to apply to the layer.
    public convenience init(layerID: Int, whereClause: String)

    /// Indicates if only related rows are added to the specific ``layerID`` in the generated geodatabase.
    ///
    /// This property is only applicable if your data has relationship classes and when
    /// ``queryOption-swift.property`` is ``QueryOption-swift.enum/noneOrRelatedOnly``.
    ///
    /// Set this to `true` for a layer or table to retrieve only rows or features used in
    /// relationships.
    ///
    /// A typical scenario is a feature layer related to a large table. Setting the tables
    /// includeRelated to `true` you can reduce the offline table size to just rows related to by
    /// features that are part of the offline extent.
    ///
    /// The default value of this property is `false`.
    final public var includesRelated: Bool

    /// The layer or table Id to be included in the service generated geodatabase.
    ///
    /// This defaults to 0.
    final public var layerID: Int

    /// Whether all, filtered or no features will be copied from
    /// the server when creating a geodatabase.
    ///
    /// Determines how other properties of the ``GenerateLayerOption`` are applicable, valid
    /// combinations are:
    /// * ``QueryOption-swift.enum/noneOrRelatedOnly`` to specify no features, or only related features as
    ///   specified by the ``includesRelated`` property. When combined with
    ///   ``SyncDirection/upload`` synchronization this option can be used for an efficient
    ///   upload-only work-flow.
    /// * ``QueryOption-swift.enum/useFilter`` to filter features by geometry or where clause
    ///   or both. The properties ``usesGeometry`` and
    ///   ``whereClause`` are applicable.
    /// * ``QueryOption-swift.enum/all`` all other properties are ignored, all features are
    ///   returned
    ///
    /// The default is ``QueryOption-swift.enum/useFilter``.
    /// - Note: See Also: ``QueryOption-swift.enum``
    final public var queryOption: ArcGIS.GenerateLayerOption.QueryOption

    /// Indicates if ``GenerateGeodatabaseParameters/extent`` is used to filter the features for downloading.
    ///
    /// This property is only applicable if ``queryOption-swift.property`` is
    /// ``QueryOption-swift.enum/useFilter``.
    ///
    /// When this property is `true`, features intersecting
    /// ``GenerateGeodatabaseParameters/extent`` are candidates for taking offline.
    ///
    /// When this property is `false`, all features are candidates.
    ///
    /// If the ``whereClause`` is also set, this further reduces the features.
    ///
    /// For non-spatial tables this property must be set to `false`.
    ///
    /// The default value of this property is `true`.
    final public var usesGeometry: Bool

    /// The where clause of the generate layer option.
    ///
    /// The where clause only applies when ``queryOption-swift.property`` is
    /// ``QueryOption-swift.enum/useFilter``.
    ///
    /// The candidate features from a where clause are also filtered by
    /// ``GenerateGeodatabaseParameters/extent`` if ``usesGeometry`` is `true`.
    final public var whereClause: String

    /// Clones the ``GenerateLayerOption``.
    /// - Returns: A new ``GenerateLayerOption`` with the same values as the current ``GenerateLayerOption``.
    final public func clone() -> Self
}

extension GenerateLayerOption.QueryOption : Equatable {
}

extension GenerateLayerOption.QueryOption : Hashable {
}

/// A Job to generate an offline map from an online map.
/// - Since: 200.1
final public class GenerateOfflineMapJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// The download directory used by this job to write the mobile map package result.
    ///
    /// This property holds the path for the mobile map package which will be generated as a result of running this job.
    ///
    /// As the job also returns a mobile map package, the same path can be used to instantiate the ``MobileMapPackage`` for later use.
    final public var downloadDirectoryURL: URL { get }

    /// The online map used by this job.
    final public var onlineMap: ArcGIS.Map? { get }

    /// The parameter overrides used by this job. Can be `nil`.
    final public var parameterOverrides: ArcGIS.GenerateOfflineMapParameterOverrides? { get }

    /// The parameters used by this job.
    final public var parameters: ArcGIS.GenerateOfflineMapParameters { get }

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.GenerateOfflineMapResult

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.GenerateOfflineMapJob.Output, Error> { get async }
}

/// Gives access to the individual parameters objects that will generate the various geodatabase, vector tile
/// and tile cache packages that make up the data of an offline map.
///
/// This object allows the user more fine-grained control over the generation of an offline map than the options presented
/// in the standard ``GenerateOfflineMapParameters``.
/// For example, the parameter overrides allow the user to adjust specific layers so that they: use a different spatial
/// extent or scale range; use custom attribute or geometry settings; are omitted from the download.
/// An instance of this object can be created from the overall map settings in ``GenerateOfflineMapParameters``
/// by calling `OfflineMapTask.makeGenerateOfflineMapParameterOverrides(parameters:)`.
/// This object gives access to the individual parameter objects via three dictionaries containing generate geodatabase
/// parameters, export tile cache parameters and export vector tile parameters. These can be accessed using
/// ``generateGeodatabaseParameters``,
/// ``exportTileCacheParameters`` and
/// ``exportVectorTilesParameters`` respectively.
/// The dictionaries contain the various parameters objects mapped against an ``OfflineMapParametersKey``. An
/// ``OfflineMapParametersKey`` represents the service that a particular parameters object is intended for.
/// The ``OfflineMapParametersKey/init(layer:)``, ``OfflineMapParametersKey/init(table:)``,
/// or ``OfflineMapParametersKey/init(utilityNetwork:)`` can be used to construct a key given its respective layer, table,
/// or utility network.
/// The returned key can be used to look up a value in a dictionary. The type of dictionary is indicated by the key's
/// ``OfflineMapParametersKey/kind-swift.property`` property.
/// Note that a given parameters key/value pair may be shared by multiple layers in the map: for example a single
/// ``GenerateGeodatabaseParameters`` could represent the online settings for multiple feature layers that all access the same
/// underlying feature service.
/// All entries in the dictionaries should correspond to layers and table instances in the online ``Map``.
/// If a dictionary entry is removed the corresponding layers or tables will be removed from the offline map without raising an error.
/// - Since: 200.1
final public class GenerateOfflineMapParameterOverrides {

    /// The `Dictionary` with keys of ``OfflineMapParametersKey`` and values of ``ExportTileCacheParameters``.
    ///
    /// All entries in the dictionary should correspond to ``ArcGISTiledLayer`` instances in the online ``Map``.
    /// If a dictionary entry is removed the corresponding layers will be removed from the offline map without raising an error.
    final public var exportTileCacheParameters: [ArcGIS.OfflineMapParametersKey : ArcGIS.ExportTileCacheParameters] { get }

    /// Sets a value in the `exportTileCacheParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setExportTileCacheParameterValue(_ value: ArcGIS.ExportTileCacheParameters?, forKey key: ArcGIS.OfflineMapParametersKey)

    /// The `Dictionary` with keys of ``OfflineMapParametersKey`` and values of ``ExportVectorTilesParameters``.
    ///
    /// All entries in the dictionary should correspond to ``ArcGISVectorTiledLayer`` instances in the online ``Map``.
    /// If a dictionary entry is removed the corresponding layers will be removed from the offline map without raising an error.
    final public var exportVectorTilesParameters: [ArcGIS.OfflineMapParametersKey : ArcGIS.ExportVectorTilesParameters] { get }

    /// Sets a value in the `exportVectorTilesParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setExportVectorTilesParameterValue(_ value: ArcGIS.ExportVectorTilesParameters?, forKey key: ArcGIS.OfflineMapParametersKey)

    /// The `Dictionary` with keys of ``OfflineMapParametersKey`` and values of ``GenerateGeodatabaseParameters``.
    ///
    /// All entries in the dictionary should correspond to ``FeatureLayer``, ``ServiceFeatureTable``, or ``UtilityNetwork`` instances in the online ``Map``.
    /// If a dictionary entry is removed the corresponding layers, tables, or utility network will be removed from the offline map without raising an error.
    final public var generateGeodatabaseParameters: [ArcGIS.OfflineMapParametersKey : ArcGIS.GenerateGeodatabaseParameters] { get }

    /// Sets a value in the `generateGeodatabaseParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setGenerateGeodatabaseParameterValue(_ value: ArcGIS.GenerateGeodatabaseParameters?, forKey key: ArcGIS.OfflineMapParametersKey)

    /// This list indicates layers that will not be taken offline and will continue to reference online services.
    ///
    /// In some situations, you may wish to prevent a layer from being taken offline even
    /// though it is supported. For example, by continuing to reference the live online service
    /// for a ``FeatureLayer``, you can benefit from the most up-to-date information. You can
    /// choose to keep layers from the map's operational layers or basemap layers collections
    /// online.
    ///
    /// To make the offline map continue to reference an online layer add it to the
    /// ``onlineLayers`` collection. By adding a ``Layer``
    /// to this list, you indicate that the layer will not be taken offline but will instead
    /// continue to reference the online service. Be aware that the resulting offline map will
    /// require a network connection and may also require authentication.
    ///
    /// Note that if a ``Layer`` is included in this collection it will not be taken offline -
    /// you should update the relevant parameters to remove the details pertaining to that
    /// layer:
    /// * ``exportTileCacheParameters`` can be removed to
    /// prevent an ``ArcGISTiledLayer`` from being taken offline
    /// * ``exportVectorTilesParameters`` can be removed
    /// to prevent an ``ArcGISVectorTiledLayer`` from being taken offline
    /// * ``generateGeodatabaseParameters`` can be
    /// removed for an entire feature service or updated to remove an individual
    /// ``FeatureLayer`` using ``GenerateGeodatabaseParameters/layerOptions``
    ///
    /// If a feature service contains many tables in the web map, you can choose to keep
    /// specific layers online by adding them to the
    /// ``onlineLayers`` collection and updating the
    /// ``generateGeodatabaseParameters`` to remove the
    /// specific layers. Any remaining feature layers or stand-alone tables that you wish to
    /// take offline can be configured using the ``GenerateGeodatabaseParameters/layerOptions``
    /// for the service in
    /// ``generateGeodatabaseParameters``.
    ///
    /// When you create a ``GenerateOfflineMapParameterOverrides`` object, this collection will
    /// be populated according to the ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property``
    /// setting in the original parameters. Things to consider are:
    /// * If you set ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` to
    ///   ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/exclude`` then this collection will be empty
    /// * If you set ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` to
    ///   ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/include`` then this collection will contain each
    ///   online-only ``Layer`` in the web map. For example, layers that cannot be taken
    ///   offline.
    /// * If you set ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` to
    ///   ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/useAuthoredSettings`` then this collection will contain
    ///   each ``Layer`` that the web map author selected to remain online
    final public var onlineLayers: [ArcGIS.Layer] { get }

    /// Adds a sequence of `Layer` values to the end of the `onlineLayers` property.
    /// - Parameter newOnlineLayers: The new `Layer` values to append.
    final public func addOnlineLayers<S>(_ newOnlineLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Adds a `Layer` value to the end of the `onlineLayers` property.
    /// - Parameter newOnlineLayer: The new `Layer` value to append.
    final public func addOnlineLayer(_ newOnlineLayer: ArcGIS.Layer)

    /// Inserts a collection of `Layer` values into the `onlineLayers` property at the specified position.
    /// - Parameters:
    ///   - newOnlineLayers: The new `Layer` values to insert.
    ///   - index: The position at which to insert the new `Layer` values.
    final public func insertOnlineLayers<C>(_ newOnlineLayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.Layer

    /// Inserts a `Layer` value into the `onlineLayers` property at the specified position.
    /// - Parameters:
    ///   - newOnlineLayer: The new `Layer` value to insert.
    ///   - index: The position at which to insert the new `Layer` value.
    final public func insertOnlineLayer(_ newOnlineLayer: ArcGIS.Layer, at index: Int)

    /// Removes all values from the `onlineLayers` property.
    final public func removeAllOnlineLayers()

    /// Removes a sequence of `Layer` values from the `onlineLayers` property.
    /// - Parameter onlineLayers: The `Layer` values to remove.
    final public func removeOnlineLayers<S>(_ onlineLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Removes a `Layer` value from the `onlineLayers` property.
    /// - Parameter onlineLayer: The `Layer` value to remove.
    final public func removeOnlineLayer(_ onlineLayer: ArcGIS.Layer)

    /// This list indicates tables that will not be taken offline and will continue to reference online services.
    ///
    /// In some situations, you may wish to prevent a non-spatial table from being taken
    /// offline even though it is supported. For example, by continuing to reference the live
    /// online ``ServiceFeatureTable``, you can benefit from the most up-to-date information.
    ///
    /// To make the offline map continue to reference an online table, you add it to the
    /// ``onlineTables`` collection. By adding a
    /// ``ServiceFeatureTable`` to this list, you indicate that the table will not be taken
    /// offline and it will continue to reference the online source. Be aware that the
    /// resulting offline map will require a network connection and may require
    /// authentication.
    ///
    /// Note that if a ``ServiceFeatureTable`` is included in this collection it will not be
    /// taken offline - you should update the
    /// ``generateGeodatabaseParameters`` to remove that
    /// table.
    ///
    /// If a feature service contains many layers in the web map, you can choose to keep
    /// specific tables online by adding them to the
    /// ``onlineTables`` collection. Any remaining tables
    /// that you wish to take offline can be configured using the service's
    /// ``GenerateGeodatabaseParameters/layerOptions`` in the
    /// ``generateGeodatabaseParameters``.
    ///
    /// When you create a ``GenerateOfflineMapParameterOverrides`` object, this collection will
    /// be populated according to the ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property``
    /// setting in the original parameters. Things to consider are:
    /// * If you set ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` to
    ///   ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/exclude`` then this collection will be empty
    /// * If you set ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` to
    ///   ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/include`` then this collection will contain each
    ///   online-only ``ServiceFeatureTable`` in the web map. For example, layers that cannot
    ///   be taken offline. because they are not sync-enabled.
    /// * If you set ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` to
    ///   ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/useAuthoredSettings``, then this collection will contain
    ///   each ``ServiceFeatureTable`` that the web map author selected to remain online
    final public var onlineTables: [ArcGIS.ServiceFeatureTable] { get }

    /// Adds a sequence of `ServiceFeatureTable` values to the end of the `onlineTables` property.
    /// - Parameter newOnlineTables: The new `ServiceFeatureTable` values to append.
    final public func addOnlineTables<S>(_ newOnlineTables: S) where S : Sequence, S.Element == ArcGIS.ServiceFeatureTable

    /// Adds a `ServiceFeatureTable` value to the end of the `onlineTables` property.
    /// - Parameter newOnlineTable: The new `ServiceFeatureTable` value to append.
    final public func addOnlineTable(_ newOnlineTable: ArcGIS.ServiceFeatureTable)

    /// Inserts a collection of `ServiceFeatureTable` values into the `onlineTables` property at the specified position.
    /// - Parameters:
    ///   - newOnlineTables: The new `ServiceFeatureTable` values to insert.
    ///   - index: The position at which to insert the new `ServiceFeatureTable` values.
    final public func insertOnlineTables<C>(_ newOnlineTables: C, at index: Int) where C : Collection, C.Element == ArcGIS.ServiceFeatureTable

    /// Inserts a `ServiceFeatureTable` value into the `onlineTables` property at the specified position.
    /// - Parameters:
    ///   - newOnlineTable: The new `ServiceFeatureTable` value to insert.
    ///   - index: The position at which to insert the new `ServiceFeatureTable` value.
    final public func insertOnlineTable(_ newOnlineTable: ArcGIS.ServiceFeatureTable, at index: Int)

    /// Removes all values from the `onlineTables` property.
    final public func removeAllOnlineTables()

    /// Removes a sequence of `ServiceFeatureTable` values from the `onlineTables` property.
    /// - Parameter onlineTables: The `ServiceFeatureTable` values to remove.
    final public func removeOnlineTables<S>(_ onlineTables: S) where S : Sequence, S.Element == ArcGIS.ServiceFeatureTable

    /// Removes a `ServiceFeatureTable` value from the `onlineTables` property.
    /// - Parameter onlineTable: The `ServiceFeatureTable` value to remove.
    final public func removeOnlineTable(_ onlineTable: ArcGIS.ServiceFeatureTable)
}

/// Parameters used for creating a ``GenerateOfflineMapJob``.
/// - Since: 200.1
final public class GenerateOfflineMapParameters {

    /// Indicates whether tables will contain all rows or can be filtered to a smaller set of related rows.
    /// Used by the property ``GenerateOfflineMapParameters/destinationTableRowFilter-swift.property``.
    public enum DestinationTableRowFilter {

        /// Indicates all rows of a table will be take offline.
        case all

        /// Indicates that, where appropriate, a table will be filtered to only related rows when taking the table offline.
        case relatedOnly

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GenerateOfflineMapParameters.DestinationTableRowFilter, b: ArcGIS.GenerateOfflineMapParameters.DestinationTableRowFilter) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Enumerates the possible options for dealing with online-only services (those which cannot be taken offline).
    public enum OnlineOnlyServicesOption {

        /// Online layers and tables that cannot be taken offline will be excluded when taking a map offline.
        case exclude

        /// Online layers and tables that cannot be taken offline will be included when taking a map offline and
        /// will continue to reference the online service.
        case include

        /// A given layer or table will be taken offline, included as online content, or excluded according to the
        /// settings in the web map.
        ///
        /// When a web map is created, the author has the option to pre-select which layers should
        /// remain online. This can include:
        /// * Choosing to leave offline-enabled layers online (for example because they contain
        ///   data that is frequently updated).
        /// * Choosing whether online-only layers should be included in the offline map or not.
        ///
        /// If no settings are provided in the web map, the default behavior will be to omit any
        /// online only layers or tables from the offline map. This matches the
        /// ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/exclude`` option.
        /// - Note: See Also: ``OfflineSettings/onlineLayers``, ``OfflineSettings/onlineTables``
        case useAuthoredSettings

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GenerateOfflineMapParameters.OnlineOnlyServicesOption, b: ArcGIS.GenerateOfflineMapParameters.OnlineOnlyServicesOption) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Different modes for synchronization of features in a generated offline map.
    public enum UpdateMode {

        /// Changes, including local edits, will be synced directly with the underlying feature services.
        case syncWithFeatureServices

        /// No feature updates will be performed.
        case noUpdates

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GenerateOfflineMapParameters.UpdateMode, b: ArcGIS.GenerateOfflineMapParameters.UpdateMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a generate offline map parameters object
    public convenience init()

    /// Creates a generate offline map parameters object.
    ///
    /// The area of interest must have a spatial reference. If min_scale or
    /// max_scale is zero that implies there is no bound on the scale. If
    /// both are non-zero, they must both be positive with min_scale greater
    /// than max_scale.
    /// - Parameters:
    ///   - areaOfInterest: Area of interest.
    ///   - minScale: Min scale.
    ///   - maxScale: Max scale.
    public convenience init(areaOfInterest: ArcGIS.Geometry, minScale: Double? = nil, maxScale: Double? = nil)

    /// The area of interest for the offline map. This is used for the extent of offline tile caches, geodatabases
    /// and the offline map's ``GeoModel/initialViewpoint`` property.
    ///
    /// The supported geometry types for the area of interest are ``Envelope`` and ``Polygon``. The area of interest must have a spatial reference.
    /// Where a ``Polygon`` is supplied, features and tiles will be filtered according to the polygon geometry, which
    /// can help reduce the size of the resulting offline map. Note that the filtered set of tiles may vary, depending on
    /// the underlying service.
    final public var areaOfInterest: ArcGIS.Geometry?

    /// Specifies the direction for attachments to be synchronized when syncing offline feature layers. This method
    /// should be used in conjunction with ``returnLayerAttachmentOption`` to determine
    /// which layers should be taken offline with attachments included.
    ///
    /// This property is valid when the service resource sync capabilities includes
    /// supportsAttachmentsSyncDirection otherwise it is ignored.
    ///
    /// This property works in conjunction with
    /// ``returnLayerAttachmentOption`` and in some cases may have
    /// its value overridden by ``returnLayerAttachmentOption``.
    ///
    /// The table below shows the valid combinations of values for layer attachment options and
    /// attachment sync direction. The notes column explains where the behavior for a given
    /// layer may differ from the values set for these properties.
    ///
    /// | Layer Attachment Option                        | Valid Attachment Sync Direction           | Note                                                                                    |
    /// | ---------------------------------------------- | ----------------------------------------- | --------------------------------------------------------------------------------------- |
    /// | ``ReturnLayerAttachmentOption/notIncluded``           | ``AttachmentSyncDirection/noSync``          |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// | ``ReturnLayerAttachmentOption/allLayers``      | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/bidirectional`` |                                                                                         |
    /// | ``ReturnLayerAttachmentOption/readOnlyLayers`` | ``AttachmentSyncDirection/noSync``          | Layers *with* attachments will treat this as ``AttachmentSyncDirection/bidirectional``  |
    /// |                                                | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/bidirectional`` | Layers *without* attachments will treat this as ``AttachmentSyncDirection/noSync``        |
    /// | ``ReturnLayerAttachmentOption/editableLayers`` | ``AttachmentSyncDirection/noSync``          | Layers *with* attachments will treat this as ``AttachmentSyncDirection/bidirectional``  |
    /// |                                                | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/bidirectional`` | Layers *without* attachments will treat this as ``AttachmentSyncDirection/noSync``        |
    ///
    /// If ``GenerateOfflineMapParameters`` is used in conjunction with
    /// ``GenerateOfflineMapParameterOverrides`` this property is superseded.
    final public var attachmentSyncDirection: ArcGIS.AttachmentSyncDirection

    /// Indicates whether or not the generate offline map job should continue running in the event of failure
    /// to take a layer offline.
    ///
    /// If this property is `true`, failure to take a layer or table offline will not fail the job, the failure will be
    /// exposed in the job result. If this property is `false`, failure to take a layer or table offline will fail the job
    /// and no more layers or tables will be taken offline. The layer or table's error will be available as the job's error.
    /// The default value is `true`.
    final public var continuesOnErrors: Bool

    /// Indicates if feature layer definition expressions are used when taking feature layers and tables offline.
    ///
    /// A value of `true` allows ``GenerateOfflineMapJob`` to use the SQL where clause in
    /// ``FeatureLayer/definitionExpression`` as a filter when generating offline geodatabases.
    ///
    /// Applying the definition expression may reduce the number of features taken offline for
    /// display and sync.
    ///
    /// If the value is `false` this could result in a larger geodatabase than is required to
    /// display the feature layer.
    ///
    /// The default value is `true`.
    ///
    /// For tables the definition expression is taken from the property
    /// ``ServiceFeatureTable/definitionExpression``.
    ///
    /// If ``GenerateOfflineMapParameters`` is used in conjunction with
    /// ``GenerateOfflineMapParameterOverrides`` this property is superseded.
    final public var definitionExpressionFilterIsEnabled: Bool

    /// Indicates whether tables will contain all rows or can be filtered to a smaller set of related rows.
    ///
    /// When the property is ``DestinationTableRowFilter-swift.enum/relatedOnly`` (the default) this can
    /// substantially reduce the number of rows in offline tables to only those that are
    /// related to rows from other layers or tables. Only tables present in ``GeoModel/tables`` are
    /// considered as candidates for filtering.
    ///
    /// This does not apply when the table:
    /// * Is the origin of a relationship and not a destination
    /// * Is a destination of a relationship from a layer or table that is not in the map
    /// * Is editable and ``returnsSchemaOnlyForEditableLayers``
    ///   is `true`
    /// * Has a ``ServiceFeatureTable/definitionExpression`` and
    ///   ``definitionExpressionFilterIsEnabled`` is `true`
    ///
    /// The relationships of a table are accessible via ``ArcGISFeatureTable/layerInfo`` and
    /// the ``ArcGISFeatureLayerInfo/relationshipInfos`` property.
    ///
    /// The default value is ``DestinationTableRowFilter-swift.enum/relatedOnly``.
    ///
    /// If set to ``DestinationTableRowFilter-swift.enum/all`` then all rows in tables are returned.
    final public var destinationTableRowFilter: ArcGIS.GenerateOfflineMapParameters.DestinationTableRowFilter

    /// Describes how Esri vector tiled basemap layers will be downloaded.
    ///
    /// This property lets you choose how to download Esri vector tiled basemap layers. This
    /// property only applies when taking an Esri vector tile basemap service offline.
    ///
    /// When taking an Esri vector tiled basemap service offline (e.g. to create a
    /// ``VectorTileCache`` on your device), you can choose from different versions of the
    /// service depending on your use case.
    ///
    /// Primary considerations are the download speed and the size of the resulting .vtpk file.
    /// Among other things, file size is influenced by the number of fonts downloaded from the
    /// service. Esri vector tiled basemap layers use fonts as part of their style resources -
    /// see the
    /// [Vector Tile Style documentation](https://developers.arcgis.com/rest/services-reference/enterprise/vector-tile-style.htm).
    /// When you take vector tiled layer offline, these fonts are downloaded as part of the
    /// ``VectorTileCache``.
    ///
    /// Esri services also offer an alternative version with a reduced font package size. This
    /// omits the large Arial Unicode font, which greatly reduces the download size. You can
    /// view the set of reduced font vector tile services
    /// [here](https://www.arcgis.com/home/group.html?id=c61ab1493fff4b84b53705184876c9b0).
    ///
    /// If you choose ``EsriVectorTilesDownloadOption/useOriginalService``, the full set of
    /// resources used by the original online service, including all fonts, will be downloaded.
    /// This increases the download size of the ``VectorTileCache`` but ensures that the
    /// offline layer will display the same as the original online data.
    ///
    /// If you choose ``EsriVectorTilesDownloadOption/useReducedFontsService``, the smaller set
    /// of fonts used by the alternative, for export, version of the service will be
    /// downloaded. This reduces the download size of the ``VectorTileCache`` but is not
    /// suitable for all locales or when your offline vector tiled layer includes certain
    /// language characters. For example, this option will not display Chinese, Japanese, Thai,
    /// Korean or Georgian characters. If an alternative, for export version of the service
    /// cannot be found, the original service will be used.
    ///
    /// The default value is ``EsriVectorTilesDownloadOption/useOriginalService``.
    final public var esriVectorTilesDownloadOption: ArcGIS.EsriVectorTilesDownloadOption

    /// Indicates whether or not a basemap will be included in the offline map.
    ///
    /// If you do not want a basemap in the offline map then set this property to `false`.
    /// After loading the offline map, your application can programmatically insert a basemap
    /// into the map. Note that, a programmatically inserted basemap will not be persisted in
    /// the map.
    ///
    /// If you want a basemap in the offline map then set this property to `true`. You can choose
    /// to either:
    /// * Generate and download the online basemap using the ``GenerateOfflineMapJob``. This is
    ///   the default.
    /// * Use a local basemap on the device by setting the
    ///   ``referenceBasemapDirectoryURL``
    ///
    /// The default value is `true`.
    ///
    /// This property is superseded if the ``GenerateOfflineMapParameters`` is used in
    /// conjunction with ``GenerateOfflineMapParameterOverrides``.
    final public var includesBasemap: Bool

    /// Offline map item info used for the local item properties in the offline map.
    ///
    /// If this property is `nil` then the properties are copied from the portal item.
    final public var itemInfo: ArcGIS.OfflineMapItemInfo?

    /// The maximum scale for how far in to extract tiles from tiled services.
    /// The 0 default means extract the levels down to the most detailed. If `nil`, there is no maximum.
    ///
    /// This is used as input for levels of detail for ``TileCache`` and ``VectorTileCache``.
    ///
    /// This is not applicable to offline data in ``Geodatabase``.
    ///
    /// A minScale of 100000 and a maxScale of 500 will select level IDs between 1:500 and
    /// 1:100,000 scale.
    ///
    /// A minScale of 0 and a maxScale of 500 will select all global level IDs down to 1:500
    /// scale.
    ///
    /// A minScale of 100000 and a maxScale of 0 will select level IDs from 1:100,000 scale
    /// to the most detailed available level.
    ///
    /// If ``GenerateOfflineMapParameters`` is used in conjunction with
    /// ``GenerateOfflineMapParameterOverrides``, this property is superseded for individual
    /// layers tile caches.
    ///
    /// Note that this property only sets the levels of detail to download for tiled data. The
    /// offline basemap layers will use the same max scale as in the online web map (either
    /// defined by the service or on the layer itself) to allow zooming in.
    final public var maxScale: Double?

    /// The minimum scale for how far out data will be in tile caches.
    /// The 0 default means extract all the available detailed levels to global scales. If `nil`, there is no minimum.
    ///
    /// This is used as input for levels of detail for ``TileCache``.
    ///
    /// This is not applicable to offline data in ``VectorTileCache`` or ``Geodatabase``.
    ///
    /// A minScale of 100000 and a maxScale of 500 will select level IDs between 1:500 and
    /// 1:100,000 scale.
    ///
    /// A minScale of 0 and a maxScale of 500 will select all global level IDs down to 1:500
    /// scale.
    ///
    /// A minScale of 100000 and a maxScale of 0 will select level IDs from 1:100,000 scale to
    /// the most detailed available level.
    ///
    /// If ``GenerateOfflineMapParameters`` is used in conjunction with
    /// ``GenerateOfflineMapParameterOverrides``, this property is superseded for individual
    /// layers tile caches.
    ///
    /// Note that this property only sets the levels of detail to download for tiled data. The
    /// offline basemap layers will use the same min scale as in the online web map (either
    /// defined by the service or on the layer itself).
    final public var minScale: Double?

    /// Describes how data that requires an online service will be handled when taking a map offline.
    ///
    /// Online layers and tables cannot be taken offline in the following situations:
    /// *	The layer or table is using a service that cannot be taken offline. For example,
    ///   ``WMSLayer`` or ``WMTSLayer``.
    /// * The layer or table is using a service that supports offline, such as an
    ///   ArcGISFeatureLayer, but synchronization has not been enabled on the service
    ///   (``FeatureServiceCapabilities/sync`` is set to `false`). Services utilize
    ///   synchronization to take layers and tables offline and synchronize changes.
    ///
    /// Online services that cannot be taken offline are referred to as online-only services.
    /// Online-only services require network connectivity and may involve authentication.
    /// Examples of online-only services include:
    /// * Dynamic information, such as changing weather or traffic conditions, that delivers
    ///   frequent and regular updates to the app
    /// * Large datasets that would be impractical to take offline to a device
    ///
    /// This property allows you to specify how online-only data will be handled when taking
    /// the map offline. There  are three options:
    /// * ``OnlineOnlyServicesOption-swift.enum/exclude`` means that any data that cannot be taken offline
    ///   will be omitted from the offline map. Choosing this option means that your offline
    ///   map will not require a network connection but may not include all of the data from
    ///   the original web map.
    /// * ``OnlineOnlyServicesOption-swift.enum/include`` means that data that cannot be taken offline
    ///   will be accessed via the URL in the offline map. Choosing this option means that your
    ///   offline map will retain all of the information from the original web map, but it will
    ///   require a network connection and may require authentication.
    /// * ``OnlineOnlyServicesOption-swift.enum/useAuthoredSettings`` means that layers and tables will be
    ///   taken offline, remain online or be omitted from the offline map according to the map
    ///   author's intent as defined in the web map
    ///
    /// The default value is ``OnlineOnlyServicesOption-swift.enum/exclude``.
    /// - Note: See Also: ``OfflineSettings/onlineLayers``, ``OfflineSettings/onlineTables``
    final public var onlineOnlyServicesOption: ArcGIS.GenerateOfflineMapParameters.OnlineOnlyServicesOption

    /// The path to a directory on the device where the local basemap file is located.
    ///
    /// Set this property to use a basemap that is already on the device (rather than
    /// downloading it). The directory should only be set when the parameters have a
    /// ``referenceBasemapFilename`` defined.
    ///
    /// This property supports any directory specified as either:
    /// * An absolute path
    /// * A path relative to the parent directory of the generated mobile map package (see
    ///   downloadPath for `OfflineMapTask.makeGenerateOfflineMapJob(parameters:downloadDirectory:overrides:)`)
    ///
    /// If the directory does not exist, or does not contain the specified basemap, the
    /// ``GenerateOfflineMapJob`` will fail.
    ///
    /// Note that, the mobile map package will store either a relative or absolute path to the
    /// reference basemap file so that it can be opened in the future.
    ///
    /// A relative path typically begins with "." to denote the parent directory of the
    /// resulting mobile map package or ".." to move up one directory. The parent directory of
    /// the mobile map package will be set when calling `OfflineMapTask.makeGenerateOfflineMapJob(parameters:downloadDirectory:overrides:)`.
    ///
    /// For example, to generate a mobile map package to
    /// "[my root path]/my_offline_maps/my_mobile_map_package", that uses a reference basemap
    /// in "[my root path]/other_maps/my_basemap.tpk", you would set the relative path as
    /// follows:
    /// * ``GenerateOfflineMapJob/downloadDirectoryURL`` to
    ///   "[my root path]/my_offline_maps/my_mobile_map_package"
    /// * ``referenceBasemapDirectoryURL`` to "../other_maps"
    /// * ``referenceBasemapFilename`` to "my_basemap.tpk"
    ///
    /// Note that this property is ignored if ``includesBasemap``
    /// is `false`.
    final public var referenceBasemapDirectoryURL: URL?

    /// The name of a local basemap file on the device that can be used rather than downloading an online basemap.
    ///
    /// The local basemap filename must end with .tpk, .tpkx or .vtpk since these are the supported file formats.
    /// This property can be read directly from settings applied by the author of the online web map
    /// (see ``OfflineSettings``) or set by user code to a file known to be on the device.
    /// This property will be populated from online settings when created with
    /// `OfflineMapTask.makeDefaultGenerateOfflineMapParameters(areaOfInterest:minScale:maxScale:)`.
    ///
    /// If you wish to use the specified local basemap rather than downloading, you must also set
    /// ``referenceBasemapDirectoryURL``.
    ///
    /// If the directory does not exist, or does not contain the specified basemap, the ``GenerateOfflineMapJob``
    /// will fail.
    ///
    /// The spatial reference of the reference basemap is used for the offline map when it is different to
    /// the online map's spatial reference.
    ///
    /// Note that this property is ignored if ``includesBasemap`` is `false`.
    /// - Note: See Also: ``OfflineSettings``
    final public var referenceBasemapFilename: String

    /// Which feature layers will include attachments when being taken offline. Attachments can be included
    /// with none of the layers, all of the layers, read only layers or editable layers. This method should be used in
    /// conjunction with ``attachmentSyncDirection`` to control how the attachments are
    /// synced.
    ///
    /// For offline maps, a feature layer is considered to be editable if the feature service has capabilities that
    /// include any of create, update or delete.
    /// A read-only layer is one that supports sync, but does not have any of create, update or delete capability.
    /// Service capabilities are accessible from service infos see ``ArcGISFeatureServiceInfo/featureServiceCapabilities`` or ``ArcGISFeatureLayerInfo/capabilities``.
    ///
    /// This property works in conjunction with ``attachmentSyncDirection``
    /// and in some cases may override the value returned by ``attachmentSyncDirection``.
    /// The table below shows the valid combinations of values for layer attachment options and attachment sync
    /// direction. The notes column explains where the behavior for a given layer may differ from the values set
    /// for these properties.
    ///
    /// | Layer Attachment Option                        | Valid Attachment Sync Direction           | Note                                                                                    |
    /// | ---------------------------------------------- | ----------------------------------------- | --------------------------------------------------------------------------------------- |
    /// | ``ReturnLayerAttachmentOption/notIncluded``           | ``AttachmentSyncDirection/noSync``          |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// | ``ReturnLayerAttachmentOption/allLayers``      | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/bidirectional`` |                                                                                         |
    /// | ``ReturnLayerAttachmentOption/readOnlyLayers`` | ``AttachmentSyncDirection/noSync``          | Layers *with* attachments will treat this as ``AttachmentSyncDirection/bidirectional``  |
    /// |                                                | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/bidirectional`` | Layers *without* attachments will treat this as ``AttachmentSyncDirection/noSync``        |
    /// | ``ReturnLayerAttachmentOption/editableLayers`` | ``AttachmentSyncDirection/noSync``          | Layers *with* attachments will treat this as ``AttachmentSyncDirection/bidirectional``  |
    /// |                                                | ``AttachmentSyncDirection/upload``        |                                                                                         |
    /// |                                                | ``AttachmentSyncDirection/bidirectional`` | Layers *without* attachments will treat this as ``AttachmentSyncDirection/noSync``        |
    ///
    /// If ``GenerateOfflineMapParameters`` is used in conjunction with ``GenerateOfflineMapParameterOverrides``
    /// this property is superseded.
    final public var returnLayerAttachmentOption: ArcGIS.ReturnLayerAttachmentOption

    /// Whether or not feature layers taken offline should be schema only and contain no data.
    ///
    /// For an upload only type workflow, this property can be set to `true` to take feature layers
    /// offline with no existing data in them.
    /// If ``GenerateOfflineMapParameters`` is used in conjunction with ``GenerateOfflineMapParameterOverrides``
    /// this property is superseded.
    final public var returnsSchemaOnlyForEditableLayers: Bool

    /// Describes how the offline map will support synchronization with online services.
    ///
    /// A value of ``UpdateMode-swift.enum/syncWithFeatureServices`` instructs the ``GenerateOfflineMapJob``
    /// to create offline geodatabases that support syncing with online feature services.
    ///
    /// A value of ``UpdateMode-swift.enum/noUpdates`` instructs the ``GenerateOfflineMapJob`` to disable
    /// data synchronization for generated offline geodatabases. In this case, no synchronization replicas will be
    /// created on corresponding feature services. This reduces the load on the feature server and frees
    /// the developer from needing to unregister server replicas when they are no longer needed.
    ///
    /// The default value is ``UpdateMode-swift.enum/syncWithFeatureServices``.
    ///
    /// If ``GenerateOfflineMapParameters`` is used in conjunction with ``GenerateOfflineMapParameterOverrides``
    /// this property is superseded by the ``GenerateGeodatabaseParameters/syncModel`` property of the overridden
    /// layer.
    /// - Note: See Also: ``GenerateGeodatabaseParameters/syncModel``
    final public var updateMode: ArcGIS.GenerateOfflineMapParameters.UpdateMode
}

extension GenerateOfflineMapParameters.DestinationTableRowFilter : Equatable {
}

extension GenerateOfflineMapParameters.DestinationTableRowFilter : Hashable {
}

extension GenerateOfflineMapParameters.OnlineOnlyServicesOption : Equatable {
}

extension GenerateOfflineMapParameters.OnlineOnlyServicesOption : Hashable {
}

extension GenerateOfflineMapParameters.UpdateMode : Equatable {
}

extension GenerateOfflineMapParameters.UpdateMode : Hashable {
}

/// The result of a ``GenerateOfflineMapJob``.
/// - Since: 200.1
final public class GenerateOfflineMapResult {

    /// Indicates that there is at least one layer or table that could not be taken offline.
    final public var hasErrors: Bool { get }

    /// A dictionary of layers to errors for any layers that could not be taken offline.
    final public var layerErrors: [ArcGIS.LayerErrorKey : Error] { get }

    /// The mobile map package containing the offline map.
    final public var mobileMapPackage: ArcGIS.MobileMapPackage { get }

    /// Offline map. The layers within the map will reference offline layers.
    final public var offlineMap: ArcGIS.Map { get }

    /// A dictionary of tables to errors for any tables that could not be taken offline.
    final public var tableErrors: [ArcGIS.TableErrorKey : Error] { get }
}

/// An abstract representation of geographic entities in a map, scene, map view or scene view.
///
/// Each geographic entity can possess geometry, to describe the location and shape of the entity, and a set of
/// attributes to provide information about the real-world entity it represents. For example, a feature in a
/// feature layer, a graphic in a graphics overlay, and a raster cell in a raster layer are represented by the
/// ``Feature``, ``Graphic``, and ``RasterCell`` classes. Each class inherits from ``GeoElement``.
///
/// Operations that identify all of the layers in a map or scene, such as `GeoView.identifyLayers(screenPoint:tolerance:returnPopupsOnly:)`, can
/// return a collection of ``IdentifyLayerResult`` objects. You can obtain the various types of ``GeoElement``
/// objects using ``IdentifyLayerResult/geoElements``.
/// - Note: See Also: `GeoView.identifyLayers(screenPoint:tolerance:returnPopupsOnly:)`
/// - Since: 200.1
public protocol GeoElement : AnyObject {

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    var attributes: [String : Any] { get }

    /// The geometry defines the shape and location of the ``GeoElement``.
    var geometry: ArcGIS.Geometry? { get }
}

/// An analysis object that evaluates visibility along a line defined by observer and target ``GeoElement`` objects.
///
/// GeoElementLineOfSight renders a line between an observer ``GeoElement`` and a target ``GeoElement`` (each using Point geometry).
/// Visible and obstructed portions of the line are displayed with unique colors (green and red by default). The observer and/or
/// target GeoElements may be moving, in which case visibility will be dynamically updated. Supported ``GeoElement`` types are ``Graphic``, ``Feature``, and ``DynamicEntity``.
/// - Note: See Also: ``LineOfSight``, ``Analysis``
/// - Since: 200.1
final public class GeoElementLineOfSight : ArcGIS.LineOfSight {

    /// Creates a LineOfSight analysis object that defines an observer and a target using point ``GeoElement`` objects.
    ///
    /// The LineOfSight analysis result is a line rendered between the observer and target elements with distinct colors representing visible and obstructed segments. Supported ``GeoElement`` types are ``Graphic``, ``Feature``, and ``DynamicEntity``.
    /// - Parameters:
    ///   - observer: A ``GeoElement`` that defines the observer.
    ///   - target: A ``GeoElement`` that defines the target.
    /// - Precondition: `target is Graphic || target is Feature || target is DynamicEntity`
    /// - Precondition: `observer is Graphic || observer is Feature || observer is DynamicEntity`
    public convenience init(observer: ArcGIS.GeoElement, target: ArcGIS.GeoElement)

    /// The observer ``GeoElement`` of the GeoElementLineOfSight.
    ///
    /// The observer ``GeoElement`` must have point geometry. Supported ``GeoElement`` types are ``Graphic``, ``Feature``, and ``DynamicEntity``.
    final public var observer: ArcGIS.GeoElement { get }

    /// The location offset applied to the observer ``GeoElement`` in the X direction.
    ///
    /// The observer location is determined by the location of the ``GeoElement`` plus any defined offsets (in X, Y, or Z).
    /// The offset position of the observer relative to the ``GeoElement`` is always maintained, even when the ``GeoElement`` moves.
    final public var observerOffsetX: Double

    /// The location offset applied to the observer ``GeoElement`` in the Y direction.
    ///
    /// The observer location is determined by the location of the ``GeoElement`` plus any defined offsets (in X, Y, or Z).
    /// The offset position of the observer relative to the ``GeoElement`` is always maintained, even when the ``GeoElement`` moves.
    final public var observerOffsetY: Double

    /// The location offset applied to the observer ``GeoElement`` in the Z direction.
    ///
    /// The observer location is determined by the location of the ``GeoElement`` plus any defined offsets (in X, Y, or Z).
    /// The offset position of the observer relative to the ``GeoElement`` is always maintained, even when the ``GeoElement`` moves.
    final public var observerOffsetZ: Double

    /// The target ``GeoElement`` of the GeoElementLineOfSight.
    ///
    /// The target ``GeoElement`` must have point geometry. Supported ``GeoElement`` types are ``Graphic``, ``Feature``, and ``DynamicEntity``.
    final public var target: ArcGIS.GeoElement { get }

    /// The location offset applied to the target ``GeoElement`` in the X direction.
    ///
    /// The target location is determined by the location of the ``GeoElement`` plus any defined offsets (in X, Y, or Z).
    /// The offset position of the target relative to the ``GeoElement`` is always maintained, even when the ``GeoElement`` moves.
    final public var targetOffsetX: Double

    /// The location offset applied to the target ``GeoElement`` in the Y direction.
    ///
    /// The target location is determined by the location of the ``GeoElement`` plus any defined offsets (in X, Y, or Z).
    /// The offset position of the target relative to the ``GeoElement`` is always maintained, even when the ``GeoElement`` moves.
    final public var targetOffsetY: Double

    /// The location offset applied to the target ``GeoElement`` in the Z direction.
    ///
    /// The target location is determined by the location of the ``GeoElement`` plus any defined offsets (in X, Y, or Z).
    /// The offset position of the target relative to the ``GeoElement`` is always maintained, even when the ``GeoElement`` moves.
    final public var targetOffsetZ: Double
}

/// GeoElementViewshed is an analysis object that renders a viewshed for a specified ``GeoElement``.
///
/// GeoElementViewshed determines visible and non-visible areas in a scene view for an observer defined with a ``GeoElement``. The viewshed will be updated as the ``GeoElement`` location changes. Supported ``GeoElement`` types are ``Graphic``, ``Feature``, and ``DynamicEntity``.
/// - Note: See Also: ``Viewshed``, ``Analysis``
/// - Since: 200.1
final public class GeoElementViewshed : ArcGIS.Viewshed {

    /// The ``GeoElement`` that represents the observer for the viewshed analysis.
    ///
    /// The observer's location, heading, and pitch are determined by the location and orientation of this ``GeoElement``. Supported ``GeoElement`` types are ``Graphic``, ``Feature``, and ``DynamicEntity``.
    final public var geoElement: ArcGIS.GeoElement { get }

    /// The offset angle applied to the heading of the ``GeoElement``.
    ///
    /// The observer heading is determined by the ``GeoElement`` heading plus the heading offset.
    final public var headingOffset: Double

    /// The location offset in the X direction that defines the observer relative to the ``GeoElement``.
    ///
    /// The observer location is determined by the ``GeoElement`` location plus the offset X,Y,Z values. Any rotations
    /// applied to the ``GeoElement`` will also be applied to the X,Y,Z offsets. This allows the observer to be positioned relative
    /// to the ``GeoElement`` and maintain the relative position even when the ``GeoElement`` moves and rotates.
    final public var offsetX: Double

    /// The location offset in the Y direction that defines the observer relative to the ``GeoElement``.
    ///
    /// The observer location is determined by the ``GeoElement`` location plus the offset X,Y,Z values. Any rotations
    /// applied to the ``GeoElement`` will also be applied to the X,Y,Z offsets. This allows the observer to be positioned relative
    /// to the ``GeoElement`` and maintain the relative position even when the ``GeoElement`` moves and rotates.
    final public var offsetY: Double

    /// The location offset in the Z direction that defines the observer relative to the ``GeoElement``.
    ///
    /// The observer location is determined by the ``GeoElement`` location plus the offset X,Y,Z values. Any rotations
    /// applied to the ``GeoElement`` will also be applied to the X,Y,Z offsets. This allows the observer to be positioned relative
    /// to the ``GeoElement`` and maintain the relative position even when the ``GeoElement`` moves and rotates.
    final public var offsetZ: Double

    /// The offset angle applied to the pitch of the ``GeoElement``.
    ///
    /// The observer pitch is determined by the ``GeoElement`` pitch plus the pitch offset. The valid range of values for the observer pitch is from 0 to 180 degrees.
    final public var pitchOffset: Double
}

extension GeoElementViewshed {

    /// Creates a viewshed analysis object whose observer is defined using a ``Graphic``.
    /// - Remark: Visible and obstructed areas are determined for an area defined by the location
    /// and orientation of a graphic, the field of view angles, and the min/max distance range.
    /// These parameters define the frustum over which visibility is calculated from the observer
    /// element. The horizontal and vertical angles must be greater than `0` and less than or equal
    /// to `120` degrees. Terrain and other obstacles between the observer and the minimum distance
    /// are excluded from the analysis, as are areas beyond the maximum distance.
    /// - Parameters:
    ///   - geoElement: A ``Graphic`` from which the position and orientation of the observer
    ///   will be determined.
    ///   - horizontalAngle: The horizontal angle of the observer's view.
    ///   - verticalAngle: The vertical angle of the observer's view.
    ///   - headingOffset: An angle offset relative to the heading of the graphic to determine
    ///   the direction of the observer's view.
    ///   - pitchOffset: An angle added to (or removed from) the pitch of the graphic.
    ///   The combined values define the angle of the frustum (relative to the surface) used in the
    ///   analysis. The valid range of values for the frustum pitch is from `0` to `180` degrees.
    ///   - minDistance: The minimum distance from the observer at which visibility will be
    ///   evaluated. The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - maxDistance: The maximum distance from the observer at which visibility will be
    ///   evaluated. The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - Precondition: `geoElement.geometry != nil`
    ///   - Precondition: `geoElement.geometry is Point`
    ///   - Precondition: `!geoElement.geometry!.isEmpty`
    ///   - Precondition: `horizontalAngle > 0 && horizontalAngle <= 360`
    ///   - Precondition: `verticalAngle > 0 && verticalAngle <= 360`
    public convenience init(geoElement: ArcGIS.Graphic, horizontalAngle: Double, verticalAngle: Double, headingOffset: Double, pitchOffset: Double, minDistance: Double? = nil, maxDistance: Double? = nil)

    /// Creates a viewshed analysis object whose observer is defined using a ``Feature``.
    /// - Remark: Visible and obstructed areas are determined for an area defined by the location
    /// and orientation of a feature, the field of view angles, and the min/max distance range.
    /// These parameters define the frustum over which visibility is calculated from the observer
    /// element. The horizontal and vertical angles must be greater than `0` and less than or equal
    /// to `120` degrees. Terrain and other obstacles between the observer and the minimum distance
    /// are excluded from the analysis, as are areas beyond the maximum distance.
    /// - Parameters:
    ///   - geoElement: A ``Feature`` from which the position and orientation of the observer
    ///   will be determined.
    ///   - horizontalAngle: The horizontal angle of the observer's view.
    ///   - verticalAngle: The vertical angle of the observer's view.
    ///   - headingOffset: An angle offset relative to the heading of the feature to determine
    ///   the direction of the observer's view.
    ///   - pitchOffset: An angle added to (or removed from) the pitch of the feature.
    ///   The combined values define the angle of the frustum (relative to the surface) used in the
    ///   analysis. The valid range of values for the frustum pitch is from `0` to `180` degrees.
    ///   - minDistance: The minimum distance from the observer at which visibility will be
    ///   evaluated. The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - maxDistance: The maximum distance from the observer at which visibility will be
    ///   evaluated. The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - Precondition: `geoElement.geometry != nil`
    ///   - Precondition: `geoElement.geometry is Point`
    ///   - Precondition: `!geoElement.geometry!.isEmpty`
    ///   - Precondition: `horizontalAngle > 0 && horizontalAngle <= 360`
    ///   - Precondition: `verticalAngle > 0 && verticalAngle <= 360`
    public convenience init(geoElement: ArcGIS.Feature, horizontalAngle: Double, verticalAngle: Double, headingOffset: Double, pitchOffset: Double, minDistance: Double? = nil, maxDistance: Double? = nil)

    /// Creates a viewshed analysis object whose observer is defined using a ``DynamicEntity``.
    /// - Remark: Visible and obstructed areas are determined for an area defined by the location
    /// and orientation of a dynamic entity, the field of view angles, and the min/max distance range.
    /// These parameters define the frustum over which visibility is calculated from the observer
    /// element. The horizontal and vertical angles must be greater than `0` and less than or equal
    /// to `120` degrees. Terrain and other obstacles between the observer and the minimum distance
    /// are excluded from the analysis, as are areas beyond the maximum distance.
    /// - Parameters:
    ///   - geoElement: A ``DynamicEntity`` from which the position and orientation of the observer
    ///   will be determined.
    ///   - horizontalAngle: The horizontal angle of the observer's view.
    ///   - verticalAngle: The vertical angle of the observer's view.
    ///   - headingOffset: An angle offset relative to the heading of the dynamic entity to determine
    ///   the direction of the observer's view.
    ///   - pitchOffset: An angle added to (or removed from) the pitch of the dynamic entity.
    ///   The combined values define the angle of the frustum (relative to the surface) used in the
    ///   analysis. The valid range of values for the frustum pitch is from `0` to `180` degrees.
    ///   - minDistance: The minimum distance from the observer at which visibility will be
    ///   evaluated. The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - maxDistance: The maximum distance from the observer at which visibility will be
    ///   evaluated. The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - Precondition: `geoElement.geometry != nil`
    ///   - Precondition: `geoElement.geometry is Point`
    ///   - Precondition: `!geoElement.geometry!.isEmpty`
    ///   - Precondition: `horizontalAngle > 0 && horizontalAngle <= 360`
    ///   - Precondition: `verticalAngle > 0 && verticalAngle <= 360`
    public convenience init(geoElement: ArcGIS.DynamicEntity, horizontalAngle: Double, verticalAngle: Double, headingOffset: Double, pitchOffset: Double, minDistance: Double? = nil, maxDistance: Double? = nil)
}

/// A base class for ``Map`` and ``Scene`` that contains layers and properties and can be displayed in a `GeoView`.
///
/// This base class represents the model in a model-view-controller (MVC) architecture, while the
/// `GeoView` represents the view. To display a map or scene to the user, pass ``GeoModel`` to its
/// appropriate `GeoView`, as follows:
/// * Pass a ``Map`` to a `MapView`.
/// * Pass a ``Scene`` to a `SceneView`.
///
/// ``GeoModel`` has many properties that are common to both maps and scenes. For example:
/// * Each map or scene typically has a ``basemap`` to help orient the users.
/// * The ``operationalLayers`` collection gives you access to the vector data (points, line, polygons), raster data, and attribute information provided by the ``Map`` or ``Scene``.
/// * The ``spatialReference`` determines how spatial data relates to real-world space.
/// - Since: 200.1
public class GeoModel : ArcGIS.Loadable {

    /// The basemap for this map or scene.
    ///
    /// A basemap provides a background of geographical context for the content you display in a map or scene. It
    /// is an optional set of non-editable layers such as aerial imagery, roads, or landmarks, that help orient
    /// the user of the map or scene.
    ///
    /// A basemap is composed of a collection of base layers (``Basemap/baseLayers``) and reference layers
    /// (``Basemap/referenceLayers``). Base layers are displayed at the bottom of a map or scene, and
    /// reference layers are displayed at the top, with the ``operationalLayers`` between them.
    ///
    /// You can use ready-to-use basemaps, style your own basemaps with the [ArcGIS Vector Tile Style Editor](https://developers.arcgis.com/documentation/mapping-apis-and-services/tools/vector-tile-style-editor/),
    /// or create and publish your own with ArcGIS Pro.
    /// - Note: See Also: ``Basemap``
    @ArcGIS.Streamed public var basemap: ArcGIS.Basemap?

    public var $basemap: AsyncStream<ArcGIS.Basemap?> { get }

    /// The collection of bookmarks defined for this map or scene.
    ///
    /// Bookmarks allow users to quickly navigate to a particular area of interest in a map or scene.
    /// - Note: See Also: ``Bookmark``
    public var bookmarks: [ArcGIS.Bookmark] { get }

    /// Adds a sequence of `Bookmark` values to the end of the `bookmarks` property.
    /// - Parameter newBookmarks: The new `Bookmark` values to append.
    public func addBookmarks<S>(_ newBookmarks: S) where S : Sequence, S.Element == ArcGIS.Bookmark

    /// Adds a `Bookmark` value to the end of the `bookmarks` property.
    /// - Parameter newBookmark: The new `Bookmark` value to append.
    public func addBookmark(_ newBookmark: ArcGIS.Bookmark)

    /// Inserts a collection of `Bookmark` values into the `bookmarks` property at the specified position.
    /// - Parameters:
    ///   - newBookmarks: The new `Bookmark` values to insert.
    ///   - index: The position at which to insert the new `Bookmark` values.
    public func insertBookmarks<C>(_ newBookmarks: C, at index: Int) where C : Collection, C.Element == ArcGIS.Bookmark

    /// Inserts a `Bookmark` value into the `bookmarks` property at the specified position.
    /// - Parameters:
    ///   - newBookmark: The new `Bookmark` value to insert.
    ///   - index: The position at which to insert the new `Bookmark` value.
    public func insertBookmark(_ newBookmark: ArcGIS.Bookmark, at index: Int)

    /// Removes all values from the `bookmarks` property.
    public func removeAllBookmarks()

    /// Removes a sequence of `Bookmark` values from the `bookmarks` property.
    /// - Parameter bookmarks: The `Bookmark` values to remove.
    public func removeBookmarks<S>(_ bookmarks: S) where S : Sequence, S.Element == ArcGIS.Bookmark

    /// Removes a `Bookmark` value from the `bookmarks` property.
    /// - Parameter bookmark: The `Bookmark` value to remove.
    public func removeBookmark(_ bookmark: ArcGIS.Bookmark)

    /// Manages the data displayed for a floor-aware map or scene, allowing filtering based on floor levels.
    ///
    /// A ``FloorManager`` must be loaded before you can access its site, facility, and level properties, and
    /// perform floor filtering.
    ///
    /// When a map's floor manager is loaded, floor-aware layers display only data associated with the ground
    /// floor by default. When a scene's floor manager is loaded, floor-aware layers display data from all floors
    /// by default. You can filter the data displayed by floor-aware layers by toggling the
    /// ``FloorLevel/isVisible`` property of levels in the floor manager.
    /// - Note: See Also: ``FloorManager``
    public var floorManager: ArcGIS.FloorManager? { get }

    /// Information about the set of ``Geotrigger`` objects defined for the map or scene.
    ///
    /// You must load the ``GeotriggersInfo`` to populate the collection with any geotriggers defined by the
    /// author of the map or scene. If no geotriggers are defined this list will remain empty.
    ///
    /// Use a ``GeotriggerMonitor`` to check each of the conditions defined in
    /// ``GeotriggersInfo/geotriggers``.
    ///
    /// When you save a map, any ``Geotrigger`` objects that reference local data (for
    /// example, a ``GraphicsOverlayFenceParameters``) will be omitted.
    public var geotriggersInfo: ArcGIS.GeotriggersInfo { get }

    /// The initial viewpoint when the map or scene is first displayed.
    ///
    /// The initial viewpoint value is available when the map or scene is loaded. If you want to change the
    /// initial viewpoint, you can do this before you add the map or scene to a `GeoView`. At this point,
    /// the `GeoView`'s viewpoint is set to this initial viewpoint. Any subsequent changes to the
    /// ``initialViewpoint`` are ignored.
    ///
    /// If you want to change the viewpoint of a displayed map or scene, use `GeoView` methods such as:
    ///
    /// * `GeoView.setViewpoint(_:)` for instantly changing the visible area with no animation.
    /// * `SceneView.setViewpointCamera(_:)` for instantly moving the perspective in 3D scenes.
    /// * `MapView.setViewpoint(_:durationSeconds:curve:)` for smooth animated viewpoint changes in 2D maps.
    public var initialViewpoint: ArcGIS.Viewpoint?

    /// The ArcGIS item associated with this map or scene.
    ///
    /// This can be a ``PortalItem`` (for web maps and web scenes loaded from a portal or saved to a portal),
    /// or a ``LocalItem`` (for maps in a map package or scenes in a scene package), or `nil` if no ``Item`` is
    /// associated with this map or scene.
    public var item: ArcGIS.Item?

    /// The properties that control the default loading and rendering behavior of feature layers in this map or scene.
    ///
    /// For example, you can specify which tiling mode should be used when feature layers are added, or specify
    /// whether feature tables should use advanced symbology.
    /// - Note: See Also: ``LoadSettings/featureTilingMode``, ``LoadSettings/usesAdvancedSymbology``
    public var loadSettings: ArcGIS.LoadSettings

    /// A collection of layers that can access geographic data from a file or a service.
    ///
    /// The operational layers collection is used to display geographic data layers on top of a basemap layer
    /// in a ``Map`` or ``Scene``. For example, you can display a fleet of vehicles being tracked on a map or
    /// display a point cloud layer of a tree canopy in a scene.
    ///
    /// This collection of layers is unique to the map or scene, it cannot be used by another ``GeoModel``. You
    /// can add and remove layers from the map or scene by adding and removing them from this collection. Ensure
    /// that the map has finished loading, otherwise you will replace the map's original operational layers
    /// with the newly added layers.
    ///
    /// The first layer in the ``operationalLayers`` collection is drawn first (on the bottom) above
    /// the basemap layer. Each subsequent layer is drawn on top. Typically, imagery or tile layers are added
    /// to the collection first, and then polygon, line, and point layers last. When you pass the ``GeoModel``
    /// to the `GeoView` it combines these layers to create the final display for the user.
    ///
    /// See [Data Layers](https://developers.arcgis.com/documentation/mapping-apis-and-services/maps/data-layers/) for more information about working with operational layers.
    /// - Note: See Also: ``Layer``, ``Basemap/baseLayers``
    public var operationalLayers: [ArcGIS.Layer] { get }

    /// Adds a sequence of `Layer` values to the end of the `operationalLayers` property.
    /// - Parameter newOperationalLayers: The new `Layer` values to append.
    public func addOperationalLayers<S>(_ newOperationalLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Adds a `Layer` value to the end of the `operationalLayers` property.
    /// - Parameter newOperationalLayer: The new `Layer` value to append.
    public func addOperationalLayer(_ newOperationalLayer: ArcGIS.Layer)

    /// Inserts a collection of `Layer` values into the `operationalLayers` property at the specified position.
    /// - Parameters:
    ///   - newOperationalLayers: The new `Layer` values to insert.
    ///   - index: The position at which to insert the new `Layer` values.
    public func insertOperationalLayers<C>(_ newOperationalLayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.Layer

    /// Inserts a `Layer` value into the `operationalLayers` property at the specified position.
    /// - Parameters:
    ///   - newOperationalLayer: The new `Layer` value to insert.
    ///   - index: The position at which to insert the new `Layer` value.
    public func insertOperationalLayer(_ newOperationalLayer: ArcGIS.Layer, at index: Int)

    /// Removes all values from the `operationalLayers` property.
    public func removeAllOperationalLayers()

    /// Removes a sequence of `Layer` values from the `operationalLayers` property.
    /// - Parameter operationalLayers: The `Layer` values to remove.
    public func removeOperationalLayers<S>(_ operationalLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Removes a `Layer` value from the `operationalLayers` property.
    /// - Parameter operationalLayer: The `Layer` value to remove.
    public func removeOperationalLayer(_ operationalLayer: ArcGIS.Layer)

    /// The spatial reference for this map or scene.
    ///
    /// ``SpatialReference`` specifies how geometry coordinates relate to real-world space. It ensures that you
    /// can accurately view, query, and analyze the layers of a map or scene.
    ///
    /// The spatial reference value is `nil` until the ``Map`` or ``Scene`` is loaded. You can set this value
    /// explicitly using the ``Map/init(spatialReference:)`` or ``Scene/init(tilingScheme:)`` constructors.
    /// - Note: See Also: ``SpatialReference``
    public var spatialReference: ArcGIS.SpatialReference? { get }

    /// A collection of feature tables in the map or scene. Unlike ``operationalLayers``, tables are not displayed by the `GeoView`.
    ///
    /// The collection of feature tables is specific to the map or scene. You can add and remove tables by
    /// adding or removing them from the collection.
    ///
    /// By default, the tables are not loaded. You can load them explicitly (``FeatureTable/load()``) or load
    /// them by calling methods such as `FeatureTable.queryFeatures(using:)`.
    /// - Note: See Also: ``FeatureTable``, `Array`, `Array.init(valueType:)`
    public var tables: [ArcGIS.FeatureTable] { get }

    /// Adds a sequence of `FeatureTable` values to the end of the `tables` property.
    /// - Parameter newTables: The new `FeatureTable` values to append.
    public func addTables<S>(_ newTables: S) where S : Sequence, S.Element == ArcGIS.FeatureTable

    /// Adds a `FeatureTable` value to the end of the `tables` property.
    /// - Parameter newTable: The new `FeatureTable` value to append.
    public func addTable(_ newTable: ArcGIS.FeatureTable)

    /// Inserts a collection of `FeatureTable` values into the `tables` property at the specified position.
    /// - Parameters:
    ///   - newTables: The new `FeatureTable` values to insert.
    ///   - index: The position at which to insert the new `FeatureTable` values.
    public func insertTables<C>(_ newTables: C, at index: Int) where C : Collection, C.Element == ArcGIS.FeatureTable

    /// Inserts a `FeatureTable` value into the `tables` property at the specified position.
    /// - Parameters:
    ///   - newTable: The new `FeatureTable` value to insert.
    ///   - index: The position at which to insert the new `FeatureTable` value.
    public func insertTable(_ newTable: ArcGIS.FeatureTable, at index: Int)

    /// Removes all values from the `tables` property.
    public func removeAllTables()

    /// Removes a sequence of `FeatureTable` values from the `tables` property.
    /// - Parameter tables: The `FeatureTable` values to remove.
    public func removeTables<S>(_ tables: S) where S : Sequence, S.Element == ArcGIS.FeatureTable

    /// Removes a `FeatureTable` value from the `tables` property.
    /// - Parameter table: The `FeatureTable` value to remove.
    public func removeTable(_ table: ArcGIS.FeatureTable)

    /// A collection of transportation network datasets defined for the map or scene.
    ///
    /// Map and scene authors can use ArcGIS Pro to create mobile map or scene packages that include
    /// transportation networks. If the map or scene is created from one of these packages, this collection
    /// will be populated with a read-only collection of ``TransportationNetworkDataset`` objects.
    ///
    /// A ``TransportationNetworkDataset`` from this collection can be used to construct one of the network
    /// analysis tasks (such as ``RouteTask``, ``ServiceAreaTask``, and ``ClosestFacilityTask``).
    /// - Note: See Also: ``RouteTask``, ``MobileScenePackage``
    public var transportationNetworks: [ArcGIS.TransportationNetworkDataset] { get }

    /// The version of the ``Map`` or ``Scene`` when it is loaded. The version of a newly created ``Map`` or ``Scene`` is empty.
    ///
    /// When you load an existing map or scene, the version value is the version that it was created at,
    /// according to the [[ESRI web map specification](https://developers.arcgis.com/web-map-specification/)
    /// or [ESRI web scene specification](https://developers.arcgis.com/web-scene-specification/), respectively.
    ///
    /// You can make changes to a map (associated with a ``PortalItem``) and save it back to the web map
    /// it originated from. Alternatively, you can save a map as a new web map on a specified ``Portal`` with a
    /// given title and folder. In these cases, the version of the saved map will be the version of the
    /// [[ESRI web map specification](https://developers.arcgis.com/web-map-specification/)
    /// supported by this API. You cannot save changes to maps in mobile map packages.
    ///
    /// Saving changes to scenes is not currently supported.
    public var version: String { get }

    /// Clones this instance of ``GeoModel`` and its members.
    /// - Returns: A new ``GeoModel`` with the same values as the current ``GeoModel``.
    public func clone() -> Self

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

extension GeoModel : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.GeoModel, rhs: ArcGIS.GeoModel) -> Bool
}

extension GeoModel {

    /// Defines the properties that allow a map or a scene to be floor-aware.
    /// - Remark: Floor-aware maps and scenes contain data representing floor plan and indoor features.
    /// The data displayed by floor-aware maps and scenes can be filtered based on floor levels using the ``FloorManager``.
    /// This property is `nil` for maps or scenes that are not floor-aware.
    /// When this property is set, a new unloaded ``GeoModel/floorManager`` is instantiated.
    /// - Note: See Also: ``GeoModel/floorManager``
    public var floorDefinition: ArcGIS.GeoModelFloorDefinition?
}

/// Contains floor-awareness settings for a map or scene.
///
/// ``GeoModelFloorDefinition`` defines the required layers, and the required fields for each of those layers in a floor-aware map or scene.
/// The floor definition must contain ``levelLayerDefinition`` and ``facilityLayerDefinition``
/// properties at a minimum representing the facilities (eg. buildings) and the floor levels within those facilities. The ``siteLayerDefinition`` property is optional,
/// and represents the sites (campuses) that the facilities may be grouped into.
/// - Note: See Also: ``LayerFloorDefinition``
/// - Since: 200.1
final public class GeoModelFloorDefinition : ArcGIS.JSONSerializable {

    /// Creates a new ``GeoModelFloorDefinition`` object with the specified facility layer definition, level layer definition, and site layer definition.
    /// - Parameters:
    ///   - facilityLayerDefinition: The layer and field properties for the layer used to describe facilities.
    ///   - levelLayerDefinition: The layer and field properties for the layer used to describe floor levels.
    ///   - siteLayerDefinition: The layer and field properties for the layer used to describe sites.
    public convenience init(facilityLayerDefinition: ArcGIS.FacilityLayerDefinition, levelLayerDefinition: ArcGIS.LevelLayerDefinition, siteLayerDefinition: ArcGIS.SiteLayerDefinition?)

    /// The layer and field properties for the layer used to describe facilities.
    final public var facilityLayerDefinition: ArcGIS.FacilityLayerDefinition { get }

    /// The layer and field properties for the layer used to describe floor levels.
    final public var levelLayerDefinition: ArcGIS.LevelLayerDefinition { get }

    /// The layer and field properties for the layer used to describe sites. This property is optional.
    final public var siteLayerDefinition: ArcGIS.SiteLayerDefinition? { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

/// An object that represents a GeoPackage.
///
/// A GeoPackage is an open, standards-based, platform-independent, portable, self-describing, compact format for
/// transferring geospatial information. It is a platform-independent SQLite database file that contains the GeoPackage
/// data and metadata tables.
/// - Since: 200.1
final public class GeoPackage : ArcGIS.Loadable {

    /// Create a GeoPackage object to read the package file at the given path.
    /// - Parameter fileURL: Path to a GeoPackage file (.gpkg).
    public convenience init(fileURL: URL)

    /// All feature tables contained in the GeoPackage.
    final public var featureTables: [ArcGIS.GeoPackageFeatureTable] { get }

    /// The path to the GeoPackage file.
    final public var fileURL: URL { get }

    /// All rasters contained in the GeoPackage.
    final public var rasters: [ArcGIS.GeoPackageRaster] { get }

    /// Close a GeoPackage.
    ///
    /// The use of all data it contains should cease before closing
    /// a GeoPackage. For example: remove feature layers and rasters from maps and release
    /// feature tables. Attempts to access a GeoPackage after it is
    /// closed will fail, resulting in an error. After closing a
    /// GeoPackage, the underlying file it references can be deleted.
    final public func close()

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An object that represents a GeoPackage feature table.
///
/// A GeoPackageFeatureTable supports core GeoPackage geometry types and represents them as Point, Multipoint,
/// Polyline, or Polygon. The GeoPackage specification supports a geometry collection type (storing a variety of
/// core geometry types in a single table). For these tables, the first geometry type found in the collection is
/// rendered. All features can be queried in the table regardless the geometry type displayed.
/// - Since: 200.1
final public class GeoPackageFeatureTable : ArcGIS.FeatureTable {

    /// A description of the GeoPackage feature table.
    final public var description: String { get }

    /// The GeoPackage from which the feature table was loaded.
    weak final public var geoPackage: ArcGIS.GeoPackage? { get }
}

/// The GeoPackage raster object which is derived from a raster object.
///
/// A GeoPackageRaster represents GeoPackage images of types PNG or JPEG. Note that a GeoPackage can store multiple
/// raster and tile pyramid datasets in different tables or views in the same container.
/// - Since: 200.1
final public class GeoPackageRaster : ArcGIS.Raster {

    /// A description of the GeoPackage raster.
    final public var description: String { get }

    /// The GeoPackage from which the raster was loaded.
    weak final public var geoPackage: ArcGIS.GeoPackage? { get }
}

/// A view that displays geographic content from a geo model.
/// - Since: 200.1
public protocol GeoView : View {

    /// Sets the visibility of this geo view's attribution bar.
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    /// attribution bar.
    func attributionBarHidden(_ hidden: Bool) -> Self

    /// Displays a callout when the specified placement is a non-`nil` value.
    /// - Parameters:
    ///   - placement: Binding to the placement for which to display a callout.
    ///   When the wrapped value of the binding is not `nil`, then the callout
    ///   is displayed.
    ///   - content: The content to be displayed within the callout.
    func callout(placement: Binding<ArcGIS.CalloutPlacement?>, @ViewBuilder content: @escaping (ArcGIS.CalloutPlacement) -> some View) -> Self

    /// Sets whether to disable flicking for this geo view.
    /// - Parameter disabled: A Boolean value that indicates whether flicking is
    ///   disabled.
    func flickingDisabled(_ disabled: Bool) -> Self

    /// Sets a closure to perform when this geo view's attribution text changes.
    /// - Parameter action: The closure to perform when the attribution text has
    ///   changed.
    func onAttributionTextChanged(perform action: @escaping (_ newAttributionText: String) -> Void) -> Self

    /// Sets a closure to perform when this geo view's draw status changes.
    /// - Parameter action: The closure to perform when the draw status has
    /// changed.
    func onDrawStatusChanged(perform action: @escaping (_ newDrawStatus: ArcGIS.DrawStatus) -> Void) -> Self

    /// Sets a closure to perform when the view state of a layer of this geo
    /// view changes.
    /// - Parameter action: The closure to perform when a layer's view state has
    ///   changed.
    func onLayerViewStateChanged(perform action: @escaping (_ layer: ArcGIS.Layer, _ newViewState: ArcGIS.LayerViewState) -> Void) -> Self

    /// Sets a closure to perform when this geo view's navigation status
    /// changes.
    ///
    /// The navigation status indicates whether the viewpoint is changing, due
    /// to either user interaction (panning and/or zooming) or a viewpoint
    /// animation.
    /// - Parameter action: The closure to perform when the navigation status
    /// has changed.
    func onNavigatingChanged(perform action: @escaping (_ newIsNavigating: Bool) -> Void) -> Self

    /// Sets a closure to perform when this geo view's spatial reference
    /// changes.
    /// - Parameter action: The closure to perform when the spatial reference
    /// has changed.
    func onSpatialReferenceChanged(perform action: @escaping (_ newSpatialReference: ArcGIS.SpatialReference?) -> Void) -> Self

    /// Sets a closure to perform when the viewpoint of this geo view changes.
    ///
    /// Viewpoints received by the `action` closure will not have a camera.
    /// - Parameters:
    ///   - kind: The kind of viewpoint passed to the `action` closure.
    ///   - action: The closure to perform when the viewpoint has changed.
    func onViewpointChanged(kind: ArcGIS.Viewpoint.Kind, perform action: @escaping (_ newViewpoint: ArcGIS.Viewpoint) -> Void) -> Self

    /// Sets the selection color for all graphic overlays and selectable layers
    /// of this geo view.
    ///
    /// The default selection color is cyan.
    /// - Parameter color: The selection color to use for this geo view.
    func selectionColor(_ color: Color) -> Self

    /// Sets the zoom factor for this geo view.
    /// - Parameter zoomFactor: The zoom factor for animated zooming in and out
    ///   in this geo view.
    func zoomFactor(_ zoomFactor: Double) -> Self
}

/// A proxy type that provides access to the operations of the ``GeoView``.
/// - Note: See Also: ``setViewpoint(_:duration:)``, ``identify(on:screenPoint:tolerance:returnPopupsOnly:maximumResults:)-1rsga``
/// - Since: 200.1
public protocol GeoViewProxy {

    /// A Boolean value indicating whether the view's content wraps around the dateline.
    /// - Precondition: The geo view reader must contain a single geo view.
    var wrapAroundIsEnabled: Bool { get }

    /// Provides an image depicting the view's current display.
    /// - Returns: An image of the view's current display.
    func exportImage() async throws -> UIImage

    /// Performs an identify operation on the specified graphics overlay.
    /// - Parameters:
    ///   - graphicsOverlay: The overlay on which to perform the identify.
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify
    ///   a circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only overlays with popups will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/popups``. If
    ///   `false`, all overlays (with or without popups) will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/graphics``.
    ///   - maximumResults: The maximum number of graphics which can be
    ///   identified. A value of `1` means that only the top-most graphic will
    ///   be identified. A value of `nil` means that the number of results will
    ///   not be limited.
    /// - Returns: An ``IdentifyGraphicsOverlayResult`` value.
    func identify(on graphicsOverlay: ArcGIS.GraphicsOverlay, screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool, maximumResults: Int?) async throws -> ArcGIS.IdentifyGraphicsOverlayResult

    /// Performs an identify operation on all graphics overlays.
    /// - Remark: Results are returned in top-to-bottom order.
    /// - Parameters:
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only overlays with popups will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/popups``. If
    ///   `false`, all overlays (with or without popups) will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/graphics``.
    ///   - maximumResultsPerOverlay: The maximum number of graphics which can
    ///   be identified per overlay. A value of `1` means only the top-most
    ///   graphic per overlay will be identified. A value of `nil` means that
    ///   the number of results per layer will not be limited.
    /// - Returns: An array of ``IdentifyGraphicsOverlayResult`` values.
    func identifyGraphicsOverlays(screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool, maximumResultsPerOverlay: Int?) async throws -> [ArcGIS.IdentifyGraphicsOverlayResult]

    /// Performs an identify operation on the specified layer.
    /// - Parameters:
    ///   - layer: The layer on which to perform the identify.
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only layers with popups will be identified and the
    ///   results will be in ``IdentifyLayerResult/popups``. If `false`, all
    ///   overlays (with or without popups) will be identified and the results
    ///   will be in ``IdentifyLayerResult/geoElements``.
    ///   - maximumResults: The maximum number of elements which can be
    ///   identified. A value of `1` indicates only the top-most element per
    ///   layer and sublayer will be identified. A value of `nil` means that
    ///   the number of results per layer will not be limited.
    /// - Returns: An ``IdentifyLayerResult`` value.
    func identify(on layer: ArcGIS.Layer, screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool, maximumResults: Int?) async throws -> ArcGIS.IdentifyLayerResult

    /// Performs an identify operation on all layers in the geo view.
    /// - Parameters:
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only layers with popups will be identified and the
    ///   results will be in ``IdentifyLayerResult/popups``. If `false`, all
    ///   layers (with or without popups) will be identified.
    ///   - maximumResultsPerLayer: The maximum number of elements which can be
    ///   identified per layer or sublayer. A value of `1` means that only
    ///   the top-most element per layer and sublayer will be identified. A
    ///   value of `nil` means that the number of results per layer will not be
    ///   limited.
    /// - Returns: An array of ``IdentifyLayerResult`` values.
    func identifyLayers(screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool, maximumResultsPerLayer: Int?) async throws -> [ArcGIS.IdentifyLayerResult]

    /// Sets the viewpoint of the geo view to that of the provided bookmark.
    /// - Parameter bookmark: The bookmark whose viewpoint will be used.
    /// - Returns: A Boolean value indicating whether the operation continued
    /// until the end without any interruption.
    @discardableResult
    func setBookmark(_ bookmark: ArcGIS.Bookmark) async throws -> Bool

    /// Retrieves the current view state for the specified layer.
    /// - Parameter layer: The layer to get the view state for.
    /// - Returns: A ``LayerViewState`` value.
    /// - Precondition: The geo view reader must contain a single geo view.
    func viewState(for layer: ArcGIS.Layer) -> ArcGIS.LayerViewState?

    /// Pan or zoom the geo view using animation to the specified viewpoint. Animation
    /// takes place over the specified duration.
    /// - Parameters:
    ///   - viewpoint: The viewpoint.
    ///   - duration: The amount of time in seconds to move to the new viewpoint.
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Geo view reader must contain a geo view.
    @discardableResult
    func setViewpoint(_ viewpoint: ArcGIS.Viewpoint, duration: TimeInterval?) async -> Bool
}

/// An error than can occur when dealing with locators.
/// - Since: 200.1
public enum GeocodeError : Error {

    /// Geocode unsupported file format.
    case unsupportedFileFormat

    /// Geocode unsupported spatial reference.
    case unsupportedSpatialReference

    /// Geocode unsupported projection transformation.
    case unsupportedProjectionTransformation

    /// Geocoder creation error.
    case geocoderCreation

    /// Geocode intersections not supported.
    case intersectionsNotSupported

    /// Uninitialized geocode task.
    case uninitializedGeocodeTask

    /// Invalid geocode locator properties.
    case invalidLocatorProperties

    /// Geocode required field missing.
    case requiredFieldMissing

    /// Geocode cannot read address.
    case cannotReadAddress

    /// Geocoding not supported.
    case reverseGeocodingNotSupported

    /// Geocode geometry type not supported.
    case geometryTypeNotSupported

    /// Geocode suggest address not supported.
    case suggestAddressNotSupported

    /// Geocode suggest result corrupt.
    case suggestResultCorrupted

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension GeocodeError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.GeocodeError, b: ArcGIS.GeocodeError) -> Bool
}

extension GeocodeError : Hashable {
}

/// A structure that describes a geocode method parameters.
///
/// Structure holding the parameters to support the geocode operation for a geocoding service or local locator.
/// - Since: 200.1
final public class GeocodeParameters {

    /// Creates a new geocode parameters object.
    public convenience init()

    /// Categories.
    ///
    /// Determines addresses from which the categories should be returned.
    /// - Note: See Also: `Array`
    final public var categories: [String] { get }

    /// Adds a sequence of `String` values to the end of the `categories` property.
    /// - Parameter newCategories: The new `String` values to append.
    final public func addCategories<S>(_ newCategories: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `categories` property.
    /// - Parameter newCategory: The new `String` value to append.
    final public func addCategory(_ newCategory: String)

    /// Inserts a collection of `String` values into the `categories` property at the specified position.
    /// - Parameters:
    ///   - newCategories: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertCategories<C>(_ newCategories: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `categories` property at the specified position.
    /// - Parameters:
    ///   - newCategory: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertCategory(_ newCategory: String, at index: Int)

    /// Removes all values from the `categories` property.
    final public func removeAllCategories()

    /// Removes a sequence of `String` values from the `categories` property.
    /// - Parameter categories: The `String` values to remove.
    final public func removeCategories<S>(_ categories: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `categories` property.
    /// - Parameter category: The `String` value to remove.
    final public func removeCategory(_ category: String)

    /// Country code.
    ///
    /// Determines addresses from which the country should be returned.
    /// - Note: See Also: `String`
    final public var countryCode: String

    /// For storage property.
    ///
    /// Specifies whether the results of the operation will be persisted.
    /// The default value is `false`, which indicates the results of the operation can't be stored.
    /// If you store the results, in a database for example, you need to set this parameter to `true`.
    final public var isForStorage: Bool

    /// Max results.
    ///
    /// Determines the maximum count of candidates which should be returned. By default should be returned all found candidates.
    final public var maxResults: Int

    /// Min score.
    ///
    /// Determines addresses the minimal score value (score threshold) [0..100].
    /// By default used 0 and get real value from locator properties.
    final public var minScore: Double

    /// Output language code.
    ///
    /// Determines the language of candidate labels which should be returned.
    /// - Note: See Also: `String`
    final public var outputLanguageCode: String

    /// Output spatial reference.
    ///
    /// The spatial reference for candidate geometries.
    /// - Note: See Also: ``SpatialReference``
    final public var outputSpatialReference: ArcGIS.SpatialReference?

    /// Preferred search location.
    ///
    /// Distance specifying with location the preferred area where candidates will be searched.
    /// Supported value from interval [1000..50000], 50000 by default.
    /// - Note: See Also: ``Point``
    final public var preferredSearchLocation: ArcGIS.Point?

    /// Attribute names.
    ///
    /// Array of candidate attribute names indicating which attributes should be returned for every candidate.
    /// For empty array return only default attributes, "*" means all attributes will be returned.
    /// - Note: See Also: `Array`
    final public var resultAttributeNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `resultAttributeNames` property.
    /// - Parameter newResultAttributeNames: The new `String` values to append.
    final public func addResultAttributeNames<S>(_ newResultAttributeNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `resultAttributeNames` property.
    /// - Parameter newResultAttributeName: The new `String` value to append.
    final public func addResultAttributeName(_ newResultAttributeName: String)

    /// Inserts a collection of `String` values into the `resultAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newResultAttributeNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertResultAttributeNames<C>(_ newResultAttributeNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `resultAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newResultAttributeName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertResultAttributeName(_ newResultAttributeName: String, at index: Int)

    /// Removes all values from the `resultAttributeNames` property.
    final public func removeAllResultAttributeNames()

    /// Removes a sequence of `String` values from the `resultAttributeNames` property.
    /// - Parameter resultAttributeNames: The `String` values to remove.
    final public func removeResultAttributeNames<S>(_ resultAttributeNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `resultAttributeNames` property.
    /// - Parameter resultAttributeName: The `String` value to remove.
    final public func removeResultAttributeName(_ resultAttributeName: String)

    /// Search area.
    ///
    /// Envelope specifying the area where candidates will be searched.
    /// - Note: See Also: ``Geometry``
    final public var searchArea: ArcGIS.Geometry?
}

/// A match candidate returned from a ``LocatorTask`` geocode or reverse geocode operation.
///
/// ``GeocodeResult`` provides information about the candidate, such as a collection of requested attribute
/// values, user-friendly label text, and locations suited for accurate match display or for routing input.
/// - Since: 200.1
final public class GeocodeResult {

    /// A collection of attributes as requested by ``GeocodeParameters/resultAttributeNames`` or
    /// ``ReverseGeocodeParameters/resultAttributeNames``.
    ///
    /// Available attributes depend on the data stored with the locator, and can include things like place name,
    /// URL, phone number, and so on.
    /// - Note: See Also: `Dictionary`
    final public var attributes: [String : Any] { get }

    /// Location of the candidate suitable for display on a map.
    ///
    /// For example, this may provide a more precise rooftop location of a house, whereas
    /// ``routeLocation`` represents the nearest street location.
    /// - Note: See Also: ``Point``
    final public var displayLocation: ArcGIS.Point? { get }

    /// An extent suitable for zooming the map to display the candidate.
    /// - Note: See Also: ``Envelope``
    final public var extent: ArcGIS.Envelope? { get }

    /// The ``Point`` provided as input to `LocatorTask.reverseGeocode(forLocation:parameters:)`.
    ///
    /// Only applicable for results of reverse-geocode operations.
    /// - Note: See Also: ``Point``
    final public var inputLocation: ArcGIS.Point? { get }

    /// User-friendly text that describes this result.
    /// - Note: See Also: `String`
    final public var label: String { get }

    /// The nearest street location for the result.
    ///
    /// Use this location if you want to use the candidate as a stop in a route. For example,
    /// ``displayLocation`` may provide a more precise rooftop location of a house,
    /// whereas ``routeLocation`` will provide the nearest street location.
    /// - Note: See Also: ``Point``
    final public var routeLocation: ArcGIS.Point? { get }

    /// A value that indicates how well the address was matched.
    ///
    /// The score is in a range between 0 (no match) and 100 (perfect match).
    final public var score: Double { get }
}

/// A mobile geodatabase containing geographic data and non-spatial tables.
///
/// ``Geodatabase`` is used to open and access the contents of a mobile geodatabase (.geodatabase file) that can
/// contain geographic features, non-spatial tabular data, and data such as attachments, utility networks, field
/// domain definitions, contingent values, and relationships between layers/tables.
///
/// Geodatabases can contain one or more geodatabase feature tables. You can create a layer from a
/// ``GeodatabaseFeatureTable`` tables, as follows:
/// * A ``FeatureLayer`` from any table returned by ``featureTables`` that contains point,
/// polyline, or polygon features. Check that ``FeatureTable/hasGeometry`` is `true`.
/// * An ``AnnotationLayer`` from any table returned by ``annotationTables``.
/// * A ``DimensionLayer`` from any table returned by ``dimensionTables``.
///
/// You can generate a mobile geodatabase file from an ArcGIS feature service and downloaded it to a device using
/// offline workflows offered by the ``GeodatabaseSyncTask`` and the ``OfflineMapTask``. Apps can then operate
/// offline to view and edit the features in these geodatabases. If the geodatabases are enabled for synchronization with
/// the original feature service, edits can be synchronized when connectivity is restored.
///
/// Mobile geodatabase files can also be created with ArcGIS Pro. These geodatabases can be used offline but they
/// do not support synchronization with the original feature service. See
/// [Build offline applications](https://developers.arcgis.com/documentation/mapping-apis-and-services/offline/)
/// for more information.
/// - Since: 200.1
final public class Geodatabase : ArcGIS.Loadable {

    /// The various types of sync models.
    public enum SyncModel {

        /// The geodatabase is not sync enabled.
        case disabled

        /// Layers within a geodatabase cannot be synchronized independently, the whole geodatabase must be synced. The sync operation and sync direction applies to all the layers in the geodatabase.
        case geodatabase

        /// Layers within a geodatabase can be synchronized independently of one another. Any subset of the layers can be synchronized when running the sync operation. Also, each layer's sync direction can be set independently.
        case layer

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Geodatabase.SyncModel, b: ArcGIS.Geodatabase.SyncModel) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a geodatabase object with the given path.
    ///
    /// If the specified path points to a stand-alone mobile geodatabase created with ArcGIS Pro and contains a controller dataset,
    /// such as a utility network or parcel fabric, the feature tables on this geodatabase are read-only.
    /// The presence of utility networks can be checked using ``utilityNetworks``.
    /// - Parameter fileURL: Path to geodatabase (including .geodatabase file extension).
    public convenience init(fileURL: URL)

    /// A collection of ``GeodatabaseFeatureTable`` from the geodatabase that contain annotation features.
    ///
    /// The collection is empty if the geodatabase is not loaded.
    final public var annotationTables: [ArcGIS.GeodatabaseFeatureTable] { get }

    /// A collection of ``GeodatabaseFeatureTable`` from the geodatabase that contain dimension features.
    ///
    /// The collection is empty if the geodatabase is not loaded.
    final public var dimensionTables: [ArcGIS.GeodatabaseFeatureTable] { get }

    /// A collection of the domains that exist in the geodatabase.
    ///
    /// The collection will be empty if the geodatabase is not loaded.
    @ArcGIS.Streamed final public var domains: [ArcGIS.Domain] { get }

    final public var $domains: AsyncStream<[ArcGIS.Domain]> { get }

    /// A collection of ``GeodatabaseFeatureTable`` from the geodatabase that contain geometries, such as points, lines or polygons.
    ///
    /// Feature tables in this array are read-only when the geodatabase is a stand-alone mobile
    /// geodatabase created with ArcGIS Pro and tables participate in a controller dataset, such as a
    /// utility network or parcel fabric. The presence of utility networks can be checked using
    /// ``utilityNetworks``.
    ///
    /// The collection will be empty if the geodatabase is not loaded.
    final public var featureTables: [ArcGIS.GeodatabaseFeatureTable] { get }

    /// The path to the geodatabase.
    final public var fileURL: URL { get }

    /// The geometry that was used to generate the sync-enabled geodatabase.
    ///
    /// If the geodatabase was created using the ``GenerateGeodatabaseJob``, the geometry matches the
    /// ``GenerateGeodatabaseParameters/extent``. If the geodatabase was created using the ``GenerateOfflineMapJob``,
    /// the geometry reflects the ``GenerateOfflineMapParameters/areaOfInterest``. If the geodatabase was downloaded
    /// as part of a ``PreplannedMapArea``, this property will match the geometry used by the web map author when
    /// the offline map area was created. See [Build offline applications](https://developers.arcgis.com/documentation/mapping-apis-and-services/offline/)
    /// for more information on taking data offline.
    ///
    /// Edits made to a sync-enabled ``Geodatabase`` must intersect this geometry. If an edit is made
    /// outside this extent, or area of interest, it will be rejected.
    ///
    /// This property is `nil` if the geodatabase was authored using ArcGIS Pro or if the ``Geodatabase``.
    /// loadStatus is not `LoadStatus.loaded`.
    final public var geometryUsedInGeneration: ArcGIS.Geometry? { get }

    /// `true` if the geodatabase has local edits, `false` otherwise.
    ///
    /// If the geodatabase was created by ArcGIS Pro, this method returns `false` because there is no concept of uploading or applying edits.
    /// If you want to determine which tables have local edits, examine `GeodatabaseFeatureTable.hasLocalEdits(since:)`.
    final public var hasLocalEdits: Bool { get }

    /// `true` if a transaction is active on the geodatabase, `false` otherwise.
    ///
    /// A transaction manages a series of geodatabase edits as a single unit of work. You can start a
    /// transaction by calling `Geodatabase.beginTransaction()`. All edits made after this call are
    /// part of the transaction.
    ///
    /// A geodatabase transaction stays active until you end it by calling `Geodatabase.commitTransaction()` or
    /// `Geodatabase.rollbackTransaction()`. `Geodatabase.commitTransaction()` saves all edits in the transaction
    /// to the geodatabase and ends the transaction. `Geodatabase.rollbackTransaction()` discards all edits in the
    /// transaction and ends the transaction.
    ///
    /// If the app unexpectedly disconnects from the database, any active transaction will be rolled back. If the app
    /// crashes, or the user closes the app without saving edits, the transaction will be rolled back and the edits
    /// discarded.
    /// - Note: See Also: `Geodatabase.beginTransaction()`, `Geodatabase.rollbackTransaction()`, `Geodatabase.commitTransaction()`
    @ArcGIS.Streamed final public var isInTransaction: Bool { get }

    final public var $isInTransaction: AsyncStream<Bool> { get }

    /// The service URL from which the geodatabase was obtained.
    final public var serviceURL: URL? { get }

    /// The sync ID of the geodatabase.
    ///
    /// Sync ID is available if ``syncIsEnabled`` is `true`. The sync ID is the same as the
    /// replica ID described in the REST documentation. It is used by the geodatabase's service to
    /// uniquely identify the geodatabase when carrying out sync operations. It is also used to unregister
    /// the geodatabase using the GeodatabaseSyncTask.unregisterGeodatabaseAsync(GUID).
    /// - Note: See Also: `GeodatabaseSyncTask.unregisterGeodatabase(withSyncID:)`
    final public var syncID: UUID? { get }

    /// `true` if the geodatabase was originally downloaded from a sync-enabled ArcGIS feature service, `false` otherwise.
    ///
    /// A sync-enabled geodatabase can be requested from an ArcGIS feature service using the
    /// ``GenerateGeodatabaseJob`` or the ``GenerateOfflineMapJob``. It can also be downloaded as part of
    /// a ``PreplannedMapArea``. See ``GeodatabaseSyncTask`` and ``OfflineMapTask`` for more information.
    ///
    /// If `true`, the geodatabase's data can be synchronized with its original ArcGIS feature service.
    /// - Note: See Also: ``GeodatabaseSyncTask``, ``OfflineMapTask``
    final public var syncIsEnabled: Bool { get }

    /// The sync model defining how datasets within the geodatabase are synchronized with the originating ArcGIS feature service.
    ///
    /// Sync model only applies to the geodatabase if ``syncIsEnabled`` is `true`.
    final public var syncModel: ArcGIS.Geodatabase.SyncModel? { get }

    /// The collection of ``UtilityNetwork`` objects that are packaged within the ``Geodatabase``.
    ///
    /// The collection will be empty if the geodatabase is not loaded or if no utility networks exist in the geodatabase.
    final public var utilityNetworks: [ArcGIS.UtilityNetwork] { get }

    /// Gets a feature table containing annotation features from the geodatabase, as specified by the given tableName.
    /// - Parameter tableName: The name of the geodatabase feature table containing annotation features.
    /// - Returns: If the specified table does not contain annotation feature data, then no table is returned.
    final public func annotationTable(named tableName: String) -> ArcGIS.GeodatabaseFeatureTable?

    /// Gets a feature table containing annotation features from the geodatabase, as specified by the given feature service layer ID.
    ///
    /// The service layer ID must match the ``ArcGISFeatureLayerInfo/serviceLayerID``.
    /// - Parameter serviceLayerID: The service layer ID of the geodatabase feature table containing annotation features.
    /// - Returns: If the specified table does not contain annotation feature data, then no table is returned.
    final public func annotationTable(withServiceLayerID serviceLayerID: Int) -> ArcGIS.GeodatabaseFeatureTable?

    /// Starts a transaction on the geodatabase.
    ///
    /// This method starts a new transaction on the geodatabase. The transaction fails to begin if another
    /// transaction is already active. A geodatabase cannot be synchronized while a transaction is active.
    final public func beginTransaction() throws

    /// Closes the connection to the geodatabase.
    ///
    /// You should stop using the geodatabase before you close it. For example, you should terminate
    /// geodatabase synchronization, remove feature layers from maps, and release the feature tables. Any
    /// attempt to access the geodatabase after it is closed will fail, resulting in an error. After closing
    /// a geodatabase, you can delete the geodatabase file from the device.
    final public func close()

    /// Commits the edits in the transaction to the geodatabase.
    ///
    /// Commits the edits in the current transaction to the geodatabase. This will also end the transaction.
    /// An error will be thrown if a transaction has not been started on the geodatabase.
    final public func commitTransaction() throws

    /// Creates an empty mobile geodatabase at the specified path.
    ///
    /// The path must be non-empty, available, allow read/write access, and end in ".geodatabase".
    /// If any of these restrictions are violated, the task will not succeed and a task error will be set.
    /// - Parameter fileURL: The path at which the mobile geodatabase is created.
    /// - Returns: A ``Geodatabase`` in a loaded state, if one was able to be created at the specified path.
    final public class func createEmpty(fileURL: URL) async throws -> ArcGIS.Geodatabase

    /// Deletes the domain with the specified name from the geodatabase.
    ///
    /// Deleting domains is only supported in mobile geodatabases (either created in Pro or via `Geodatabase.createEmpty(fileURL:)`).
    /// The domain with the specified name must exist in the geodatabase. The domain must not be in use by any fields in
    /// existing tables.
    /// - Parameter domainName: The name of the domain to delete.
    final public func deleteDomain(named domainName: String) async throws

    /// Gets a feature table containing dimension features from the geodatabase, as specified by the given tableName.
    /// - Parameter tableName: The name of the geodatabase feature table containing dimension features.
    /// - Returns: If the specified table does not contain dimension feature data, then no table is returned.
    final public func dimensionTable(named tableName: String) -> ArcGIS.GeodatabaseFeatureTable?

    /// Gets a feature table containing dimension features from the geodatabase, as specified by the given feature service layer ID.
    ///
    /// The service layer ID must match the ``ArcGISFeatureLayerInfo/serviceLayerID``.
    /// - Parameter serviceLayerID: The service layer ID of the geodatabase feature table containing dimension features.
    /// - Returns: If the specified table does not contain dimension feature data, then no table is returned.
    final public func dimensionTable(withServiceLayerID serviceLayerID: Int) -> ArcGIS.GeodatabaseFeatureTable?

    /// Gets a feature table from the geodatabase containing point, line, or polygon features, as specified by the given tableName.
    /// - Parameter tableName: The name of the geodatabase feature table containing point, line, or polygon features.
    /// - Returns: If the specified table contains annotation or dimension feature data, then no table is returned.
    final public func featureTable(named tableName: String) -> ArcGIS.GeodatabaseFeatureTable?

    /// Gets a feature table from the geodatabase containing point, line or polygon features, as specified by the given feature service layer ID.
    ///
    /// The feature table returned is read-only when the geodatabase is a stand-alone mobile geodatabase created with ArcGIS Pro
    /// and the table participates in a controller dataset, such as a utility network or parcel fabric. The presence of utility networks
    /// can be checked using ``utilityNetworks``.
    /// - Parameter serviceLayerID: The service layer ID of the geodatabase feature table containing point, line or polygon features.
    /// - Returns: If the given layer ID matches
    /// a table in the geodatabase containing annotation or dimension feature data, then no table is returned.
    final public func featureTable(withServiceLayerID serviceLayerID: Int) -> ArcGIS.GeodatabaseFeatureTable?

    /// Creates a new domain in the geodatabase.
    ///
    /// Creating domains is only supported in mobile geodatabases (either created in Pro or via `Geodatabase.createEmpty(fileURL:)`).
    /// The ``FieldType`` of the domain cannot be unknown. The domain name must not already exist in the geodatabase.
    /// For additional domain name constraints, see ``DomainDescription/name``.
    /// - Parameter domainDescription: The description of the domain to create.
    /// - Returns: A ``Domain`` if one was able to be created.
    final public func makeDomain(description domainDescription: ArcGIS.DomainDescription) async throws -> ArcGIS.Domain

    /// Rollback the edits in the transaction from the geodatabase.
    ///
    /// Discards the edits in the current transaction from the geodatabase. This will also end the transaction.
    /// An error will be thrown if a transaction has not been started on the geodatabase.
    final public func rollbackTransaction() throws

    /// Gets an ``UtilityNetwork`` from the geodatabase with the specified utility network name.
    /// - Parameter utilityNetworkName: The name of the utility network.
    /// - Returns: If the specified utility network is not found, then no ``UtilityNetwork`` is returned.
    final public func utilityNetwork(named utilityNetworkName: String) -> ArcGIS.UtilityNetwork?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension Geodatabase {

    /// The minimum server generation number for the geodatabase.
    /// - Remark: Server generation numbers indicate the state of a geodatabase
    /// (or individual layers) with respect to changes which have been synced
    /// with the online service. The number increases as new changes from the
    /// online feature service are synced to the local geodatabase.
    ///
    /// If the value of ``syncModel-swift.property`` is
    /// ``SyncModel-swift.enum/geodatabase``, this value will indicate the
    /// server generation number for the entire geodatabase. If the value of
    /// ``syncModel-swift.property`` is ``SyncModel-swift.enum/layer``, this
    /// value will be the lowest server generation number for all of the layers
    /// in the geodatabase. This property will be `nil` if the geodatabase does
    /// not support sync.
    ///
    /// This property will be `nil` until the geodatabase is loaded.
    ///
    /// Note that this property is only required when using advanced workflows
    /// to manually apply pre-generated changes and not when performing a sync
    /// directly against the online service.
    final public var minServerGeneration: Int? { get }

    /// Creates a new table in the geodatabase.
    ///
    /// Creating tables is only supported in mobile geodatabases (either created in Pro or via `Geodatabase.createEmpty(fileURL:)`).
    /// The table name must not already exist in the geodatabase. For additional table name constraints, see `TableDescription.tableName`.
    /// - Parameter tableDescription: The description of the table to create.
    /// - Returns: A `GeodatabaseFeatureTable` in a loaded state, if one was able to be created.
    final public func makeTable(description tableDescription: ArcGIS.TableDescription) async throws -> ArcGIS.GeodatabaseFeatureTable

    /// Deletes an existing table from the geodatabase.
    ///
    /// Deleting tables is only supported in mobile geodatabases (either created in Pro or via `Geodatabase.createEmpty(fileURL:)`).
    /// A table with the specified name must exist in the geodatabase. Attempting further use of a deleted table,
    /// such as rendering it in a feature layer or querying it, may result in errors. Only spatial and non-spatial
    /// tables can be deleted.
    /// - Parameter tableName: The name of the table to delete.
    /// - Throws: An error if the the table was not deleted successfully.
    final public func deleteTable(named tableName: String) async throws
}

extension Geodatabase.SyncModel : Equatable {
}

extension Geodatabase.SyncModel : Hashable {
}

/// A interface for geodatabase dataset.
///
/// Describes functionality common to all geodatabase datasets.
/// - Since: 200.1
public protocol GeodatabaseDataset {

    /// The geodatabase.
    ///
    /// Instance of geodatabase.
    /// - Note: See Also: ``Geodatabase``
    var geodatabase: ArcGIS.Geodatabase? { get }

    /// The name of geodatabase dataset.
    ///
    /// The geodatabase dataset's name.
    /// - Note: See Also: `String`
    var name: String { get }
}

/// Represents the delta files created to synchronize changes to a ``Geodatabase``.
///
/// A delta geodatabase is a file that contains the changes that have occurred since a mobile
/// replica ``Geodatabase`` was last synchronized with its feature service. See
/// https://developers.arcgis.com/rest/services-reference/enterprise/synchronize-replica.htm
/// for an overview of the delta files used in synchronization.
///
/// There are two types of delta geodatabase:
/// * Local edits, performed on the user's device, are exported as an "upload" delta that is
///   applied to the originating feature service
/// * Online edits, performed by other users are requested as a "download" delta which is then
///   applied to the local replica geodatabase.
///
/// Delta geodatabases allow you to troubleshoot sync problems. For example, you can inspect
/// the geodatabase changes or you could send the file to the administrator of the feature
/// service.
///
/// To access the ``GeodatabaseDeltaInfo`` after a sync has completed, set one of the following
/// properties to `true`:
/// * ``SyncGeodatabaseParameters/keepsGeodatabaseDeltas``. This will populate the
///   ``SyncGeodatabaseJob/geodatabaseDeltaInfo`` property.
/// * ``OfflineMapSyncParameters/keepsGeodatabaseDeltas``. This will add instances to the
///   ``OfflineMapSyncJob/geodatabaseDeltaInfos`` property.
/// - Since: 200.1
final public class GeodatabaseDeltaInfo {

    /// The full file path of the downloaded delta file, including the file name and extension.
    ///
    /// This property is the full path to the download delta geodatabase downloaded from the server during a bidirectional
    /// or download sync. The file will be saved to the user's temp directory and will be subject to the system's
    /// policy for cleanup of temporary files.
    /// This property will be `nil` if there were no server changes to download or the sync direction is ``SyncDirection/upload``.
    final public var downloadDeltaURL: URL? { get }

    /// The feature service that is used to sync changes to the geodatabase specified by ``geodatabaseURL``.
    final public var featureServiceURL: URL { get }

    /// The file path to the ``Geodatabase`` that is used to sync changes, including the file name and extension.
    ///
    /// The path refers to a .geodatabase file that is used to sync changes to the service specified by
    /// ``featureServiceURL``. Each sync process can create an "upload" delta file
    /// (``uploadDeltaURL``) and/or a "download" delta file
    /// (``downloadDeltaURL``).
    final public var geodatabaseURL: URL { get }

    /// The full file path of the generated upload delta file, including the file name and extension.
    ///
    /// This property is the full path to the upload delta geodatabase created from the local ``Geodatabase`` during a bidirectional
    /// or upload sync. The file will be saved to the user's temp directory and will be subject to the system's
    /// policy for cleanup of temporary files.
    /// This property will be `nil` if there were no changes to upload or the sync direction is ``SyncDirection/download`` only.
    final public var uploadDeltaURL: URL? { get }
}

/// An error than can occur when dealing with geodatabases.
/// - Since: 200.1
public enum GeodatabaseError : Error {

    /// Geodatabase value out of range.
    case valueOutOfRange

    /// Geodatabase data type mismatch.
    case dataTypeMismatch

    /// Geodatabase invalid XML.
    case badXML

    /// Database already exists.
    case databaseAlreadyExists

    /// Database does not exist.
    case databaseDoesNotExist

    /// Geodatabase name longer than 128 characters.
    case nameLongerThan128Characters

    /// Geodatabase invalid shape type.
    case invalidShapeType

    /// Geodatabase raster not supported.
    case rasterNotSupported

    /// Geodatabase relationship class one to one.
    case relationshipClassOneToOne

    /// Geodatabase item not found.
    case itemNotFound

    /// Geodatabase duplicate code.
    case duplicateCode

    /// Geodatabase missing code.
    case missingCode

    /// Geodatabase wrong item type.
    case wrongItemType

    /// Geodatabase Id field not nullable.
    case idFieldNotNullable

    /// Geodatabase default value not supported.
    case defaultValueNotSupported

    /// Geodatabase table not editable.
    case tableNotEditable

    /// Geodatabase field not found.
    case fieldNotFound

    /// Geodatabase field exists.
    case fieldExists

    /// Geodatabase cannot alter field type.
    case cannotAlterFieldKind

    /// Geodatabase cannot alter field width.
    case cannotAlterFieldWidth

    /// Geodatabase cannot alter field to nullable.
    case cannotAlterFieldToNullable

    /// Geodatabase cannot alter field to editable.
    case cannotAlterFieldToEditable

    /// Geodatabase cannot alter field to deletable.
    case cannotAlterFieldToDeletable

    /// Geodatabase cannot alter geometry properties.
    case cannotAlterGeometryProperties

    /// Geodatabase unnamed table.
    case unnamedTable

    /// Geodatabase invalid type for domain.
    case invalidTypeForDomain

    /// Geodatabase min max reversed.
    case minMaxReversed

    /// Geodatabase field not supported on relationship class.
    case fieldNotSupportedOnRelationshipClass

    /// Geodatabase relationship class key.
    case relationshipClassKey

    /// Geodatabase value is `nil`.
    case valueIsNull

    /// Geodatabase multiple SQL statements.
    case multipleSQLStatements

    /// Geodatabase no SQL statements.
    case noSQLStatements

    /// Geodatabase geometry field missing.
    case geometryFieldMissing

    /// Geodatabase transaction started.
    case transactionStarted

    /// Geodatabase transaction not started.
    case transactionNotStarted

    /// Geodatabase shape requires z.
    case shapeRequiresZ

    /// Geodatabase shape requires m.
    case shapeRequiresM

    /// Geodatabase shape no z.
    case shapeNoZ

    /// Geodatabase shape no m.
    case shapeNoM

    /// Geodatabase shape wrong type.
    case shapeWrongType

    /// Geodatabase cannot update field type.
    case cannotUpdateFieldKind

    /// Geodatabase no rows affected.
    case noRowsAffected

    /// Geodatabase subtype invalid.
    case subtypeInvalid

    /// Geodatabase subtype must be integer.
    case subtypeMustBeInteger

    /// Geodatabase subtypes not enabled.
    case subtypesNotEnabled

    /// Geodatabase subtype exists.
    case subtypeExists

    /// Geodatabase duplicate field not allowed.
    case duplicateFieldNotAllowed

    /// Geodatabase cannot delete field.
    case cannotDeleteField

    /// Geodatabase index exists.
    case indexExists

    /// Geodatabase index not found.
    case indexNotFound

    /// Geodatabase cursor not on row.
    case cursorNotOnRow

    /// Geodatabase internal error.
    case internalError(details: String)

    /// Geodatabase cannot write geodatabase managed fields.
    case cannotWriteGeodatabaseManagedFields

    /// Geodatabase item already exists.
    case itemAlreadyExists

    /// Geodatabase invalid spatial index name.
    case invalidSpatialIndexName

    /// Geodatabase requires spatial index.
    case requiresSpatialIndex

    /// Geodatabase reserved name.
    case reservedName

    /// Geodatabase cannot update schema if change tracking.
    case cannotUpdateSchemaIfChangeTracking

    /// Geodatabase invalid date.
    case invalidDate

    /// Geodatabase database does not have changes.
    case databaseDoesNotHaveChanges

    /// Geodatabase replica does not exist.
    case replicaDoesNotExist

    /// Geodatabase storage type not supported.
    case storageTypeNotSupported

    /// Geodatabase replica model error.
    case replicaModelError

    /// Geodatabase replica client generation error.
    case replicaClientGenError

    /// Geodatabase replica no upload to acknowledge.
    case replicaNoUploadToAcknowledge

    /// Geodatabase last write time in the future.
    case lastWriteTimeInTheFuture

    /// Geodatabase invalid argument.
    case invalidArgument

    /// Geodatabase transportation network corrupt.
    case transportationNetworkCorrupt

    /// Geodatabase transportation network file IO error.
    case transportationNetworkFileIO

    /// Geodatabase feature has pending edits.
    case featureHasPendingEdits

    /// Geodatabase change tracking not enabled.
    case changeTrackingNotEnabled

    /// Geodatabase transportation network file open.
    case transportationNetworkFileOpen

    /// Geodatabase transportation network unsupported.
    case transportationNetworkUnsupported

    /// Geodatabase cannot sync copy.
    case cannotSyncCopy

    /// Geodatabase access control denied.
    case accessControlDenied(details: String)

    /// Geodatabase geometry outside replica extent.
    case geometryOutsideReplicaExtent

    /// Geodatabase upload already in progress.
    case uploadAlreadyInProgress

    /// Geodatabase is closed.
    case databaseClosed

    /// Domain exists.
    case domainAlreadyExists

    /// Geodatabase geometry type not supported.
    case geometryTypeNotSupported

    /// ArcGISFeatureTable requires a global Id field to support adding bulk attachments.
    case attachmentsRequireGlobalIDs

    /// Violated attribute constraint rule.
    case constraintRuleViolation

    /// The evaluation of attribute rules is cyclic or exceeds maximum cascading level.
    case maxRuleEvaluationLevelExceeded
}

extension GeodatabaseError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.GeodatabaseError, b: ArcGIS.GeodatabaseError) -> Bool
}

/// A feature table stored in a Geodatabase.
///
/// For mobile geodatabases created by ArcGIS Pro, renderer information isn't stored in the geodatabase.
/// A default renderer is therefore used to display mobile geodatabase feature tables in a feature layer.
/// In most cases, this default should be replaced with a custom renderer.
/// - Since: 200.1
final public class GeodatabaseFeatureTable : ArcGIS.ArcGISFeatureTable {

    /// Creates a new geodatabase feature table object from the specified table and relationship info.
    /// - Parameters:
    ///   - table: The table from which to create a new table.
    ///   - relationshipInfo: The relationship info specifying which table to create.
    public convenience init(table: ArcGIS.GeodatabaseFeatureTable, relationshipInfo: ArcGIS.RelationshipInfo)

    /// The geodatabase from the geodatabase feature table.
    weak final public var geodatabase: ArcGIS.Geodatabase? { get }

    /// Checks if the geodatabase feature table has local edits since a specific date.
    /// - Parameter date: The date.
    /// - Returns: `true` if it does have local edits, `false` otherwise.
    final public func hasLocalEdits(since date: Date) -> Bool
}

/// An object that represents a geodatabase sync task. Use this in conjunction with a feature service to synchronize offline data.
/// - Since: 200.1
final public class GeodatabaseSyncTask : ArcGIS.APIKeyResource, ArcGIS.Loadable {

    /// Create a geodatabase sync task object using a URL to create an ``ArcGISFeatureServiceInfo``
    ///
    /// To ensure the service info can be loaded, you must call ``featureServiceInfo`` and set any callbacks.
    /// - Parameter url: A URL to a feature service with sync capabilities.
    public convenience init(url: URL)

    /// The feature service info that represents the feature service to synchronize with.
    ///
    /// If this sync task was created from a URL, then ensure the ``ArcGISFeatureServiceInfo`` instance has callbacks set for requests.
    final public var featureServiceInfo: ArcGIS.ArcGISFeatureServiceInfo? { get }

    /// The URL of the feature service to synchronize with.
    ///
    /// This property is only writable when the task is in load status `LoadStatus.notLoaded`.
    final public var url: URL { get }

    /// Imports a geodatabase delta and applies it to the given geodatabase.
    ///
    /// A delta geodatabase contains the changes that have occurred since a mobile replica
    /// ``Geodatabase`` was last-synchronized with the feature service. See
    /// https://developers.arcgis.com/rest/services-reference/enterprise/synchronize-replica.htm
    /// for an overview of the delta files used in synchronization. A "download" delta
    /// geodatabase contains the online edits that will be imported to the local geodatabase.
    ///
    /// The task returned by this method returns an array of ``SyncLayerResult``.
    ///
    /// You should not execute more than one sync on a particular geodatabase at the same time.
    /// This includes any operations that export or import deltas from the local
    /// ``Geodatabase``, which are:
    /// * `GeodatabaseSyncTask.exportDelta(from:to:)`
    /// * `GeodatabaseSyncTask.importDelta(from:into:)`
    /// * ``SyncGeodatabaseJob``
    /// * ``OfflineMapSyncJob``
    /// - Parameters:
    ///   - inputFileURL: The path and filename to import the delta from
    ///   - geodatabase: The geodatabase to apply a delta to.
    /// - Returns: A task that imports a geodatabase delta and has an element type of `Array`. The array
    /// elements are of type ``SyncLayerResult``.
    final public class func importDelta(from inputFileURL: URL, into geodatabase: ArcGIS.Geodatabase) async throws -> [ArcGIS.SyncLayerResult]

    /// Creates default parameters for a generate geodatabase.
    ///
    /// This will populate the parameters with values matching what the service supports.
    /// For example if the service does not support ``Geodatabase/SyncModel-swift.enum/layer`` then ``Geodatabase/SyncModel-swift.enum/geodatabase`` will be used
    /// All layers from the service will be included.
    /// The output spatial reference will be the spatial reference of the given extent.
    /// Attachments are included by default.
    /// - Parameter extent: The extent of the data to be included in the generated geodatabase. Must be non-`nil`.
    /// - Returns: Returns an array of parameters that can be used to generate a geodatabase.
    final public func makeDefaultGenerateGeodatabaseParameters(extent: ArcGIS.Geometry) async throws -> ArcGIS.GenerateGeodatabaseParameters

    /// Returns a job that when started will generate a geodatabase from a service.
    /// - Parameters:
    ///   - parameters: The parameters for generate geodatabase.
    ///   - downloadFileURL: a path including a new filename where the downloaded geodatabase is written to.
    /// - Returns: Returns a job to generate a geodatabase into the specified filename.
    /// The filenames should end in .geodatabase.
    final public func makeGenerateGeodatabaseJob(parameters: ArcGIS.GenerateGeodatabaseParameters, downloadFileURL: URL) -> ArcGIS.GenerateGeodatabaseJob

    /// Returns a job to synchronize a geodatabase back to a service.
    ///
    /// For a successfully completed job the job's result returns an array of
    /// ``SyncLayerResult``, typically the array is empty. If individual edits failed then the
    /// result array provides these errors grouped by each table using ``SyncLayerResult``
    /// instances which in turn contain each edit error.
    ///
    /// You should not execute more than one sync on a particular geodatabase at the same time.
    /// This includes any operations that export or import deltas from the local
    /// ``Geodatabase``, which are:
    /// * `GeodatabaseSyncTask.exportDelta(from:to:)`
    /// * `GeodatabaseSyncTask.importDelta(from:into:)`
    /// * ``SyncGeodatabaseJob``
    /// * ``OfflineMapSyncJob``
    /// - Parameters:
    ///   - parameters: Parameters to use to sync the geodatabase.
    ///   - geodatabase: The geodatabase to sync
    /// - Returns: A job to synchronize a geodatabase.
    final public func makeSyncGeodatabaseJob(parameters: ArcGIS.SyncGeodatabaseParameters, geodatabase: ArcGIS.Geodatabase) -> ArcGIS.SyncGeodatabaseJob

    /// Returns a job to synchronize a geodatabase back to its service using the given sync direction and rollback on failure boolean value.
    ///
    /// If the given sync direction is not compatible with the sync task's feature service, the
    /// returned job will fail.
    ///
    /// You should not execute more than one sync on a particular geodatabase at the same time.
    /// This includes any operations that export or import deltas from the local
    /// ``Geodatabase``, which are:
    /// * `GeodatabaseSyncTask.exportDelta(from:to:)`
    /// * `GeodatabaseSyncTask.importDelta(from:into:)`
    /// * ``SyncGeodatabaseJob``
    /// * ``OfflineMapSyncJob``
    /// - Parameters:
    ///   - syncDirection: Sync direction to use when syncing the geodatabase.
    ///   - rollbackOnFailure: `true` to rollback all changes to the service and/or the geodatabase if the job fails, `false` to accept any of the changes up until the point when the job fails.
    ///   - geodatabase: The geodatabase to sync
    /// - Returns: A job to synchronize a geodatabase.
    final public func makeSyncGeodatabaseJob(syncDirection: ArcGIS.SyncDirection, rollbackOnFailure: Bool, geodatabase: ArcGIS.Geodatabase) -> ArcGIS.SyncGeodatabaseJob

    /// Registers a copy of a sync enabled geodatabase with a service to allow the copy to sync changes.
    ///
    /// This method is typically used as part of services pattern workflow, sometimes known as a pre-planned workflow.
    /// A sync enabled geodatabase is generated centrally and not modified or synced. Copies of this original geodatabase are distributed and loaded onto each user's device.
    /// The copy must first be registered with the service to allow the server to identify changes in subsequent sync operations.
    /// One of the main benefits of this workflow is a reduction in server load to generate geodatabases for many clients.
    /// It is important not to sync the copy before registering to ensure the server can maintain consistent state on each copy.
    /// This operation is not the opposite of `GeodatabaseSyncTask.unregisterGeodatabase(_:)` which is used to
    /// remove a geodatabase from the service prior to deletion.
    /// - Parameter geodatabase: a geodatabase to register.
    final public func registerSyncEnabledGeodatabase(_ geodatabase: ArcGIS.Geodatabase) async throws

    /// Unregisters a geodatabase from a service removing the services replica id.
    ///
    /// After unregistering a geodatabase it can no longer be synced back to the service.
    /// This is often used prior to deleting a local geodatabase.
    /// This operation is not related to `GeodatabaseSyncTask.registerSyncEnabledGeodatabase(_:)`, which is for registering copies of a sync enabled geodatabase.
    /// - Parameter geodatabase: a geodatabase to unregister.
    final public func unregisterGeodatabase(_ geodatabase: ArcGIS.Geodatabase) async throws

    /// Unregisters a geodatabase from a service removing the service's replica id. This overload uses the geodatabase's
    /// sync ID rather than a reference to the geodatabase itself.
    ///
    /// This method is used to unregister a geodatabase from a service using the sync ID. This is commonly used to
    /// enable cleanup of the service after the local geodatabase has already been deleted. See ``Geodatabase/syncID``.
    /// After unregistering a geodatabase it can no longer be synced back to the service.
    /// This operation is not related to `GeodatabaseSyncTask.registerSyncEnabledGeodatabase(_:)`, which is for registering copies of a sync enabled geodatabase.
    /// - Parameter syncID: sync ID of geodatabase to unregister.
    final public func unregisterGeodatabase(withSyncID syncID: UUID) async throws

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension GeodatabaseSyncTask {

    /// Generates an upload delta geodatabase file containing all the changes since the last sync.
    /// - Remark: A delta geodatabase contains the changes that have occurred since a mobile replica
    /// ``Geodatabase`` was last-synchronized with the feature service. See
    /// this [URL](https://developers.arcgis.com/rest/services-reference/enterprise/synchronize-replica.htm)
    /// for an overview of the delta files used in synchronization.
    ///
    /// An "upload" delta geodatabase contains the local edits, performed on the user's device, to be sent to the
    /// originating feature service.
    ///
    /// When you run this task, any local edits in the geodatabase will be exported to the
    /// specified output path. The output path should include the full path and file name
    /// (ending in ".geodatabase") for the export.
    ///
    /// The delta file created by this method is not sent to the server and has no impact on
    /// any subsequent sync job. You can call this method repeatedly without affecting the
    /// state of the local geodatabase.
    ///
    /// You should not execute more than one sync on a particular geodatabase at the same time.
    /// This includes any operations that export or import deltas from the local
    /// geodatabase, which are:
    /// - ``GeodatabaseSyncTask/exportDelta(from:to:)``
    /// - ``GeodatabaseSyncTask/importDelta(from:into:)``
    /// - ``SyncGeodatabaseJob``
    /// - ``OfflineMapSyncJob``
    /// - Parameters:
    ///   - geodatabase: The geodatabase to generate a delta from.
    ///   - outputFileURL: The path and filename to save the generated delta to.
    /// - Throws: An error if the delta geodatabase was not generated.
    /// - Note: See Also: ``SyncGeodatabaseParameters/keepsGeodatabaseDeltas``
    final public class func exportDelta(from geodatabase: ArcGIS.Geodatabase, to outputFileURL: URL) async throws

    /// Creates default parameters for a sync geodatabase job.
    /// - Remark: This will populate the parameters with values matching what
    /// the sync task's feature service and the geodatabase supports. For a
    /// geodatabase with ``Geodatabase/SyncModel-swift.enum/layer`` then all
    /// geodatabase layers will be included. A service is editable if it has
    /// capabilities that include any of create, update or delete. In this case
    /// both ``SyncDirection/bidirectional`` and ``SyncDirection/upload`` are
    /// supported sync directions. Alternatively, a service that does not have
    /// create, update or delete capability is considered read-only and only
    /// ``SyncDirection/download`` will be supported. If the given sync
    /// direction is not compatible with the sync task's feature service or the
    /// geodatabase is not sync enabled, the returned task will fail.
    /// - Parameters:
    ///   - geodatabase: A geodatabase to sync.
    ///   - syncDirection: The sync direction to use.
    /// - Returns: A sync parameters object.
    final public func makeDefaultSyncGeodatabaseParameters(geodatabase: ArcGIS.Geodatabase, syncDirection: ArcGIS.SyncDirection? = nil) async throws -> ArcGIS.SyncGeodatabaseParameters
}

/// The required parameters for calling the geometry engine's ellipse geodesic
/// method.
///
/// The supported geometry types are ``Polygon``, ``Polyline``, and
/// ``Multipoint``.
/// - Since: 200.1
public struct GeodesicEllipseParameters<Geometry> : Hashable where Geometry : ArcGIS.Geometry {

    /// The direction of the major axis of the ellipse as an angle in units of `AngularUnit`.
    public var axisDirection: Double

    /// The unit of measure for `axisDirection`.
    public var angularUnit: ArcGIS.AngularUnit

    /// The center of the ellipse.
    public var center: ArcGIS.Point?

    /// The unit of measure for `semiAxis1Length`, `semiAxis2Length` and `maxSegmentLength`.
    public var linearUnit: ArcGIS.LinearUnit

    /// The max number of vertices in the ellipse.
    public var maxPointCount: Int

    /// The max segment length of the result.
    public var maxSegmentLength: Double

    /// The length of the semi-major or semi-minor axis of the ellipse.
    public var semiAxis1Length: Double

    /// The length of the semi-major or semi-minor axis of the ellipse. If `semiAxis1Length` = `semiAxis2Length`
    /// then a geodesic circle is created.
    public var semiAxis2Length: Double

    /// Creates a new ``GeodesicEllipseParameters`` object with the given values.
    /// - Parameters:
    ///   - axisDirection: The direction of the major axis of the ellipse as an angle in units of `angularUnit`.
    ///   - angularUnit: The angular unit of measure. The default is `degrees`.
    ///   - center: The center of the ellipse.
    ///   - linearUnit: The linear unit of measure. The default is `meters`.
    ///   - maxPointCount: The max number of vertices in the ellipse.
    ///   - maxSegmentLength: The max segment length of the result approximation in units of `linearUnit`.
    ///   - semiAxis1Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`
    ///   - semiAxis2Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`.
    public init(axisDirection: Double = 0, angularUnit: ArcGIS.AngularUnit = .degrees, center: ArcGIS.Point? = nil, linearUnit: ArcGIS.LinearUnit = .meters, maxPointCount: Int = 10, maxSegmentLength: Double = 0, semiAxis1Length: Double = 0, semiAxis2Length: Double = 0) where Geometry : ArcGIS.Multipart

    /// Creates a new ``GeodesicEllipseParameters`` object with the given values.
    /// - Parameters:
    ///   - axisDirection: The direction of the major axis of the ellipse as an angle in units of `angularUnit`.
    ///   - angularUnit: The angular unit of measure. The default is `degrees`.
    ///   - center: The center of the ellipse.
    ///   - linearUnit: The linear unit of measure. The default is `meters`.
    ///   - maxPointCount: The max number of vertices in the ellipse.
    ///   - maxSegmentLength: The max segment length of the result approximation in units of `linearUnit`.
    ///   - semiAxis1Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`
    ///   - semiAxis2Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`.
    public init(axisDirection: Double = 0, angularUnit: ArcGIS.AngularUnit = .degrees, center: ArcGIS.Point? = nil, linearUnit: ArcGIS.LinearUnit = .meters, maxPointCount: Int = 10, maxSegmentLength: Double = 0, semiAxis1Length: Double = 0, semiAxis2Length: Double = 0) where Geometry == ArcGIS.Multipoint

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.GeodesicEllipseParameters<Geometry>, b: ArcGIS.GeodesicEllipseParameters<Geometry>) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// The required parameters for calling the geometry engine's geodesic sector
/// method.
///
/// The supported geometry types are ``Polygon``, ``Polyline``, and
/// ``Multipoint``.
/// - Since: 200.1
public struct GeodesicSectorParameters<Geometry> : Hashable where Geometry : ArcGIS.Geometry {

    /// The direction of the major axis of the ellipse as an angle in `angularUnit`.
    public var axisDirection: Double

    /// The unit of measure for `axisDirection`, `sectorAngle` and `startDirection`.
    public var angularUnit: ArcGIS.AngularUnit

    /// The center of the ellipse.
    public var center: ArcGIS.Point?

    /// The unit of measure for `semiAxis1Length`, `semiAxis2Length` and `maxSegmentLength`.
    public var linearUnit: ArcGIS.LinearUnit

    /// The max number of vertices in the ellipse.
    public var maxPointCount: Int

    /// The max segment length of the result.
    public var maxSegmentLength: Double

    /// The sweep angle of the sector in `angularUnit`. The sweep angle goes clockwise from the starting radius.
    public var sectorAngle: Double

    /// The length of the semi-major or semi-minor axis of the ellipse.
    public var semiAxis1Length: Double

    /// The length of the semi-major or semi-minor axis of the ellipse. If `semiAxis1Length` = `semiAxis2Length` then a geodesic circle is created.
    public var semiAxis2Length: Double

    /// The direction of starting radius of the sector as an angle in `angularUnit`.
    public var startDirection: Double

    /// Creates a new ``GeodesicSectorParameters`` object with the given values.
    /// - Parameters:
    ///   - axisDirection: The direction of the major axis of the ellipse as an angle in `angularUnit`.
    ///   - angularUnit: The angular unit of measure. The default is `degrees`.
    ///   - center: The center of the ellipse.
    ///   - linearUnit: The linear unit of measure. The default is `meters`.
    ///   - maxPointCount: The max number of vertices in the ellipse.
    ///   - maxSegmentLength: The max segment length of the result approximation in units of `linearUnit`.
    ///   - sectorAngle: The sweep angle of the sector in `angularUnit`.
    ///   - semiAxis1Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`.
    ///   - semiAxis2Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`.
    ///   - startDirection: The direction of starting radius of the sector as an angle in `angularUnit`.
    public init(axisDirection: Double = 0, angularUnit: ArcGIS.AngularUnit = .degrees, center: ArcGIS.Point? = nil, linearUnit: ArcGIS.LinearUnit = .meters, maxPointCount: Int = 10, maxSegmentLength: Double = 0, sectorAngle: Double = 0, semiAxis1Length: Double = 0, semiAxis2Length: Double = 0, startDirection: Double = 0) where Geometry : ArcGIS.Multipart

    /// Creates a new ``GeodesicSectorParameters`` object with the given values.
    /// - Parameters:
    ///   - axisDirection: The direction of the major axis of the ellipse as an angle in `angularUnit`.
    ///   - angularUnit: The angular unit of measure. The default is `degrees`.
    ///   - center: The center of the ellipse.
    ///   - linearUnit: The linear unit of measure. The default is `meters`.
    ///   - maxPointCount: The max number of vertices in the ellipse.
    ///   - maxSegmentLength: The max segment length of the result approximation in units of `linearUnit`.
    ///   - sectorAngle: The sweep angle of the sector in `angularUnit`.
    ///   - semiAxis1Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`.
    ///   - semiAxis2Length: The length of the semi-major or semi-minor axis of the ellipse in the units of `linearUnit`.
    ///   - startDirection: The direction of starting radius of the sector as an angle in `angularUnit`.
    public init(axisDirection: Double = 0, angularUnit: ArcGIS.AngularUnit = .degrees, center: ArcGIS.Point? = nil, linearUnit: ArcGIS.LinearUnit = .meters, maxPointCount: Int = 10, maxSegmentLength: Double = 0, sectorAngle: Double = 0, semiAxis1Length: Double = 0, semiAxis2Length: Double = 0, startDirection: Double = 0) where Geometry == ArcGIS.Multipoint

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.GeodesicSectorParameters<Geometry>, b: ArcGIS.GeodesicSectorParameters<Geometry>) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// The result of a geodetic distance operation.
/// - Since: 200.1
public struct GeodeticDistanceResult : Hashable {

    /// The azimuth at point one towards point two.
    ///
    /// Forward azimuth is the clockwise angle between tangent vector at point one in the direction of the curve
    /// towards point two and meridian passing through the point one.
    public let azimuth1: Measurement<UnitAngle>

    /// The azimuth at point two towards point one.
    ///
    /// Back azimuth is the clockwise angle between tangent vector at point two in the direction of the curve
    /// towards point two and meridian passing through the point two.
    public let azimuth2: Measurement<UnitAngle>

    /// The geodesic distance from the two input points.
    public let distance: Measurement<UnitLength>

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.GeodeticDistanceResult, b: ArcGIS.GeodeticDistanceResult) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Used to transform coordinates of geometries between spatial references that have two different geographic
/// coordinate systems.
///
/// Each geographic transformation has an input and an output spatial reference.
/// The transformation operates on the horizontal (geographic) datums in each spatial reference.
///
/// The inverse of the geographic transformation, if any, used to transform in the
/// opposite direction, may be accessed using a member function.
///
/// A geographic transformation can be constructed from a single
/// geographic transformation step object, or from a list of geographic
/// transformation steps objects that are chained together. Most transformations
/// between spatial references that do not share the WGS 1984 datum use WGS 1984
/// as an intermediate datum. Thus, it is common to create a
/// geographic transformation object with two geographic transformation steps:
/// first to transform from the datum in the input spatial reference to WGS 1984,
/// and then from WGS 1984 to the output spatial reference's datum. There are a
/// limited number of transformations directly between two non-WGS84 datums, such
/// as WKID 4461, which is NAD_1983_HARN_To_NAD_1983_NSRS2007_1. These do not
/// need WGS 1984 as an intermediate datum.
///
/// In most cases, you do not need to construct your own ``GeographicTransformation``.
/// You can get a list of suitable transformations for a given input and output
/// spatial reference using one of the functions on the transformation catalog class.
///
/// A geographic transformation object is immutable.
/// - Since: 200.1
final public class GeographicTransformation : ArcGIS.DatumTransformation {

    /// Create a single step transformation.
    /// - Parameter step: A ``GeographicTransformationStep`` instance.
    public convenience init(step: ArcGIS.GeographicTransformationStep)

    /// Create a multi-step transformation from one or more ``GeographicTransformationStep`` instances.
    ///
    /// Use this when the multi-step transformation is known in advance.
    /// The output of each step should match the input of the following step. Then,
    /// you can use the new multi-step transformation where you would use a
    /// single-step transformation.
    /// - Parameter steps: An `Array` containing ``GeographicTransformationStep`` instances.
    public convenience init(steps: [ArcGIS.GeographicTransformationStep])

    /// The array of geographic transformation steps that define this geographic transformation.
    final public var steps: [ArcGIS.GeographicTransformationStep] { get }
}

/// Represents a step in the process of transforming between datums.
///
/// Each geographic transformation step can be constructed from a well-known ID
/// (WKID) that represents a geographic transformation. Because the Projection
/// Engine supports thousands of transformations, WKIDs are not presented in the
/// SDK as enumerations. Instead, they are documented in the developers guide.
///
/// The list of supported WKIDs includes a transformation from every supported
/// datum to WGS 1984. Additionally, there is more limited list of
/// transformations directly between two non-WGS84 datums, such as
/// 4461, which is NAD_1983_HARN_To_NAD_1983_NSRS2007_1.
///
/// Transformations with more than one step typically go via WGS84, with one
/// forward and one inverse geographic transformation chained together to get the
/// required geographic coordinates.
///
/// A geographic transformation step object is immutable.
/// - Note: See Also: ``GeographicTransformation``, ``HorizontalVerticalTransformationStep``
/// - Since: 200.1
final public class GeographicTransformationStep {

    /// Creates a new ``GeographicTransformationStep`` instance from a well-known text string.
    /// - Parameter wkText: The well-known text of the geographic transformation step to create.
    public convenience init?(wkText: String)

    /// Creates a new ``GeographicTransformationStep`` instance from a well-known ID.
    ///
    /// Occasionally, WKIDs may change, and older codes may be deprecated in favor of a new code. Both old
    /// (deprecated) and new (latest) WKIDs continue to work for instantiation, as long as they are supported
    /// by the Projection Engine. The ``wkid`` property returns the new (latest)
    /// WKID code.
    /// - Parameter wkid: The well-known ID of the geographic transformation step to create.
    public convenience init?(wkid: ArcGIS.WKID?)

    /// Returns the inverse of this geographic transformation step or `nil` if the transformation is not invertible.
    final public var inverse: ArcGIS.GeographicTransformationStep? { get }

    /// `true` if this geographic transformation step instance is an inverted transformation.
    ///
    /// Transformations have a specific direction that is indicated by the
    /// ``wkText`` value. An inverted transformation is used to transform
    /// geometries in the opposite direction to that indicated by the well-known text. ``GeographicTransformation``
    /// has ``DatumTransformation/inputSpatialReference`` and ``DatumTransformation/outputSpatialReference``
    /// properties that respect the inverse value of the contained transformation(s).
    ///
    /// This API supports a large number of transformation WKIDs, including transformations from every
    /// supported datum to the World Geodetic System 1984 (WGS84) datum. To transform coordinates between two
    /// non-WGS84 datums, typically one forward and one inverse ``GeographicTransformationStep`` are added
    /// to a ``GeographicTransformation``, to get the required inputs and outputs.
    /// - Note: See Also: `GeographicTransformationStep.inverse`
    final public var isInverse: Bool { get }

    /// `true` if any files needed by the Projection Engine for this
    /// geographic transformation step are missing from the local file system.
    final public var isMissingProjectionEngineFiles: Bool { get }

    /// A list of the Projection Engine files required to support this geographic transformation step.
    ///
    /// Each name in the list includes the full path. Projection Engine datasets are used in grid-based transforms.
    final public var projectionEngineFilenames: [String] { get }

    /// The well-known text of this geographic transformation step instance.
    ///
    /// This value does not respect the ``isInverse`` property.
    final public var wkText: String { get }

    /// The well-known ID, or 0 if the transformation in this step does not have a well-known ID.
    ///
    /// Occasionally, WKIDs may change, and an older code may be deprecated in favor of a new code. This property
    /// returns the new (latest) WKID code.
    final public var wkid: ArcGIS.WKID? { get }
}

extension GeographicTransformationStep : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.GeographicTransformationStep, rhs: ArcGIS.GeographicTransformationStep) -> Bool
}

extension GeographicTransformationStep : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// A base class for multilayer symbol geometric effect.
///
/// Geometric effects are components of display rules that dynamically alter the representation of a symbol layer.
/// If a multi layer symbol has multiple layers and an effect is applied to a specific layer it will alter only
/// that layer of the symbol. Currently only dash geometric effect is supported.
/// - Since: 200.1
public class GeometricEffect {

    /// Clones the ``GeometricEffect``.
    /// - Returns: A new ``GeometricEffect`` with the same values as the current ``GeometricEffect``.
    public func clone() -> Self
}

extension GeometricEffect : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.GeometricEffect, rhs: ArcGIS.GeometricEffect) -> Bool
}

extension GeometricEffect : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Base class for all classes that represent geometric shapes.
///
/// ``Geometry`` is the base class for two-dimensional (x,y) or three-dimensional
/// (x,y,z) geometries. Objects that inherit from the ``Geometry`` class may also include a
/// measure (m-value) for each vertex. The ``Geometry`` class provides functionality common
/// to all types of geometry. ``Point``, ``Multipoint``, ``Polyline``, ``Polygon``, and
/// ``Envelope`` all inherit from ``Geometry`` and represent different types of shapes.
///
/// ``Geometry`` represents real-world objects by defining a shape at a specific geographic location.
/// It is used throughout this API to represent the shapes of features and graphics, layer extents,
/// viewpoints, and GPS locations. It is also used, for example, to define inputs and outputs for
/// spatial analysis and geoprocessing operations and to measure distances and areas.
///
/// All types of geometry:
/// * Have a ``SpatialReference`` indicating the coordinate system used by its coordinates
/// * Can be empty, indicating that they have no specific location or shape
/// * May have z-values and/or m-values to define elevation and measures respectively
/// * Can be converted to and from JSON to be persisted or to be exchanged directly with
/// REST services
///
/// Immutability
/// Most geometries are created and not changed for their lifetime. Examples include features
/// created to be stored in a geodatabase or read from a non-editable layer, and features returned
/// from tasks such as a spatial query, geocode operation, network trace, or geoprocessing task.
/// Immutable geometries (geometries that cannot be changed) offer some important benefits to
/// your app. They are inherently thread-safe, help prevent inadvertent changes, and allow for
/// certain performance optimizations.
///
/// Instead of changing the properties of existing geometries, you can create and update geometries
/// using the various subclasses of ``GeometryBuilder`` (for example, ``PolygonBuilder``), which can
/// represent the state of a geometry under construction while allowing modifications, thus enabling
/// editing workflows.
///
/// Additionally, ``GeometryEngine`` offers a range of topological and spatial transformations that
/// read the content of existing geometries and create new geometries, for example, project, buffer,
/// union, and so on. Relational tests such as intersects and overlaps are also available on
/// ``GeometryEngine``.
///
/// Coordinate units
/// The coordinates that define a geometry are only meaningful in the context of the geometry's
/// ``SpatialReference``. The vertices and spatial reference together allow your app to translate a
/// real-world object from its location on the Earth to its location on your map or scene.
///
/// In some cases, a geometry's spatial reference may not be set. For example, a ``Graphic`` that
/// does not have a spatial reference is drawn using the same spatial reference as the `MapView`
/// to which it was added. If the coordinates are in a different spatial reference, the graphics may
/// not display in the correct location, or at all.
///
/// When using ``GeometryBuilder`` to create a ``Polyline`` or ``Polygon`` from a collection of
/// ``Point``, you don't need to set the spatial reference of every point before you add it to
/// the builder, as it is assigned the spatial reference of the builder itself. In most other
/// cases, such as when using a geometry in geometry operations or when editing a feature table,
/// ``spatialReference`` must be set.
///
/// Spatial reference and projection
/// Changing the coordinates of a geometry to have the same shape and location represented using a
/// different ``SpatialReference`` is known as "projection" or sometimes as "reprojection". Because
/// geometries are immutable, they do not have any member methods that project, transform, or
/// otherwise modify their content.
/// - Note: See Also: ``GeometryEngine``, ``GeometryBuilder``, ``GeometryEditor``
/// - Since: 200.1
public class Geometry : ArcGIS.JSONSerializable {

    /// The number of dimensions of the geometry.
    ///
    /// How many dimensions the geometry contains.
    /// - Note: See Also: ``Geometry``, ``Geometry/dimension-swift.property``
    public enum Dimension {

        /// The geometry is a point or multipoint.
        case point

        /// The geometry is a curve.
        case curve

        /// The geometry has an area.
        case area

        /// The geometry has a volume.
        case volume

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Geometry.Dimension, b: ArcGIS.Geometry.Dimension) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The number of dimensions for the geometry.
    /// - Note: See Also: ``Dimension-swift.enum``
    public var dimension: ArcGIS.Geometry.Dimension? { get }

    /// The extent for the geometry.
    ///
    /// The extent for the geometry which is a envelope and contains the same spatial reference
    /// as the input geometry.
    /// - Note: See Also: ``Envelope``
    public var extent: ArcGIS.Envelope { get }

    /// `true` if this geometry contains curve segments; `false` otherwise.
    ///
    /// ArcGIS software supports polygon and polyline geometries that contain curve segments (where
    /// ``Segment/isCurve`` is `true`, sometimes known as `true` curves or nonlinear segments). Curves may be present
    /// in certain types of data - for example Mobile Map Packages (MMPK) or geometry JSON. When connecting to
    /// ArcGIS feature services that support curves (``ArcGISFeatureServiceInfo/supportsTrueCurve``),
    /// this API retrieves densified versions of curve feature geometries by default.
    ///
    /// If a polygon or polyline geometry contains curve segments, this property returns `true`. Prior to v100.12,
    /// it was not possible to access curve segments, and only ``LineSegment`` instances would be returned
    /// when iterating through the segments in a ``Polygon`` or ``Polyline`` object, irrespective of this property.
    ///
    /// From v100.12, you can use curve segments when using a ``MultipartBuilder`` to create or edit polygon and
    /// polyline geometries, and also get curve segments when iterating through the segments of existing
    /// ``Multipart`` geometries when this property returns `true`. You can also choose to return `true` curves from
    /// feature services by using ``ArcGISEnvironment/serviceCurveGeometryMode``.
    /// - Note: See Also: ``GeometryBuilder/hasCurves``, ``Part/hasCurves``, ``Segment/isCurve``, ``CubicBezierSegment``, ``EllipticArcSegment``
    public var hasCurves: Bool { get }

    /// A value indicating if the geometry has M.
    ///
    /// M is a vertex value that is stored with the geometry.
    public var hasM: Bool { get }

    /// A value indicating if the geometry has Z.
    ///
    /// Z typically represent elevations or heights.
    public var hasZ: Bool { get }

    /// Check if a geometry is empty or not.
    ///
    /// Only check the geometry to see if it is empty. Does not check the spatial reference.
    public var isEmpty: Bool { get }

    /// The spatial reference for the geometry.
    ///
    /// If the geometry does not have a spatial reference `nil` is returned.
    /// - Note: See Also: ``SpatialReference``
    public var spatialReference: ArcGIS.SpatialReference? { get }

    /// Creates a geometry from an ArcGIS JSON geometry representation.
    ///
    /// ``Geometry`` can be serialized and de-serialized to and from JSON. The
    /// [ArcGIS REST API documentation](https://developers.arcgis.com/documentation/common-data-types/geometry-objects.htm)
    /// describes the JSON representation of geometry objects.
    /// You can use this encoding and decoding mechanism to exchange geometries with REST Web services
    /// or to store them in text files.
    /// - Parameters:
    ///   - JSON: JSON representation of geometry.
    ///   - spatialReference: The geometry's spatial reference.
    /// - Returns: Geometry converted from a JSON String.
    /// - Note: See Also: ``Geometry``
    public class func fromJSON(_ JSON: String, spatialReference: ArcGIS.SpatialReference?) throws -> Self

    /// Check if two geometries are equal to within some tolerance.
    ///
    /// This function performs a lightweight comparison of two geometries,
    /// such as might be useful when writing test code.
    /// It uses the tolerance to compare each of x, y, and any other values
    /// the geometries possess (such as z or m) independently in the manner:
    /// abs(value1 - value2) <= tolerance.
    /// Returns `true` if the difference of each is within the tolerance and
    /// all other properties of the geometries are exactly equal (spatial
    /// reference, vertex count, etc.).
    /// A single tolerance is used even if the units for the horizontal
    /// coordinates and other values differ, e.g horizontal coordinates in
    /// degrees and vertical coordinates in meters. This function does not
    /// respect modular arithmetic of spatial references which wrap around,
    /// so longitudes of -180 and +180 degrees are considered to differ by
    /// 360 degrees.For topological equality, use relational operators
    /// instead of this function. See `GeometryEngine.isGeometry(_:equivalentTo:)`.
    /// - Parameters:
    ///   - other: The second geometry.
    ///   - tolerance: The tolerance.
    /// - Returns: `true` if the geometries are equal, within the tolerance, otherwise `false`.
    public func isEqual(to other: ArcGIS.Geometry, tolerance: Double) -> Bool

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension Geometry : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Geometry, rhs: ArcGIS.Geometry) -> Bool
}

extension Geometry : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension Geometry {

    /// A Boolean value indicating whether this geometry contains sufficient
    /// points to show a valid graphical sketch.
    ///
    /// This can be used as an initial lightweight check to see whether this is
    /// a non-empty geometry; for example, it may be used to enable or disable
    /// functionality in an editing user interface. The exact requirements vary
    /// depending on the type of geometry:
    /// * A point must contain non-`nan` x,y coordinates
    /// * A multipoint must contain at least one valid Point
    /// * An envelope must contain non-`nan` minimum and maximum x,y coordinates
    /// * A polyline must contain at least one part. Each part must have:
    ///   * At least two valid points, or
    ///   * At least one segment where ``Segment/isCurve`` is `true`
    /// * A polygon must contain at least one part. Each part must have:
    ///   * At least three valid points, or
    ///   * At least one segment where ``Segment/isCurve`` is `true`
    ///
    /// Note that this is not equivalent to topological simplicity, which is
    /// enforced by ``GeometryEngine/simplify(_:)`` and checked using
    /// ``GeometryEngine/isSimple(_:)``. Geometries must be topologically simple
    /// to be successfully saved in a geodatabase or used in some service
    /// operations.
    ///
    /// Does not check the spatial reference.
    public var sketchIsValid: Bool { get }
}

extension Geometry.Dimension : Equatable {
}

extension Geometry.Dimension : Hashable {
}

/// A geometry builder object
/// - Note: See Also: ``GeometryEditor``
/// - Since: 200.1
public class GeometryBuilder<Buildable> where Buildable : ArcGIS.Geometry {

    /// The extent for the geometry in the builder.
    ///
    /// The extent for the geometry in the builder which is a envelope and contains the same spatial reference
    /// as the input geometry.
    /// - Note: See Also: ``Envelope``
    public var extent: ArcGIS.Envelope { get }

    /// A value indicating whether the geometry builder currently contains any curve segments.
    ///
    /// ArcGIS software supports polygon and polyline geometries that contain curve segments (where ``Segment/isCurve`` is `true`, sometimes known as
    /// `true` curves or nonlinear segments). Curves may be present in certain types of data - for example Mobile Map
    /// Packages (MMPKs), or geometry JSON.
    ///
    /// Prior to v100.12, only ``LineSegment`` instances were supported when creating new geometries using a
    /// ``MultipartBuilder``. Attempting to add curve geometries to a ``MultipartBuilder`` would cause an error.
    ///
    /// From v100.12, you can use curves in a ``MultipartBuilder``. New segment types ``CubicBezierSegment`` and
    /// ``EllipticArcSegment`` represent different types of curve that can be added to polygon and polyline
    /// geometries.
    /// - Note: See Also: ``MutablePart/hasCurves``, ``Geometry/hasCurves``, ``Segment/isCurve``
    public var hasCurves: Bool { get }

    /// A value indicating if the geometry builder has M.
    ///
    /// M is a vertex value that is stored with the geometry builder.
    public var hasM: Bool { get }

    /// A value indicating if the geometry builder has Z.
    ///
    /// Z typically represent elevations or heights.
    public var hasZ: Bool { get }

    /// Check if a geometry builder is empty or not.
    ///
    /// Only check the geometry builder to see if it is empty. Does not check the spatial reference.
    public var isEmpty: Bool { get }

    /// Check if a geometry builder contains sufficient points to show a valid graphical sketch.
    ///
    /// This can be used as an initial lightweight check to see if the current state of a builder produces a
    /// non-empty geometry; for example, it may be used to enable or disable functionality in an editing user
    /// interface. The exact requirements vary depending on the type of geometry produced by the builder:
    /// * A ``PointBuilder`` must contain non-`nan` x,y coordinates
    /// * A ``MultipointBuilder`` must contain at least one valid Point
    /// * An ``EnvelopeBuilder`` must contain non-`nan` minimum and maximum x,y coordinates
    /// * A ``PolylineBuilder`` must contain at least one ``MutablePart``. Each ``MutablePart`` it contains must have:
    ///   * At least two valid points, or
    ///   * At least one ``Segment`` where ``Segment/isCurve`` is `true`
    /// * A ``PolygonBuilder`` must contain at least one ``MutablePart``. Each ``MutablePart`` it contains must have:
    ///   * At least three valid points, or
    ///   * At least one ``Segment`` where ``Segment/isCurve`` is `true`
    ///
    /// Note that this is not equivalent to topological simplicity, which is enforced by `GeometryEngine.simplify(_:)`
    /// and checked using `GeometryEngine.isSimple(_:)`. Geometries must be topologically simple to be
    /// successfully saved in a geodatabase or used in some service operations.
    ///
    /// Does not check the spatial reference.
    /// Prior to v100.8, only one part of a multipart polygon or polyline was required to have the minimum number
    /// (2 for a polyline, 3 for a polygon) of points, and only ``LineSegment`` instances were supported in
    /// builders.
    ///
    /// Prior to v100.12, a ``PolygonBuilder`` required at least three valid Points in each ``MutablePart``, and at
    /// least one part.
    public var sketchIsValid: Bool { get }

    /// The spatial reference for the geometry.
    ///
    /// If the geometry does not have a spatial reference `nil` is returned.
    /// - Note: See Also: ``SpatialReference``
    public var spatialReference: ArcGIS.SpatialReference? { get }

    /// Replaces the geometry in the builder with the new geometry.
    ///
    /// This does not update the spatial reference
    /// of the builder. If the geometry is `nil`, the builder is cleared.
    ///
    /// Prior to v100.12, only geometries without curves could be used; passing in a geometry where
    /// ``Geometry/hasCurves`` is `true` would throw an exception.
    ///
    /// From v100.12, geometries with curves are supported.
    /// - Parameter replacement: The geometry object.
    public func replaceGeometry(with replacement: Buildable?)

    /// Creates a geometry with the values in the geometry builder.
    /// - Returns: A geometry. This is passed to geometry functions.
    public func toGeometry() -> Buildable
}

/// Allows you to create new geometries, and change existing geometries, by interacting with a `MapView`.
///
/// To use a ``GeometryEditor``:
/// * Set the `MapView.geometryEditor` property.
/// * Call one of the start methods.
///   * To interactively create new geometries from scratch, call `GeometryEditor.start(withType:)` passing
///     in a `Geometry.Type` to determine the type of geometry created.
///   * For geometry editing workflows, pass an existing ``Geometry`` into `GeometryEditor.start(withInitial:)`.
/// * You can then edit the geometry directly on the map view using mouse or touch gestures.
///   * The ``tool`` determines how you draw on the map to define the new geometry, for example by
///     adding individual vertices or with a freehand gesture. The default tool is ``VertexTool``.
///   * If you passed in an initial geometry, it is displayed in the view, and you can interact with the geometry to
///     make changes.
/// * Call `GeometryEditor.stop()` to return the geometry and prevent the geometry editor from processing any more
///   interactions.
///   * Geometries are immutable, therefore a new ``Geometry`` object reflecting the updates is returned from
///     ``geometry`` and `GeometryEditor.stop()` each time.
///
/// When started (``isStarted`` is `true`), you can interact with the different
/// ``GeometryEditorElement`` objects that compose the representation of the ``geometry`` in the map
/// view. Depending on what is selected, different types of ``GeometryEditorElement`` are returned from
/// ``selectedElement``. Tap to select the different elements and drag to move them. Tap multiple
/// times on an element to select the different types of ``GeometryEditorElement`` representing vertices, parts, and
/// the entire geometry. You can control which interactions are possible by changing the ``InteractionConfiguration``
/// of the current ``tool``. For example, you can change the types of element you can tap to select,
/// and whether they can create new vertices or parts by tapping or dragging on the map. Programmatic changes to the
/// ``geometry`` or ``selectedElement`` (for example
/// `GeometryEditor.selectVertexAt(partIndex:vertexIndex:)` or `GeometryEditor.moveSelectedElement(to:)`) are
/// not affected by the settings in ``InteractionConfiguration``.
///
/// Change the appearance of the geometry by using the ``GeometryEditorStyle`` of the current
/// ``tool`` - for example to match the symbology used by the graphic or feature being edited.
///
/// Programmatic editing methods are also provided so you can augment your interactive geometry editing to
/// support specific user requirements. For example:
/// * Use `GeometryEditor.insertVertex(at:)` to add a subsequent vertex based on a GPS location from
///   ``LocationDisplay``.
/// * Use `GeometryEditor.deleteSelectedElement()` to delete the current
///   ``selectedElement``.
/// * Use `GeometryEditor.moveSelectedElement(to:)` to move the currently selected ``GeometryEditorElement``
///   to a specific ``Point``, or `GeometryEditor.moveSelectedElementBy(deltaX:deltaY:)` to nudge
///   it in a specific direction.
/// * Use `GeometryEditor.replaceGeometry(with:)` to take the current ``geometry``, apply an
///   operation such as a union or intersect by using ``GeometryEngine``, and then replace the current geometry
///   with the result so you can continue to edit as required.
/// * Use `GeometryEditor.undo()` and `GeometryEditor.redo()` to undo and redo individual
///   interactive or programmatic edits.
///
/// Use ``geometry`` and ``selectedElement`` to be notified when a user
/// interaction or API call has changed the ``selectedElement`` or ``geometry``.
/// Changing the geometry state can also change ``canUndo``, which triggers
/// ``canUndo``.
///
/// Starting a ``GeometryEditor`` and a ``GeometryEditor`` in the same view at the same time is likely to cause
/// unexpected behavior.
/// - Since: 200.1
final public class GeometryEditor {

    /// Creates a default ``GeometryEditor``.
    public convenience init()

    /// `true` if there are actions that can be redone on the ``geometry``, `false` otherwise.
    ///
    /// This applies to both programmatic and interactive changes to the ``geometry`` and is useful for
    /// enabling or disabling a UI control for redo actions.
    ///
    /// The value of ``canRedo`` changes, raising the ``canRedo`` event, when:
    /// * an initial action that can be redone is performed in the ``GeometryEditor``, or
    /// * the last remaining action that can be redone was redone
    /// - Note: See Also: `GeometryEditor.redo()`, ``canUndo``
    @ArcGIS.Streamed final public var canRedo: Bool { get }

    final public var $canRedo: AsyncStream<Bool> { get }

    /// `true` if there are actions that can be undone on the ``geometry``, `false` otherwise.
    ///
    /// This applies to both programmatic and interactive changes to the ``geometry`` and is useful for
    /// enabling or disabling a UI control for undo actions.
    ///
    /// The value of ``canUndo`` changes, raising the ``canUndo`` event, when:
    /// * an initial action that can be undone is performed in the ``GeometryEditor``, or
    /// * the last remaining action that can be undone was undone
    /// - Note: See Also: `GeometryEditor.undo()`, ``canRedo``
    @ArcGIS.Streamed final public var canUndo: Bool { get }

    final public var $canUndo: AsyncStream<Bool> { get }

    /// The current geometry, updated as you interact with the view.
    ///
    /// The geometry returned depends on the state of the ``GeometryEditor``:
    /// * Returns `nil` while ``isStarted`` is `false`.
    /// * Returns an empty geometry (``Geometry/isEmpty`` is `true`) immediately after the ``GeometryEditor`` was
    ///   started using `GeometryEditor.start(withType:)`.
    /// * Returns the input geometry immediately after the ``GeometryEditor`` was started using
    ///   `GeometryEditor.start(withInitial:)`.
    /// * Returns the current geometry while the ``GeometryEditor`` is in use (``isStarted`` is `true`).
    ///
    /// The geometry is returned in the spatial reference of the associated `MapView`, if one is set. If there
    /// is no associated `MapView`, and the ``GeometryEditor`` was started by passing a geometry parameter to a
    /// start method, then the spatial reference of that geometry is used. If neither of these cases is `true`, the
    /// spatial reference of the geometry is `nil`.
    ///
    /// The value of ``geometry`` changes, raising the ``geometry``, when:
    /// * starting or stopping the geometry editor - for example using `GeometryEditor.start(withType:)` or
    ///   `GeometryEditor.stop()`
    /// * performing programmatic edits - for example using `GeometryEditor.insertVertex(at:)` or
    ///   GeometryEditor.deleteSelectedElement()
    /// * performing interactive edits - for example adding or moving a vertex
    /// * undoing or redoing edits - using `GeometryEditor.undo()` or `GeometryEditor.redo()`
    /// - Note: See Also: ``selectedElement``
    @ArcGIS.Streamed final public var geometry: ArcGIS.Geometry? { get }

    final public var $geometry: AsyncStream<ArcGIS.Geometry?> { get }

    /// `true` if an editing session is active, `false` otherwise.
    ///
    /// When `true`, interactions with the view can affect the state of the ``geometry`` or
    /// ``selectedElement``.
    ///
    /// Starting or stopping the ``GeometryEditor`` raises the ``isStarted`` event.
    /// - Note: See Also: `GeometryEditor.start(withInitial:)`, `GeometryEditor.start(withType:)`, `GeometryEditor.stop()`
    @ArcGIS.Streamed final public var isStarted: Bool { get }

    final public var $isStarted: AsyncStream<Bool> { get }

    /// `true` if the geometry is visible in the view, `false` otherwise.
    /// - Note: See Also: ``GeometryEditorStyle/opacity``
    final public var isVisible: Bool

    /// The element that is currently selected in the ``GeometryEditor``, or `nil` if nothing is selected.
    ///
    /// Clicking or tapping on the different visible elements of a ``geometry`` in a view allows you
    /// to select and unselect them. This property returns a different type of ``GeometryEditorElement`` depending
    /// on what is selected - a vertex (``GeometryEditorVertex``), a mid-vertex (``GeometryEditorMidVertex``), a
    /// part of a polygon or polyline (``GeometryEditorPart``), or the entire geometry (``GeometryEditorGeometry``).
    /// You can change which selection interactions are allowed by using the ``InteractionConfiguration`` of the
    /// ``tool``.
    ///
    /// You can also programmatically select specific vertices (`GeometryEditor.selectVertexAt(partIndex:vertexIndex:)`),
    /// mid-vertices (`GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`), parts of polygons or polylines
    /// (`GeometryEditor.selectPart(atIndex:)`), or the entire geometry (`GeometryEditor.selectGeometry()`). You
    /// can clear the selection using `GeometryEditor.clearSelection()`.
    ///
    /// The value of ``selectedElement`` changes, raising the
    /// ``selectedElement`` event, when:
    /// * performing programmatic selection - for example using `GeometryEditor.selectGeometry()` or
    ///   GeometryEditor.selectVertex(size_t, size_t)
    /// * performing interactive selection - for example selecting or unselecting a ``GeometryEditorElement``
    /// * the location of the selected element changes - for example moving the selected element programmatically or
    ///   interactively
    /// * performing edits - for example inserting a vertex interactively or deleting the selected element
    ///   programmatically
    ///
    /// It may also change when:
    /// * undoing or redoing edits - using `GeometryEditor.undo()` or `GeometryEditor.redo()`
    /// * stopping the geometry editor using `GeometryEditor.stop()`
    @ArcGIS.Streamed final public var selectedElement: ArcGIS.GeometryEditorElement? { get }

    final public var $selectedElement: AsyncStream<ArcGIS.GeometryEditorElement?> { get }

    /// The tool defining how you interact with the view to create and edit the ``geometry``.
    ///
    /// The default value is a ``VertexTool`` with all interactive operations enabled, providing a common way
    /// of editing points, multipoints, polygons, and polylines.
    ///
    /// The tool can be replaced while a ``GeometryEditor`` is started (``isStarted`` = `true`), enabling a combination of
    /// tools to be used to edit a geometry.
    /// - Note: See Also: ``VertexTool``, ``FreehandTool``
    final public var tool: ArcGIS.GeometryEditorTool

    /// Clears the current geometry being edited.
    ///
    /// Sets ``geometry`` to an empty geometry (``Geometry/isEmpty`` = `true`). The `Geometry.Type`
    /// is maintained - to edit a different type of geometry, restart the ``GeometryEditor`` with the required type.
    /// - Note: See Also: `GeometryEditor.clearSelection()`
    final public func clearGeometry()

    /// Clears the current selection.
    ///
    /// This sets ``selectedElement`` to `nil`. It does not change the ``geometry``.
    /// - Note: See Also: `GeometryEditor.clearGeometry()`
    final public func clearSelection()

    /// Deletes the selected element from the current ``geometry``.
    ///
    /// To clear the selection, but leave the state of the ``geometry`` unchanged, call
    /// `GeometryEditor.clearSelection()` instead.
    /// - Note: See Also: ``selectedElement``, ``InteractionConfiguration/allowsDeletingSelectedElement``
    /// - Precondition: `isStarted`
    /// - Precondition: `selectedElement?.canBeDeleted == true`
    final public func deleteSelectedElement()

    /// Creates a new vertex at the specified location and inserts it after the currently selected element, or appends the point if there is nothing selected.
    ///
    /// If ``geometry`` is empty (``Geometry/isEmpty`` is `true`), the given point is added as the
    /// initial vertex, and then selected. If nothing is selected (``selectedElement`` is `nil`), the
    /// point is appended to the end of the ``geometry``, and then selected. If ``selectedElement``
    /// is the first vertex in a part of a ``Multipart``, the given point is inserted before the currently selected
    /// vertex, and then selected.
    ///
    /// If ``geometry`` is a non-empty ``Point``, this method replaces the existing point with the
    /// given point and selects it.
    /// - Parameter point: The location of the new vertex.
    /// - Note: See Also: ``InteractionConfiguration/allowsVertexCreation``
    /// - Precondition: `isStarted`
    /// - Precondition: `!point.isEmpty`
    final public func insertVertex(at point: ArcGIS.Point)

    /// Moves the selected element to the specified location.
    ///
    /// If ``selectedElement`` is a ``GeometryEditorVertex``, then the location of the vertex is moved to the given
    /// point. If the ``selectedElement`` is any other type of ``GeometryEditorElement``, then the center of the
    /// element is moved to the given point.
    /// - Parameter point: The new location for the selected element.
    /// - Note: See Also: ``InteractionConfiguration/allowsMovingSelectedElement``
    /// - Precondition: `isStarted`
    /// - Precondition: `!point.isEmpty`
    final public func moveSelectedElement(to point: ArcGIS.Point)

    /// Moves the selected element by the specified deltas.
    /// - Parameters:
    ///   - deltaX: The amount to move the selected element along the x-axis, in the units of the ``geometry`` spatial reference.
    ///   - deltaY: The amount to move the selected element along the y-axis, in the units of the ``geometry`` spatial reference.
    /// - Note: See Also: ``InteractionConfiguration/allowsMovingSelectedElement``
    /// - Precondition: `isStarted`
    final public func moveSelectedElementBy(deltaX: Double, deltaY: Double)

    /// Redoes the last action undone on the ``geometry``.
    /// - Note: See Also: ``canRedo``, `GeometryEditor.undo()`, ``canRedo``
    final public func redo()

    /// Replaces the current ``geometry`` with the specified geometry.
    ///
    /// Use this method to make changes to the ``geometry`` that are not directly supported
    /// using other ``GeometryEditor`` methods. For example, to start a new part in a ``Polygon`` or ``Polyline``
    /// geometry, get the current ``geometry``, use a ``MultipartBuilder`` to add the required part,
    /// and then pass the updated `GeometryBuilder.toGeometry()` to this method.
    /// - Parameter geometry: The new geometry to replace the current geometry. The `Geometry.Type` of these geometries must match.
    /// - Precondition: `isStarted`
    /// - Precondition: The type of the specified geometry must match the type of the current geometry.
    /// - Precondition: `!geometry.hasCurves`
    final public func replaceGeometry(with geometry: ArcGIS.Geometry)

    /// Selects the entire ``geometry``.
    ///
    /// When the entire geometry is selected it can be edited interactively and programmatically. For example you
    /// can move the entire geometry interactively by dragging, or call
    /// `GeometryEditor.moveSelectedElement(to:)` or `GeometryEditor.moveSelectedElementBy(deltaX:deltaY:)` to
    /// move it programmatically.
    ///
    /// When the entire geometry is selected, the ``GeometryEditorGeometry`` returned from
    /// ``selectedElement`` has a geometry equal to ``geometry``. If the
    /// ``geometry`` is a ``Point``, then a ``GeometryEditorVertex`` is returned from
    /// ``selectedElement`` instead, which is equivalent to the entire geometry and provides
    /// immediate access to the x,y coordinates of the selected point geometry.
    /// - Note: See Also: ``InteractionConfiguration/allowsGeometrySelection``, `GeometryEditor.clearSelection()`,
    /// `GeometryEditor.selectVertexAt(partIndex:vertexIndex:)`, `GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`,
    /// `GeometryEditor.selectPart(atIndex:)`
    /// - Precondition: `isStarted`
    final public func selectGeometry()

    /// Selects the mid-vertex with the specified indices.
    ///
    /// Mid-vertices do not exist in the ``geometry``. They exist only in the display to serve
    /// as a visual cue that new vertices can be inserted between existing vertices. Since they do not
    /// exist in the geometry, mid-vertices cannot be programmatically moved or deleted. They can be
    /// used to insert a new vertex interactively.
    ///
    /// When a mid-vertex is selected, a ``GeometryEditorMidVertex`` is returned from
    /// ``selectedElement``.
    /// - Parameters:
    ///   - partIndex: The index of the part in the geometry editor's ``Multipart`` geometry that contains the mid-vertex to be selected. Use a value of 0 for non-multipart geometry types - ``Point`` and ``Multipoint``.
    ///   - segmentIndex: The index of segment that the mid-vertex to be selected lies on, within the given part of the geometry editor's ``Multipart`` geometry, or within the ``Multipoint`` geometry. Use a value of 0 for ``Point`` geometries.
    /// - Note: See Also: ``InteractionConfiguration/allowsMidVertexSelection``, `GeometryEditor.clearSelection()`,
    /// `GeometryEditor.selectVertexAt(partIndex:vertexIndex:)`, `GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`, `GeometryEditor.selectGeometry()`
    /// - Precondition: `isStarted`
    /// - Precondition: Mid-vertices must be shown for the geometry editor's current geometry type.
    /// - Precondition: The given indices must be within range for the geometry.
    final public func selectMidVertexAt(partIndex: Int, segmentIndex: Int)

    /// Selects the part with the specified index.
    ///
    /// When a part of a polygon or polyline geometry is selected, a ``GeometryEditorPart`` is returned from
    /// ``selectedElement``. If the polygon or polyline has only one part (``Part``),
    /// then a ``GeometryEditorGeometry`` with a shape equivalent to the entire geometry is returned from
    /// ``selectedElement`` instead, which provides immediate access to the extent
    /// (``Geometry/extent``) and can be directly used in other geometry operations. If the current
    /// ``geometry`` is a ``Point`` or ``Multipoint``, the entire geometry is selected.
    ///
    /// When a part of a ``Polygon`` or ``Polyline`` (``Multipart``) geometry is selected it can be edited
    /// separately from the other parts of the geometry. For example, you can move
    /// only the selected part interactively by dragging, or call `GeometryEditor.moveSelectedElement(to:)` or
    /// `GeometryEditor.moveSelectedElementBy(deltaX:deltaY:)` to move only the selected part programmatically.
    /// - Parameter partIndex: The index of the part in the geometry editor's ``Multipart`` geometry to be selected. Use a value of 0 for ``Multipoint`` geometries.
    /// - Note: See Also: ``InteractionConfiguration/allowsPartSelection``, `GeometryEditor.clearSelection()`,
    /// `GeometryEditor.selectVertexAt(partIndex:vertexIndex:)`, `GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`, `GeometryEditor.selectGeometry()`
    /// - Precondition: `isStarted`
    /// - Precondition: `geometry is Multipart`
    /// - Precondition: The given index must be within range for the geometry.
    final public func selectPart(atIndex partIndex: Int)

    /// Selects the vertex with the specified indices.
    ///
    /// When a vertex is selected it can be edited while all other vertices of
    /// the geometry are unchanged. For example, you can move only the selected vertex interactively by dragging, or
    /// call `GeometryEditor.moveSelectedElement(to:)` or `GeometryEditor.moveSelectedElementBy(deltaX:deltaY:)`
    /// to move the selected vertex programmatically.
    ///
    /// When a vertex is selected, a ``GeometryEditorVertex`` is returned from ``selectedElement``.
    /// - Parameters:
    ///   - partIndex: The index of the part that contains the vertex (point)) to be selected, within the geometry editor's ``Multipart`` geometry. Use a value of 0 for ``Point`` and ``Multipoint`` (non-multipart geometries).
    ///   - vertexIndex: The index of the vertex (point) to be selected, within the given part of the geometry editor's ``Multipart`` geometry, or within the ``Multipoint`` geometry. Use a value of 0 for ``Point`` geometries.
    /// - Note: See Also: ``InteractionConfiguration/allowsVertexSelection``, `GeometryEditor.clearSelection()`,
    /// `GeometryEditor.selectVertexAt(partIndex:vertexIndex:)`, `GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`,
    /// `GeometryEditor.selectGeometry()`
    /// - Precondition: `isStarted`
    /// - Precondition: The given indices must be within range for the geometry.
    final public func selectVertexAt(partIndex: Int, vertexIndex: Int)

    /// Starts a geometry editing session based on the specified geometry.
    /// - Parameter initialGeometry: The initial ``geometry`` to start the editing session with.
    /// - Precondition: `!(initialGeometry is Envelope)`
    final public func start(withInitial initialGeometry: ArcGIS.Geometry)

    /// Starts a geometry editing session with an empty geometry of the specified `Geometry.Type`.
    /// - Parameter geometryType: The `Geometry.Type` of geometry to edit.
    /// - Precondition: `!(geometryType is Envelope.Type)`
    final public func start(withType geometryType: ArcGIS.Geometry.Type)

    /// Stops the editing session by making the ``GeometryEditor`` no longer respond to user interaction and clears the ``geometry``.
    /// - Returns: The final ``geometry`` before it is cleared. `nil` if the geometry editor is not started.
    /// - Note: See Also: ``geometry``, ``geometry``
    @discardableResult
    final public func stop() -> ArcGIS.Geometry?

    /// Undoes the last action on the ``geometry``.
    /// - Note: See Also: ``canUndo``, `GeometryEditor.redo()`, ``canUndo``
    final public func undo()
}

/// The base class for all selectable elements in a ``GeometryEditor``.
///
/// ``GeometryEditor/selectedElement`` returns an object that inherits from this base class, representing the
/// specific type of element that is selected.
/// - Since: 200.1
public class GeometryEditorElement {

    /// `true` if this element can be deleted interactively, `false` otherwise.
    ///
    /// The value of ``InteractionConfiguration/allowsDeletingSelectedElement`` of the current ``GeometryEditor/tool``
    /// determines this value. The element can be deleted programmatically regardless of this value, for example using
    /// `GeometryEditor.deleteSelectedElement()`.
    ///
    /// A ``GeometryEditorMidVertex`` is not part of the ``GeometryEditor/geometry`` state, and therefore can never be deleted
    /// from the geometry regardless of the ``InteractionConfiguration`` settings.
    public var canBeDeleted: Bool { get }

    /// `true` if this element can be moved interactively, `false` otherwise.
    ///
    /// The value of ``InteractionConfiguration/allowsMovingSelectedElement`` of the current ``GeometryEditor/tool``
    /// determines this value. The element can be moved programmatically regardless of this value, for example using
    /// `GeometryEditor.moveSelectedElement(to:)`.
    ///
    /// A ``GeometryEditorMidVertex`` is not part of the ``GeometryEditor/geometry`` state, and therefore can never be
    /// moved regardless of the ``InteractionConfiguration`` settings.
    public var canBeMoved: Bool { get }

    /// The extent of the selected element in the ``SpatialReference`` of the ``GeometryEditor/geometry``.
    ///
    /// To find the specific shape of the selected element instead of its extent, use
    /// ``GeometryEditorGeometry/geometry``, ``GeometryEditorMidVertex/point``, ``GeometryEditorPart/part``, or
    /// ``GeometryEditorVertex/point``.
    public var extent: ArcGIS.Envelope { get }
}

/// The element in a ``GeometryEditor`` representing the entire ``GeometryEditor/geometry``.
///
/// A ``GeometryEditorGeometry`` represents the entire geometry in a ``GeometryEditor`` - it displays
/// the existing location and shape of the geometry, and allows you to select and move the entire geometry in
/// interactive workflows. For more information about selecting and working with selections, see ``GeometryEditor``.
///
/// When a entire geometry is selected (displayed with a selection halo), a ``GeometryEditorGeometry`` is returned
/// from ``GeometryEditor/selectedElement``, except if the ``GeometryEditor/geometry`` is a ``Point``, in which case
/// a ``GeometryEditorVertex`` is returned instead.
///
/// Select the entire geometry programmatically using `GeometryEditor.selectGeometry()`. To prevent whole
/// geometries from being selected interactively while still allowing programmatic selection, set
/// ``InteractionConfiguration/allowsGeometrySelection`` to `false`.
///
/// Use ``GeometryEditorStyle/lineSymbol`` and ``GeometryEditorStyle/fillSymbol`` to change the appearance of
/// polygons and polylines displayed by a ``GeometryEditor``. You may also wish to control the appearance of a
/// geometry during interactive edits by using ``GeometryEditorStyle/feedbackLineSymbol`` and
/// ``GeometryEditorStyle/feedbackVertexSymbol``.
/// - Since: 200.1
final public class GeometryEditorGeometry : ArcGIS.GeometryEditorElement {

    /// The entire geometry in the ``SpatialReference`` of the associated `MapView`, if one is set.
    final public var geometry: ArcGIS.Geometry { get }
}

/// A mid-vertex element in a ``GeometryEditor``.
///
/// Mid-vertices do not exist in the ``GeometryEditor/geometry``, but instead exist only in the display. They are
/// displayed between vertices in polygon and polyline geometries and are used in interactive workflows as a visual
/// cue to indicate new vertices can be inserted between existing vertices. They may be most helpful for users with
/// less editing experience. Tap on a mid-vertex to select it, and drag to change the mid-vertex into a vertex
/// (``GeometryEditorVertex``) in the ``GeometryEditor/geometry`` and move it to the required location.
///
/// When a mid-vertex is selected (displayed with a selection halo), a ``GeometryEditorMidVertex`` is returned from
/// ``GeometryEditor/selectedElement``. Select a mid-vertex programmatically using
/// `GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`.
///
/// Use ``GeometryEditorStyle/midVertexSymbol`` and ``GeometryEditorStyle/selectedMidVertexSymbol`` to change the
/// appearance of the mid-vertex when unselected and selected, or set to `nil` to prevent mid-vertices from being
/// displayed entirely. If mid-vertices are not displayed, you can still insert vertices between existing vertices
/// by selecting an existing ``GeometryEditorVertex`` and tapping on the map at the location to insert the new
/// vertex.
///
/// To prevent mid-vertices from being selected interactively while still allowing programmatic selection, set
/// ``InteractionConfiguration/allowsMidVertexSelection`` to `false`. If
/// ``InteractionConfiguration/allowsVertexCreation`` is `false` then new vertices cannot be inserted into the
/// geometry, including by the use of mid-vertices.
/// - Note: See Also: ``GeometryEditorVertex``, ``GeometryEditor``, ``InteractionConfiguration``
/// - Since: 200.1
final public class GeometryEditorMidVertex : ArcGIS.GeometryEditorElement {

    /// The index position of the part within the part collection of a multipart geometry that contains this ``GeometryEditorMidVertex``.
    final public var partIndex: Int { get }

    /// The location of the point represented by this ``GeometryEditorMidVertex`` in the ``SpatialReference`` of the associated ``GeometryEditor/geometry``.
    final public var point: ArcGIS.Point { get }

    /// The index position of the segment on which the selected mid-vertex lies.
    final public var segmentIndex: Int { get }
}

/// A ``Part`` element in a ``GeometryEditor`` editing a ``Multipart`` geometry.
///
/// Polygons and polylines are ``Multipart`` geometries that can consist of one or more ``Part`` objects.
/// A ``GeometryEditorPart`` represents a part of the geometry in a ``GeometryEditor`` - it displays
/// the existing location and shape of the part, and allows you to select and move the part in interactive
/// workflows. For more information about selecting and working with selections, see ``GeometryEditor``.
///
/// When a part is selected (displayed with a selection halo), a ``GeometryEditorPart`` is returned from
/// ``GeometryEditor/selectedElement``. If the ``GeometryEditor/geometry`` is a polygon or polyline with only one
/// part (``Part``), then a ``GeometryEditorGeometry`` is returned instead.
///
/// Select a part programmatically using `GeometryEditor.selectPart(atIndex:)`. To
/// prevent parts from being selected interactively while still allowing programmatic selection, set
/// ``InteractionConfiguration/allowsPartSelection`` to `false`.
///
/// Use ``GeometryEditorStyle/lineSymbol`` and ``GeometryEditorStyle/fillSymbol`` to change the appearance of
/// polygons and polylines displayed by a ``GeometryEditor``. You can also control the appearance of a
/// part during interactive edits by using ``GeometryEditorStyle/feedbackLineSymbol`` and
/// ``GeometryEditorStyle/feedbackVertexSymbol``.
/// - Note: See Also: ``GeometryEditor``, ``InteractionConfiguration``, ``GeometryEditorGeometry``, `GeometryEditor.moveSelectedElementBy(deltaX:deltaY:)`
/// - Since: 200.1
final public class GeometryEditorPart : ArcGIS.GeometryEditorElement {

    /// The part in the ``SpatialReference`` of the ``GeometryEditor/geometry``.
    final public var part: ArcGIS.Part { get }

    /// The index position of the part within the ``GeometryEditor/geometry``.
    final public var partIndex: Int { get }
}

/// Defines the visual appearance of a geometry displayed by the ``GeometryEditor``.
///
/// Each ``GeometryEditorTool`` has a ``GeometryEditorStyle`` which controls the appearance of the different
/// elements of the ``GeometryEditor/geometry``. You can change the symbology used for vertices, selections, lines
/// and fills. For example, in a ``Feature`` editing workflow, you can set the ``lineSymbol``
/// to match the symbol of a polyline feature in order to provide visual consistency.
///
/// When a ``GeometryEditorTool`` is created, a consistent set of default symbology appropriate for that tool type
/// is applied to its ``GeometryEditorTool/style`` property.
///
/// You can change the ``opacity`` of the overall style, or alternatively set different opacity
/// (alpha) values on the individual symbols of the style, so that the underlying map components are visible through
/// the geometry being edited.
///
/// You can set each symbol to `nil` - consider carefully how this can affect your workflows, as you will not be able
/// to see, select, or otherwise interact with those ``GeometryEditorElement`` types.
/// - Note: See Also: ``InteractionConfiguration``, ``Symbol``
/// - Since: 200.1
final public class GeometryEditorStyle {

    /// Creates a new ``GeometryEditorStyle`` with a consistent set of red symbols, and displays white numbers on vertices.
    ///
    /// Using this constructor results in the same default symbology as the ``GeometryEditorTool/style``.
    public convenience init()

    /// The symbol used to draw the edges currently being changed by an interactive edit, when editing polyline or polygon geometries.
    ///
    /// During an interactive edit, this symbol displays the current location of edges (polylines, or boundaries of
    /// polygons) that are changed by the interaction in progress. Unchanged lines remain displayed with
    /// ``lineSymbol``.
    ///
    /// The default value is a dotted red ``SimpleLineSymbol``.
    /// - Note: See Also: ``feedbackVertexSymbol``
    final public var feedbackLineSymbol: ArcGIS.Symbol?

    /// The symbol used to draw vertices currently being changed by an interactive edit, when editing any geometry type.
    ///
    /// During an interactive edit, this symbol displays the current location of vertices that are changed by
    /// the interaction in progress. Unchanged vertices remain displayed with ``vertexSymbol``.
    ///
    /// Vertex numbers are not displayed for the changed vertices. The default value is the same as the default
    /// ``vertexSymbol``.
    /// - Note: See Also: ``feedbackVertexSymbol``, ``vertexTextSymbol``
    final public var feedbackVertexSymbol: ArcGIS.Symbol?

    /// The symbol used to fill the current geometry when editing polygon geometries.
    ///
    /// The default value is a red semi-transparent ``SimpleFillSymbol`` with a red outline.
    /// - Note: See Also: ``lineSymbol``
    final public var fillSymbol: ArcGIS.Symbol?

    /// The symbol used to draw the current geometry when editing polyline geometries, and the outline of the geometry when editing polygon geometries.
    ///
    /// The default value is a solid red ``SimpleLineSymbol``.
    /// - Note: See Also: ``feedbackLineSymbol``, ``fillSymbol``
    final public var lineSymbol: ArcGIS.Symbol?

    /// The symbol used to draw the mid-vertices of the current geometry when editing polygon or polyline geometries.
    ///
    /// Mid-vertices do not exist in the ``GeometryEditor/geometry``, but instead exist only in the display, located
    /// between vertices in polygon and polyline geometries as a visual cue for interactive editing. When moved
    /// interactively, a new vertex is inserted at that ``LocationDisplay``.
    ///
    /// If `nil`, no mid-vertex is displayed. In this case, you can still insert vertices between existing vertices
    /// by selecting an existing ``GeometryEditorVertex`` and tapping on the map.
    /// - Note: See Also: ``GeometryEditorMidVertex``, ``vertexSymbol``, ``selectedMidVertexSymbol``, ``InteractionConfiguration/allowsMidVertexSelection``
    final public var midVertexSymbol: ArcGIS.Symbol?

    /// The opacity of the ``GeometryEditor`` display in the view, a value between 0 (fully transparent) and 1 (fully opaque). Default is 1.
    ///
    /// It can be useful to change opacity of the entire ``GeometryEditor`` display to allow features, graphics, or
    /// imagery in the underlying map view to show through the geometry editor display, which can help allow precise
    /// placement of new vertices relative to those map components.
    ///
    /// Alternatively, you can set opacity separately on each of the symbols used by this style, allowing you to make
    /// specific aspects of the geometry editor semi-transparent.
    /// - Note: See Also: ``GeometryEditor/isVisible``
    final public var opacity: Float

    /// The symbol used to draw the currently selected mid-vertex of the current geometry when editing polygon or polyline geometries.
    ///
    /// When a mid-vertex is selected, it is displayed with this symbol instead of
    /// ``midVertexSymbol``.
    ///
    /// As soon as a mid-vertex is moved interactively, it is replaced by a vertex that is part of the
    /// ``GeometryEditor/geometry``, and is displayed with the ``selectedVertexSymbol``.
    /// - Note: See Also: ``midVertexSymbol``, ``selectedVertexSymbol``, ``GeometryEditorMidVertex``
    final public var selectedMidVertexSymbol: ArcGIS.Symbol?

    /// The symbol used to draw the currently selected vertex of the current geometry when editing any geometry type.
    ///
    /// This symbol can be used to emphasize the currently selected vertex, which can be useful if you require extra
    /// emphasis in addition to the selection halo, or wish to make the selected vertex a larger target for user
    /// interactions.
    /// - Note: See Also: ``vertexSymbol``, ``selectedMidVertexSymbol``, ``GeometryEditorVertex``
    final public var selectedVertexSymbol: ArcGIS.Symbol?

    /// The symbol used to draw the vertices of the current geometry when editing any geometry type.
    ///
    /// Setting a larger symbol can help users on touch devices select and work with vertices, especially for field
    /// apps where users may wear thick gloves that work with touch screens.
    ///
    /// If `nil`, the vertices of the geometry are not explicitly displayed. By default when using a ``FreehandTool``,
    /// this is `nil`, as you work with geometry parts instead of individual vertices. For a ``VertexTool``, consider
    /// your workflow carefully before setting this property to `nil`, as you must be able to see vertices in order
    /// to select, move, or otherwise interact with them.
    /// - Note: See Also: ``selectedVertexSymbol``, ``vertexTextSymbol``, ``midVertexSymbol``
    final public var vertexSymbol: ArcGIS.Symbol?

    /// The symbol used to draw vertex numbers for the current geometry. If `nil`, no numbers are displayed.
    ///
    /// By default when using a ``FreehandTool``, this symbol is `nil`.
    final public var vertexTextSymbol: ArcGIS.Symbol?
}

/// A base class for tools that determine how you interact with a view when editing geometries with a ``GeometryEditor``.
///
/// Different types of ``GeometryEditorTool`` provide different ways of interacting with the view to create and
/// edit geometries with a ``GeometryEditor``. They control how an interaction (for example a tap or a drag gesture
/// on the map view) uses the interaction position to update the ``GeometryEditor/geometry``, or to navigate the map
/// view. ``VertexTool`` and ``FreehandTool`` are both types of tools that allow you to customize how the
/// ``GeometryEditor`` reacts to each user interaction, allowing you to tailor the exact behavior appropriately for
/// your users and workflow. ``GeometryEditorTool`` also determines the appearance of the
/// ``GeometryEditor/geometry`` by specifying the ``GeometryEditorStyle`` used to draw the geometry in the view.
///
/// You may wish to create multiple different tool objects in order to hold different settings, and set them into
/// ``GeometryEditor/tool`` as appropriate for your workflow. For example, you could create multiple ``VertexTool``
/// objects with ``GeometryEditorStyle`` values corresponding the different symbols used by different feature
/// layers.
///
/// The different tools do not correspond to different geometry types - for example the ``VertexTool`` can be used
/// to edit ``Point``, ``Multipoint``, ``Polyline`` and ``Polygon`` geometries. The type of geometry being edited
/// using the tool is defined by the start method parameter (see `GeometryEditor.start(withType:)` and
/// `GeometryEditor.start(withInitial:)`.
///
/// When a ``GeometryEditorTool`` is created, a consistent set of default symbology appropriate for that tool type
/// is applied to the ``style`` property.
/// - Note: See Also: ``VertexTool``, ``FreehandTool``, ``GeometryEditor/geometry``, ``GeometryEditor/selectedElement``
/// - Since: 200.1
public class GeometryEditorTool {

    /// Defines the visual appearance of ``GeometryEditor`` geometries when this tool is in use.
    ///
    /// When a ``GeometryEditorTool`` is created, a consistent set of default symbology appropriate for that tool
    /// type is applied to its ``style`` property. For example, the ``FreehandTool`` defines all
    /// vertex symbols as `nil` by default because this tool uses drag gestures to define entire parts of polyline
    /// and polygon geometries, whereas the ``VertexTool`` defines non-`nil` vertex symbols because it is important
    /// to be able to see and interact with individual vertices when editing geometries with this tool.
    public var style: ArcGIS.GeometryEditorStyle
}

/// A vertex element in a ``GeometryEditor``.
///
/// Vertices represent points in a ``GeometryEditor/geometry``. They display the existing location of the point, and
/// are used in interactive workflows to allow you to select and move those points. For more information about
/// selecting and working with selections, see ``GeometryEditor``.
///
/// When a vertex is selected (displayed with a selection halo), a ``GeometryEditorVertex`` is returned from
/// ``GeometryEditor/selectedElement``.
///
/// Select a vertex programmatically using `GeometryEditor.selectVertexAt(partIndex:vertexIndex:)`, or
/// move it programmatically using `GeometryEditor.moveSelectedElementBy(deltaX:deltaY:)` or
/// `GeometryEditor.moveSelectedElement(to:)`.
///
/// Use ``GeometryEditorStyle/vertexSymbol`` and ``GeometryEditorStyle/selectedVertexSymbol`` to change the
/// appearance of the vertex when unselected and selected, or set to `nil` to prevent them from being
/// displayed entirely.
///
/// To prevent vertices from being selected interactively while still allowing programmatic
/// selection, set ``InteractionConfiguration/allowsVertexSelection`` to `false`.
/// - Note: See Also: ``GeometryEditor``, ``InteractionConfiguration``, ``GeometryEditorMidVertex``
/// - Since: 200.1
final public class GeometryEditorVertex : ArcGIS.GeometryEditorElement {

    /// The index position of the part which contains the vertex.
    final public var partIndex: Int { get }

    /// The position of the vertex in the ``SpatialReference`` of the ``GeometryEditor/geometry``.
    final public var point: ArcGIS.Point { get }

    /// The index position of the vertex within a part.
    final public var vertexIndex: Int { get }
}

/// Performs geometric operations such as spatial relationship tests, reprojections, shape manipulations,
/// topological query and analysis operations on ``Geometry`` objects.
///
/// Capabilities include:
/// * Create new geometries from others with `GeometryEngine.buffer(around:distance:)`,
///   `GeometryEngine.clip(_:to:)` and
///   `GeometryEngine.union(_:_:)`
/// * Test spatial relationships between geometries such as
///   `GeometryEngine.isGeometry(_:intersecting:)` and
///   `GeometryEngine.doesGeometry(_:contain:)`
/// * Find the `GeometryEngine.nearestCoordinate(in:to:)` or
///   `GeometryEngine.nearestVertex(in:to:)` between geometries
/// * Reproject a geometry to another ``SpatialReference`` using
///   `GeometryEngine.project(_:into:datumTransformation:)`
/// * Calculate area and length using `GeometryEngine.area(of:)` and
///   `GeometryEngine.length(of:)`, or the geodetic equivalents
///   (`GeometryEngine.geodeticBuffer(around:distance:distanceUnit:maxDeviation:curveType:)`
///   and `GeometryEngine.geodeticLength(of:lengthUnit:curveType:)`) that
///   account for the curvature of the earth
///
/// ``GeometryEngine`` generally operates in two dimensions; operations do not account for z-values unless
/// documented as such for a specific method (for example `GeometryEngine.project(_:into:datumTransformation:)`
/// transforms z-values in some cases).
///
/// Geodetic methods are better suited to data that have a geographic spatial reference (see ``SpatialReference/isGeographic``),
/// especially for large-area, small-scale use, while planar methods are suitable to data that have a projected
/// coordinate system, especially for local, large-scale areas. Geodetic methods indicate this in the name, for example
/// GeometryEngine.bufferGeodetic(Geometry, double, LinearUnit, double, GeodeticCurveType).
/// - Since: 200.1
public enum GeometryEngine {

    /// Flags for the type of extend operation to perform.
    public struct ExtendOptions : OptionSet {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: Int)

        /// By default, extension considers both ends of paths. The old ends
        /// remain and new points are added at the extended ends. The new points
        /// have attributes that are extrapolated from adjacent existing
        /// segments.
        public static let `default`: ArcGIS.GeometryEngine.ExtendOptions

        /// If an extension is performed at an end, relocate the end point to
        /// the new position instead of leaving the old point and adding a new
        /// point at the new position.
        public static let relocateEnds: ArcGIS.GeometryEngine.ExtendOptions

        /// If an extension is performed at an end, do not extrapolate the
        /// end-segment's attributes for the new point. Instead, make its
        /// attributes the same as the current end. Incompatible with
        /// ``noEndAttributes``.
        public static let keepEndAttributes: ArcGIS.GeometryEngine.ExtendOptions

        /// If an extension is performed at an end, do not extrapolate the
        /// end-segment's attributes for the new point. Instead, make its
        /// attributes be empty. Incompatible with
        /// ``keepEndAttributes``.
        public static let noEndAttributes: ArcGIS.GeometryEngine.ExtendOptions

        /// Do not extend the 'from' end of any path.
        public static let doNotExtendFromStartPoint: ArcGIS.GeometryEngine.ExtendOptions

        /// Do not extend the 'to' end of any path.
        public static let doNotExtendFromEndPoint: ArcGIS.GeometryEngine.ExtendOptions

        /// The type of the elements of an array literal.
        public typealias ArrayLiteralElement = ArcGIS.GeometryEngine.ExtendOptions

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        public typealias Element = ArcGIS.GeometryEngine.ExtendOptions

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = Int
    }

    /// The different types of geodetic curves.
    public enum GeodeticCurveType {

        /// A geodesic line (shortest path along two points on the ellipsoid).
        case geodesic

        /// A rhumb line (loxodrome).
        case loxodrome

        /// A great elliptic.
        case greatElliptic

        /// A normal section.
        case normalSection

        /// The segment shape is preserved in the projection where it is defined.
        case shapePreserving

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GeometryEngine.GeodeticCurveType, b: ArcGIS.GeometryEngine.GeodeticCurveType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The different types of geometry offset joints.
    public enum OffsetType {

        /// Refers to a mitered joint type.
        case mitered

        /// Refers to a bevelled joint type.
        case bevelled

        /// Refers to a rounded joint type.
        case rounded

        /// Refers to a squared joint type.
        case squared

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GeometryEngine.OffsetType, b: ArcGIS.GeometryEngine.OffsetType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Calculates the area of the given geometry.
    ///
    /// Planar measurements of distance and area can be extremely inaccurate if using an unsuitable spatial reference.
    /// Ensure that you understand the potential for error with the geometry's spatial reference. If you need to calculate
    /// more accurate results consider using a different spatial reference, or using the geodetic equivalent,
    /// `GeometryEngine.geodeticArea(of:unit:curveType:)`.
    /// See https://developers.arcgis.com/documentation/spatial-references/ for more information about spatial references.
    ///
    /// Supports `true` curves.
    /// - Parameter geometry: A geometry object.
    /// - Returns: The area of the given geometry in the same units as the geometry's spatial reference system.
    public static func area(of geometry: ArcGIS.Geometry) -> Double

    /// Fills the closed gaps between polygons using polygon boundaries and
    /// polylines as the boundary for the new polygons.
    ///
    /// The new polygons are created in the closed empty areas bounded by
    /// the edges of the existing polygon boundaries and the new boundary
    /// polylines. The newly created polygons do not overlap any existing
    /// polygons or polylines, and the boundary of a new polygon must
    /// contain at least one edge from the polylines. Only polygons that
    /// intersect the input polylines participate in the operation, so
    /// it makes sense to prefilter the input accordingly.
    ///
    /// The geometries in existing_boundaries must all have an area, i.e. be polygons or
    /// envelopes.
    ///
    /// The geometries in new_boundaries must all be polylines.
    ///
    /// The geometries in existing_boundaries and new_boundaries must have consistent spatial
    /// references.
    /// - Parameters:
    ///   - existingBoundaries: The polygons.
    ///   - newBoundaries: The polylines.
    /// - Returns: The new polygons that were created. If either
    /// existing_boundaries or new_boundaries is empty, returns an empty
    /// array. Returns `nil` on error.
    public static func autoComplete(existingBoundaries: [ArcGIS.Polygon], newBoundaries: [ArcGIS.Polyline]) -> [ArcGIS.Polygon]

    /// Calculates the boundary of the given geometry.
    ///
    /// Supports `true` curves.
    /// - Parameter geometry: A geometry object.
    /// - Returns: The boundary of the given geometry.
    public static func boundary(of geometry: ArcGIS.Geometry) -> ArcGIS.Geometry?

    /// Returns a geometry object that represents a buffer relative to the given geometry.
    ///
    /// Planar measurements of distance and area can be extremely inaccurate if using an unsuitable spatial reference.
    /// Ensure that you understand the potential for error with the geometry's spatial reference. If you need to calculate
    /// more accurate results consider using a different spatial reference, or using the geodetic equivalent,
    /// `GeometryEngine.geodeticBuffer(around:distance:distanceUnit:maxDeviation:curveType:)`.
    /// See https://developers.arcgis.com/documentation/spatial-references/ for more information about spatial references.
    ///
    /// Supports `true` curves as input, producing a densified curve as output where applicable.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - distance: The buffer distance for the geometry in the same units as the geometry's spatial reference system.
    /// - Returns: A polygon object that represents a buffer at the desired distance relative to the given geometry.
    public static func buffer(around geometry: ArcGIS.Geometry, distance: Double) -> ArcGIS.Polygon?

    /// Creates and returns a buffer relative to the given geometries.
    ///
    /// The geometries must have the same spatial reference. Planar measurements of distance and area can be extremely
    /// inaccurate if using an unsuitable spatial reference. Ensure that you understand the potential for error with the geometry's spatial reference. If you need to calculate
    /// more accurate results consider using a different spatial reference, or using the geodetic equivalent,
    /// `GeometryEngine.geodeticBuffer(around:distances:distanceUnit:maxDeviation:curveType:shouldUnion:)`.
    /// See https://developers.arcgis.com/documentation/spatial-references/ for more information about spatial references.
    /// If unionResult is `true`, the output collection contains a single result. If geometries is empty, an empty array is returned.
    /// Returns `nil` on error.
    ///
    /// Supports `true` curves as input, producing a densified curve as output where applicable.
    /// - Parameters:
    ///   - geometries: A collection of geometries.
    ///   - distances: The distance to buffer each geometry, expressed as an `Array` of double. If the size of the distances array is less than the number of geometries, the last distance value is used for the rest of geometries.
    ///   - shouldUnion: Returns a single geometry that buffers all the geometries (`true`), or one buffer for each in the given collection (`false`).
    /// - Returns: A collection of polygons representing buffers at the defined distance(s) relative to the input geometries.
    public static func buffer(around geometries: [ArcGIS.Geometry], distances: [Double], shouldUnion: Bool) -> [ArcGIS.Polygon]

    /// Clips the given geometry with the envelope.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - envelope: The envelope representing the area to clip.
    /// - Returns: A geometry object that represents the given geometry with the desired area clipped out.
    public static func clip(_ geometry: ArcGIS.Geometry, to envelope: ArcGIS.Envelope) -> ArcGIS.Geometry?

    /// Returns the envelope of the two given geometries.
    ///
    /// The given geometries must have consistent spatial references.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry1: A geometry object.
    ///   - geometry2: Another geometry object.
    /// - Returns: The maximum extents of the two given geometries, or `nil` on error.
    public static func combineExtents(_ geometry1: ArcGIS.Geometry, _ geometry2: ArcGIS.Geometry) -> ArcGIS.Envelope?

    /// Returns the envelope of geometries in the given collection.
    ///
    /// The given geometries must have consistent spatial references.
    ///
    /// Supports `true` curves.
    /// - Parameter geometries: A collection of geometries.
    /// - Returns: The maximum extents of the geometries in the collection, or `nil` on error.
    public static func combineExtents<S>(of geometries: S) -> ArcGIS.Envelope? where S : Sequence, S.Element == ArcGIS.Geometry

    /// Returns the minimum bounding geometry that completely encloses the given geometry.
    /// - Parameter geometry: A geometry object.
    /// - Returns: The minimum bounding geometry that completely encloses the given geometry.
    public static func convexHull(for geometry: ArcGIS.Geometry) -> ArcGIS.Geometry?

    /// Returns the convex hull for the geometries in the given collection.
    ///
    /// The geometries must have consistent spatial references.
    /// - Parameters:
    ///   - geometries: A collection of geometries.
    ///   - shouldMerge: Return a single geometry that encloses all the geometries (`true`), or one enclosing geometry for each in the collection (`false`).
    /// - Returns: If merge is `true`, returns a single convex hull that
    /// encloses all the geometries in the collection as a single geometry
    /// in an array. If merge is `false`, returns the minimum bounding
    /// geometry that completely encloses each of the geometries in the
    /// given collection as an array of geometries. If geometries is empty,
    /// returns an empty array. Returns `nil` on error.
    public static func convexHull<S>(for geometries: S, shouldMerge: Bool) -> [ArcGIS.Geometry] where S : Sequence, S.Element == ArcGIS.Geometry

    /// Cut the 'geometry' ``Geometry`` with the 'cutter' ``Polyline``
    ///
    /// The cutter and geometry's spatial references must match.
    ///
    /// A touch event is considered to be a cut (applies when cutting a ``Polyline``).
    ///
    /// When cutting a ``Polyline``, all left cuts are grouped together in the first ``Geometry``, right cuts and coincident
    /// cuts are grouped in the second ``Geometry``, and each undefined cut, along with any uncut parts, are output as separate Polylines.
    ///
    /// When cutting a ``Polygon``, all left cuts are grouped in the first ``Geometry``, all right cuts are in the second ``Geometry``,
    /// and each undefined cut, along with any left-over parts after cutting, are output as a separate ``Geometry``.
    ///
    /// If there were no cuts then an empty `Array` is returned.
    ///
    /// If the left or right cut does not exist, the returned ``Geometry`` is empty for this type of cut.
    /// An undefined cut is only be produced if a left cut or right cut was produced, and there was a part left over after cutting or a cut is bounded to the left and right of the cutter.
    /// - Parameters:
    ///   - geometry: The input ``Geometry`` to be cut.
    ///   - cutter: The ``Polyline`` used to divide the geometry into pieces where they cross the cutter.
    /// - Returns: An `Array` of ``Geometry``.
    public static func cut(_ geometry: ArcGIS.Geometry, usingCutter cutter: ArcGIS.Polyline) -> [ArcGIS.Geometry]

    /// Densifies the input geometry by inserting additional vertices along the geometry at an interval defined by maxSegmentLength.
    ///
    /// Additional vertices are not inserted on segments of the input ``Envelope``, ``Polygon``, or ``Polyline``
    /// that are shorter than maxSegmentLength.
    ///
    /// Supports `true` curves as input, producing a densified curve as output where applicable.
    /// - Parameters:
    ///   - geometry: An ``Envelope``, ``Polygon``, or ``Polyline`` geometry.
    ///   - maxSegmentLength: The maximum distance between vertices when the input geometry is densified. The linear unit is assumed to be that of the input geometry's spatial reference (decimal degrees for a geometry with a geographic spatial reference, meters for geometry with a Mercator spatial reference, and so on). Use ``SpatialReference/unit`` to determine the unit used by a specific spatial reference.
    /// - Returns: The densified geometry.
    public static func densify(_ geometry: ArcGIS.Geometry, maxSegmentLength: Double) -> ArcGIS.Geometry?

    /// Constructs the set-theoretic difference between two geometries.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry1: A geometry object.
    ///   - geometry2: The second geometry of dimension equal to or greater than the elements of the first geometry.
    /// - Returns: A new geometry object that represents the difference of the two given input geometries.
    public static func difference(_ geometry1: ArcGIS.Geometry, _ geometry2: ArcGIS.Geometry) -> ArcGIS.Geometry?

    /// Measures the simple planar distance between two geometries.
    ///
    /// Planar measurements of distance and area can be extremely inaccurate if using an unsuitable spatial reference.
    /// Ensure that you understand the potential for error with the geometry's spatial reference. If you need to calculate
    /// more accurate results consider using a different spatial reference, or using the geodetic equivalent,
    /// `GeometryEngine.geodeticDistance(from:to:distanceUnit:azimuthUnit:curveType:)`.
    /// See https://developers.arcgis.com/documentation/spatial-references/ for more information about spatial references.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: The distance between the two geometries in the same units as the geometry's spatial reference system.
    public static func distance(from geometry: ArcGIS.Geometry, to other: ArcGIS.Geometry) -> Double?

    /// Returns a Boolean value indicating whether `geometry` contains `other`.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if `geometry` contains `other`, otherwise `false`.
    public static func doesGeometry(_ geometry: ArcGIS.Geometry, contain other: ArcGIS.Geometry) -> Bool

    /// Extends a polyline using a polyline as the extender.
    ///
    /// The output polyline has the first and last segment of each
    /// path extended to the extender if the segments can be interpolated to
    /// intersect the extender. In the case that the segments can be
    /// extended to multiple segments of the extender, the shortest
    /// extension is chosen. Only end points for paths that are not shared
    /// by the end points of other paths are extended. If the polyline
    /// cannot be extended by the input extender, then `nil` is
    /// returned.
    /// - Parameters:
    ///   - polyline: The polyline to be extended.
    ///   - extender: The polyline to extend to.
    ///   - extendOptions: The flag for the type of extend operation to perform.
    /// - Returns: The extended polyline. Returns `nil` on error.
    public static func extend(_ polyline: ArcGIS.Polyline, usingExtender extender: ArcGIS.Polyline, extendOptions: ArcGIS.GeometryEngine.ExtendOptions) -> ArcGIS.Polyline?

    /// Generalizes the given geometry by removing vertices based on the Douglas-Poiker algorithm.
    ///
    /// Supports `true` curves as input, producing a densified curve as output where applicable.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - maxDeviation: The maximum distance that the generalized geometry can deviate from the original, in the same units as the geometry's spatial reference system.
    ///   - removeDegenerateParts: If `true`, degenerate parts of the resulting geometry that are undesired for drawing are removed.
    /// - Returns: The geometry object that represents the generalization of the input geometry.
    public static func generalize(_ geometry: ArcGIS.Geometry, maxDeviation: Double, removeDegenerateParts: Bool) -> ArcGIS.Geometry?

    /// Constructs a geodesic ellipse centered on a specific point.
    /// - Parameter parameters: Various parameters needed to construct the ellipse.
    /// - Returns: The geodesic ellipse described by the parameters.
    public static func geodesicEllipse<Geometry>(parameters: ArcGIS.GeodesicEllipseParameters<Geometry>) -> Geometry? where Geometry : ArcGIS.Geometry

    /// Constructs a geodesic sector defined by a geodesic arc and 2 radii.
    /// - Parameter parameters: Specifies the parameters for constructing the sector.
    /// - Returns: A geometry representing the geodesic sector.
    public static func geodesicSector<Geometry>(parameters: ArcGIS.GeodesicSectorParameters<Geometry>) -> Geometry? where Geometry : ArcGIS.Geometry

    /// Calculates the geodesic area of the given geometry.
    ///
    /// Supports `true` curves, calculating the result by densifying curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - unit: The unit of measure for the return value. If `nil`, meters squared are assumed.
    ///   - curveType: The type of curve to calculate.
    /// - Returns: The calculated geodesic area in the requested unit.
    public static func geodeticArea(of geometry: ArcGIS.Geometry, unit: ArcGIS.AreaUnit?, curveType: ArcGIS.GeometryEngine.GeodeticCurveType) -> Double

    /// Calculates the geodesic buffer of a given geometry.
    ///
    /// Geodesic buffers account for the actual shape of the Earth.
    /// Distances are calculated between points on a curved surface (the geoid)
    /// as opposed to points on a flat surface (the Cartesian plane).
    ///
    /// Negative distance can be used to create a buffer inside a ``Polygon`` or an ``Envelope``.
    /// Using a negative buffer distance shrinks the geometry's boundary by the distance specified.
    /// Note that if the negative buffer distance is large enough, the geometry may collapse to an empty polygon.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - distance: The distance to buffer.
    ///   - distanceUnit: The unit of measure for the distance.
    ///   - maxDeviation: The maximum deviation between points.
    ///   - curveType: The curve type to calculate.
    /// - Returns: The geodesic buffer.
    public static func geodeticBuffer(around geometry: ArcGIS.Geometry, distance: Double, distanceUnit: ArcGIS.LinearUnit?, maxDeviation: Double, curveType: ArcGIS.GeometryEngine.GeodeticCurveType) -> ArcGIS.Polygon?

    /// Calculates the geodesic buffer of the geometries in a given collection.
    ///
    /// Geodesic buffers account for the actual shape of the Earth.
    /// Distances are calculated between points on a curved surface (the geoid)
    /// as opposed to points on a flat surface (the Cartesian plane).
    ///
    /// Negative distance can be used to create buffers inside polygons.
    /// Using a negative buffer distance shrinks the polygons' boundaries by the distance specified.
    /// Note that if the negative buffer distance is large enough, polygons may collapse to empty geometries.
    /// - Parameters:
    ///   - geometries: A collection of geometries.
    ///   - distances: The distance to buffer each geometry, expressed as an `Array` of double. If the size of the distances array is less than the number of geometries, the last distance value is used for the rest of geometries.
    ///   - distanceUnit: The unit of measure for the distance.
    ///   - maxDeviation: The maximum deviation between points.
    ///   - curveType: The curve type to calculate.
    ///   - shouldUnion: Return a single geometry that buffers all the geometries (`true`), or one buffer for each in the given collection (`false`).
    /// - Returns: A collection of polygon geometries that represent a geodesic buffer
    /// at the desired distance(s) relative to the given geometries. If
    /// 'unionResult' is `true`, the resulting collection contains a single
    /// polygon. If geometries is empty, returns an empty array. Returns
    /// `nil` on error.
    public static func geodeticBuffer(around geometries: [ArcGIS.Geometry], distances: [Double], distanceUnit: ArcGIS.LinearUnit?, maxDeviation: Double, curveType: ArcGIS.GeometryEngine.GeodeticCurveType, shouldUnion: Bool) -> [ArcGIS.Polygon]

    /// Densifies the input geometry by creating additional vertices along the geometry, using a geodesic curve.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - maxSegmentLength: The maximum distance between vertices when the input geometry is densified, in the given linear units.
    ///   - lengthUnit: The unit of measure for the maximum segment length. If `nil`, meters are assumed.
    ///   - curveType: The type of curve to calculate.
    /// - Returns: The geodesic densified geometry.
    public static func geodeticDensify(_ geometry: ArcGIS.Geometry, maxSegmentLength: Double, lengthUnit: ArcGIS.LinearUnit?, curveType: ArcGIS.GeometryEngine.GeodeticCurveType) -> ArcGIS.Geometry?

    /// Calculates the geodesic distance between the two points.
    /// - Parameters:
    ///   - point: A point object.
    ///   - other: Another point object.
    ///   - distanceUnit: The linear unit of measure for the returned results.
    ///   - azimuthUnit: The angular unit of measure for the returned results.
    ///   - curveType: The type of curve to calculate.
    /// - Returns: A structure containing the distance and the azimuth at both points for the geodesic curve that connects them.
    public static func geodeticDistance(from point: ArcGIS.Point, to other: ArcGIS.Point, distanceUnit: ArcGIS.LinearUnit?, azimuthUnit: ArcGIS.AngularUnit?, curveType: ArcGIS.GeometryEngine.GeodeticCurveType) -> ArcGIS.GeodeticDistanceResult?

    /// Calculates the geodesic length of the geometry.
    ///
    /// Supports `true` curves, calculating the result by densifying curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - lengthUnit: The unit of measure for the returned value. If `nil`, meters are assumed.
    ///   - curveType: The type of curve to calculate.
    /// - Returns: The geodesic length of the given geometry.
    public static func geodeticLength(of geometry: ArcGIS.Geometry, lengthUnit: ArcGIS.LinearUnit?, curveType: ArcGIS.GeometryEngine.GeodeticCurveType) -> Double

    /// Moves each point in the point collection by a geodesic distance.
    ///
    /// There must be the same spatial reference on each point in the input `Array` of points.
    /// The returned collection is in the same order as the input, but with new points at their destination locations.
    /// Specifying a negative distance moves points in the opposite direction from azimuth.
    /// - Parameters:
    ///   - points: An `Array` of ``Point`` geometries. Contents of the `Array` are copied.
    ///   - distance: The distance to move the points.
    ///   - distanceUnit: The unit of measure for distance. If `nil`, meters are assumed.
    ///   - azimuth: The azimuth angle of the direction for the points.
    ///   - azimuthUnit: The angular unit of measure for azimuth. If `nil`, degrees are assumed.
    ///   - curveType: The type of curve to calculate.
    /// - Returns: A new collection of points moved by the given distance from the input collection.
    public static func geodeticMove<S>(_ points: S, distance: Double, distanceUnit: ArcGIS.LinearUnit?, azimuth: Double, azimuthUnit: ArcGIS.AngularUnit?, curveType: ArcGIS.GeometryEngine.GeodeticCurveType) -> [ArcGIS.Point] where S : Sequence, S.Element == ArcGIS.Point

    /// Determines the nearest point in the input geometry to the input point, by using a shape preserving geodesic approximation of the input geometry.
    ///
    /// All geometry types are supported for the geometry parameter.
    /// - Parameters:
    ///   - geometry: A geometry object on which to calculate the nearest coordinate to the point parameter.
    ///   - point: The point from which to calculate the nearest coordinate on the geometry parameter.
    ///   - maxDeviation: The maximum distance that the geodesic geometry can deviate from the original, in the units of the deviationUnit parameter.
    ///   - deviationUnit: The unit of measure for the maxDeviation parameter. If `nil`, the units of maxDeviation are assumed to be meters.
    /// - Returns: A ``ProximityResult`` containing the results of the operation, where the ``ProximityResult/distance`` is
    /// returned in meters. Returns `nil` if the input geometry is empty. ``ProximityResult/distance`` is zero if the
    /// point lies inside an input polygon, polyline, or envelope.
    /// - Note: See Also: GeometryEngine.nearestCoordinate(Geometry, Point)
    public static func geodeticNearestCoordinate(in geometry: ArcGIS.Geometry, to point: ArcGIS.Point, maxDeviation: Double, deviationUnit: ArcGIS.LinearUnit? = nil) -> ArcGIS.ProximityResult?

    /// Calculates the intersection of two geometries.
    ///
    /// The result has the same dimensionality as the lower dimensionality
    /// of the two intersecting geometries. If there is no intersection with
    /// this dimensionality, returns an empty geometry. For example, the
    /// intersection of two polygons (geometries with area, so they have
    /// dimensionality of 2) or, say, a polygon and an envelope (also an
    /// area) is a polygon. Similarly, the intersection of a polyline (a
    /// line, so dimensionality of 1) and another polyline is always a
    /// polyline. Therefore when computing the intersection of polylines,
    /// this function does not return points where they cross, but rather
    /// lines of overlap. If there are no lines of overlap, an empty
    /// polyline is returned even if the input lines cross. To obtain all
    /// intersections, irrespective of dimensionality, see
    /// `GeometryEngine.intersections(_:_:)`. Returns an empty geometry if the
    /// two input geometries do not intersect. Returns `nil` on error.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry1: A geometry object.
    ///   - geometry2: Another geometry object.
    /// - Returns: A geometry object that represents the intersection of the given geometries.
    /// - Note: See Also: `GeometryEngine.intersections(_:_:)`
    public static func intersection(_ geometry1: ArcGIS.Geometry, _ geometry2: ArcGIS.Geometry) -> ArcGIS.Geometry?

    /// Calculates the intersection of two geometries.
    ///
    /// The returned collection contains one geometry of each dimension for
    /// which there are intersections. For example, if both inputs are
    /// polylines, the collection contains at most two geometries: the
    /// first a multipoint containing the points at which the lines cross,
    /// and the second a polyline containing the lines of overlap. If a
    /// crossing point lies within a line of overlap, only the line of
    /// overlap is present -- the result set is not self-intersecting. If
    /// there are no crossing points or there are no lines of overlap, the
    /// respective geometry is not be present in the returned
    /// collection. If the input geometries do not intersect, the resulting
    /// collection is empty. The table below shows, for each
    /// combination of pairs of input geometry types, the types of geometry
    /// that are contained within the returned collection if there are
    /// intersections of that type.
    /// <table>
    /// <caption>Set of potential output geometry types for pairs of input geometry types</caption>
    /// <tr><th>Input type       <th>Point/Multipoint <th>Polyline             <th>Polygon/Envelope
    /// <tr><th>Point/Multipoint <td>Multipoint       <td>Multipoint           <td>Multipoint
    /// <tr><th>Polyline         <td>Multipoint       <td>Multipoint, Polyline <td>Multipoint, Polyline
    /// <tr><th>Polygon/Envelope <td>Multipoint       <td>Multipoint, Polyline <td>Multipoint, Polyline, Polygon
    /// </table>
    /// The geometries in the returned collection are sorted by ascending
    /// dimensionality, e.g. multipoint (dimension 0) then polyline
    /// (dimension 1) then polygon (dimension 2) for the intersection of two
    /// geometries with area that have intersections of those types.
    /// Returns `nil` on error.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry1: A geometry object.
    ///   - geometry2: Another geometry object.
    /// - Returns: A collection of geometry objects that represent the intersection of the given geometries.
    /// - Note: See Also: `GeometryEngine.intersection(_:_:)`
    public static func intersections(_ geometry1: ArcGIS.Geometry, _ geometry2: ArcGIS.Geometry) -> [ArcGIS.Geometry]

    /// Returns a Boolean value indicating whether `geometry` crosses `other`.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if `geometry` crosses `other`, otherwise `false`.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, crossing other: ArcGIS.Geometry) -> Bool

    /// Tests if the two geometries are disjoint.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if the two geometries are disjoint, `false` otherwise.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, disjointWith other: ArcGIS.Geometry) -> Bool

    /// Tests if two geometries are equal
    ///
    /// The geometries are equal if they have the same spatial reference systems, geometry type and points.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if the two geometries are equal, `false` otherwise.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, equivalentTo other: ArcGIS.Geometry) -> Bool

    /// Tests if two geometries intersect.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if the two geometries intersect, `false` otherwise.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, intersecting other: ArcGIS.Geometry) -> Bool

    /// Tests if two geometries overlap.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if the two geometries overlap, `false` otherwise.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, overlapping other: ArcGIS.Geometry) -> Bool

    /// Test if the two geometries are related by the given relation.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    ///   - relation: The DE-9IM string to be evaluated
    /// - Returns: `true` if the two geometries have the given relationship, `false` otherwise.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, relatedTo other: ArcGIS.Geometry, byRelation relation: String) -> Bool

    /// Test if the two geometries touch on their borders.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if the two geometries touch, `false` otherwise.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, touching other: ArcGIS.Geometry) -> Bool

    /// Tests if geometry1 is within geometry2.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - other: Another geometry object.
    /// - Returns: `true` if geometry1 is within geometry2, `false` otherwise.
    public static func isGeometry(_ geometry: ArcGIS.Geometry, within other: ArcGIS.Geometry) -> Bool

    /// Gets a value indicating whether or not the geometry is simple.
    ///
    /// Point geometry is always simple.
    ///
    /// For Multi_point: there can be no point with exactly equal x and y - the tolerance is not taken into account.
    ///
    /// For Polylines: the only condition is there can be no degenerate segments. When the polyline has no z, the
    /// degenerate segments are those that have length in xy plane less or equal the tolerance. When the polyline
    /// has z, the degenerate segments are those that are shorter than the tolerance in xy plane, and the
    /// change in z-value along the segment is less than or equal to the z-tolerance.
    ///
    /// For Polygons:
    /// * Exterior rings are clockwise, and holes are counterclockwise
    /// * Rings can touch other rings in finite number of points
    /// * Rings can be self tangent in finite number of points
    /// * Vertices are either exactly coincident, or further than the Spatial_reference
    ///   tolerance from each other
    /// * If a vertex is not equal to any boundary point of a segment, it has to be further
    ///   than tolerance from any segment
    /// * No segment length is zero or less than tolerance
    /// * Each path contains at least three non-equal vertices
    /// * No empty paths allowed
    /// * Order of rings does not matter
    ///
    /// Supports `true` curves.
    /// - Parameter geometry: The geometry object.
    /// - Returns: `true` if the geometry object is simple.
    public static func isSimple(_ geometry: ArcGIS.Geometry) -> Bool

    /// Calculates an interior point for the given polygon. This point can be used by clients to place a label for the polygon.
    ///
    /// Supports `true` curves.
    /// - Parameter polygon: A polygon object.
    /// - Returns: A geometry object that represents the intersection of the given geometries.
    public static func labelPoint(for polygon: ArcGIS.Polygon) -> ArcGIS.Point?

    /// Calculates the length of the given geometry.
    ///
    /// Supports `true` curves.
    /// - Parameter geometry: A geometry object.
    /// - Returns: The length of the given geometry.
    public static func length(of geometry: ArcGIS.Geometry) -> Double

    /// Determines the nearest point in the input geometry to the input point using a simple planar measurement.
    ///
    /// Input geometry of type ``Envelope`` is not supported. To find the nearest coordinate on
    /// an ``Envelope``, convert it to a ``Polygon`` first.
    ///
    /// If the specified geometry is a polyline or polygon the nearest coordinate is the closest
    /// point in a segment that comprises geometry; it may not necessarily be the closest
    /// vertex of a segment. If you want to obtain the closest vertex in the polyline or
    /// polygon use the `GeometryEngine.nearestVertex(in:to:)` method instead.
    ///
    /// Planar measurements of distance and area can be extremely inaccurate if using an unsuitable spatial reference.
    /// Ensure that you understand the potential for error with the geometry's spatial reference. If you need to calculate
    /// more accurate results consider using a different spatial reference, or using the geodetic equivalent,
    /// `GeometryEngine.geodeticNearestCoordinate(in:to:maxDeviation:deviationUnit:)`.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - point: The point of interest.
    /// - Returns: A ``ProximityResult`` containing the results of the operation. This is `nil` if the input geometry is empty.
    /// ``ProximityResult/distance`` is zero if the point lies inside an input polygon, polyline, or envelope.
    public static func nearestCoordinate(in geometry: ArcGIS.Geometry, to point: ArcGIS.Point) -> ArcGIS.ProximityResult?

    /// Returns a ``ProximityResult`` that describes the nearest vertex in the input geometry to the input point.
    ///
    /// Input geometry of type ``Envelope`` is not supported. To find the nearest vertex on an ``Envelope``, convert it to a ``Polygon`` first.
    ///
    /// Input geometries with `true` curves (where ``Geometry/hasCurves`` is `true`) are supported, although curve
    /// segments do not affect the return value.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - point: The point of interest.
    /// - Returns: A struct containing the results of the operation.
    public static func nearestVertex(in geometry: ArcGIS.Geometry, to point: ArcGIS.Point) -> ArcGIS.ProximityResult?

    /// Folds the geometry into a range of 360 degrees.  This may be necessary when wrap around is enabled on the map.
    ///
    /// Supports `true` curves.
    /// - Parameter geometry: A geometry object.
    /// - Returns: The normalized geometry.
    public static func normalizeCentralMeridian(of geometry: ArcGIS.Geometry) -> ArcGIS.Geometry?

    /// Creates an offset version of the input geometry.
    ///
    /// The offset operation creates a geometry that is a constant distance from the input geometry.  If is similar to buffering, but produces
    /// a one sided result.  If distance > 0, then the offset geometry is constructed to the right of the input geometry, otherwise it is constructed
    /// to the left.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - distance: The offset distance for the new geometry.
    ///   - offsetType: The offset type the resulting geometry.
    ///   - bevelRatio: The ratio used to produce a bevel join instead of a miter join (used only when the offset type is Miter).
    ///   - flattenError: The maximum distance of the resulting segments compared to the `true` circular arc (used only when the offset type if round).
    /// - Returns: The offset geometry object.
    public static func offset(_ geometry: ArcGIS.Geometry, byDistance distance: Double, offsetType: ArcGIS.GeometryEngine.OffsetType, bevelRatio: Double, flattenError: Double) -> ArcGIS.Geometry?

    /// Return the point at the given distance along the line.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - polyline: A line.
    ///   - distance: The distance along the line of the point to return, in the line's units.
    /// - Returns: the point at the given distance along the line. If
    /// 'distance' is less than or equal to zero, the point returned is
    /// coincident with the start of the line. If 'distance' is greater than
    /// or equal to the line's length, the point returned is coincident with
    /// the end of the line. If the line has multiple parts, and the
    /// distance falls exactly on a boundary between two parts, the returned
    /// point is coincident with either the end of one part or the
    /// start of the next--which is undetermined.
    public static func point(along polyline: ArcGIS.Polyline, atDistance distance: Double) -> ArcGIS.Point?

    /// Finds the location on the line nearest the input point, expressed as the
    /// fraction along the line's total geodesic length, if the point is
    /// within the specified distance from the closest location on the
    /// line.  The line and point must have consistent spatial references.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - polyline: The line to locate the point's distance along its length.
    ///   - point: The point to locate.
    ///   - tolerance: The maximum distance that a point is allowed to be from the line, in the units of the ``SpatialReference``. If the tolerance is -1, the fraction of the closest location on the line is always returned as long as the point lies between the two ends of the polyline. If the distance from the point to the closest location on the line is greater than the tolerance, or the tolerance is -1 and the point does not lie between the two ends of the polyline, `nan` is returned.
    /// - Returns: The length along the line nearest the input point, expressed as the fraction of the line's length between 0.0 and 1.0, or `nan` if the point is outside the tolerance.
    public static func polyline(_ polyline: ArcGIS.Polyline, fractionalLengthClosestTo point: ArcGIS.Point, tolerance: Double) -> Double

    /// Projects the given geometry from its current spatial reference system into the given output spatial reference system, applying the datum transformation provided.
    ///
    /// Use this overload to project a geometry if the difference between the input geometry's SpatialReference
    /// and the outputSpatialReference involves a change of datum, and you do not wish to use the default datum
    /// transformation used by `GeometryEngine.project(_:into:datumTransformation:)`.
    ///
    /// Supports `true` curves. Projecting curves located at poles and coordinate system horizons using the ArcGIS
    /// Maps API may give results that differ slightly from other ArcGIS software. This is because it uses a
    /// different geometry projection function.
    /// - Parameters:
    ///   - geometry: A geometry object.
    ///   - outputSpatialReference: The spatial reference system to project to.
    ///   - datumTransformation: The datum transformation that describes how coordinates are converted from one coordinate system to another.
    /// - Returns: The geometry projected into the given SpatialReference. If the input geometry has a `nil` SpatialReference,
    /// no projection occurs; instead, an identical geometry with the given SpatialReference is returned.
    public static func project<Geometry>(_ geometry: Geometry, into outputSpatialReference: ArcGIS.SpatialReference, datumTransformation: ArcGIS.DatumTransformation? = nil) -> Geometry? where Geometry : ArcGIS.Geometry

    /// Reshape polygons or polylines with a single path polyline.
    ///
    /// Performs the reshape operation on a polygon or polyline using a
    /// single path polyline as the reshaper. The output geometry takes the
    /// shape of the Multi_path where it first intersects the reshaper to
    /// the last intersection. The first and last intersection points of the
    /// reshaper are chosen closest to the end points of the reshaper in the
    /// case that multiple intersections are found. For polygons, only
    /// individual paths can be reshaped. However, polylines can be reshaped
    /// across paths. If the geometry cannot be reshaped by the input
    /// reshaper, then `nil` is returned.
    /// - Parameters:
    ///   - multipart: The polygon or polyline to be reshaped.
    ///   - reshaper: The single path polyline reshaper
    /// - Returns: The reshaped polygon or polyline. Returns `nil` on error.
    public static func reshape<Multipart>(_ multipart: Multipart, usingReshaper reshaper: ArcGIS.Polyline) -> Multipart? where Multipart : ArcGIS.Multipart

    /// Simplifies the given geometry to make it topologically consistent according to its geometry type.
    ///
    /// Supports `true` curves.
    /// - Parameter geometry: A geometry object.
    /// - Returns: The simplified geometry.
    public static func simplify<Geometry>(_ geometry: Geometry) -> Geometry? where Geometry : ArcGIS.Geometry

    /// Calculates the symmetric difference (exclusive or) of the two geometries.
    /// - Parameters:
    ///   - geometry1: A geometry object.
    ///   - geometry2: Another geometry object.
    /// - Returns: The symmetric difference of the two geometries.
    public static func symmetricDifference(_ geometry1: ArcGIS.Geometry, _ geometry2: ArcGIS.Geometry) -> ArcGIS.Geometry?

    /// Calculates the union of the two geometries.
    ///
    /// If the two geometries have different dimensionality, returns a copy
    /// of the geometry with the higher dimensionality. E.g. if given a
    /// polygon and a point, returns the polygon.
    ///
    /// Supports `true` curves.
    /// - Parameters:
    ///   - geometry1: A geometry object.
    ///   - geometry2: Another geometry object.
    /// - Returns: The union of the two geometries.
    public static func union(_ geometry1: ArcGIS.Geometry, _ geometry2: ArcGIS.Geometry) -> ArcGIS.Geometry?

    /// Calculates the union of a collection of geometries
    ///
    /// There must be at least one geometry in the given collection.
    /// The geometries must have consistent spatial references.
    /// If the collection contains geometries of differing dimensionality,
    /// returns the union of the subset of geometries with the highest
    /// dimensionality. E.g. given a collection of polygons, polylines and
    /// points, returns the union of the polygons.
    ///
    /// Supports `true` curves.
    /// - Parameter geometries: A collection of geometries.
    /// - Returns: The union of all the geometries in the given collection. Returns `nil` on error.
    public static func union(of geometries: [ArcGIS.Geometry]) -> ArcGIS.Geometry?
}

extension GeometryEngine {

    /// Creates a new geometry from the given geometry with the specified *z*
    /// values.
    /// - Parameters:
    ///   - geometry: The geometry from which to create the new geometry.
    ///   - z: The *z* value for the new geometry or `nil` if the new geometry
    ///   should not have *z* values.
    public static func makeGeometry<Geometry>(from geometry: Geometry, z: Double?) -> Geometry where Geometry : ArcGIS.Geometry

    /// Creates a new geometry from the given geometry with the specified *m*
    /// values.
    /// - Parameters:
    ///   - geometry: The geometry from which to create the new geometry.
    ///   - m: The *m* value for the new geometry or `nil` if the new geometry
    ///   should not have *m* values.
    public static func makeGeometry<Geometry>(from geometry: Geometry, m: Double?) -> Geometry where Geometry : ArcGIS.Geometry

    /// Creates a new geometry from the given geometry with the specified *z*
    /// and *m* values.
    /// - Parameters:
    ///   - geometry: The geometry from which to create the new geometry.
    ///   - z: The *z* value for the new geometry or `nil` if the new geometry
    ///   should not have *z* values.
    ///   - m: The *m* value for the new geometry or `nil` if the new geometry
    ///   should not have *m* values.
    public static func makeGeometry<Geometry>(from geometry: Geometry, z: Double?, m: Double?) -> Geometry where Geometry : ArcGIS.Geometry
}

extension GeometryEngine.GeodeticCurveType : Equatable {
}

extension GeometryEngine.GeodeticCurveType : Hashable {
}

extension GeometryEngine.OffsetType : Equatable {
}

extension GeometryEngine.OffsetType : Hashable {
}

/// A boolean input or output parameter.
///
/// Corresponds to GPBoolean parameter type on the service.
/// - Since: 200.1
final public class GeoprocessingBoolean : ArcGIS.GeoprocessingParameter {

    /// Create a geoprocessing boolean parameter with the given value.
    /// - Parameter value: The value of the parameter.
    public convenience init(value: Bool)

    /// The value of this parameter.
    final public var value: Bool
}

/// A data file input or output parameter.
///
/// Corresponds to GPDataFile parameter type on the service.
/// - Since: 200.1
public class GeoprocessingDataFile : ArcGIS.GeoprocessingParameter {

    /// Create a geoprocessing data parameter with the given URL.
    /// - Parameter url: The URL of the data file location.
    public convenience init(url: URL)

    /// The input file path of this parameter. This should be the location on disk of a file that will
    /// be uploaded to the server that the geoprocessing task will run on.
    ///
    /// This is only for input parameters. Setting this will override a URL set with ``url``.
    /// Note that this property will be ignored if uploadId is set.
    /// - Note: See Also: ``url``, ``uploadID``
    public var inputFileURL: URL?

    /// The upload item id of this parameter. This should be the item id of an item in the geoprocessing service's
    /// uploads resource.
    ///
    /// This is only for input parameters. This will be the upload id of an item previously uploaded to the server. Note
    /// that if this property is set it will cause both the inputFilePath and URL properties to be ignored.
    /// - Note: See Also: ``url``, ``inputFileURL``
    public var uploadID: String

    /// The URL of this parameter. This will be the location of the data file for an input parameter.
    ///
    /// This is only for input parameters to a URL containing the input data file. Ensure this URL accessible to the service.
    /// A geoprocessing service can have an uploads rest resource associated with it for placing inputs.
    ///
    /// Note that if inputFilePath or uploadId are set the URL property will be ignored.
    /// - Note: See Also: ``inputFileURL``, ``uploadID``
    public var url: URL?

    /// Fetches the data file at the URL in the ``url`` property.
    ///
    /// If filePath is a directory, the file will be given the name of the file taken from the
    /// end of the ``url``. The full file path will be available as the returned task's result.
    /// Alternatively filePath can be a destination filename within an existing directory.
    /// Note that any pre-existing file at that location with the same name will be deleted first.
    /// - Parameter fileURL: Path to a directory or full file name.
    /// - Returns: Returns a task that fetches the data file at the ``url``. The task's result
    /// is the full file path.
    public func download(to fileURL: URL) async throws -> URL
}

/// A date input or output parameter.
///
/// Corresponds to GPDate parameter type on the service.
/// - Since: 200.1
final public class GeoprocessingDate : ArcGIS.GeoprocessingParameter {

    /// Create a geoprocessing date parameter with the given value.
    /// - Parameter value: The value of the parameter as a `Date`.
    public convenience init(value: Date)

    /// The value of this parameter as a `Date`.
    final public var value: Date
}

/// A double input or output parameter.
///
/// Corresponds to GPDouble parameter type on the service.
/// - Since: 200.1
final public class GeoprocessingDouble : ArcGIS.GeoprocessingParameter {

    /// Create a geoprocessing double parameter with the given value.
    /// - Parameter value: The value of the parameter.
    public convenience init(value: Double)

    /// The value of this parameter.
    final public var value: Double
}

/// The list of geoprocessing execution types.
///
/// This is used to indicate the geoprocessing service's execution type.
/// Every geoprocessing service is exposed either as a submit or execute operation on the ArcGIS Server or Local Server
/// and the execution type needs to match the used service.
/// - Since: 200.1
public enum GeoprocessingExecutionType {

    /// Submit geoprocessing job asynchronously. Corresponds execution type 'esriExecutionTypeAsynchronous' on service definition.
    case asynchronousSubmit

    /// Execute geoprocessing job synchronously. Corresponds execution type 'esriExecutionTypeSynchronous' on service definition.
    case synchronousExecute

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.GeoprocessingExecutionType, b: ArcGIS.GeoprocessingExecutionType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension GeoprocessingExecutionType : Equatable {
}

extension GeoprocessingExecutionType : Hashable {
}

/// Geoprocessing feature set is a read-only set of features that are returned from ``GeoprocessingFeatures/features``.
/// - Since: 200.1
final public class GeoprocessingFeatureSet : ArcGIS.FeatureSet {

    /// Indicates if retrieving output features resulted in exceeding the transfer limit.
    final public var transferLimitIsExceeded: Bool { get }

    /// The fields of the feature set.
    /// - Note: See Also: `Array`, ``Field``
    final public var fields: [ArcGIS.Field] { get }

    /// The geometry type stored in this feature set.
    final public var geometryType: ArcGIS.Geometry.Type? { get }

    /// The spatial reference of the feature set.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// Returns the feature iterator.
    /// - Returns: An `AnySequence` that returns ``Feature`` types.
    final public func features() -> AnySequence<ArcGIS.Feature>
}

/// The geoprocessing features used as input or output parameters.
///
/// Corresponds to GPRecordSet and GPFeatureRecordSetLayer parameter types on the service.
///
/// A feature contains a ``features`` and may contains extra attributes on ``GeoElement/attributes`` collection.
/// A record (or a row) doesn't contain ``Feature`` and information is stored in attributes on
/// ``GeoElement/attributes`` collection.
///
///
/// When ``features`` are returned as an output parameter the returned results are provided as a read-only
/// list of ``Feature`` using ``GeoprocessingFeatureSet``. These features can be visualized on a map
/// using temporary ``Graphic`` on a ``GraphicsOverlay`` or using ``FeatureCollectionTable`` on a
/// ``FeatureCollectionLayer``. If used geoprocessing service is configured to use a result map server, then
/// ``GeoprocessingResult/mapImageLayer`` was populated and it can be used to visualize the results using the symbology
/// predefined by the service.
///
/// When providing ``GeoprocessingFeatures`` as an input to the geoprocessing task, features can be provided directly from the
/// ``FeatureQueryResult`` that was returned from the ``FeatureTable``. If there is a need to create a new set a features
/// or records, ``FeatureCollectionTable`` can be used.
/// - Since: 200.1
final public class GeoprocessingFeatures : ArcGIS.GeoprocessingParameter {

    /// Create a geoprocessing features parameter with an input ``FeatureSet``
    /// - Parameter features: An element that contains a type implementing the ``FeatureSet``
    public convenience init(features: ArcGIS.FeatureSet)

    /// Create a geoprocessing features parameter with a URL for the service to retrieve a feature set for input.
    /// - Parameter url: A URL to a feature set
    public convenience init(url: URL)

    /// Indicates if features can be fetched from the service of an output parameter.
    ///
    /// This property applies to output parameters. It indicates the parameter is an output parameter that can
    /// fetch features from the geoprocessing service.
    /// Depending on the type of the service the ``features`` may already be available.
    /// If features are not present then this property indicates that you can use `GeoprocessingFeatures.fetchOutputFeatures()` to
    /// request features and asynchronously update the ``features`` property.
    final public var canFetchOutputFeatures: Bool { get }

    /// The features that are sent to or returned from the geoprocessing service.
    ///
    /// For an input parameter, this contains features to be sent to the geoprocessing service. This property will be ignored if ``url`` is set.
    /// For an output parameter, this can contain features returned from a geoprocessing service depending on the service configuration.
    /// It can be `nil` for services that have a map service, in which case calling `GeoprocessingFeatures.fetchOutputFeatures()`
    /// will retrieve the features from the service.
    final public var features: ArcGIS.FeatureSet?

    /// The input URL that will be sent to the geoprocessing service to retrieve features.
    ///
    /// The URL is for input parameters only. For output parameters this is empty.
    /// For input it must be a URL that is accessible to the geoprocessing service so it can retrieve the feature set.
    /// If this property is set, it will override the ``features`` property.
    final public var url: URL?

    /// Starts a request to fetch output features from the service.
    ///
    /// If the parameter is an output of a geoprocessing service this can be used to fetch features if
    /// ``features`` is `nil`.
    /// It is not necessary to call this if ``features`` is already populated.
    final public func fetchOutputFeatures() async throws
}

/// Geoprocessing job is used to run the geoprocessing task on the service.
/// - Note: See Also: `GeoprocessingTask.makeJob(parameters:)`
/// - Since: 200.1
final public class GeoprocessingJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// The input geoprocessing parameters as passed to this job via `GeoprocessingTask.makeJob(parameters:)`.
    ///
    /// The returned ``GeoprocessingParameters`` will be a reference to the same instance
    /// that was passed to `GeoprocessingTask.makeJob(parameters:)`.
    /// If this parameters object contains any ``GeoprocessingDataFile`` instances created with a local
    /// file path, they will be updated on job completion to contain the upload id of the uploaded local
    /// file.
    final public var parameters: ArcGIS.GeoprocessingParameters { get }

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.GeoprocessingResult

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.GeoprocessingJob.Output, Error> { get async }
}

/// A linear unit input or output parameter.
///
/// Corresponds to GPLinearUnit parameter type on the service.
///
/// Geoprocessing tasks support a set of linear units defined in the ``Unit-swift.enum``.
///
/// When a ``GeoprocessingLinearUnit`` parameter is created with one of the supported ``Unit-swift.enum`` the value is sent
/// to the service using defined linear unit type.
///
/// When a ``GeoprocessingLinearUnit`` parameter is created with a ``LinearUnit``, the value is converted to meters if the
/// type is not supported. For example if provided ``LinearUnit`` is international miles, the value is converted to meters since only the
/// US Survey Miles unit is supported in geoprocessing. After ``GeoprocessingLinearUnit`` is created, the used linear unit type can be checked from
/// `GeoprocessingLinearUnit.linearUnit`.
///
/// When ``GeoprocessingLinearUnit`` is created with a supported ``LinearUnit``, then no conversion takes place and the value is sent
/// to the service using the defined type.
///
/// When ``GeoprocessingLinearUnit`` is returned as an output parameter, you can get ``LinearUnit`` using `GeoprocessingLinearUnit.linearUnit`
/// method.
/// - Since: 200.1
final public class GeoprocessingLinearUnit : ArcGIS.GeoprocessingParameter {

    /// The list of geoprocessing linear unit types.
    ///
    /// This defines the subset of linear units supported by ``GeoprocessingLinearUnit``.
    public enum Unit {

        /// Centimeter.
        case centimeter

        /// Decimeter.
        case decimeter

        /// Kilometer.
        case kilometer

        /// Meter.
        case meter

        /// Millimeter.
        case millimeter

        /// Typographical point (1/72").
        case point

        /// US nautical mile (pre-1954).
        case usNauticalMile

        /// US survey foot.
        case usSurveyFoot

        /// US survey inch.
        case usSurveyInch

        /// US survey mile.
        case usSurveyMile

        /// US survey yard.
        case usSurveyYard

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GeoprocessingLinearUnit.Unit, b: ArcGIS.GeoprocessingLinearUnit.Unit) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Create a geoprocessing linear unit parameter with the given distance. The unit is
    /// assumed to be meters.
    ///
    /// Note that although this constructor defaults to meters, the unit can be changed by
    /// calling ``unit-swift.property``. If the unit is changed in this way, the
    /// value is not converted.
    /// - Parameter distance: The distance value of the parameter.
    public convenience init(distance: Double)

    /// Create a geoprocessing linear unit parameter with the given distance and linear unit.
    ///
    /// Note that if the given linear unit does not correspond to any of the values in
    /// ``Unit-swift.enum``, the unit will be converted internally to meters. This
    /// means that the distance property will return a different value to that set.
    /// - Parameters:
    ///   - distance: The distance value of the parameter.
    ///   - linearUnit: The unit of distance.
    public convenience init(distance: Double, linearUnit: ArcGIS.LinearUnit)

    /// Create a geoprocessing linear unit parameter with the given distance and linear unit WKID.
    ///
    /// Note that if the given linear unit WKID does not correspond to any of the values in
    /// ``Unit-swift.enum``, the unit will be converted internally to meters. This
    /// means that the distance property will return a different value to that set.
    /// - Parameters:
    ///   - distance: The distance value of the parameter.
    ///   - linearUnitID: The WKID of the unit of distance.
    public convenience init(distance: Double, linearUnitID: ArcGIS.LinearUnit.ID)

    /// Create a geoprocessing linear unit parameter with the given distance and linear unit.
    ///
    /// The ``Unit-swift.enum`` used here represents the subset of linear
    /// units supported by geoprocessing.
    /// - Parameters:
    ///   - distance: The distance value of the parameter.
    ///   - unit: The unit of distance.
    public convenience init(distance: Double, unit: ArcGIS.GeoprocessingLinearUnit.Unit)

    /// The distance value of this parameter.
    ///
    /// Note that if this geoprocessing linear unit instance was created with
    /// a unit type unsupported by geoprocessing, this value will differ from that set
    /// as it will have been converted to meters.
    final public var distance: Double

    /// Gets the geometry linear unit that corresponds to the unit of this parameter.
    ///
    /// This method gives a convenient means of using a geoprocessing linear unit
    /// with the geometry API. The returned ``LinearUnit`` can be used to convert
    /// the distance value of this parameter instance to any other linear unit supported
    /// by the geometry API.
    final public var linearUnit: ArcGIS.LinearUnit { get }

    /// The geoprocessing unit of this parameter.
    final public var unit: ArcGIS.GeoprocessingLinearUnit.Unit
}

extension GeoprocessingLinearUnit.Unit : Equatable {
}

extension GeoprocessingLinearUnit.Unit : Hashable {
}

/// A long input or output parameter.
///
/// Corresponds to GPLong parameter type on the service.
/// The range of values corresponds to a 32 bit integer from -2,147,483,648 to 2,147,483,647.
/// - Since: 200.1
final public class GeoprocessingLong : ArcGIS.GeoprocessingParameter {

    /// Create a geoprocessing long parameter with the given value.
    /// - Parameter value: The value of the parameter.
    public convenience init(value: Int32)

    /// The value of this parameter.
    final public var value: Int32
}

/// A multi value input or output parameter which contains a collection of single geoprocessing parameter type.
///
/// Corresponds to GPMultiValue parameter type on the service.
///
/// Note that all the parameters in the collection must be of the same type.
/// - Note: See Also: `GeoprocessingMultiValue.init?(parameterType:values:)`
/// - Since: 200.1
final public class GeoprocessingMultiValue : ArcGIS.GeoprocessingParameter {

    /// The type of the geoprocessing parameters in this multi-value parameter's collection.
    ///
    /// An exception will be thrown if the given type doesn't match that of the collection
    /// if the collection has already been set.
    final public var valueParameterType: ArcGIS.GeoprocessingParameter.Type { get }

    /// The collection of geoprocessing parameters from this parameter.
    ///
    /// All of the geoprocessing parameters in the given `Array` should be of the same type.
    /// If the parameter type has been set in this multi value, the given collection of
    /// geoprocessing parameters must be of the matching type or an exception will be thrown.
    final public var values: [ArcGIS.GeoprocessingParameter] { get }

    /// Adds a sequence of `GeoprocessingParameter` values to the end of the `values` property.
    /// - Parameter newValues: The new `GeoprocessingParameter` values to append.
    final public func addValues<S>(_ newValues: S) where S : Sequence, S.Element == ArcGIS.GeoprocessingParameter

    /// Adds a `GeoprocessingParameter` value to the end of the `values` property.
    /// - Parameter newValue: The new `GeoprocessingParameter` value to append.
    final public func addValue(_ newValue: ArcGIS.GeoprocessingParameter)

    /// Inserts a collection of `GeoprocessingParameter` values into the `values` property at the specified position.
    /// - Parameters:
    ///   - newValues: The new `GeoprocessingParameter` values to insert.
    ///   - index: The position at which to insert the new `GeoprocessingParameter` values.
    final public func insertValues<C>(_ newValues: C, at index: Int) where C : Collection, C.Element == ArcGIS.GeoprocessingParameter

    /// Inserts a `GeoprocessingParameter` value into the `values` property at the specified position.
    /// - Parameters:
    ///   - newValue: The new `GeoprocessingParameter` value to insert.
    ///   - index: The position at which to insert the new `GeoprocessingParameter` value.
    final public func insertValue(_ newValue: ArcGIS.GeoprocessingParameter, at index: Int)

    /// Removes all values from the `values` property.
    final public func removeAllValues()

    /// Removes a sequence of `GeoprocessingParameter` values from the `values` property.
    /// - Parameter values: The `GeoprocessingParameter` values to remove.
    final public func removeValues<S>(_ values: S) where S : Sequence, S.Element == ArcGIS.GeoprocessingParameter

    /// Removes a `GeoprocessingParameter` value from the `values` property.
    /// - Parameter value: The `GeoprocessingParameter` value to remove.
    final public func removeValue(_ value: ArcGIS.GeoprocessingParameter)
}

extension GeoprocessingMultiValue {

    /// Create a geoprocessing multi value parameter with the given collection of geoprocessing parameters.
    ///
    /// All of the geoprocessing parameters in the given `Array` should be of the same type. This type
    /// should match the given `parameterType`.
    /// - Parameters:
    ///   - parameterType: The type of the parameters in the collection.
    ///   - values: The collection of geoprocessing parameters for this multi value.
    public convenience init(parameterType: ArcGIS.GeoprocessingParameter.Type, values: [ArcGIS.GeoprocessingParameter] = [])
}

/// Base class for all concrete parameter types that can be used in geoprocessing.
/// - Since: 200.1
public class GeoprocessingParameter {
}

/// Provides information on a single input or output parameter of a geoprocessing
/// task.
///
/// GeoprocessingParameterInfo instances are retrieved from a GeoprocessingTaskInfo by
/// calling ``GeoprocessingTaskInfo/parameterInfos``. Each instance in the list gives
/// the parameter's name and type along with a property indicating whether or not it is
/// optional (for input parameters) and whether it is an input or output parameter.
/// - Since: 200.1
final public class GeoprocessingParameterInfo {

    /// The list of geoprocessing parameter directions.
    ///
    /// This defines whether a geoprocessing parameter information instance defines an
    /// input or an output.
    public enum Direction {

        /// An input parameter.
        case input

        /// An output parameter.
        case output

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GeoprocessingParameterInfo.Direction, b: ArcGIS.GeoprocessingParameterInfo.Direction) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The geoprocessing parameter's category.
    final public var category: String { get }

    /// A list of value choices for this parameter.
    final public var choiceList: [String] { get }

    /// The geoprocessing parameter's data type.
    final public var dataType: ArcGIS.GeoprocessingParameter.Type { get }

    /// A new ``GeoprocessingParameter`` set to the default value
    /// for this parameter info instance.
    ///
    /// Either a parameter containing the default value for this
    /// parameter info or one with no value set if there is no default.
    final public var defaultParameter: ArcGIS.GeoprocessingParameter? { get }

    /// The geoprocessing parameter's description.
    final public var description: String { get }

    /// The geoprocessing parameter's direction: either input or output.
    final public var direction: ArcGIS.GeoprocessingParameterInfo.Direction { get }

    /// The geoprocessing parameter's display name.
    final public var displayName: String { get }

    /// Whether or not this geoprocessing parameter is required.
    final public var isRequired: Bool { get }

    /// If this parameter info describes a multivalue, this property indicates the type of the parameters
    /// contained in the multivalue.
    ///
    /// If this is not a multivalue parameter, this property will return `GeoprocessingUnknownParameter.Type`.
    final public var multiValueDataType: ArcGIS.GeoprocessingParameter.Type { get }

    /// The geoprocessing parameter's name.
    final public var name: String { get }

    /// Whether or not a geoprocessing feature parameter requires features with geometry.
    final public var requiresFeaturesWithGeometry: Bool { get }
}

extension GeoprocessingParameterInfo.Direction : Equatable {
}

extension GeoprocessingParameterInfo.Direction : Hashable {
}

/// Geoprocessing parameters contains input parameters that are sent to the target geoprocessing task.
///
/// GeoprocessingParameters contains both input parameters and environment variables that are used in
/// the target geoprocessing task. At a minimum all parameters that are set as required on the published task must to
/// be provided to run the task successfully. Parameters that have default values can be overridden by
/// providing a new value in the inputs dictionary. Optional parameters can be provided the same way.
/// - Since: 200.1
final public class GeoprocessingParameters {

    /// Create a geoprocessing input parameters object with the given execution type.
    ///
    /// Note that the execution type needs to match the expected execution type of
    /// the geoprocessing task being run as indicated by the service's metadata.
    /// - Parameter executionType: A ``GeoprocessingExecutionType`` indicating the job execution type.
    public convenience init(executionType: ArcGIS.GeoprocessingExecutionType)

    /// The execution type set on this geoprocessing parameters object.
    /// - Note: See Also: ``GeoprocessingExecutionType``
    final public var executionType: ArcGIS.GeoprocessingExecutionType { get }

    /// The input geoprocessing parameters dictionary.
    ///
    /// Can be made to this collection to modify the input parameters
    /// without needing to call setParameters.  The `Dictionary` will have keys
    /// of type `String` and elements of type ``GeoprocessingParameter``.
    /// - Note: See Also: `Dictionary.init(keyType:valueType:)`
    final public var inputs: [String : ArcGIS.GeoprocessingParameter] { get }

    /// Sets a value in the `inputs` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setInputValue(_ value: ArcGIS.GeoprocessingParameter?, forKey key: String)

    /// The output spatial reference.
    ///
    /// This property is the spatial reference that will be used for any output
    /// geometries. If neither output spatial reference nor process spatial reference are
    /// supplied, the input geometries' spatial reference will be used. If output spatial
    /// reference is not set but process spatial reference is, this will be used instead.
    final public var outputSpatialReference: ArcGIS.SpatialReference?

    /// The process spatial reference.
    ///
    /// This property is the spatial reference that will be used to perform any
    /// geometry operations. This spatial reference will also be used for output geometries
    /// if output spatial reference is not set.
    final public var processSpatialReference: ArcGIS.SpatialReference?

    /// Whether or not returned geometries will have m values.
    final public var returnsM: Bool

    /// Whether or not returned geometries will have z values.
    final public var returnsZ: Bool
}

/// A raster input or output parameter.
///
/// Corresponds to GPRasterData and GPRasterDataLayer parameter types on the service.
/// - Note: See Also: ``init()``, ``init(url:format:)``
/// - Since: 200.1
final public class GeoprocessingRaster : ArcGIS.GeoprocessingDataFile {

    /// Create a geoprocessing raster data parameter.
    public convenience init()

    /// Create a geoprocessing raster parameter with the given local file path.
    /// - Parameter localFileURL: The local path of a file to send with this raster parameter.
    public convenience init(localFileURL: URL)

    /// Create a geoprocessing raster parameter with the given upload ID.
    /// - Parameter uploadID: The upload ID of an item uploaded to the geoprocessing service.
    public convenience init(uploadID: String)

    /// Create a geoprocessing raster data parameter with the given URL. The image format will be determined
    /// from the URL.
    /// - Parameter url: The URL of the raster data location.
    public convenience init(url: URL)

    /// Create a geoprocessing date parameter with the given URL and image format.
    /// - Parameters:
    ///   - url: The URL of the raster data location.
    ///   - format: The image format of the raster data.
    public convenience init(url: URL, format: String)

    /// The image format of this parameter.
    final public var format: String
}

/// Contains output parameters returned from the service.
///
/// Single output parameters can be found from ``outputs`` dictionary where the key of the item
/// is the name of the output parameters and the value is the returned ``GeoprocessingParameter``.
///
/// If used geoprocessing service is configured to use result map server then ``mapImageLayer`` might be
/// populated. ``mapImageLayer`` is a dynamic map service that accompanies a geoprocessing service to visualize the geoprocessing results.
/// Each geodataset output parameter of a geoprocessing task will be added as a layer to a map service. The visualization of the layer is determined
/// by the symbology on geoprocessing service. ``mapImageLayer`` are mainly used to visualize ``GeoprocessingRaster`` or
/// ``GeoprocessingFeatures`` but in some cases ``GeoprocessingString`` is used as a reference to a geodataset which is added to the
/// result map service as a layer.
/// - Note: See Also: ``GeoprocessingJob/result``
/// - Since: 200.1
final public class GeoprocessingResult {

    /// The geoprocessing result's output map service layer if there is one defined for the geoprocessing service.
    ///
    /// The map image layer is returned not loaded.
    final public var mapImageLayer: ArcGIS.ArcGISMapImageLayer? { get }

    /// The geoprocessing result's output parameters.
    final public var outputs: [String : ArcGIS.GeoprocessingParameter] { get }
}

/// A string input or output parameter.
///
/// Corresponds to GPString parameter type on the service.
/// - Since: 200.1
final public class GeoprocessingString : ArcGIS.GeoprocessingParameter {

    /// Create a geoprocessing string parameter with the given value.
    /// - Parameter value: The value of the parameter.
    public convenience init(value: String)

    /// The value of this parameter.
    final public var value: String
}

/// GeoprocessingTask is used to run geoprocessing task that is published as a web service.
///
/// GeoprocessingTask is the main component when running geoprocessing tasks. The task might be
/// published through ArcGIS Server or Local server (on the platforms that supports it) using either synchronous
/// execute or asynchronous submit execution type. When ``GeoprocessingParameters`` is created it is
/// important to match ``GeoprocessingExecutionType`` to the value on the service.
/// - Note: See Also: ``init(url:)``
/// - Since: 200.1
final public class GeoprocessingTask : ArcGIS.Loadable {

    /// Create a geoprocessing task from a URL to a task within a ArcGIS REST geoprocessing service.
    /// - Parameter url: The URL of a task within an ArcGIS REST geoprocessing service.
    public convenience init(url: URL)

    /// The metadata of this geoprocessing task.
    final public var info: ArcGIS.GeoprocessingTaskInfo? { get }

    /// The URL of this geoprocessing task.
    final public var url: URL { get }

    /// Creates default parameters for a geoprocessing task.
    ///
    /// This will populate the parameters with default values for all of the input parameters defined by the service.
    /// If the service defines a default value for a parameter, this will be used. If no default value is defined for
    /// a parameter, it will be given an appropriate default for its type: boolean parameters `false`, string parameters
    /// an empty string, numerical parameters 0.
    /// The correct execution type for this task will also be set.
    /// - Returns: Returns a set of parameters that can be used to run this geoprocessing task. The element type of the
    /// task is ``GeoprocessingParameters``
    final public func makeDefaultParameters() async throws -> ArcGIS.GeoprocessingParameters

    /// Returns a job that when started will run a geoprocessing job on the server.
    /// - Parameter parameters: The parameters for submitting the geoprocessing job.
    /// - Returns: Returns a job to run a geoprocessing job on the server.
    final public func makeJob(parameters: ArcGIS.GeoprocessingParameters) -> ArcGIS.GeoprocessingJob

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// GeoprocessingTaskInfo contains information on a geoprocessing task.
///
/// GeoprocessingTaskInfo is retrieved from a loaded GeoprocessingTask instance by
/// calling ``GeoprocessingTask/info``. GeoprocessingTaskInfo
/// contains the name and description of the geoprocessing task along with execution
/// type and descriptions of all the task's parameters.
/// - Note: See Also: ``GeoprocessingTask/info``
/// - Since: 200.1
final public class GeoprocessingTaskInfo {

    /// The geoprocessing task's category.
    final public var category: String { get }

    /// The geoprocessing task's description.
    final public var description: String { get }

    /// The geoprocessing task's display name.
    final public var displayName: String { get }

    /// The geoprocessing task's execution type.
    final public var executionType: ArcGIS.GeoprocessingExecutionType { get }

    /// The geoprocessing task's help URL.
    final public var helpURL: URL { get }

    /// The geoprocessing task's name.
    final public var name: String { get }

    /// The list of geoprocessing task parameters information instances.
    ///
    /// The returned `Array` contains ``GeoprocessingParameterInfo`` instances.
    /// Each parameter information instance in the array describes one input or output
    /// parameter of the geoprocessing task. Includes such properties as name, data type,
    /// whether input or output and whether a particular input parameter is required or
    /// not.
    final public var parameterInfos: [ArcGIS.GeoprocessingParameterInfo] { get }

    /// The geoprocessing task URL.
    final public var url: URL { get }
}

/// A condition monitored by a ``GeotriggerMonitor``.
///
/// A ``Geotrigger`` defines a condition that can be continually monitored in real time. After
/// the condition is met, the ``Geotrigger`` defines how a ``GeotriggerNotificationInfo`` can be used
/// to inform the user.
///
/// A ``GeotriggerMonitor``, created with the ``Geotrigger``, handles monitoring and reporting.
///
/// You can create a ``FenceGeotrigger`` describing target areas, covered by spatial rules
/// such as enter or exit. This type of spatial monitoring is also known as "Geofencing".
///
/// If a ``Geotrigger`` is defined in a ``GeotriggersInfo``, check whether the
/// ``GeotriggerFeed`` is of type ``LocationGeotriggerFeed`` and, if so, supply a
/// ``LocationDataSource`` to provide your device location. Set the
/// ``LocationGeotriggerFeed/locationDataSource`` to your ``LocationDataSource`` - for example,
/// using the ``LocationDisplay/dataSource``.
/// - Since: 200.1
public class Geotrigger : Identifiable {

    /// The ``GeotriggerFeed`` that is monitored for changes.
    ///
    /// You can construct a ``LocationGeotriggerFeed`` from any ``LocationDataSource``.
    /// Typically, this shows the device location based on GPS, but can be any
    /// ``LocationDataSource``.
    public var feed: ArcGIS.GeotriggerFeed { get }

    /// A unique ID for the ``Geotrigger``.
    public var id: String { get }

    /// An ``ArcadeExpression`` that controls the notification details when a ``Geotrigger`` is met.
    ///
    /// The expression uses the Arcade language to generate notification information that can be:
    ///
    /// * a string literal that is the same for all notifications relating to this ``Geotrigger``
    /// * information that is specific to the attributes of objects that met the ``Geotrigger``
    ///
    /// The expression is evaluated whenever the ``Geotrigger`` condition is met, in order to
    /// populate the ``GeotriggerNotificationInfo/message`` property. Display this message to alert
    /// the user that the ``Geotrigger`` condition has been met. Note that the
    /// expression cannot be changed when the ``GeotriggerMonitor`` is running.
    ///
    /// For example, with a ``FenceGeotrigger``, using the following expression:
    ///
    /// "You have " + $fencenotificationtype + " " + $fencefeature.area_name
    ///
    /// returns the ``GeotriggerNotificationInfo/message`` "You have entered Area A", where
    /// "area_name" is an attribute field on the
    /// ``FenceGeotriggerNotificationInfo/fenceGeoElement``.
    ///
    /// Optionally, the expression can return extra properties in addition to the message. For
    /// example, it could produce another string, suitable for logging to a database. To supply
    /// additional properties, write an arcade expression that evaluates to a dictionary of key
    /// value pairs.
    ///
    /// * A value with the key "message" will populate the
    /// ``GeotriggerNotificationInfo/message`` property.
    ///
    /// * A value with the key "actions" will populate the
    /// ``GeotriggerNotificationInfo/actions`` property.
    ///
    /// * Any additional key value pairs are returned in the
    /// ``GeotriggerNotificationInfo/messageProperties`` dictionary.
    ///
    /// For example, this expression results in a ``GeotriggerNotificationInfo/message`` of:
    /// "Hello world" and a ``GeotriggerNotificationInfo/actions`` list of either
    /// "startTracking" or "stopTracking".
    ///
    /// var action = IIf($fencenotificationtype == 'enter', 'stopTracking', 'startTracking');
    /// return {
    ///   'message': 'Hello world',
    ///   'actions': [ action ]
    /// }
    ///
    /// The ``ArcadeExpression`` must evaluate to either a string or a dictionary; see
    /// ``ArcadeExpression/returnType``. Note that this property is an
    /// ``ArcadeExpression`` object, rather than a string.
    ///
    /// For more information on the available profile variables and functions for creating the
    /// ``messageExpression``, see the "Geotrigger Notification" profile at
    ///  https://developers.arcgis.com/arcade/profiles/.
    public var messageExpression: ArcGIS.ArcadeExpression?

    /// The name of the ``Geotrigger``.
    public var name: String

    /// A list of strings indicating the set of requested actions when a notification is delivered.
    ///
    /// This property shows the full list of recommended actions that the ``Geotrigger`` author intends to be taken. Note that there is no
    /// requirement to take any action when a notification is delivered, but these provide a way
    /// to understand the ``Geotrigger`` author's intention. Use this property to:
    ///
    /// * Display the expected behavior of a ``Geotrigger`` to the user, prior to monitoring.
    /// * Check that your app supports the expected actions for the ``Geotrigger``.
    ///
    /// This list of strings shows the full set of recommended actions for any notifications
    /// from this ``Geotrigger``. Individual ``GeotriggerNotificationInfo`` events may include a
    /// subset of these actions. The specific actions for an individual notification event (for
    /// example, when a given fence is entered) are shown in
    /// ``GeotriggerNotificationInfo/actions``. To populate the list of actions for a
    /// notification, the ``messageExpression`` must return a dictionary with the key
    /// "actions", and a value showing the list of action strings.
    ///
    /// The list of actions are simple strings, so you can use them to control any custom action
    /// you wish your app to perform.
    public var requestedActions: [String] { get }

    /// Adds a sequence of `String` values to the end of the `requestedActions` property.
    /// - Parameter newRequestedActions: The new `String` values to append.
    public func addRequestedActions<S>(_ newRequestedActions: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `requestedActions` property.
    /// - Parameter newRequestedAction: The new `String` value to append.
    public func addRequestedAction(_ newRequestedAction: String)

    /// Inserts a collection of `String` values into the `requestedActions` property at the specified position.
    /// - Parameters:
    ///   - newRequestedActions: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    public func insertRequestedActions<C>(_ newRequestedActions: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `requestedActions` property at the specified position.
    /// - Parameters:
    ///   - newRequestedAction: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    public func insertRequestedAction(_ newRequestedAction: String, at index: Int)

    /// Removes all values from the `requestedActions` property.
    public func removeAllRequestedActions()

    /// Removes a sequence of `String` values from the `requestedActions` property.
    /// - Parameter requestedActions: The `String` values to remove.
    public func removeRequestedActions<S>(_ requestedActions: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `requestedActions` property.
    /// - Parameter requestedAction: The `String` value to remove.
    public func removeRequestedAction(_ requestedAction: String)

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = String
}

/// An error than can occur when dealing with geotriggers.
/// - Since: 200.1
public enum GeotriggerError : Error {

    /// A problem was encountered with a ``GeotriggerFeed``.
    /// - Remark: An invalid ``GeotriggerFeed`` indicates that a ``GeotriggerMonitor`` is unable to
    /// perform checks. No ``GeotriggerNotificationInfo`` events will be sent.
    case invalidFeed

    /// A problem was encountered with the ``FenceParameters`` for a ``FenceGeotrigger``.
    /// - Remark: An invalid ``FenceParameters`` indicates that a ``GeotriggerMonitor`` is
    /// unable to perform checks. No ``GeotriggerNotificationInfo`` events will be sent.
    case invalidFenceParameters

    /// A problem was encountered with the fence data for a ``Geotrigger``.
    /// - Remark: There is a problem with some of the fence data and these will not be checked by a
    /// ``GeotriggerMonitor``. However, other data is valid and so
    /// ``GeotriggerNotificationInfo`` events can be sent.
    case invalidFenceData

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension GeotriggerError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.GeotriggerError, b: ArcGIS.GeotriggerError) -> Bool
}

extension GeotriggerError : Hashable {
}

/// Feed data required for a ``Geotrigger``.
///
/// A ``GeotriggerFeed`` is the dynamic component of a ``Geotrigger``. Typically, it is
/// the data that moves around and triggers the condition. For example, if the condition is
/// "notify me when my position comes within 50 meters of one of my target areas", the feed
/// data is "my position". Feed data for the device location is created as a
/// ``LocationGeotriggerFeed``.
/// - Since: 200.1
public class GeotriggerFeed {
}

/// A ``GeotriggerMonitor`` monitors a ``Geotrigger`` condition and, when it is met, results in a ``GeotriggerNotificationInfo``.
///
/// A ``Geotrigger`` defines a query that is evaluated against GIS data as it
/// changes in real time. For example, "Notify me when my device location enters one of my
/// target areas" or "Notify me when my device location is within 50 m of my destination".
///
/// A ``GeotriggerMonitor`` is created with a ``Geotrigger`` that it continually checks to
/// determine whether the condition has been met.
///
/// Once a ``GeotriggerMonitor`` is created, you begin checking the condition by calling
/// `GeotriggerMonitor.start()`. Once you are finished, call
/// `GeotriggerMonitor.stop()`. When a ``Geotrigger`` evaluates to `true`, a
/// ``notifications`` is sent. You can subscribe to the
/// notification info to receive details of where the ``Geotrigger`` was activated and the
/// condition that was met.
/// - Since: 200.1
final public class GeotriggerMonitor {

    /// The current status of a ``GeotriggerMonitor``.
    public enum Status {

        /// The ``GeotriggerMonitor`` has been stopped or has not been started yet.
        case stopped

        /// The ``GeotriggerMonitor`` is starting.
        case starting

        /// The ``GeotriggerMonitor`` has been started.
        case started

        /// The ``GeotriggerMonitor`` failed to start.
        case failedToStart

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GeotriggerMonitor.Status, b: ArcGIS.GeotriggerMonitor.Status) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Constructs a ``GeotriggerMonitor`` with a ``Geotrigger`` condition.
    /// - Parameter geotrigger: The ``Geotrigger`` which will be monitored.
    public convenience init(geotrigger: ArcGIS.Geotrigger)

    /// The ``Geotrigger`` that will be monitored.
    final public var geotrigger: ArcGIS.Geotrigger { get }

    /// Indicates that the ``GeotriggerMonitor`` condition has been meet.
    final public var notifications: AsyncStream<ArcGIS.GeotriggerNotificationInfo> { get }

    /// The current monitoring status of the ``GeotriggerMonitor``.
    ///
    /// A ``GeotriggerMonitor`` begins with a monitoring status of ``Status-swift.enum/stopped`` and changes to
    /// ``Status-swift.enum/started`` when you call `GeotriggerMonitor.start()`. When you call
    /// `GeotriggerMonitor.stop()`, the monitoring status changes to ``Status-swift.enum/stopped``.
    @ArcGIS.Streamed final public var status: ArcGIS.GeotriggerMonitor.Status { get }

    final public var $status: AsyncStream<ArcGIS.GeotriggerMonitor.Status> { get }

    /// An error that describes a problem encountered while starting or monitoring the ``Geotrigger``.
    ///
    /// A warning can occur at various stages of monitoring a ``Geotrigger``:
    ///
    /// * when starting the ``GeotriggerMonitor``
    /// * when accessing the components of the ``Geotrigger`` such as the ``GeotriggerFeed``
    /// * when performing on-going monitoring
    ///
    /// If the problem is resolved, this property will be cleared.
    ///
    /// Problems that occur when starting the ``GeotriggerMonitor`` result in a
    /// ``status-swift.property`` of ``Status-swift.enum/failedToStart``. These
    /// issues must be fixed and start called again before you receive any notifications. For
    /// example, if the ``Geotrigger/messageExpression`` is an invalid ``ArcadeExpression``,
    /// monitoring cannot be carried out.
    ///
    /// Problems that occur when accessing the components of the ``Geotrigger`` will not prevent
    /// the ``GeotriggerMonitor`` from starting. However, until the problem is resolved, you
    /// will not receive any notifications. For example, if a ``LocationGeotriggerFeed`` uses a
    /// ``LocationDataSource`` that is not started, you will not receive any notifications. Once
    /// the ``LocationDataSource`` is successfully started, monitoring will resume. If a
    /// ``FenceParameters`` has no valid data for a fence you will not receive any
    /// notifications.
    ///
    /// Problems that occur during ongoing monitoring relate to issues with individual objects
    /// such as the graphics that make up the fences for a ``GraphicFenceParameters``. These
    /// warnings do not prevent notifications from being sent for other valid fences. For example, a
    /// fence is considered invalid if it has:
    ///
    /// * an empty ``Geometry``
    /// * a missing ``SpatialReference``
    /// * a point or polyline ``Geometry`` and a buffer distance of 0
    @ArcGIS.Streamed final public var warning: Error? { get }

    final public var $warning: AsyncStream<Error?> { get }

    /// Starts evaluating the ``GeotriggerMonitor``.
    ///
    /// When the ``GeotriggerMonitor`` is successfully performing checks, the ``status-swift.property`` will be
    /// ``Status-swift.enum/started``.
    final public func start() async throws

    /// Stops evaluating the ``GeotriggerMonitor``.
    ///
    /// Stopping the ``GeotriggerMonitor`` prevents the condition from being evaluated and
    /// notifications from being sent. If you are using a ``LocationGeotriggerFeed`` created
    /// from a ``LocationDataSource``, the data source must also be stopped to turn off GPS
    /// receivers etc.
    ///
    /// When the ``GeotriggerMonitor`` is stopped, the ``status-swift.property`` will
    /// be ``Status-swift.enum/stopped``.
    final public func stop()
}

extension GeotriggerMonitor.Status : Equatable {
}

extension GeotriggerMonitor.Status : Hashable {
}

/// Provides details about a ``Geotrigger`` condition that has been met.
///
/// A ``GeotriggerNotificationInfo`` is sent by a ``GeotriggerMonitor`` whenever the condition
/// described by its ``Geotrigger`` is met. The ``Geotrigger`` also defines how the
/// ``GeotriggerNotificationInfo`` should be created. For example, it describes what message should
/// be displayed to the user.
/// - Since: 200.1
public class GeotriggerNotificationInfo {

    /// A set of strings describing recommended actions based on this notification.
    ///
    /// Optionally, use these strings to determine whether your app will perform custom behavior,
    /// such as showing messages or starting/stopping tracking. Note that there is no
    /// requirement to take any action when a notification is delivered, but these provide a way
    /// to understand the intention of the author of the ``Geotrigger``. This property can be
    /// empty.
    ///
    /// These actions are the result of evaluating the ``Geotrigger/messageExpression`` for the
    /// specific objects that triggered this notification. If the expression returns a
    /// dictionary containing a list of strings with the key "actions", they are shown in
    /// this property.
    ///
    /// For example, if the ``Geotrigger/messageExpression`` evaluates to a dictionary of
    /// ``messageProperties`` containing the following key value
    /// pairs:
    ///
    /// * "message" with the string "Hello world"
    /// * "actions" with a list of action strings "startTracking"
    ///
    /// ... then this property returns a list containing "startTracking". The list of
    /// actions are simple strings, so you can use them to control any custom action for
    /// your app.
    ///
    /// The author of a ``Geotrigger`` can supply a set of all the possible
    /// ``Geotrigger/requestedActions`` when defining the ``Geotrigger``. This property
    /// returns a list of strings indicating the actions that should be taken by your
    /// app, based on this ``GeotriggerNotificationInfo``.
    public var actions: [String] { get }

    /// A unique ID for the entity within the feed that triggered the notification info.
    ///
    /// This property is consistent for all notifications for a given feed entity. For example,
    /// use this ID to count the number of sites a team member visits.
    ///
    /// If a feed is a ``LocationGeotriggerFeed``, all location updates for that feed share
    /// the same ID.
    ///
    /// With a ``FenceGeotrigger``, you can combine this property with the
    /// ``FenceGeotriggerNotificationInfo/fenceID`` to create an ID that groups all
    /// notifications for a given feed entity and a specific fence. For example, use a
    /// concatenation of the two properties to display a list of areas of interest that are
    /// currently occupied and the details of who has entered them.
    ///
    /// To group events by the geotrigger, use the `Geotrigger.id` property.
    /// - Note: See Also: ``FenceGeotriggerNotificationInfo/fenceID``, `Geotrigger.id`
    public var feedEntityID: String { get }

    /// A ``Location``, received from the feed, that meets the ``GeotriggerMonitor`` condition.
    ///
    /// The ``Location`` is set if a ``LocationGeotriggerFeed`` was used to create the ``Geotrigger`` that the
    /// ``GeotriggerMonitor`` is monitoring. This allows you to access the position and meta-data from the feed,
    /// such as the horizontal accuracy, velocity, time stamp and other ``Location/additionalSourceProperties``.
    public var feedLocation: ArcGIS.Location? { get }

    /// The ``GeotriggerMonitor`` that sent this notification.
    ///
    /// The ``GeotriggerMonitor`` evaluates a specific ``Geotrigger`` condition that has been
    /// met by this ``GeotriggerNotificationInfo``. A single ``Geotrigger`` condition can result in
    /// multiple, repeat notifications.
    ///
    /// Use this property to interact directly with the ``GeotriggerMonitor``. For
    /// example, if you no longer want to receive future notifications, you can call
    /// `GeotriggerMonitor.stop()`.
    public var geotriggerMonitor: ArcGIS.GeotriggerMonitor { get }

    /// A message that describes the notification.
    ///
    /// The notification message is the result of evaluating the
    /// ``Geotrigger/messageExpression`` for the specific objects that
    /// triggered this notification. The message could be a hard-coded string or use attributes
    /// from an area of interest that was entered to display a custom message.
    ///
    /// For example, with a ``FenceGeotrigger``, setting the ``Geotrigger/messageExpression``
    /// property to:
    ///
    /// "You have entered " + $fencefeature.area_name
    ///
    /// would return the ``message`` "You have entered Area A", where
    /// "area_name" is an attribute field on the
    /// ``FenceGeotriggerNotificationInfo/fenceGeoElement``.
    ///
    /// You can use this message to alert the user directly or in other business logic in your app.
    public var message: String { get }

    /// A dictionary of optional properties derived from the ``Geotrigger/messageExpression``.
    ///
    /// Optionally, you can evaluate the ``ArcadeExpression`` to produce properties on top of
    /// the basic ``message``. You can access this additional information
    /// via this dictionary.
    public var messageProperties: [String : Any] { get }
}

/// Presents information on a set of ``Geotrigger`` objects defined for a ``GeoModel``.
///
/// The author of a ``Map`` or a ``Scene`` can optionally specify one or more ``Geotrigger``
/// conditions to be monitored when using the data. Once this type is loaded, review the list of
/// ``geotriggers`` and create a ``GeotriggerMonitor`` to monitor each.
///
/// When a ``Geotrigger`` is defined with a ``GeotriggerFeed`` of type
/// ``LocationGeotriggerFeed``, you must supply a ``LocationDataSource`` to
/// provide your device location. The general workflow is as follows:
///
/// * Get the ``GeotriggersInfo`` from the ``GeoModel/geotriggersInfo`` property.
///
/// * Load the ``GeotriggersInfo`` to populate the ``geotriggers``
/// list.
///
/// * For each ``Geotrigger`` in the list, check whether the ``Geotrigger/feed`` is of type
/// ``LocationGeotriggerFeed``.
///
/// * Set the ``LocationGeotriggerFeed/locationDataSource`` to your ``LocationDataSource`` - for
/// example, using the ``LocationDisplay/dataSource``.
///
/// * Create a ``GeotriggerMonitor`` for each ``Geotrigger`` you want to use.
///
/// * Connect to notifications sent by the ``GeotriggerMonitor``.
///
/// * Call `GeotriggerMonitor.start()` to begin monitoring.
///
/// Geotriggers can also take into account floors within buildings. If the ``GeotriggersInfo`` is
/// defined as part of a ``GeoModel`` that includes a valid ``GeoModelFloorDefinition``, then the
/// list of ``geotriggers`` can take floor information into account. All layers
/// and tables that are used by the floor definition are loaded when a floor aware
/// ``GeotriggerMonitor`` is started. To take floors into account when monitoring
/// geotriggers, use a ``LocationDataSource`` that includes floor details,
/// such as the ``IndoorsLocationDataSource``.
/// - Since: 200.1
final public class GeotriggersInfo : ArcGIS.Loadable {

    /// The set of ``Geotrigger`` objects defined for a ``GeoModel``.
    ///
    /// This list is populated with ``Geotrigger`` conditions defined by the author of the map
    /// or scene when the ``GeotriggersInfo`` is `LoadStatus.loaded`. If no geotriggers
    /// are defined, this list will remain empty.
    ///
    /// You can add your own geotriggers to this property but be aware that when you save the
    /// map or scene any ``Geotrigger`` objects that reference local data (for example a
    /// ``GraphicsOverlayFenceParameters``) will be omitted.
    final public var geotriggers: [ArcGIS.Geotrigger] { get }

    /// Adds a sequence of `Geotrigger` values to the end of the `geotriggers` property.
    /// - Parameter newGeotriggers: The new `Geotrigger` values to append.
    final public func addGeotriggers<S>(_ newGeotriggers: S) where S : Sequence, S.Element == ArcGIS.Geotrigger

    /// Adds a `Geotrigger` value to the end of the `geotriggers` property.
    /// - Parameter newGeotrigger: The new `Geotrigger` value to append.
    final public func addGeotrigger(_ newGeotrigger: ArcGIS.Geotrigger)

    /// Inserts a collection of `Geotrigger` values into the `geotriggers` property at the specified position.
    /// - Parameters:
    ///   - newGeotriggers: The new `Geotrigger` values to insert.
    ///   - index: The position at which to insert the new `Geotrigger` values.
    final public func insertGeotriggers<C>(_ newGeotriggers: C, at index: Int) where C : Collection, C.Element == ArcGIS.Geotrigger

    /// Inserts a `Geotrigger` value into the `geotriggers` property at the specified position.
    /// - Parameters:
    ///   - newGeotrigger: The new `Geotrigger` value to insert.
    ///   - index: The position at which to insert the new `Geotrigger` value.
    final public func insertGeotrigger(_ newGeotrigger: ArcGIS.Geotrigger, at index: Int)

    /// Removes all values from the `geotriggers` property.
    final public func removeAllGeotriggers()

    /// Removes a sequence of `Geotrigger` values from the `geotriggers` property.
    /// - Parameter geotriggers: The `Geotrigger` values to remove.
    final public func removeGeotriggers<S>(_ geotriggers: S) where S : Sequence, S.Element == ArcGIS.Geotrigger

    /// Removes a `Geotrigger` value from the `geotriggers` property.
    /// - Parameter geotrigger: The `Geotrigger` value to remove.
    final public func removeGeotrigger(_ geotrigger: ArcGIS.Geotrigger)

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// Support Global Camera navigation.
///
/// The Globe camera controller provides free roaming camera navigation around the globe.
/// - Note: See Also: ``OrbitGeoElementCameraController``, ``OrbitLocationCameraController``
/// - Since: 200.1
final public class GlobeCameraController : ArcGIS.CameraController {

    /// Create a globe camera controller object.
    ///
    /// A Globe camera controller is used to perform free roaming global navigation.
    public convenience init()
}

/// A graphic.
/// - Since: 200.1
final public class Graphic : ArcGIS.GeoElement {

    /// Create a Graphic object.
    /// - Parameters:
    ///   - geometry: geometry. Can be `nil`.
    ///   - attributes: The attributes of the graphic. Can be `nil`.
    ///   - symbol: symbol. Can be `nil`.
    public convenience init(geometry: ArcGIS.Geometry? = nil, attributes: [String : Any] = [:], symbol: ArcGIS.Symbol? = nil)

    /// The graphics overlay the graphic is contained in. If the graphic is not contained in an overlay then `nil` is returned.
    /// - Note: See Also: ``GraphicsOverlay``
    weak final public var graphicsOverlay: ArcGIS.GraphicsOverlay? { get }

    /// Graphic selected.
    final public var isSelected: Bool

    /// Graphic visibility.
    final public var isVisible: Bool

    /// The Graphic's symbol.
    final public var symbol: ArcGIS.Symbol?

    /// Defines the draw order for graphics. Graphics with higher Z-index values are drawn on top of lower Z-index graphics
    ///
    /// A graphic's Z-index is mostly relevant for display in a two dimensional map. For dynamic 3D rendering (in a scene), graphic display order is
    /// determined by the distance to the camera rather than by Z-index. Z-index is considered, however, when using static rendering in a scene (draping
    /// graphics on the surface, in other words).
    /// If Z-index is not set, graphics will usually render in the order in which they were added to the graphics overlay, the first added is rendered
    /// first and subsequent ones on top. In rare cases, the rendering algorithm may change the display order to provide more efficient rendering. If
    /// ordering is important, set the Z-index explicitly on graphics. You can also place graphics of the same geometry type in their own graphics overlay
    /// and manage the order of the overlays in the `MapView` or `SceneView`.
    final public var zIndex: Int

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    final public var attributes: [String : Any] { get }

    final public func setAttributeValue(_ value: Any?, forKey key: String)

    /// The geometry defines the shape and location of the ``GeoElement``.
    final public var geometry: ArcGIS.Geometry?
}

/// Geotrigger fence parameters data created from graphics.
///
/// The graphics used to create a ``GraphicFenceParameters`` provide a set of geometries and
/// attributes that define targets for a ``FenceGeotrigger`` condition. For example, if the
/// condition is "notify me when my position comes within 50 meters of one of my target areas",
/// the fence data is "my target areas".
///
/// A ``GraphicFenceParameters`` allows you to track a specific set of ``Graphic`` objects:
/// these can be a selection of the graphics from a ``GraphicsOverlay`` or graphics that are not
/// displayed on a `GeoView`. If you wish to track all of the graphics displayed in a
/// ``GraphicsOverlay``, use a ``GraphicsOverlayFenceParameters``.
///
/// A ``GraphicFenceParameters`` is created using a list of ``Graphic`` objects. The graphics
/// can have point, line, or polygon geometry. A ``FenceParameters/bufferDistance`` must be
/// supplied for points or lines.
/// - Since: 200.1
final public class GraphicFenceParameters : ArcGIS.FenceParameters {

    /// Creates a ``GraphicFenceParameters`` that will apply a buffer distance to any graphics that are added to ``graphics``.
    /// - Parameters:
    ///   - graphics: A set of graphics that should be used as fences.
    ///   - bufferDistance: A buffer distance in meters to apply to the graphics when checking if a ``Geotrigger`` condition is met.
    public convenience init(graphics: [ArcGIS.Graphic] = [], bufferDistance: Double = 0)

    /// The graphics to use in the ``GraphicFenceParameters``.
    ///
    /// This collection will be tracked when monitoring a ``Geotrigger`` such that any graphics
    /// that are added will be included and any that are removed will no longer be
    /// checked.
    ///
    /// The ``Geometry`` of each ``Graphic`` will be buffered by the buffer distance.
    final public var graphics: [ArcGIS.Graphic] { get }

    /// Adds a sequence of `Graphic` values to the end of the `graphics` property.
    /// - Parameter newGraphics: The new `Graphic` values to append.
    final public func addGraphics<S>(_ newGraphics: S) where S : Sequence, S.Element == ArcGIS.Graphic

    /// Adds a `Graphic` value to the end of the `graphics` property.
    /// - Parameter newGraphic: The new `Graphic` value to append.
    final public func addGraphic(_ newGraphic: ArcGIS.Graphic)

    /// Inserts a collection of `Graphic` values into the `graphics` property at the specified position.
    /// - Parameters:
    ///   - newGraphics: The new `Graphic` values to insert.
    ///   - index: The position at which to insert the new `Graphic` values.
    final public func insertGraphics<C>(_ newGraphics: C, at index: Int) where C : Collection, C.Element == ArcGIS.Graphic

    /// Inserts a `Graphic` value into the `graphics` property at the specified position.
    /// - Parameters:
    ///   - newGraphic: The new `Graphic` value to insert.
    ///   - index: The position at which to insert the new `Graphic` value.
    final public func insertGraphic(_ newGraphic: ArcGIS.Graphic, at index: Int)

    /// Removes all values from the `graphics` property.
    final public func removeAllGraphics()

    /// Removes a sequence of `Graphic` values from the `graphics` property.
    /// - Parameter graphics: The `Graphic` values to remove.
    final public func removeGraphics<S>(_ graphics: S) where S : Sequence, S.Element == ArcGIS.Graphic

    /// Removes a `Graphic` value from the `graphics` property.
    /// - Parameter graphic: The `Graphic` value to remove.
    final public func removeGraphic(_ graphic: ArcGIS.Graphic)
}

/// Contains a collection of graphics for display in a map or scene view.
///
/// Graphics overlays display on top of all other data in a map or scene view. A graphics overlay can contain graphics of various geometry types
/// and can define symbology for the graphics it contains using its ``renderer``.
///
/// A graphic's Z-index can be used to define its draw order in the collection and is mostly relevant for display in a two dimensional map. For
/// dynamic 3D rendering (in a scene), graphic display order is determined by the distance to the camera rather than by Z-index. Z-index is considered,
/// however, when using static rendering in a scene (draping graphics on the surface, in other words).
///
/// If Z-index for graphics is not set, they will usually render in the order in which they were added to the graphics overlay, the first added is rendered
/// first and subsequent ones on top. In rare cases, the rendering algorithm may change the display order to provide more efficient rendering. If
/// ordering is important, set the ``Graphic/zIndex`` explicitly on graphics. You can also place graphics of the same geometry type in their own graphics
/// overlay and manage the order of the overlays in the view.
/// - Since: 200.1
final public class GraphicsOverlay : ArcGIS.PopupSource {

    /// The different rendering modes for ``GraphicsOverlay``
    public enum RenderingMode {

        /// Dynamic rendering mode - the default. Update graphics as the map zooms and pans in an immediate mode.
        case dynamic

        /// Static rendering mode. Only update graphics between zoom and pan operations in a retained mode.
        /// Use this mode to handle large amount of graphics.
        case `static`

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GraphicsOverlay.RenderingMode, b: ArcGIS.GraphicsOverlay.RenderingMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a graphics overlay object.
    public convenience init()

    /// Calculate and return the extent of the graphics contained in the overlay's graphics collection.
    ///
    /// The extent's spatial reference is that of the `GeoView` that contains the overlay.
    /// If the overlay is not in a view, returns `nil`.
    /// If the overlay is in a view but that view does not yet have a spatial reference, returns `nil`.
    /// If the overlay is in a view with a spatial reference, but has no graphics, then an empty envelope will be returned.
    final public var extent: ArcGIS.Envelope? { get }

    /// The graphics collection. An observable `Array` of graphics.
    ///
    /// If Z-index for graphics is not set, they will usually render in the order in which they were added to the graphics overlay, the first added is rendered
    /// first and subsequent ones on top. In rare cases, the rendering algorithm may change the display order to provide more efficient rendering. If
    /// ordering is important, set the ``Graphic/zIndex`` explicitly on graphics. You can also place graphics of the same geometry type in their own graphics
    /// overlay and manage the order of the overlays in the view.
    ///
    /// The graphics property is initially set (not `nil`).
    final public var graphics: [ArcGIS.Graphic] { get }

    /// Adds a sequence of `Graphic` values to the end of the `graphics` property.
    /// - Parameter newGraphics: The new `Graphic` values to append.
    final public func addGraphics<S>(_ newGraphics: S) where S : Sequence, S.Element == ArcGIS.Graphic

    /// Adds a `Graphic` value to the end of the `graphics` property.
    /// - Parameter newGraphic: The new `Graphic` value to append.
    final public func addGraphic(_ newGraphic: ArcGIS.Graphic)

    /// Inserts a collection of `Graphic` values into the `graphics` property at the specified position.
    /// - Parameters:
    ///   - newGraphics: The new `Graphic` values to insert.
    ///   - index: The position at which to insert the new `Graphic` values.
    final public func insertGraphics<C>(_ newGraphics: C, at index: Int) where C : Collection, C.Element == ArcGIS.Graphic

    /// Inserts a `Graphic` value into the `graphics` property at the specified position.
    /// - Parameters:
    ///   - newGraphic: The new `Graphic` value to insert.
    ///   - index: The position at which to insert the new `Graphic` value.
    final public func insertGraphic(_ newGraphic: ArcGIS.Graphic, at index: Int)

    /// Removes all values from the `graphics` property.
    final public func removeAllGraphics()

    /// Removes a sequence of `Graphic` values from the `graphics` property.
    /// - Parameter graphics: The `Graphic` values to remove.
    final public func removeGraphics<S>(_ graphics: S) where S : Sequence, S.Element == ArcGIS.Graphic

    /// Removes a `Graphic` value from the `graphics` property.
    /// - Parameter graphic: The `Graphic` value to remove.
    final public func removeGraphic(_ graphic: ArcGIS.Graphic)

    /// The overlay's id.
    ///
    /// The default value of id is an empty string.
    /// A graphics overlay's id does not need to be unique.
    final public var id: String

    /// The visibility for the graphics overlay.
    ///
    /// All of the connected map views will be updated.
    final public var isVisible: Bool

    /// The collection of ``LabelDefinition`` objects for this graphics overlay.
    final public var labelDefinitions: [ArcGIS.LabelDefinition] { get }

    /// Adds a sequence of `LabelDefinition` values to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinitions: The new `LabelDefinition` values to append.
    final public func addLabelDefinitions<S>(_ newLabelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Adds a `LabelDefinition` value to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinition: The new `LabelDefinition` value to append.
    final public func addLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition)

    /// Inserts a collection of `LabelDefinition` values into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinitions: The new `LabelDefinition` values to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` values.
    final public func insertLabelDefinitions<C>(_ newLabelDefinitions: C, at index: Int) where C : Collection, C.Element == ArcGIS.LabelDefinition

    /// Inserts a `LabelDefinition` value into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinition: The new `LabelDefinition` value to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` value.
    final public func insertLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition, at index: Int)

    /// Removes all values from the `labelDefinitions` property.
    final public func removeAllLabelDefinitions()

    /// Removes a sequence of `LabelDefinition` values from the `labelDefinitions` property.
    /// - Parameter labelDefinitions: The `LabelDefinition` values to remove.
    final public func removeLabelDefinitions<S>(_ labelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Removes a `LabelDefinition` value from the `labelDefinitions` property.
    /// - Parameter labelDefinition: The `LabelDefinition` value to remove.
    final public func removeLabelDefinition(_ labelDefinition: ArcGIS.LabelDefinition)

    /// `true` if labels should be displayed.
    final public var labelsAreEnabled: Bool

    /// The maximum scale for the graphics overlay. If `nil`, there is no maximum.
    ///
    /// This controls the maximum scale level the graphics overlay can zoom to.
    /// All of the connected map views will be updated.
    final public var maxScale: Double?

    /// The minimum scale for the graphics overlay. If `nil`, there is no minimum.
    ///
    /// This controls the minimum scale level the graphics overlay can zoom to.
    /// All of the connected map views will be updated.
    final public var minScale: Double?

    /// The opacity for the graphics overlay.
    ///
    /// All of the connected map views will be updated.
    final public var opacity: Float

    /// A copy of the graphics overlay's renderer.
    final public var renderer: ArcGIS.Renderer?

    /// The graphic overlay's rendering mode.
    final public var renderingMode: ArcGIS.GraphicsOverlay.RenderingMode

    /// Whether the overlay's symbols and labels honor the map reference scale when displayed in a map view.
    ///
    /// If the map has a positive reference scale, and the overlay honors it, then symbols and labels
    /// will be drawn at their specified size when the viewing scale is the same as the reference scale. They
    /// will grow or shrink as the view zooms in or out to keep the symbol a fixed size on the map.
    /// If the map has no reference scale, the reference scale is zero, or ``scalesSymbols`` is `false`,
    /// the symbols and labels will be drawn at their fixed screen size.
    /// The default value is '`false`'.
    /// GraphicsOverlay.scaleSymbols only affects display in a `MapView`.
    /// The symbols and labels will be displayed at fixed screen size in a `SceneView`.
    final public var scalesSymbols: Bool

    /// The scene properties for the graphics overlay.
    final public var sceneProperties: ArcGIS.LayerSceneProperties

    /// Returns an array containing all selected graphics in the graphics overlay.
    final public var selectedGraphics: [ArcGIS.Graphic] { get }

    /// Deselect all graphics in the graphics overlay.
    final public func clearSelection()

    /// Selects the specified graphics.
    ///
    /// Any graphics that are not in the overlay will be ignored.
    /// - Parameter graphics: The graphics to be selected
    final public func selectGraphics(_ graphics: [ArcGIS.Graphic])

    /// Unselects the specified graphics.
    ///
    /// Any graphics that are not in the overlay will be ignored.
    /// - Parameter graphics: The graphics to be unselected.
    final public func unselectGraphics(_ graphics: [ArcGIS.Graphic])

    /// The pop-up definition.
    ///
    /// The ``PopupDefinition`` associated with the popup source.
    final public var popupDefinition: ArcGIS.PopupDefinition?

    /// A flag indicating whether the ``PopupDefinition`` defined on the ``PopupSource`` is enable / disable.
    final public var popupsAreEnabled: Bool
}

extension GraphicsOverlay {

    /// Creates an overlay with the provided graphics.
    /// - Parameter graphics: The graphics to create the overlay with.
    public convenience init(graphics: [ArcGIS.Graphic])

    /// Creates an overlay with the given rendering mode.
    /// - Parameter renderingMode: The rendering mode for the overlay.
    public convenience init(renderingMode: ArcGIS.GraphicsOverlay.RenderingMode)
}

extension GraphicsOverlay.RenderingMode : Equatable {
}

extension GraphicsOverlay.RenderingMode : Hashable {
}

/// Geotrigger fence parameters data created from a ``GraphicsOverlay``.
///
/// The ``GraphicsOverlay`` used to create a ``GraphicsOverlayFenceParameters`` provides a
/// dynamic set of graphics that define targets for a ``FenceGeotrigger`` condition. For
/// example, if the condition is "notify me when my position comes within 50 meters of one of my
/// target areas", "my target areas" are the graphics in the overlay. Changes to the
/// ``GraphicsOverlay`` will be reflected in the fences tracked by the ``Geotrigger``.
///
/// A ``GraphicsOverlayFenceParameters`` allows you to track all of the graphics displayed on
/// the `GeoView` in a ``GraphicsOverlay``. This allows you to track new target areas
/// as they are added to the view and to stop tracking areas that are removed. If you wish to
/// track a subset of the graphics displayed in a ``GraphicsOverlay``, or graphics which are not
/// displayed in a `GeoView`, use a ``GraphicFenceParameters``.
///
/// The graphics can have point, line, or polygon geometry. A ``FenceParameters/bufferDistance`` must be
/// supplied for points or lines.
/// - Since: 200.1
final public class GraphicsOverlayFenceParameters : ArcGIS.FenceParameters {

    /// Creates a ``GraphicsOverlayFenceParameters`` using all of the graphics in the ``GraphicsOverlay`` buffered by the buffer distance.
    ///
    /// Note that the ``GraphicsOverlayFenceParameters`` will respect any changes made to the supplied
    /// graphics overlay - for example, if a ``Graphic`` is removed or added to the original
    /// ``GraphicsOverlay``, it will be added or removed as a fence.
    /// - Parameters:
    ///   - graphicsOverlay: The ``GraphicsOverlay``, to use as the source of graphics for the ``GraphicFenceParameters``.
    ///   - bufferDistance: A buffer distance in meters to apply to the graphics when checking if a ``Geotrigger`` condition is met.
    public convenience init(graphicsOverlay: ArcGIS.GraphicsOverlay, bufferDistance: Double = 0)

    /// The ``GraphicsOverlay`` to use in the ``GraphicsOverlayFenceParameters``.
    ///
    /// Changes to the ``GraphicsOverlay`` will be reflected in the fences tracked by the ``Geotrigger``.
    final public var graphicsOverlay: ArcGIS.GraphicsOverlay { get }
}

/// Grid is a base class for MGRSGrid, USNGGrid, UTMGrid and
/// LatitudeLongitudeGrid that represents the display of a coordinate
/// system grid on the map view.
///
/// It contains all of the common operations and properties that apply
/// to displaying and working with the different grids currently
/// supported. This includes toggling visibility and configuring layout
/// and appearance preferences.
/// - Since: 200.1
public class Grid {

    /// A positioning scheme to use when labeling a Grid.
    /// - Note: See Also: ``Grid``
    public enum LabelPosition {

        /// Labels anchored to a geographical position on the map view.
        case geographic

        /// 'Y' labels anchored to left of map view, 'X' labels anchored to bottom.
        case bottomLeft

        /// 'Y' labels anchored to right of map view, 'X' labels anchored to bottom.
        case bottomRight

        /// 'Y' labels anchored to left of map view, 'X' labels anchored to top.
        case topLeft

        /// 'Y' labels anchored to right of map view, 'X' labels anchored to top.
        case topRight

        /// 'Y' and 'X' labels in center of map view.
        case center

        /// Labels anchored to top, right, bottom, and left of map view.
        case allSides

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Grid.LabelPosition, b: ArcGIS.Grid.LabelPosition) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The visibility of the grid.
    public var isVisible: Bool

    /// The grid's text label offset from the edge of the map view in DIPS.
    public var labelOffset: CGFloat

    /// The positioning of the grid's labels.
    public var labelPosition: ArcGIS.Grid.LabelPosition

    /// The visibility of the grid's labels.
    public var labelsAreVisible: Bool
}

extension Grid {

    /// The resolution level for the grid lines.
    public typealias Level = Int

    /// A view into a grid as line symbols.
    public struct LineSymbolView {
    }

    /// The line symbols of the grid, as a view into the grid.
    ///
    /// There are line symbols used for the grid lines at each ``Grid/Level``.
    public var lineSymbols: ArcGIS.Grid.LineSymbolView { get }
}

extension Grid {

    /// A view into a grid as text symbols.
    public struct TextSymbolView {
    }

    /// The text symbols of the grid, as a view into the grid.
    ///
    /// There are text symbols used for the grid lines at each ``Grid/Level``.
    public var textSymbols: ArcGIS.Grid.TextSymbolView { get }
}

extension Grid.LabelPosition : Equatable {
}

extension Grid.LabelPosition : Hashable {
}

extension Grid.LineSymbolView : RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = ArcGIS.Grid.Level

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: ArcGIS.Grid.LineSymbolView.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: ArcGIS.Grid.LineSymbolView.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: ArcGIS.Grid.LineSymbolView.Index) -> ArcGIS.Symbol

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Symbol

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<ArcGIS.Grid.LineSymbolView.Index>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.Grid.LineSymbolView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.Grid.LineSymbolView>
}

extension Grid.TextSymbolView : RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = ArcGIS.Grid.Level

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> ArcGIS.Symbol

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Symbol

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<ArcGIS.Grid.TextSymbolView.Index>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.Grid.TextSymbolView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.Grid.TextSymbolView>
}

/// A container for other layers and group layers. It is used to represent datasets that are composed
/// of multiple layers to be managed as a single layer with respect to display in a map or scene.
///
/// Group layers are designed for presentation of operational layers that are related by a
/// theme. You can add several related operational child layers into a group layer so the
/// layers can be displayed together. Suppose there are several feature layers that represent
/// existing infrastructure projects (buildings, sidewalks, roads, and trees). You can add
/// these feature layers into a single group layer called "Existing". Similarly assume there
/// are also proposed infrastructure projects that are features in other layers. These layers
/// can be added to a group layer called "Planned". You can manage the visibility of the
/// existing or planned features as separate groups.
///
/// For the most part, group layers behave like any other layer in that:
/// * A group layer has visual properties (visibility, opacity) that can be applied to all
///   layers in the group layer at once. This is helpful when controlling the visibility of the
///   group.
/// * You can set a scale range on a group layer using the minimum and maximum scale
///   properties. If a child layer has more restricted scale range, that scale range will be
///   honored for that child layer.
/// * A group layer may be queried for the aggregate geographic extent of its child layers
/// * A group layer may be nested inside another group layer. There is no defined nesting
///   level limit.
/// * Cloning a group layer will also clone its child layers
/// * A group layer does not have its own attribute values. The text from the child layers is
///   displayed instead.
/// * A group layer is not time-aware, but may contain layers that are
/// * A group layer cannot be added to a basemap
///
/// The full extent of a group layer is derived asynchronously based on what information is
/// available from the child layers. This means the full extent can change when child layers
/// are added or removed. The full extent geometry will have the spatial reference of the first
/// loaded child layer.
///
/// Group layers are not supported in Web maps. Saving a map with a group layer to a web map
/// flattens the operational layers. Group layers are supported in Web scenes.
///
/// The visual opacity property of the group layer affects the opacity of the child layers. The
/// opacity of the child layers is a mathematical product of the individual child layer's
/// opacity and the group layer's opacity. Opacity values range from 0.0 (transparent) to 1.0
/// (opaque). This means that setting the opacity of the group layer to 0.0 will make all child
/// layers transparent [0 * AnyNumber = 0].  Likewise when the group layer opacity is 1.0, will
/// set the opacity of the child layers to their individual layer opacity [1 * AnyNumber =
/// AnyNumber].
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class GroupLayer : ArcGIS.Layer {

    /// The visibility modes on a group layer.
    /// - Note: See Also: ``GroupLayer``
    public enum VisibilityMode {

        /// Each child layer independently manages its visibility.
        ///
        /// In independent mode, a child layer's visibility property is independent of its parent's and
        /// siblings' visibility properties. Changes to the parent or siblings' visibility properties have no
        /// effect on the current layer's visibility property. However, the rendering of a child layer on the view
        /// requires both its visibility property and its parent's visibility property to be `true`. This can be
        /// visualized in the context of a table of contents. A parent can contain multiple child layers, each
        /// with a differing value of their visibility property. Turning off the parent's visibility will prevent
        /// any child layer from rendering on the view. But their visibility property will still be reflected in
        /// the table of contents. Setting the parent's visibility back to `true` returns the view to the original
        /// state.
        case independent

        /// Each child inherits the visibility of its parent group.
        ///
        /// The visibility property of child layers is determined by the visibility of the parent layer and
        /// cannot be set independently of the parent. This means all child layers' visibility properties always
        /// match the visibility property of the parent. In an implementation of a table of contents, setting the
        /// parent's visibility to on or off will cause child layers to match. You may choose to hide all child
        /// layers from your table of contents given the group is treated as a single logical layer in terms of
        /// visibility.
        case inherited

        /// Only one child is visible at a time.
        ///
        /// In exclusive mode, only a single child may have its visible property set to `true`. When setting
        /// the visibility property of a child layer to `true`, all others will have their visibility set to `false`.
        /// However, the rendering of a child layer requires both its visibility property and its parent's
        /// visibility property to be `true`. In an implementation of a table of contents, a group layer will only
        /// ever contain one visible child layer.
        case exclusive

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.GroupLayer.VisibilityMode, b: ArcGIS.GroupLayer.VisibilityMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a group layer object with child layers.
    /// - Parameter layers: An `Array` of layers to combine into a group layer.
    /// - Note: See Also: ``layers``
    public convenience init(layers: [ArcGIS.Layer] = [])

    /// The child layers associated with a group layer.
    final public var layers: [ArcGIS.Layer] { get }

    /// Adds a sequence of `Layer` values to the end of the `layers` property.
    /// - Parameter newLayers: The new `Layer` values to append.
    final public func addLayers<S>(_ newLayers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Adds a `Layer` value to the end of the `layers` property.
    /// - Parameter newLayer: The new `Layer` value to append.
    final public func addLayer(_ newLayer: ArcGIS.Layer)

    /// Inserts a collection of `Layer` values into the `layers` property at the specified position.
    /// - Parameters:
    ///   - newLayers: The new `Layer` values to insert.
    ///   - index: The position at which to insert the new `Layer` values.
    final public func insertLayers<C>(_ newLayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.Layer

    /// Inserts a `Layer` value into the `layers` property at the specified position.
    /// - Parameters:
    ///   - newLayer: The new `Layer` value to insert.
    ///   - index: The position at which to insert the new `Layer` value.
    final public func insertLayer(_ newLayer: ArcGIS.Layer, at index: Int)

    /// Removes all values from the `layers` property.
    final public func removeAllLayers()

    /// Removes a sequence of `Layer` values from the `layers` property.
    /// - Parameter layers: The `Layer` values to remove.
    final public func removeLayers<S>(_ layers: S) where S : Sequence, S.Element == ArcGIS.Layer

    /// Removes a `Layer` value from the `layers` property.
    /// - Parameter layer: The `Layer` value to remove.
    final public func removeLayer(_ layer: ArcGIS.Layer)

    /// Determines if the child layers should be shown in the map legend.
    final public var showsChildrenInLegend: Bool

    /// The visibility mode for the layers in a table of contents.
    final public var visibilityMode: ArcGIS.GroupLayer.VisibilityMode
}

extension GroupLayer.VisibilityMode : Equatable {
}

extension GroupLayer.VisibilityMode : Hashable {
}

/// A struct that implements hatch fill symbol layer inside of the geometry attached to a multilayer polygon symbol.
///
/// A ``HatchFillSymbolLayer`` represents a polygon geometry filled with hatch lines.
///
/// "Hatch lines" are uniformly spaced parallel lines. A ``HatchFillSymbolLayer``, in a multilayer polygon
/// symbol, fills the geometry of the symbol with the specified hatch lines. Each hatch line is itself a
/// multilayer polyline symbol. You can define a custom hatch line (through the setPolyline and certain create
/// methods) that is repeated in parallel throughout the inside of the geometry attached to a multilayer polygon
/// symbol's geometry.
///
/// The ``HatchFillSymbolLayer`` provides a similar experience to the ``SimpleFillSymbol``, but with more
/// customizability. Whereas you can select from a list of predefined hatch fill styles for a ``SimpleFillSymbol``,
/// the ``HatchFillSymbolLayer`` allows you to specify a fully-customized symbol to use as the hatch line.
/// You can also adjust line angle, offset, and separation distance.
/// - Since: 200.1
final public class HatchFillSymbolLayer : ArcGIS.FillSymbolLayer {

    /// Create a hatch fill symbol layer, given a ``MultilayerPolylineSymbol`` and an angle.
    ///
    /// The fill rotates counterclockwise from East.
    /// Angle values can be negative.
    /// - Parameters:
    ///   - polylineSymbol: a ``MultilayerPolylineSymbol`` to use as the hatch line of the symbol layer.
    ///   - angle: a float64 representing the angle to rotate the hatch lines, in degrees measured counterclockwise from East.
    /// - Precondition: `!angle.isNaN`
    public convenience init(polylineSymbol: ArcGIS.MultilayerPolylineSymbol = MultilayerPolylineSymbol(symbolLayers: [SolidStrokeSymbolLayer(width: 1.3333334, color: .black)]), angle: Double = .zero)

    /// The angle of rotation of the hatch lines in a ``HatchFillSymbolLayer``, in degrees counterclockwise from East.
    ///
    /// The angle of rotation of the hatch lines in a ``HatchFillSymbolLayer``. The returned values are expressed
    /// in degrees measured counterclockwise from East. If there is no angle set, the method returns 0.0.
    /// , and the function will return `nan`.
    final public var angle: Double

    /// The polyline symbol used to symbolize the hatch lines of a ``HatchFillSymbolLayer``.
    ///
    /// The polyline symbol used to symbolize the hatch lines in a ``HatchFillSymbolLayer``.
    /// The polyline is itself must be a multilayer symbol, specifically a ``MultilayerPolylineSymbol``.
    /// and stored internally as points. If no polyline is specified, the default polyline applies.
    /// That default polyline has a single ``SolidStrokeSymbolLayer``, with width of 1.3333 DIPs (1.0 in points)
    /// and opaque black color.
    final public var polylineSymbol: ArcGIS.MultilayerPolylineSymbol

    /// The distance between the line symbols in the hatch pattern of a ``HatchFillSymbolLayer``, in DIPs.
    ///
    /// The distance between the hatch lines in a ``HatchFillSymbolLayer``. Values are passed in as DIPs,
    /// and stored internally as points. The larger the value, the more the hatch lines are separated. If no value
    /// is specified, the default, 5.3333 DIPs (4.0 in points), applies. Separation values must be non-negative.
    final public var separation: CGFloat
}

/// A Heatmap Renderer object.
///
/// This renderer currently does not have any properties and can be created only through json.
/// - Since: 200.1
final public class HeatmapRenderer : ArcGIS.Renderer {
}

/// A hillshade renderer object which is derived from a raster renderer object.
/// - Note: See Also: ``RasterRenderer``
/// - Since: 200.1
public class HillshadeRenderer : ArcGIS.RasterRenderer {

    /// The list of raster slope types.
    ///
    /// This is used to determine the raster slope type.
    public enum SlopeType {

        /// Degree slope type.
        case degree

        /// Percent rise slope type.
        case percentRise

        /// Scaled slope type.
        case scaled

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.HillshadeRenderer.SlopeType, b: ArcGIS.HillshadeRenderer.SlopeType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a hillshade renderer.
    /// - Parameters:
    ///   - altitude: Altitude angle of the light source.
    ///   - azimuth: Azimuth angle of the light source, measured clockwise from north.
    ///   - slopeType: ``SlopeType-swift.enum``
    ///   - zFactor: Factor to convert z unit to x,y units, default is 1.
    ///   - pixelSizeFactor: Pixel size factor, default is 1.
    ///   - pixelSizePower: Pixel size power value, default is 1.
    ///   - outputBitDepth: Output bit depth, default is 8-bit.
    public convenience init(altitude: Double, azimuth: Double, slopeType: ArcGIS.HillshadeRenderer.SlopeType?, zFactor: Double = 1, pixelSizeFactor: Double = 1, pixelSizePower: Double = 1, outputBitDepth: Int = 8)

    /// The altitude angle in degree.
    public var altitude: Measurement<UnitAngle> { get }

    /// The azimuth angle in degree.
    public var azimuth: Measurement<UnitAngle> { get }

    /// The output bit depth.
    public var outputBitDepth: Int { get }

    /// The pixel size factor.
    public var pixelSizeFactor: Double { get }

    /// The pixel size power.
    public var pixelSizePower: Double { get }

    /// The slope type.
    public var slopeType: ArcGIS.HillshadeRenderer.SlopeType? { get }

    /// The Z factor.
    public var zFactor: Double { get }
}

extension HillshadeRenderer.SlopeType : Equatable {
}

extension HillshadeRenderer.SlopeType : Hashable {
}

/// The histogram equalization stretch parameters object.
/// - Since: 200.1
final public class HistogramEqualizationStretchParameters : ArcGIS.StretchParameters {

    /// Creates a histogram equalization stretch parameters object.
    public convenience init()
}

/// Used to transform coordinates of z-aware geometries between spatial references that have different
/// geographic and/or vertical coordinate systems.
///
/// A HorizontalVerticalTransformation is an ordered list of ``HorizontalVerticalTransformationStep`` objects.
/// Each HorizontalVerticalTransformation has an input and an output ``SpatialReference``, and this
/// HorizontalVerticalTransformation object can be used to convert coordinates between the horizontal (geographic)
/// and vertical datums of these spatial references using the series of steps it contains. Use the
/// `GeometryEngine.project(_:into:datumTransformation:)` method to transform the coordinates
/// of a specific ``Geometry``.
///
/// A horizontal transformation step is not needed when the input and output spatial references have the same
/// underlying geographic coordinate systems. A vertical transformation is not needed if both datums (for
/// ellipsoidal heights) or vertical datums (for gravity-related heights) are the same. To transform coordinates
/// only between different horizontal (geographic) coordinate systems, you can use a ``GeographicTransformation``
/// instead.
///
/// The inverse of this transformation, used to transform in the opposite direction, is returned from the
/// `DatumTransformation.inverse` method.
///
/// A HorizontalVerticalTransformation can be constructed from a single ``HorizontalVerticalTransformationStep``
/// object, or from a number of transformation step objects that are chained together.
///
/// You can get a list of suitable transformations for a given input and output spatial reference using one of the
/// methods on the ``TransformationCatalog`` class.
///
/// Some transformations require that certain Projection Engine data files be present on the local file system,
/// and vertical transformation steps are especially likely to use such files, which can be very large in size.
/// The ``DatumTransformation/isMissingProjectionEngineFiles`` property indicates whether any of the files are
/// missing. The complete list of necessary files for each specific step is available using the
/// ``HorizontalVerticalTransformationStep/projectionEngineFilenames`` property.
///
/// A HorizontalVerticalTransformation object is immutable.
/// - Note: See Also: ``GeographicTransformation``
/// - Since: 200.1
final public class HorizontalVerticalTransformation : ArcGIS.DatumTransformation {

    /// Create a single step transformation.
    /// - Parameter step: A ``HorizontalVerticalTransformationStep`` instance.
    public convenience init(step: ArcGIS.HorizontalVerticalTransformationStep)

    /// Create a multi-step transformation from one or more ``HorizontalVerticalTransformationStep`` instances.
    ///
    /// Use this constructor to create a horizontal-vertical transformation that has multiple steps.
    /// The output ``SpatialReference`` of each step should match the input ``SpatialReference`` of the
    /// following step.
    /// - Parameter steps: An `Array` containing ``HorizontalVerticalTransformationStep`` instances.
    public convenience init(steps: [ArcGIS.HorizontalVerticalTransformationStep])

    /// The array of transformation steps that define this transformation.
    final public var steps: [ArcGIS.HorizontalVerticalTransformationStep] { get }
}

/// Represents a step in the process of transforming between horizontal and/or vertical datums.
///
/// Each ``HorizontalVerticalTransformationStep`` can be constructed from a well-known ID (WKID) that represents a
/// horizontal (geographic) or a vertical transformation. This API supports thousands of predefined
/// transformations, and all the supported WKIDs are documented in the 'Coordinate systems and transformations'
/// topic in the developers guide.
///
/// One or more ``HorizontalVerticalTransformationStep`` objects are combined into a ``HorizontalVerticalTransformation`` object, and
/// can then be used to control how coordinates are transformed in a
/// `GeometryEngine.project(_:into:datumTransformation:)` method call.
///
/// A ``HorizontalVerticalTransformationStep`` object is immutable.
/// - Note: See Also: ``HorizontalVerticalTransformation``, ``GeographicTransformationStep``
/// - Since: 200.1
final public class HorizontalVerticalTransformationStep {

    /// Creates a new ``HorizontalVerticalTransformationStep`` instance from a well-known text string.
    /// - Parameter wkText: The well-known text of the transformation step to create.
    public convenience init?(wkText: String)

    /// Creates a new ``HorizontalVerticalTransformationStep`` instance from a well-known ID.
    ///
    /// Occasionally, WKIDs may change, and older codes may be deprecated in favor of a new code. Both old
    /// (deprecated) and new (latest) WKIDs continue to work for instantiation, as long as they are supported
    /// by the Projection Engine. The ``wkid`` property returns the new
    /// (latest) WKID code.
    /// - Parameter wkid: The well-known ID of the transformation step to create.
    public convenience init?(wkid: ArcGIS.WKID?)

    /// Returns the inverse of this transformation step or `nil` if the transformation is not invertible.
    final public var inverse: ArcGIS.HorizontalVerticalTransformationStep? { get }

    /// `true` if this transformation step instance is an inverted transformation.
    ///
    /// Transformations have a specific direction that is indicated by the
    /// ``wkText`` value. An inverted transformation is used to transform
    /// geometries in the opposite direction to that indicated by the well-known text.
    /// ``HorizontalVerticalTransformationStep`` has ``DatumTransformation/inputSpatialReference`` and
    /// ``DatumTransformation/outputSpatialReference`` properties that respect the inverse value of the contained
    /// transformation(s).
    /// - Note: See Also: `HorizontalVerticalTransformationStep.inverse`
    final public var isInverse: Bool { get }

    /// `true` if any files needed by the Projection Engine for this transformation step are missing from the local
    /// file system.
    final public var isMissingProjectionEngineFiles: Bool { get }

    /// A list of the Projection Engine files required to support this transformation step.
    ///
    /// Each name in the list includes the full path. Projection Engine datasets are used in grid-based transforms.
    final public var projectionEngineFilenames: [String] { get }

    /// The well-known text of this transformation step instance.
    final public var wkText: String { get }

    /// The well-known ID or 0 if the transformation in this step does not have a well-known ID.
    ///
    /// Occasionally, WKIDs may change, and an older code may be deprecated in favor of a new code. This property
    /// returns the new (latest) WKID code.
    final public var wkid: ArcGIS.WKID? { get }
}

extension HorizontalVerticalTransformationStep : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.HorizontalVerticalTransformationStep, rhs: ArcGIS.HorizontalVerticalTransformationStep) -> Bool
}

extension HorizontalVerticalTransformationStep : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// An object that represents the sub layer metadata for a Feature service or a Map service.
/// - Note: See Also: ``ArcGISFeatureServiceInfo/layerInfos``, ``ArcGISFeatureServiceInfo/tableInfos``, ``ArcGISMapServiceInfo/layerInfos``, ``ArcGISMapServiceInfo/tableInfos``
/// - Since: 200.1
public class IDInfo {

    /// The id info's name.
    public var name: String { get }
}

extension IDInfo {

    /// The id info's id.
    /// - Remark: If `nil`, an error occurred.
    public var id: Int? { get }
}

/// Identify result containing an overlay and the identified graphics of that overlay
///
/// You need to pass this object to identify result functions.
/// - Since: 200.1
final public class IdentifyGraphicsOverlayResult {

    /// The error that occurred during the identify operation, if there is one.
    final public var error: Error? { get }

    /// The identify result's list of identified graphics.
    final public var graphics: [ArcGIS.Graphic] { get }

    /// The overlay identify result's overlay.
    final public var graphicsOverlay: ArcGIS.GraphicsOverlay { get }

    /// The identify result's list of identified popups.
    final public var popups: [ArcGIS.Popup] { get }
}

/// Identify result containing a layer and the identified elements of that layer.
///
/// You need to pass this object to identify result functions.
/// - Since: 200.1
final public class IdentifyLayerResult {

    /// The error that occurred during the identify operation, if there is one.
    final public var error: Error? { get }

    /// The identify result's list of identified graphics.
    ///
    /// If there are no geo element results at the layer level (for layers where geo element results are exposed in sublayer results), an empty array is returned.
    /// The array type depends on the type of objects contained in the layer. The function will always return an array containing objects that implement ``GeoElement``.
    final public var geoElements: [ArcGIS.GeoElement] { get }

    /// The layer identify result's layer content (a ``LayerContent``).
    ///
    /// The element will contain an object that implements ``LayerContent``. This may be either an ``ArcGISSublayer`` or a ``Layer``.
    final public var layerContent: ArcGIS.LayerContent { get }

    /// The identify result's list of identified popups.
    final public var popups: [ArcGIS.Popup] { get }

    /// The identify layer result's list of sub results.
    ///
    /// For layers that do not contain sublayers, this array will be empty.
    final public var sublayerResults: [ArcGIS.IdentifyLayerResult] { get }

    /// If the transfer limit was exceeded for the identify results.
    final public var transferLimitIsExceeded: Bool { get }
}

/// An error denoting an illegal state.
/// - Since: 200.1
public struct IllegalStateError : Error {

    /// The error details.
    public let details: String
}

extension IllegalStateError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.IllegalStateError, b: ArcGIS.IllegalStateError) -> Bool
}

/// Allows for changes to an image.
/// - Since: 200.1
public class ImageAdjustmentLayer : ArcGIS.Layer {

    /// The brightness of the layer.
    public var brightness: Float

    /// The contrast of the layer.
    public var contrast: Float

    /// The gamma of the layer.
    public var gamma: Float
}

/// A frame that, when added to an ``ImageOverlay``, renders an image on top of a scene.
///
/// An ``ImageFrame`` can contain images that do not have georeferencing information. In such cases, location data can be provided to geolocate the image.
/// - Note: See Also: ``ImageOverlay``
/// - Since: 200.1
final public class ImageFrame : ArcGIS.Loadable {

    /// Creates an ``ImageFrame`` containing the image for display at the specified geographic extent.
    ///
    /// If a spatial reference is not defined for the extent, it is assumed to be the same as the
    /// scene. If the spatial reference of the extent is different from that of the scene, then the
    /// image would fail to render. Supported image formats are TIFF, GeoTIFF, ICO, BMP, GIF, JPEG, and PNG.
    /// Animated GIF is not supported.
    /// - Parameters:
    ///   - image: An image to display in the frame.
    ///   - extent: The geographic extent at which the image is displayed.
    public convenience init(image: UIImage, extent: ArcGIS.Envelope)

    /// Creates an ``ImageFrame`` using the image and a four-point polygon representing the corners of an image.
    ///
    /// If a spatial reference is not defined for the polygon, it is assumed to be the same as the scene.
    /// If the spatial reference of the extent is different from that of the scene, then the image would fail
    /// to render. If the provided polygon doesn't contain exactly four points, the image frame will fail to load.
    /// Supported image formats are TIFF, GeoTIFF, ICO, BMP, GIF, JPEG, and PNG. Animated GIF is not supported.
    /// - Parameters:
    ///   - image: An image to display in the frame.
    ///   - quadrilateral: A polygon consisting of four points that represent each corner of the image.
    public convenience init(image: UIImage, quadrilateral: ArcGIS.Polygon)

    /// Creates an ``ImageFrame`` containing the image defined by the provided uri.
    ///
    /// Supported image formats are GeoTIFF, TIFF, JPEG, and PNG. The URI can be a local file path or an HTTP path to an image.
    /// - Parameter url: A uri that identifies a local or online image source.
    public convenience init(url: URL)

    /// Creates an ``ImageFrame`` containing the image identified by the uri for display at the specified geographic extent.
    ///
    /// If a spatial reference is not defined for the extent, it is assumed to be the same as the scene. If the spatial reference of the extent is different from that of the scene,
    /// then the image would fail to render. Supported image formats are GeoTIFF, TIFF, JPEG, and PNG. The URI can be a local file path or an HTTP path to an image.
    /// - Parameters:
    ///   - url: A uri that identifies a local or online image source.
    ///   - extent: The geographic extent at which the image is displayed.
    public convenience init(url: URL, extent: ArcGIS.Envelope)

    /// Creates an ``ImageFrame`` using the uri of an image and a four-point polygon representing the corners of an image.
    ///
    /// If a spatial reference is not defined for the polygon, it is assumed to be the same as the scene. If the spatial reference of the extent is different from that of the scene,
    /// then the image would fail to render. If the provided polygon doesn't contain exactly four points, the image frame will fail to load. Supported image formats are GeoTIFF, TIFF, JPEG, and PNG. The URL can be a local file path or an HTTP path to an image.
    /// - Parameters:
    ///   - url: A uri that identifies a local or online image source.
    ///   - quadrilateral: A polygon consisting of four points that represent each corner of the image.
    public convenience init(url: URL, quadrilateral: ArcGIS.Polygon)

    /// The extent of the image.
    ///
    /// Returns the extent of the image.
    final public var extent: ArcGIS.Envelope? { get }

    /// Returns the image contained in the ``ImageFrame``.
    final public var image: UIImage? { get }

    /// Returns a polygon consisting of four points that represent each corner of the image.
    final public var quadrilateral: ArcGIS.Polygon? { get }

    /// Returns the URI of the image.
    final public var url: URL? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An overlay that contains a frame with an image to display in the view.
///
/// Currently, this feature is supported in a `SceneView` (3D) only. The overlay can contain exactly one image at any given time. Multiple overlays, however, can be added and rendered at the same time on the `SceneView`.
/// An ``ImageOverlay`` can be used to quickly render frequently changing images. For example, rendering realtime sensor data, such as weather, where each static image represents a single frame from the radar. In this workflow, images are constantly updated via a new ``ImageFrame`` each time new data is available. This provides a fast-refreshing workflow where the underlying images are frequently updated as new data comes in.
///
/// Since ``ImageOverlay`` does not support the rich processing and rendering capabilities of a ``RasterLayer``, you should use ``Raster`` and ``RasterLayer`` for workflows that require static image rendering, analysis, and persistence.
///
/// Image overlays are rendered above all other layers in the scene, draped on the surface, and below any graphics overlays in the scene view.
/// - Note: See Also: ``ImageFrame``, `SceneView`
/// - Since: 200.1
final public class ImageOverlay {

    /// The extent of the ``ImageOverlay``.
    ///
    /// The spatial reference of the extent matches the extent of the `SceneView` that contains the image overlay.
    final public var extent: ArcGIS.Envelope? { get }

    /// The ``ImageFrame`` contained in the ``ImageOverlay``.
    final public var imageFrame: ArcGIS.ImageFrame?

    /// The visibility of the ``ImageOverlay``.
    final public var isVisible: Bool

    /// The opacity for the ``ImageOverlay``.
    ///
    /// Opacity values range from 0.0 to 1.0, where 0.0 is fully transparent and 1.0 is fully opaque.
    final public var opacity: Float
}

extension ImageOverlay {

    /// Creates an `ImageOverlay` that contains an `ImageFrame`.
    /// - Parameter imageFrame: The `ImageFrame` of the `ImageOverlay`. If it is `nil`,
    /// an empty image overlay will be created.
    public convenience init(imageFrame: ArcGIS.ImageFrame? = nil)
}

/// An instance of this class represents a raster that is retrieved from an ArcGIS image service.
///
/// An image service provides access to raster data through a web service. A single raster dataset or
/// a mosaic dataset which contains a collection of raster datasets can be served as one image service.
/// The mosaic dataset can dynamically process and mosaic the images on the fly. An image service
/// supports accessing both the mosaicked image and its catalog, as well as individual rasters
/// in the catalog. An image service raster allows you to display raster data from image services using
/// a ``RasterLayer``. It also allows you to apply service-defined or client-defined rendering rules by
/// setting ``RenderingRule`` on it. You can pass an image service raster as a raster input to a
/// ``RasterFunction`` to work with local raster functions.
///
/// The image service raster is derived from the raster class. It's the same as a ``Raster``.
/// - Since: 200.1
final public class ImageServiceRaster : ArcGIS.Raster {

    /// Creates an image service raster object with URL.
    /// - Parameter url: Image service URL
    public convenience init(url: URL)

    /// The mosaic rule used for combining a number of input rasters that are often overlapping.
    final public var mosaicRule: ArcGIS.MosaicRule?

    /// The rendering rule on an image service raster object.
    ///
    /// The image service raster must be in the `LoadStatus.notLoaded` or `LoadStatus.failedToLoad` state when calling this function.
    final public var renderingRule: ArcGIS.RenderingRule?

    /// The ArcGIS image service info object.
    final public var serviceInfo: ArcGIS.ArcGISImageServiceInfo? { get }

    /// The URL on an image service raster object.
    final public var url: URL? { get }
}

/// A base class for layers that display cached maps. You would typically work with one or more sub-classes of this class.
///
/// ``ImageTiledLayer`` defines a base class for layers that display tiled map services and cached
/// image services. This is an abstract class that can be derived in a custom class to implement
/// a local tile data scheme. To implement a custom ``ImageTiledLayer``, for example to load your
/// own local tile data, you should derive from this type and supply the data for each tile as it
/// is requested.
///
/// Additionally, implementers must also supply a ``TileInfo`` that describes the tiling scheme,
/// and an ``Envelope`` that defines the layer extent.
///
/// Implement this class if you want to create a custom tiled layer where the cached images
/// cannot be referenced by a simple URI. If your images can be referenced
/// by a simple URI, you should instead implement ``ServiceImageTiledLayer``.
/// - Note: See Also: ``Layer``, ``ServiceImageTiledLayer``, ``ArcGISTiledLayer``, ``WMTSLayer``, ``WebTiledLayer``, ``OpenStreetMapLayer``
/// - Since: 200.1
public class ImageTiledLayer : ArcGIS.ImageAdjustmentLayer {

    /// The ``ImageTiledLayer`` behavior for the tiles without data.
    /// - Note: See Also: ``ImageTiledLayer/noDataTileBehavior-swift.property``
    public enum NoDataTileBehavior {

        /// Show coarser tiles. That's the default for operational layers and basemap base layers.
        case upSample

        /// Show blank tiles (nothing). That's the default for basemap reference layers.
        case blank

        /// Show the tiles with 'No Data' stamped over them.
        case show

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ImageTiledLayer.NoDataTileBehavior, b: ArcGIS.ImageTiledLayer.NoDataTileBehavior) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Determines how a tile request that returns 'NoData' is resampled.
    ///
    /// Zooming in can result in tile requests with no tiles at the
    /// requested level of detail. In this case, there are options that control what to display
    /// where the tile should be including:
    /// * ``NoDataTileBehavior-swift.enum/upSample`` - Resample the pixels from a lower level of detail
    ///   tile. This can result in pixelation or blurriness. This is the default behavior for
    ///   operational layers.
    /// * ``NoDataTileBehavior-swift.enum/blank`` - The 'NoData' pixels will show the raster picture as
    ///   being blank (or disappearing). This is the default behavior for basemap reference
    ///   layers.
    /// * ``NoDataTileBehavior-swift.enum/show`` - This will show the raster picture with the text
    ///  'No Data' stamped over it once you pass the lowest level-of-detail scale.
    ///
    /// Sometimes, to see the effect on the map when setting the ``noDataTileBehavior-swift.property``
    /// property, the ``Layer/maxScale`` value must also be explicitly set. The
    /// ``Layer/maxScale`` property may need to be smaller than the level-of-detail
    /// setting that was used to create the tiled images in ArcGIS Pro or ArcGIS Desktop.
    /// For example, consider an operational image tile layer showing forest cover that was created
    /// with the level-of-detail assumption that it was to be viewed above a scale of
    /// 5000 (meaning you will not see 'NoData' until you zoom closer to the Earth than
    /// a 5000 scale). However, you want to be able to zoom in closer to the Earth surface, say
    /// down to 3000 or 300. By setting the ``Layer/maxScale`` property to a number
    /// smaller than 5000, you will be able to zoom in closer to the Earth and
    /// see the effects of changing the ``noDataTileBehavior-swift.property`` enumerations.
    public var noDataTileBehavior: ArcGIS.ImageTiledLayer.NoDataTileBehavior?

    /// The tile information.
    ///
    /// Use this method to set tile info on an already created tiled layer.
    public var tileInfo: ArcGIS.TileInfo { get }

    /// Sets the attribution string for the image tiled layer.
    ///
    /// Set the attribution string for the image tiled layer.
    /// - Parameter attribution: The attribution string
    public func setAttribution(_ attribution: String)
}

extension ImageTiledLayer {

    /// The default tile info for image tiled layers.
    public class var defaultTileInfo: ArcGIS.TileInfo { get }

    /// The default full extent of image tiled layers.
    public class var defaultFullExtent: ArcGIS.Envelope { get }
}

extension ImageTiledLayer.NoDataTileBehavior : Equatable {
}

extension ImageTiledLayer.NoDataTileBehavior : Hashable {
}

/// A class that represents an incident.
///
/// Incidents also represent locations that can serve as the starting point or ending point of
/// a closest facility analysis, for example, a fire or a traffic accident.
/// The ``Incident`` class contains one of location inputs for the ``ClosestFacilityTask``.
/// The ``ClosestFacilityTask`` will create a route between facilities and incidents.
/// - Since: 200.1
final public class Incident {

    /// Creates a incident instance with point.
    ///
    /// Creates a incident.
    /// - Parameter point: A point.
    /// - Note: See Also: ``Point``
    public convenience init(point: ArcGIS.Point)

    /// Curb approach.
    ///
    /// Default value ``CurbApproach/eitherSide`` will be returned on error.
    /// - Note: See Also: ``CurbApproach``
    final public var curbApproach: ArcGIS.CurbApproach?

    /// Current bearing in degrees.
    ///
    /// Current bearing in degrees, measured clockwise from `true` north. Typical values are 0 to 360 or `nan`,
    /// negative values will be subtracted from 360 (e.g. -15 => 345), values greater than 360 will be have 360
    /// subtracted from them (e.g. 385 => 25). For this property to be used the bearing tolerance also has to be set.
    final public var currentBearing: Double

    /// Current bearing tolerance in degrees. Valid values are 0 to 180 or `nan`.
    final public var currentBearingTolerance: Double

    /// Distance to network location in meters.
    ///
    /// The distance to network location in meters that can be populated by closest facility task.
    final public var distanceToNetworkLocation: Measurement<UnitLength> { get }

    /// Incident's point geometry.
    ///
    /// Incident's location using geographical point.
    /// - Note: See Also: ``Point``
    final public var geometry: ArcGIS.Point? { get }

    /// Incident ID.
    ///
    /// This is a caller supplied foreign key that can be used to associate output incidents with input incidents.
    /// - Note: See Also: `ClosestFacilityParameters.setIncidents(fromFeaturesIn:queryParameters:)`, ``ClosestFacilityResult/incidents``
    final public var id: Int

    /// Impedance cutoff.
    ///
    /// It's a value for the impedance beyond which facilities should not be found.
    final public var impedanceCutoff: Double

    /// Location status.
    ///
    /// Incident location's status that can be populated by closest facility task.
    /// Default value ``LocationStatus/notLocated`` will be returned on error.
    /// - Note: See Also: ``LocationStatus``
    final public var locationStatus: ArcGIS.LocationStatus { get }

    /// Incident's name.
    ///
    /// Incident's name to be reported in driving directions.
    /// - Note: See Also: `String`
    final public var name: String

    /// Navigation latency in seconds.
    final public var navigationLatency: TimeInterval

    /// Navigation speed in meters per second.
    final public var navigationSpeed: Double

    /// Network location.
    ///
    /// The incident's location on the network that can be populated by closest facility task.
    /// Set to `nil` for resetting a network location.
    /// - Note: See Also: ``NetworkLocation``
    final public var networkLocation: ArcGIS.NetworkLocation?

    /// Target facility count.
    ///
    /// The -1 value means target facility count property is not considered, but default is used instead.
    /// Default value can be obtained from ``ClosestFacilityTaskInfo/defaultTargetFacilityCount`` method.
    final public var targetFacilityCount: Int

    /// Gets added cost attribute value.
    ///
    /// Returns added cost value for given impedance or accumulate attribute.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: The value of added cost.
    final public func addedCost(forAttributeNamed attributeName: String) -> Double

    /// Clones the ``Incident``.
    /// - Returns: A new ``Incident`` with the same values as the current ``Incident``.
    final public func clone() -> Self

    /// Sets added cost.
    ///
    /// Sets added cost value for given impedance or accumulate attribute.
    /// - Parameters:
    ///   - addedCost: The added cost.
    ///   - attributeName: The name of attribute.
    final public func setAddedCost(_ addedCost: Double, forAttributeNamed attributeName: String)
}

/// Provides an indoor or outdoor position based on device sensor data (radio, GPS, motion sensors).
///
/// An IPS (indoor positioning system) position is calculated based on radio data and motion sensors.
/// The GPS position is used as a fallback in case an IPS position can't be calculated, or if the
/// IPS position reports a position outside of a building.
/// - Since: 200.1
final public class IndoorsLocationDataSource : ArcGIS.LocationDataSource {

    /// Create a new ``IndoorsLocationDataSource``.
    /// - Parameters:
    ///   - positioningTable: The "ips_positioning" feature table from an IPS-enabled map.
    ///   - pathwaysTable: An ``ArcGISFeatureTable`` that contains pathways in accordance with the ArcGIS Indoors Information Model. Setting this property enables path snapping of locations provided by the ``IndoorsLocationDataSource``.
    ///   - levelsTable: An ``ArcGISFeatureTable`` that contains floor levels in accordance with the ArcGIS Indoors Information Model.  Providing this table enables the retrieval of a location's floor level ID.
    ///   - positioningID: An ID that identifies a specific row in the ``FeatureTable`` to use for setting up IPS. If it is `nil`, the entry in ``positioningTable`` with the most recent date is used.
    public convenience init(positioningTable: ArcGIS.FeatureTable, pathwaysTable: ArcGIS.ArcGISFeatureTable?, levelsTable: ArcGIS.ArcGISFeatureTable?, positioningID: UUID?)

    /// An ``ArcGISFeatureTable`` that contains levels in accordance with the ArcGIS Indoors Information Model.
    /// Providing this table enables the retrieval of the location floor level ID.
    ///
    /// Floor level ID can be obtained from ``Location/additionalSourceProperties`` of a ``Location`` emitted by the ``IndoorsLocationDataSource``.
    /// For more information about the levels table and ArcGIS Indoors Information Model see
    /// [the ArcGIS Pro documentation](https://pro.arcgis.com/en/pro-app/latest/help/data/indoors/arcgis-indoors-information-model.htm#ESRI_SECTION2_31525AA777E54CDD884C7F2B31F7D51B).
    final public var levelsTable: ArcGIS.ArcGISFeatureTable? { get }

    /// An ``ArcGISFeatureTable`` that contains pathways as per the ArcGIS Indoors Information Model.
    /// Setting this property enables path snapping of locations provided by the IndoorsLocationDataSource.
    ///
    /// For more information about the ArcGIS Indoors Information Model see https://pro.arcgis.com/en/pro-app/latest/help/data/indoors/arcgis-indoors-information-model.htm#ESRI_SECTION2_72E0DE4BBEFA435485E2D10CB16D2BE6.
    final public var pathwaysTable: ArcGIS.ArcGISFeatureTable? { get }

    /// An ID that identifies a specific row in the ``FeatureTable`` to use for setting up IPS.
    /// If it is `nil`, the entry in ``positioningTable`` with the most recent date is used.
    final public var positioningID: UUID? { get }

    /// The "ips_positioning" feature table from an IPS-enabled map.
    final public var positioningTable: ArcGIS.FeatureTable? { get }

    /// An error that describes a problem encountered while starting or running the ``LocationDataSource``.
    ///
    /// This property is used to notify user about transient, non-terminal errors, which occur in ``IndoorsLocationDataSource``.
    /// Such errors can influence accuracy of the final positioning. Information stored inside reported error contains useful
    /// information about its origin. Unlike ``LocationDataSource`` error it does not require ``IndoorsLocationDataSource``
    /// to be restarted.
    @ArcGIS.Streamed final public var warning: Error? { get }

    final public var $warning: AsyncStream<Error?> { get }
}

extension IndoorsLocationDataSource {

    /// Creates a new instance with the given parameters.
    /// - Parameters:
    ///   - positioningTable: The "ips_positioning" feature table from an
    ///   IPS-enabled map.
    ///   - pathwaysTable: An ArcGIS feature table that contains pathways as per
    ///   the ArcGIS Indoors Information Model. Providing this table enables
    ///   path snapping of locations provided by the data source.
    ///   - positioningID: An identifier specifying the  row in
    ///   `positioningTable` that should be used for setting up IPS. If `nil`,
    ///   the data source will try to determine the latest row in the table and
    ///   use that to set up IPS.
    public convenience init(positioningTable: ArcGIS.FeatureTable, pathwaysTable: ArcGIS.ArcGISFeatureTable? = nil, positioningID: UUID? = nil)
}

/// An object that specifies an inherited domain that specifies the valid values for a ``Field``.
/// - Since: 200.1
final public class InheritedDomain : ArcGIS.Domain {
}

/// An instance of this class represents a layer that can visualize an integrated mesh layer.
/// An integrated mesh can represent built and natural 3D features, such as building walls, trees,
/// valleys, and cliffs, with realistic textures and includes elevation information.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class IntegratedMeshLayer : ArcGIS.Layer {

    /// Creates an integrated mesh layer object with a portal item.
    /// - Parameter item: The integrated mesh layer item (only ``PortalItem`` are supported).
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// Creates an Integrated Mesh layer object.
    ///
    /// If the specified URI is a portal item URL (see ``PortalItem/init(url:)`` for the supported URL formats), the underlying ``PortalItem`` will be created and accessible through ``Layer/item``.
    /// - Parameter url: The URI to the service, scene layer package, or portal item.
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(url: URL)

    /// The layer altitude offset.
    final public var altitudeOffset: Double

    /// The URI of the Integrated mesh layer.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:)``
    final public var url: URL? { get }
}

/// Defines the set of interactive operations you can enable or disable for a ``VertexTool`` or ``FreehandTool``.
///
/// An ``InteractionConfiguration`` allows you to customize the interactive geometry editing experience to suit
/// your specific users. For example:
/// * Disable vertex, mid-vertex, and part selection (``allowsVertexCreation``,
///   ``allowsMidVertexSelection``, ``allowsPartCreation``) to
///   define a tool to only move the complete geometry.
/// * Disable moving the selected element (``allowsMovingSelectedElement``) but allow
///   all selections, and provide a tool for a user to enter new coordinates instead of moving interactively.
///
/// You can tap multiple times on any ``GeometryEditorElement`` to select the different types of
/// ``GeometryEditorElement`` representing vertices, parts, and the entire geometry. For example if all elements are allowed to be selected:
/// * tap twice on a vertex of a ``Multipoint`` to select first the vertex and then the entire multipoint geometry
/// * tap three times on a vertex of a ``Polyline`` or ``Polygon`` to select first the vertex, then the part, and
///   then the entire geometry
/// * tap twice on an edge of a ``Polyline`` or ``Polygon`` to select first the part and then the entire geometry
/// * tap twice on a fill of a ``Polygon`` to select first the part and then the entire geometry
///
/// You can change the interaction properties of a tool at any point, including when a geometry editor is started
/// (``GeometryEditor/isStarted`` = `true`) and the tool is in use by the editor. If you change a property that
/// disallows an in-progress interaction, then the interaction is cancelled and does not affect the state of the
/// ``GeometryEditor``.
///
/// Convenience methods are available to quickly set all properties relative to a category of interaction - for
/// example use `InteractionConfiguration.allowSelecting(_:)` to change all selection interactions,
/// and `InteractionConfiguration.allowTransforming(_:)` to change all properties that control geometry
/// transformation.
/// - Note: See Also: ``VertexTool/configuration``,
/// ``FreehandTool/configuration``,
/// `InteractionConfiguration.allowSelecting(_:)`,
/// `InteractionConfiguration.allowTransforming(_:)`,
/// `InteractionConfiguration.allowDeleting(_:)`
/// - Since: 200.1
final public class InteractionConfiguration {

    /// Creates an ``InteractionConfiguration`` that enables selection, transformation and deletion.
    ///
    /// Defines the most powerful and least restrictive interactive experience. When you create a new ``VertexTool``
    /// or ``FreehandTool``, its ``InteractionConfiguration`` property defines the values appropriate for that tool,
    /// which may differ from the default values set by this constructor. For more information on the different
    /// default values for these tools, see ``VertexTool`` and ``FreehandTool``.
    /// - Note: See Also: ``VertexTool/configuration``, ``FreehandTool/configuration``
    public convenience init()

    /// `true` if the selected ``GeometryEditorElement`` can be interactively deleted, `false` otherwise. Default is `true`.
    ///
    /// Whether `true` or `false`, an element can be deleted by `GeometryEditor.deleteSelectedElement()`.
    ///
    /// If `true`, then the ``GeometryEditorElement/canBeDeleted`` property of the ``GeometryEditor/selectedElement``
    /// is also `true`. If you have implemented a customization to allow users to interactively delete the
    /// selected element, then you can use this property to check if that customization should be enabled.
    ///
    /// `InteractionConfiguration.allowDeleting(_:)` sets this property.
    final public var allowsDeletingSelectedElement: Bool

    /// `true` if the entire geometry can be interactively selected, `false` otherwise. Default is `true`.
    ///
    /// If `true`, you can tap multiple times on elements of the geometry to make the entire geometry selected.
    ///
    /// Whether `true` or `false`, the entire geometry can be selected by `GeometryEditor.selectGeometry()`.
    ///
    /// `InteractionConfiguration.allowSelecting(_:)` sets this property.
    /// - Note: See Also: ``GeometryEditor/selectedElement``, ``GeometryEditor/selectedElement``, ``GeometryEditorGeometry``
    final public var allowsGeometrySelection: Bool

    /// `true` if a mid-vertex of a polygon or polyline can be interactively selected, `false` otherwise. Default is `true`.
    ///
    /// By default, mid-vertices (``GeometryEditorMidVertex``) are displayed and can be helpful in interactive
    /// workflows to provide a visual cue that new vertices can be inserted between the existing vertices of
    /// polygons and polylines. They may be most helpful for users with less editing experience.
    ///
    /// If `true`, and ``allowsVertexCreation`` is also `true`, then you can select and drag a
    /// mid-vertex to insert a vertex into the ``GeometryEditor/geometry`` and immediately move it to the required
    /// position.
    ///
    /// If `false`, and you also do not intend to programmatically select any mid-vertices
    /// (`GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`) then set ``GeometryEditorStyle/midVertexSymbol``
    /// to `nil` to prevent the display of unusable mid-vertices.
    ///
    /// Whether `true` or `false`, a mid-vertex can be selected by `GeometryEditor.selectMidVertexAt(partIndex:segmentIndex:)`.
    ///
    /// `InteractionConfiguration.allowSelecting(_:)` sets this property.
    /// - Note: See Also: ``GeometryEditor/selectedElement``, ``GeometryEditor/selectedElement``
    final public var allowsMidVertexSelection: Bool

    /// `true` if the selected ``GeometryEditorElement`` can be interactively moved, `false` otherwise. Default is `true`.
    ///
    /// If `true`, you can use a drag gesture to move the selected ``GeometryEditorElement`` to the required
    /// location. Create a tool to allow moving only specific types of ``GeometryEditorElement`` by also allowing or
    /// disallowing the selection of different types of element (``allowsVertexSelection``
    /// for example).
    ///
    /// If `false`, the behavior of a drag gesture depends on the current ``GeometryEditor/tool``. A ``VertexTool``
    /// will pan the map, whereas a ``FreehandTool`` will create a new part (depending on
    /// ``allowsPartCreation``).
    ///
    /// `InteractionConfiguration.allowTransforming(_:)` sets this property.
    /// - Note: See Also: ``requiresSelectionBeforeMove``
    final public var allowsMovingSelectedElement: Bool

    /// `true` if you can interactively create a new part in a polyline or polygon, `false` otherwise. Default is `true`.
    ///
    /// If `true` and the `Geometry.Type` of the ``GeometryEditor/geometry`` is a polygon or polyline, you can you
    /// can add new parts to the ``Multipart`` geometry - the ``GeometryEditor/tool`` determines the interaction
    /// required to add the new part. If the `Geometry.Type` of the ``GeometryEditor/geometry`` is a point or
    /// multipoint, this property is ignored.
    ///
    /// Users less experienced with GIS data may not understand how visually separate parts of polygons and
    /// polylines form a single geometry. You may wish to prevent such users from inadvertently creating geometries
    /// with multiple parts in order to keep their workflows straightforward and understandable. Alternatively, your
    /// app may be editing data which does not support multipart geometries.
    ///
    /// `InteractionConfiguration.allowCreating(_:)` sets this property.
    /// - Note: See Also: `GeometryEditor.replaceGeometry(with:)`, ``allowsVertexCreation``
    final public var allowsPartCreation: Bool

    /// `true` to allow a part of a ``Multipart`` geometry (``Polyline`` or ``Polygon``) to be
    /// selected interactively, `false` otherwise. Default is `true`.
    ///
    /// If `true`, you can tap on the edge of a polygon or polyline ``GeometryEditorGeometry`` in order to the select
    /// the part.
    ///
    /// Whether `true` or `false`, a part can be selected by `GeometryEditor.selectPart(atIndex:)`. Parts are also selected
    /// after creation using a ``FreehandTool``.
    ///
    /// `InteractionConfiguration.allowSelecting(_:)` sets this property.
    /// - Note: See Also: ``allowsPartCreation``, ``GeometryEditorPart``
    final public var allowsPartSelection: Bool

    /// `true` to allow a vertex to be created interactively, `false` otherwise. Default is `true`.
    ///
    /// If `true`, you can tap on the map to add a new vertex. The vertex is inserted after the previously selected
    /// vertex, or as the first vertex if the previous selection was the first vertex in a ``Polyline``. If you tap
    /// on an existing ``GeometryEditorElement`` then selection occurs instead.
    ///
    /// A ``FreehandTool`` ignores this property as it does not create individual vertices; instead you use a
    /// freehand gesture to create a a part in a polygon or polyline geometry.
    ///
    /// Whether `true` or `false`, a vertex can be created by `GeometryEditor.insertVertex(at:)`.
    ///
    /// `InteractionConfiguration.allowCreating(_:)` sets this property.
    /// - Note: See Also: ``GeometryEditor/geometry``, ``allowsPartCreation``
    final public var allowsVertexCreation: Bool

    /// `true` to allow vertices to be selected interactively, `false` otherwise. Default is `true`.
    ///
    /// If `true`, you can tap on a vertex to select it.
    ///
    /// To prevent vertices from being selected interactively by tapping on the vertex, while still allowing
    /// programmatic selection, set ``allowsVertexSelection`` to `false`.
    ///
    /// Whether `true` or `false`, a vertex may still become selected in other ways, for example by a call to
    /// `GeometryEditor.selectVertexAt(partIndex:vertexIndex:)`, or when a new vertex is created.
    ///
    /// `InteractionConfiguration.allowSelecting(_:)` sets this property.
    /// - Note: See Also: ``GeometryEditor/selectedElement``, ``GeometryEditor/selectedElement``, ``GeometryEditorVertex``
    final public var allowsVertexSelection: Bool

    /// `true` to require a ``GeometryEditorElement`` to first be selected before it can be moved by interactively dragging, `false` otherwise. Default is `false`.
    ///
    /// By default, you can select and immediately move an element in one gesture. Some users may find this can lead
    /// to an increase in accidental element moves when editing. By setting this to `true`, this can reduce the
    /// possibility of accidental moves. Alternatively, you may wish to provide access to `GeometryEditor.undo()`
    /// and `GeometryEditor.redo()` to provide easy correction of accidental edits.
    ///
    /// If `false`, the behavior of a drag gesture depends on the current ``GeometryEditor/tool``. For a
    /// ``VertexTool``, a drag gesture on the map over a geometry editor element that is not already selected pans
    /// the map, whereas a ``FreehandTool`` will create a new part (depending on
    /// ``allowsPartCreation``).
    ///
    /// This property applies if and only if ``allowsMovingSelectedElement`` is `true`.
    final public var requiresSelectionBeforeMove: Bool

    /// Enable or disable creation.
    ///
    /// Sets the following properties:
    /// * ``allowsVertexCreation``
    /// * ``allowsPartCreation``
    ///
    /// Deletion, selection and transformation properties are unaltered.
    /// - Parameter allowCreating: Indicates if creation is allowed.
    final public func allowCreating(_ allowCreating: Bool)

    /// Enable or disable deletion.
    ///
    /// Sets the following properties:
    /// * ``allowsDeletingSelectedElement``
    ///
    /// Creation, selection and transformation properties are unaltered.
    /// - Parameter allowDeleting: Indicates if deletion is allowed.
    final public func allowDeleting(_ allowDeleting: Bool)

    /// Enable or disable selection.
    ///
    /// Sets the following properties:
    /// * ``allowsGeometrySelection``
    /// * ``allowsMidVertexSelection``
    /// * ``allowsPartSelection``
    /// * ``allowsVertexSelection``
    ///
    /// Creation, deletion and transformation properties are unaltered.
    /// - Parameter allowSelecting: Indicates if selection is allowed.
    final public func allowSelecting(_ allowSelecting: Bool)

    /// Enable or disable interactions that transform the ``GeometryEditor/geometry``, for example
    /// ``allowsMovingSelectedElement``.
    ///
    /// Sets the following properties:
    /// * ``allowsMovingSelectedElement``
    ///
    /// Creation, deletion and selection properties are unaltered.
    /// - Parameter allowTransforming: Indicates if transformation is allowed.
    final public func allowTransforming(_ allowTransforming: Bool)
}

/// An error denoting an invalid argument.
/// - Since: 200.1
public struct InvalidArgumentError : Error {

    /// The error details.
    public let details: String
}

extension InvalidArgumentError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.InvalidArgumentError, b: ArcGIS.InvalidArgumentError) -> Bool
}

/// An error denoting a call was invalid.
/// - Since: 200.1
public struct InvalidCallError : Error {

    /// The error details.
    public let details: String
}

extension InvalidCallError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.InvalidCallError, b: ArcGIS.InvalidCallError) -> Bool
}

/// An object that represents an item.
/// - Note: See Also: ``Layer/item``, ``GeoModel/item``, ``Basemap/item``
/// - Since: 200.1
public class Item {

    /// The information on the source of the item and its copyright status.
    public var accessInformation: String

    /// The date the item was created.
    public var creationDate: Date? { get }

    /// Fetches the item's data.
    public var data: Data { get async throws }

    /// The description of the specified item.
    public var description: String

    /// The extent of the specified item.
    public var extent: ArcGIS.Envelope?

    /// The date the item was last modified.
    public var modificationDate: Date? { get }

    /// The name of this item.
    public var name: String { get }

    /// The short summary description of the specified item.
    ///
    /// A short summary description of the item.
    public var snippet: String

    /// The spatial reference name of the specified item.
    ///
    /// The coordinate system of the specified item.
    public var spatialReferenceName: String { get }

    /// The user defined tags that describe the specified item.
    /// - Note: See Also: `Array`, `String`
    public var tags: [String] { get }

    /// Adds a sequence of `String` values to the end of the `tags` property.
    /// - Parameter newTags: The new `String` values to append.
    public func addTags<S>(_ newTags: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `tags` property.
    /// - Parameter newTag: The new `String` value to append.
    public func addTag(_ newTag: String)

    /// Inserts a collection of `String` values into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTags: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    public func insertTags<C>(_ newTags: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTag: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    public func insertTag(_ newTag: String, at index: Int)

    /// Removes all values from the `tags` property.
    public func removeAllTags()

    /// Removes a sequence of `String` values from the `tags` property.
    /// - Parameter tags: The `String` values to remove.
    public func removeTags<S>(_ tags: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `tags` property.
    /// - Parameter tag: The `String` value to remove.
    public func removeTag(_ tag: String)

    /// The terms of use of the item.
    ///
    /// It is stored in the "licenseInfo" property in json.
    /// The property can contain HTML markup.
    public var termsOfUse: String

    /// The thumbnail of the item.
    /// - Note: See Also: ``LoadableImage/image``
    public var thumbnail: ArcGIS.LoadableImage? { get }

    /// The title of the specified item.
    ///
    /// This is the name that's displayed to users and by which they refer to the item. Every item must have a title.
    public var title: String

    /// An array of keywords that further describes the type of this item. Each item is tagged with a set of type keywords that are derived based on its primary type.
    ///
    /// The type keywords of the specified item.
    /// - Note: See Also: `Array`, `String`
    public var typeKeywords: [String] { get }

    /// Adds a sequence of `String` values to the end of the `typeKeywords` property.
    /// - Parameter newTypeKeywords: The new `String` values to append.
    public func addTypeKeywords<S>(_ newTypeKeywords: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `typeKeywords` property.
    /// - Parameter newTypeKeyword: The new `String` value to append.
    public func addTypeKeyword(_ newTypeKeyword: String)

    /// Inserts a collection of `String` values into the `typeKeywords` property at the specified position.
    /// - Parameters:
    ///   - newTypeKeywords: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    public func insertTypeKeywords<C>(_ newTypeKeywords: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `typeKeywords` property at the specified position.
    /// - Parameters:
    ///   - newTypeKeyword: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    public func insertTypeKeyword(_ newTypeKeyword: String, at index: Int)

    /// Removes all values from the `typeKeywords` property.
    public func removeAllTypeKeywords()

    /// Removes a sequence of `String` values from the `typeKeywords` property.
    /// - Parameter typeKeywords: The `String` values to remove.
    public func removeTypeKeywords<S>(_ typeKeywords: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `typeKeywords` property.
    /// - Parameter typeKeyword: The `String` value to remove.
    public func removeTypeKeyword(_ typeKeyword: String)

    /// Sets the thumbnail of the item with the specified image.
    /// - Parameter image: The image (can be `nil`).
    public func setThumbnailImage(to image: UIImage?)
}

extension Item {

    /// Updates an item's properties in a file on disk when this item instance is a ``LocalItem``.
    ///
    /// The following remarks apply when the item instance is a ``LocalItem``.
    ///
    /// Updating properties can be only done for local items that are unpacked.
    /// For example a mobile map package file (.mmpk) can be unpacked using
    /// ``MobileMapPackage/unpack(at:to:)``. Once unpacked local items within the package can be updated see
    /// ``MobileMapPackage/item`` and for any maps use ``GeoModel/item``.
    /// As well as packages, the local item available from an item resource cache can be updated. This is accessed
    /// with ``ItemResourceCache/item``.
    /// If the package is not unpacked an error of ``InvalidCallError`` is returned as an
    /// error in the async task.
    public func updateProperties() async throws
}

extension Item {

    public struct ID : CustomStringConvertible, Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        public init?(_ rawValue: String)

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The ID of the item.
    public var id: ArcGIS.Item.ID? { get }
}

/// An object containing information on offline resources typically associated with a custom style for an ``ArcGISVectorTiledLayer``.
///
/// An object containing information about resources associated with an ``ArcGISVectorTiledLayer``.
/// For example, a vector tile layer has style resources such as fonts, sprites, etc.
/// - Since: 200.1
final public class ItemResourceCache : ArcGIS.Loadable {

    /// Creates an instance of this object with a path to a directory containing ``ItemResourceCache``.
    /// - Parameter fileURL: path
    public convenience init(fileURL: URL)

    /// The path to the on-disk location containing the ``ItemResourceCache``.
    ///
    /// The path can be a directory on-disk that contains the ``ItemResourceCache``.
    /// Alternatively, if the ``ItemResourceCache`` was loaded from a package file, such as a ``MobileMapPackage``,
    /// the path is to the package.
    final public var fileURL: URL? { get }

    /// The ``LocalItem`` containing the ``ItemResourceCache``'s thumbnail and metadata.
    ///
    /// This property can be `nil` if the ``LocalItem`` is not present within the ``ItemResourceCache`` directory.
    /// If the ``ItemResourceCache`` was taken offline using ``ExportVectorTilesTask`` or ``OfflineMapTask``
    /// the ``LocalItem`` will be populated from the online ``PortalItem``.
    /// If the ``ItemResourceCache`` was created inside a ``MobileMapPackage`` authored from ArcGIS Pro then
    /// this property will return `nil`.
    final public var item: ArcGIS.LocalItem? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An error representing a JSON error.
/// - Since: 200.1
public struct JSONError : Error {

    /// The types of JSON errors.
    public enum Kind {

        /// Invalid JSON.
        case invalidJSON

        /// JSON parser invalid token.
        case invalidToken

        /// JSON parser invalid character.
        case invalidCharacter

        /// JSON parser invalid unicode.
        case invalidUnicode

        /// JSON parser invalid start of JSON.
        case invalidJSONStart

        /// JSON parser invalid end of pair.
        case invalidEndOfPair

        /// JSON parser invalid end of element.
        case invalidEndOfElement

        /// JSON parser invalid escape sequence.
        case invalidEscapeSequence

        /// JSON parser invalid end of field name.
        case invalidEndOfFieldName

        /// JSON parser invalid start of field name.
        case invalidStartOfFieldName

        /// JSON parser invalid start of comment.
        case invalidStartOfComment

        /// JSON parser invalid decimal digit.
        case invalidDecDigit

        /// JSON parser invalid hex digit.
        case invalidHexDigit

        /// JSON parser expecting `nil`.
        case expectingNull

        /// JSON parser expecting `true`.
        case expectingTrue

        /// JSON parser expecting `false`.
        case expectingFalse

        /// JSON parser expecting closing quote.
        case expectingClosingQuote

        /// JSON parser expecting not a number.
        case expectingNan

        /// JSON parser expecting end of comment.
        case expectingEndOfComment

        /// JSON parser unexpected end of data.
        case unexpectedEndOfData

        /// JSON object expecting start object.
        case expectingStartObject

        /// JSON object expecting start array.
        case expectingStartArray

        /// JSON object expecting value object.
        case expectingValueObject

        /// JSON object expecting value array.
        case expectingValueArray

        /// JSON object expecting value int32.
        case expectingValueInt32

        /// JSON object expecting integer type.
        case expectingIntegerType

        /// JSON object expecting number type.
        case expectingNumberType

        /// JSON object expecting value string.
        case expectingValueString

        /// JSON object expecting value bool.
        case expectingValueBool

        /// JSON object iterator not started.
        case iteratorNotStarted

        /// JSON object iterator is finished.
        case iteratorIsFinished

        /// JSON object key not found.
        case keyNotFound

        /// JSON object index out of range.
        case indexOutOfRange

        /// JSON string writer JSON is complete.
        case jsonIsComplete

        /// JSON string writer invalid JSON input.
        case invalidJSONInput

        /// JSON string writer expecting container.
        case expectingContainer

        /// JSON string writer expecting key or end object.
        case expectingKeyOrEndObject

        /// JSON string writer expecting value or end array.
        case expectingValueOrEndArray

        /// JSON string writer expecting value.
        case expectingValue

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.JSONError.Kind, b: ArcGIS.JSONError.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The kind of error.
    public let kind: ArcGIS.JSONError.Kind

    /// Details beyond the basic message about the error.
    public let details: String
}

extension JSONError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.JSONError, b: ArcGIS.JSONError) -> Bool
}

extension JSONError.Kind : Equatable {
}

extension JSONError.Kind : Hashable {
}

/// A interface for reading and writing JSON.
///
/// This interface will be used when an Object needs to be read or written to JSON. These methods return a specific object and not
/// the interface ``JSONSerializable``. Objects implementing this interface have the ability to persist custom data to
/// the JSON output. This custom data is stored as a `Dictionary` where the keys are strings that represent properties on
/// the Object, and the values are strings that represent the JSON value for that corresponding property.
/// Any custom data that causes malformed JSON when the Object is persisted will not be included in the JSON output.
/// For example, if a key from the custom data matches a property on the Object and both were written out to JSON,
/// it would result in malformed JSON. So in this example, the key in the custom data causing the malformed JSON would not be persisted.
/// - Since: 200.1
public protocol JSONSerializable {

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    static func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    func toJSON() -> String
}

/// A job represents a long running asynchronous action.
/// - Remark: A job can be paused and re-started. A job can involve multiple network requests.
/// - Since: 200.1
public class Job {

    /// The job's messages.
    public var messages: AsyncStream<ArcGIS.JobMessage> { get }

    /// The current progress of the job. The progress is not cancellable or pausable. Starting,
    /// pausing, and cancelling must be handled through ``Job/start()``, ``Job/pause()`` and
    /// ``Job/cancel()``.
    final public let progress: Progress

    /// The ID of the associated job running on the server.
    public var serverJobID: String { get }

    /// The status of the job.
    @ArcGIS.Streamed public var status: ArcGIS.Job.Status { get }

    public var $status: AsyncStream<ArcGIS.Job.Status> { get }

    /// Cancels this job and waits for any asynchronous, server-side operations
    /// to be canceled.
    ///
    /// The job is canceled and will result in a
    /// ``Status-swift.enum/failed`` status after all cancellation tasks have
    /// completed. For jobs running on a server, a cancel request is sent for
    /// the associated ``serverJobID``. You should always cancel unneeded jobs
    /// (for example when exiting your app) to avoid placing unnecessary load on
    /// the server. Examples of server-side jobs include:
    ///
    ///   * ``ExportTileCacheJob``
    ///   * ``ExportVectorTilesJob``
    ///   * ``GenerateGeodatabaseJob``
    ///   * ``GeoprocessingJob``
    ///
    /// In addition, the ``GenerateOfflineMapJob`` is composed of several
    /// server-side jobs, depending on the types of layers in your ``Map``.
    /// Canceling this high-level job will also send a cancel request to the
    /// underlying server jobs. Upon calling this method,
    /// ``Job/status-swift.property`` is immediately set to
    /// ``Status-swift.enum/canceling``.
    public func cancel() async

    /// Initiates a request to check the status of the job on the server.
    ///
    /// This can be helpful for supporting background fetch. A request for status is only sent if
    /// the job was in a state where it was polling.
    /// - Remark: The job automatically polls the server periodically, but this method is helpful
    /// if you want to check the status at a specific moment.
    public func checkStatus() async throws

    /// Pauses the job if it is running.
    public func pause()

    /// Starts the job if it is currently not started. Resumes the job if it is currently paused.
    public func start()
}

extension Job {

    /// The current status of a job.
    public enum Status {

        /// A job that has not started.
        case notStarted

        /// A job that has started and is executing.
        case started

        /// A job that is paused. Use ``Job/start()`` to resume the job.
        case paused

        /// A job that has completed successfully.
        case succeeded

        /// A job that has completed and has failed.
        case failed

        /// A job that is in the process of being canceled.
        case canceling

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Job.Status, b: ArcGIS.Job.Status) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension Job : ArcGIS.JSONSerializable {

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension Job.Status : Equatable {
}

extension Job.Status : Hashable {
}

/// A message from a job.
/// - Since: 200.1
public struct JobMessage {
}

extension JobMessage {

    /// The different levels of severity of a job message.
    ///
    /// Each of the values represents a different level of job message severity.
    public enum Severity {

        /// An informative message is generated during the job's execution, such as a
        /// job uploading data, job progressing on a server or job results. This message
        /// type never indicates a problem.
        case info

        /// A warning message is generated when a job experiences a situation that may
        /// cause a problem during its execution or when the result may not be what you
        /// expect. For example, when the job has failed to take a layer offline from an
        /// online map. Generally the job will run to successful completion even if
        /// there are one or more warnings.
        case warning

        /// An error message indicates a critical event that caused the job to fail.
        case error

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.JobMessage.Severity, b: ArcGIS.JobMessage.Severity) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension JobMessage {

    /// The origin of a job message.
    ///
    /// Each of the values represents a different type of job message source.
    public enum Source {

        /// A job message generated by this API.
        case client

        /// A job message generated by a service.
        case service

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.JobMessage.Source, b: ArcGIS.JobMessage.Source) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension JobMessage {

    /// The job message's severity: information, warning or error.
    public var severity: ArcGIS.JobMessage.Severity { get }

    /// The source of the job message, either from the service or from this API.
    public var source: ArcGIS.JobMessage.Source { get }

    /// The job message's message string.
    public var text: String { get }

    /// The date and time that the job message was created. This will be the current system
    /// time on the user's device.
    public var timestamp: Date { get }
}

extension JobMessage.Severity : Equatable {
}

extension JobMessage.Severity : Hashable {
}

extension JobMessage.Source : Equatable {
}

extension JobMessage.Source : Hashable {
}

/// A type that is able to kick off a long running job on a server.
/// - Since: 200.1
public protocol JobProtocol : ArcGIS.Job {

    /// The type associated with the result of a successful job.
    associatedtype Output

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    var result: Result<Self.Output, Error> { get async }
}

extension JobProtocol {

    /// The output of the completed job.
    /// - Remark: Accessing this property does not start the job.
    public var output: Self.Output { get async throws }
}

/// Determines how altitude values should be interpreted.
/// - Note: See Also: ``KMLGeometry``
/// - Since: 200.1
public enum KMLAltitudeMode {

    /// The \<altitude\> specification is ignored, and the object will be draped over the ground.
    case clampToGround

    /// (default) Interprets the \<altitude\> as a value in meters above the ground. If the point is over water, the \<altitude\> will be interpreted as a value in meters above sea level.
    case relativeToGround

    /// Interprets the \<altitude\> as a value in meters above sea level, regardless of the terrain elevation beneath the feature.
    case absolute

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.KMLAltitudeMode, b: ArcGIS.KMLAltitudeMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension KMLAltitudeMode : Equatable {
}

extension KMLAltitudeMode : Hashable {
}

/// KMLColorStyle defines how KMLNode will appear based on the specified Color and ColorMode properties.
///
/// For KMLIcon objects, the Color that is specified is blended with the existing color of the base image.
/// Due to this blending effect, to have the exact color appear that was specified by the Color property, it is
/// recommended that the base image be white. Also note that, because Color defaults to white, the Color property
/// of KMLIcon will result in the original color of the base image.
/// - Since: 200.1
public class KMLColorStyle {

    /// A KML color mode object.
    public enum Mode {

        /// Normal is the default value. This means that whatever Color property is set for the KMLColorStyle will be used.
        case normal

        /// Random means whatever the Color property is set for the KMLColorStyle will be overwritten by a random color.
        case random

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.KMLColorStyle.Mode, b: ArcGIS.KMLColorStyle.Mode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The KMLColorStyle's color.
    public var color: UIColor

    /// The KMLColorStyle's color mode.
    public var mode: ArcGIS.KMLColorStyle.Mode
}

extension KMLColorStyle.Mode : Equatable {
}

extension KMLColorStyle.Mode : Hashable {
}

/// A KML Container object.
///
/// A KML container element holds one or more KML nodes and allows the creation of nested hierarchies.
/// - Since: 200.1
public class KMLContainer : ArcGIS.KMLNode {

    /// The KML container's child nodes.
    public var childNodes: [ArcGIS.KMLNode] { get }

    /// Adds a sequence of `KMLNode` values to the end of the `childNodes` property.
    /// - Parameter newChildNodes: The new `KMLNode` values to append.
    public func addChildNodes<S>(_ newChildNodes: S) where S : Sequence, S.Element == ArcGIS.KMLNode

    /// Adds a `KMLNode` value to the end of the `childNodes` property.
    /// - Parameter newChildNode: The new `KMLNode` value to append.
    public func addChildNode(_ newChildNode: ArcGIS.KMLNode)

    /// Inserts a collection of `KMLNode` values into the `childNodes` property at the specified position.
    /// - Parameters:
    ///   - newChildNodes: The new `KMLNode` values to insert.
    ///   - index: The position at which to insert the new `KMLNode` values.
    public func insertChildNodes<C>(_ newChildNodes: C, at index: Int) where C : Collection, C.Element == ArcGIS.KMLNode

    /// Inserts a `KMLNode` value into the `childNodes` property at the specified position.
    /// - Parameters:
    ///   - newChildNode: The new `KMLNode` value to insert.
    ///   - index: The position at which to insert the new `KMLNode` value.
    public func insertChildNode(_ newChildNode: ArcGIS.KMLNode, at index: Int)

    /// Removes all values from the `childNodes` property.
    public func removeAllChildNodes()

    /// Removes a sequence of `KMLNode` values from the `childNodes` property.
    /// - Parameter childNodes: The `KMLNode` values to remove.
    public func removeChildNodes<S>(_ childNodes: S) where S : Sequence, S.Element == ArcGIS.KMLNode

    /// Removes a `KMLNode` value from the `childNodes` property.
    /// - Parameter childNode: The `KMLNode` value to remove.
    public func removeChildNode(_ childNode: ArcGIS.KMLNode)

    /// A flag indicating if the KML container is open.
    ///
    /// Opens the container if is_open is `true`, closes it otherwise.
    public var isOpen: Bool

    /// A flag indicating if the KML container is partially visible.
    public var isPartiallyVisible: Bool { get }

    /// The container's list item type.
    ///
    /// See 'listItemType' attribute of 'ListStyle' in the KML specification for more information.
    /// This defines how visibility selection should work, enabling either single or multiple selection of child nodes when shown in a list (for example, a legend).
    /// When the item type is ``KMLListItemType/radioFolder``, making a node visible will hide its sibling nodes.
    public var listItemType: ArcGIS.KMLListItemType?
}

/// A KML dataset object.
///
/// KML dataset represents the current state of the KML data specified in a KML/KMZ file.
/// - Since: 200.1
final public class KMLDataset : ArcGIS.Loadable {

    /// Creates a KML dataset from the specified root node.
    ///
    /// Creates a KML dataset. KML dataset is the source of KML information backing a KML layer. Use the KML dataset to interact with the contents of a KML layer.
    /// Licensing for KML depends on the method of access. Creating a KML dataset from a root node requires an ArcGIS Runtime 'Standard' license level.
    /// - Parameter rootNode: The root KML node with which to create a KML dataset.
    public convenience init(rootNode: ArcGIS.KMLNode)

    /// Creates a KML dataset from the provided path to a KML/KMZ file.
    ///
    /// Creates a KML dataset. KML dataset is the source of KML information backing a KML layer. Use the KML dataset to interact with the contents of a KML layer.
    /// Licensing for KML depends on the method of access. Accessing files on disk requires an ArcGIS Runtime 'Standard' license level.
    /// - Parameter url: The location of the file, either on disk or from the network.
    public convenience init(url: URL)

    /// Visibility changes to a KML node balloon.
    ///
    /// This property is helpful to know when to show or hide a KML node's balloon popup.
    final public var nodeBalloonVisibilities: AsyncStream<(eventTarget: ArcGIS.KMLNode, balloonVisibility: Bool)> { get }

    /// Refresh status changes to a KML node.
    final public var nodeRefreshStatuses: AsyncStream<(kmlNode: ArcGIS.KMLNode, refreshStatus: ArcGIS.KMLNode.RefreshStatus)> { get }

    /// The KML dataset's root nodes.
    ///
    /// KML files can have multiple root nodes, each of which may have children.
    /// When traversing the KML feature tree (for example to build a TOC), ``rootNodes`` is the correct starting point.
    /// Each root node can be the start of a tree of nodes, so these should be recursively explored with ``KMLContainer/childNodes`` or ``KMLNetworkLink/childNodes``.
    final public var rootNodes: [ArcGIS.KMLNode] { get }

    /// The location of the KML/KMZ file, which can either be on disk or from the network.
    ///
    /// The URI of the backing file. Files can be loaded from local storage or the network.
    /// Note that KML files often point to network locations for their data (using network links). As a result, the loaded KML
    /// layer may display more information than is contained in the loaded KML file.
    /// KML files can point to network locations. These locations may be insecure (over plain text HTTP) even when the
    /// URI returned from this function is pointing to an SSL/TLS-secured resource.
    /// - Note: See Also: `String`
    final public var url: URL? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A KML Document object.
///
/// A KML document is a container for features and styles.
/// - Since: 200.1
final public class KMLDocument : ArcGIS.KMLContainer {

    /// Creates a KML document.
    public convenience init()
}

/// A KML Folder object.
///
/// A KML folder is used to arrange other Features hierarchically (Folders, Placemarks, NetworkLinks, or Overlays).
/// A KML node is visible only if it and all its ancestors are visible.
/// - Since: 200.1
final public class KMLFolder : ArcGIS.KMLContainer {

    /// Creates a KML folder.
    public convenience init()
}

/// A KML geometry object.
///
/// A KML geometry contains all the KML specific information associated with a Geometry.
/// - Since: 200.1
final public class KMLGeometry {

    /// The list of KML geometry types.
    ///
    /// This is used to determine KML node type.
    /// - Note: See Also: ``KMLPlacemark``
    public enum Kind {

        /// A point.
        case point

        /// A polyline.
        case polyline

        /// A polygon.
        case polygon

        /// A model.
        case model

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.KMLGeometry.Kind, b: ArcGIS.KMLGeometry.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a ``KMLGeometry`` from a ``Geometry`` using a specific altitude mode, extruded flag, and a tessellated flag.
    ///
    /// Only polyline geometries can be tessellated.
    /// - Parameters:
    ///   - geometry: The ``Geometry`` used to create a new KML geometry.
    ///   - altitudeMode: Determines how altitude values should be interpreted.
    ///   - isExtruded: `true` if the geometry is extruded, `false` otherwise.
    ///   - isTessellated: `true` if the geometry is tessellated, `false` otherwise.
    public convenience init?(geometry: ArcGIS.Geometry, altitudeMode: ArcGIS.KMLAltitudeMode, isExtruded: Bool = false, isTessellated: Bool = false)

    /// The KML altitude mode.
    final public var altitudeMode: ArcGIS.KMLAltitudeMode? { get }

    /// The ``Geometry`` contained within the KML geometry.
    final public var geometry: ArcGIS.Geometry { get }

    /// A flag indicating if the KML geometry is extruded.
    final public var isExtruded: Bool { get }

    /// A flag indicating if the KML geometry is tessellated.
    ///
    /// In order for tessellated geometry to follow the terrain, ``altitudeMode`` must be ``KMLAltitudeMode/clampToGround``.
    /// Only polyline geometries can be tessellated.
    final public var isTessellated: Bool { get }

    /// The KML geometry type.
    final public var kind: ArcGIS.KMLGeometry.Kind? { get }
}

extension KMLGeometry.Kind : Equatable {
}

extension KMLGeometry.Kind : Hashable {
}

/// A KML GroundOverlay object.
///
/// KML GroundOverlay is an image overlay draped on to the terrain.
/// - Since: 200.1
final public class KMLGroundOverlay : ArcGIS.KMLNode {

    /// Creates a KML ground overlay with the specified geometry and icon.
    ///
    /// The specified geometry must be either an ``Envelope`` or a ``Polygon`` with exactly 4 points.
    /// Other geometry types are not supported.
    /// - Parameters:
    ///   - geometry: The geometry associated to the ground overlay.
    ///   - icon: The icon associated to the ground overlay.
    public convenience init?(geometry: ArcGIS.Geometry, icon: ArcGIS.KMLIcon?)

    /// The KML ground overlay's altitude.
    final public var altitude: Double

    /// The altitude mode of the KML ground overlay. Ground overlays currently support ``KMLAltitudeMode/absolute``
    /// and ``KMLAltitudeMode/clampToGround``.
    final public var altitudeMode: ArcGIS.KMLAltitudeMode?

    /// The color mask to be applied to the KML ground overlay's image.
    ///
    /// The color mask used to blend the image associated with KML ground overlay.
    /// Pixels in the overlay image are multiplied by this color channel-by-channel. Colors in KML are specified in ABGR order. As of version 100.4, only the alpha (opacity) channel is multiplied; all others are left as-is.
    final public var color: UIColor?

    /// The KML ground overlay's draw order.
    ///
    /// Draw order defines the stacking order for the images in overlapping overlays.
    /// Overlays with higher draw order values are drawn on top of overlays with lower draw order values.
    final public var drawOrder: Int

    /// The geometry for the KML ground overlay.
    ///
    /// The specified geometry must be either an ``Envelope`` or a ``Polygon`` with exactly 4 points.
    /// Other geometry types are not supported.
    final public var geometry: ArcGIS.Geometry

    /// The KML ground overlay icon.
    final public var icon: ArcGIS.KMLIcon?

    /// The KML ground overlay's rotation.
    ///
    /// Specify the rotation of the overlay about its center, in degrees.
    /// Values can be in the range of +/-180. The default is 0 (north).
    /// Rotations are specified in a counterclockwise direction.
    final public var rotation: Double
}

/// A KML icon object.
///
/// A KML icon specifies the location and refresh paramaters of an overlay image.
/// - Since: 200.1
final public class KMLIcon {

    /// Creates a KML icon from the provided path to an image file.
    ///
    /// Creates a KML icon. KML icon defines the image associated with an overlay or an icon style.
    /// - Parameter url: The location of the image file, either on disk or from the network.
    public convenience init(url: URL)

    /// An icon's refresh interval.
    final public var refreshInterval: TimeInterval

    /// An icon's refresh mode.
    final public var refreshMode: ArcGIS.KMLRefreshMode

    /// An icon's image file URI.
    final public var url: URL { get }

    /// An icon's view refresh mode.
    final public var viewRefreshMode: ArcGIS.KMLViewRefreshMode

    /// An icon's view refresh time.
    final public var viewRefreshTime: TimeInterval
}

/// A KML icon style object.
///
/// Specifies how icons for placemarks and photo overlays with a point geometry are drawn.
/// Color is blended with the existing color of the icon.
/// - Since: 200.1
final public class KMLIconStyle : ArcGIS.KMLColorStyle {

    /// Creates an icon style with the specified icon and scale.
    ///
    /// A `nil` icon will result in the default yellow pushpin icon being used. An icon with an incorrect or inaccessible URI will result in a red cross icon being used.
    /// - Parameters:
    ///   - icon: Icon for drawing the point placemarks.
    ///   - scale: Scale of the icon.
    public convenience init(icon: ArcGIS.KMLIcon? = nil, scale: Double = 1)

    /// The direction in decimal degrees.
    ///
    /// Values range from 0 (North) to 360 degrees. The default value is 0.
    final public var heading: Double

    /// The position within the icon that is anchored to the point specified in the placemark.
    final public var hotSpot: ArcGIS.KMLImageCoordinate?

    /// The icon to be used by the placemark.
    ///
    /// A `nil` icon will result in the default yellow pushpin icon being used. An icon with an incorrect or inaccessible URI will result in a red cross icon being used.
    final public var icon: ArcGIS.KMLIcon?

    /// The scale factor that should be applied to the rendered icon.
    final public var scale: Double
}

/// A KML image coordinate object.
///
/// According to the OGC 2.3 specification in section 16.26.2 (https://docs.opengeospatial.org/is/12-007r2/12-007r2.html#1254)
/// "Specifies an image coordinate system. The x and y values may each be specified in three different ways - as pixels (pixels), as
/// fractions of the icon (fraction), or as inset pixels (insetPixels), which is an offset in pixels from the upper right corner of
/// the icon. They may or may not be specified in a consistent manner - for example, x can be specified in pixels and y as a fraction."
/// Use the ``UnitsType`` enumeration (either via the ``xUnits`` and ``yUnits`` properties or
/// via the ``init(x:y:xUnits:yUnits:)`` constructor) to establish the KML
/// image coordinate system. The ``UnitsType/pixels`` and ``UnitsType/insetPixels`` image coordinate systems are defined with
/// device-independent pixels (DIPs).
/// - Since: 200.1
final public class KMLImageCoordinate {

    /// A KML units type object.
    ///
    /// Use the ``KMLImageCoordinate/UnitsType`` enumeration (either via the ``KMLImageCoordinate/xUnits`` and ``KMLImageCoordinate/yUnits`` properties or
    /// via the ``KMLImageCoordinate/init(x:y:xUnits:yUnits:)`` constructor) to establish the KML
    /// image coordinate system. Values of type fraction must be between 0.0 and 1.0. Values below 0.0 will be set to 0.0, and values above
    /// 1.0 will be set to 1.0. If a non-integral number is specified with a unit type of device-independent pixels (``pixels``
    /// or ``insetPixels``), it will be rounded down to a whole number (e.g. 2.243 will be rounded to 2.0).
    public enum UnitsType {

        /// Fraction is the default value. Treat the x/y value as a fraction of the width/height.
        case fraction

        /// Treat the x/y value as an integral number of device-independent pixels (DIPs).
        case pixels

        /// Treat the x/y value as an integral number of device-independent pixels (DIPs) from the top right corner.
        case insetPixels

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.KMLImageCoordinate.UnitsType, b: ArcGIS.KMLImageCoordinate.UnitsType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a KML image coordinate.
    /// - Parameters:
    ///   - x: The x component of a point. Default is 0.5.
    ///   - y: The y component of a point. Default is 0.5.
    ///   - xUnits: Units in which the x value is specified. Default is ``UnitsType/fraction``.
    ///   - yUnits: Units in which the y value is specified. Default is ``UnitsType/fraction``.
    public convenience init(x: Double, y: Double, xUnits: ArcGIS.KMLImageCoordinate.UnitsType, yUnits: ArcGIS.KMLImageCoordinate.UnitsType)

    /// The x component of a point.
    ///
    /// The default value is 1.0.
    final public var x: Double { get }

    /// Units in which the x value is specified.
    ///
    /// The default value is fraction.
    final public var xUnits: ArcGIS.KMLImageCoordinate.UnitsType { get }

    /// The y component of a point.
    ///
    /// The default value is 1.0.
    final public var y: Double { get }

    /// Units in which the y value is specified.
    ///
    /// The default value is fraction.
    final public var yUnits: ArcGIS.KMLImageCoordinate.UnitsType { get }
}

extension KMLImageCoordinate.UnitsType : Equatable {
}

extension KMLImageCoordinate.UnitsType : Hashable {
}

/// Specifies how the name of a ``KMLNode`` is drawn, including color and scale.
///
/// Controls how the \<name\> of a ``KMLNode`` is displayed. Corresponds to a \<LabelStyle\> in a KML
/// document. Controls the color and scale of the name label.
/// - Note: See Also: ``KMLNode/name``
/// - Since: 200.1
final public class KMLLabelStyle : ArcGIS.KMLColorStyle {

    /// Creates a KML label style with a specified label color and scale.
    /// - Parameters:
    ///   - color: Color of the label. Default is RGBA(255,255,255,255).
    ///   - scale: Scale of the label. Default is 1.0.
    public convenience init(color: UIColor = .white, scale: Double = 1)

    /// Scale of the label. Default is 1.0.
    final public var scale: Double
}

/// A layer that can visualize KML data.
///
/// Keyhole Markup Language (KML) is a specification for working with geographic content.
/// KML files can contain 2D and 3D content, as well as links to content from the network.
/// You can read .kml and .kmz files from disk or the network and create, edit, and save a KML layer via the
/// ``KMLDataset``.
///
/// Functional characteristics
/// KML represents features as a tree of nodes, including network links, folders, and place marks.
/// Like ArcGIS features, place marks are defined with point, line, or polygon geometry. KML
/// geometry, however, is always based on the WGS84 coordinate system. KML can also have
/// attributes, but unlike ArcGIS feature services, a KML document does not use a schema to
/// define a standard set of fields. This API supports
/// [version 2.2 of the KML specification](https://www.ogc.org/standards/kml) as
/// defined by the Open Geospatial Consortium (OGC).
///
/// Unique features of KML include network links and screen overlays. Network links are useful
/// for retrieving network content on a specified intervalperfect for keeping a live map up to
/// date. Network links can also be used to split a large KML file into multiple per-region KML
/// files, with each being loaded only when the region is in view. Screen overlays can be used to
/// show content, such as branding or a legend, on top of the view. Screen overlay content does
/// not scroll with the map or react to user interaction.
///
/// All coordinates are expressed in latitude and longitude (using decimal degrees), and are
/// based on the `SpatialReference.wgs84` geographic coordinate system. Altitude
/// is always expressed in meters. The geographic features can contain attribute information and
/// various styles can be specified to render them. Ground overlays allow images to be displayed
/// for specific geographic objects or draped onto the map itself. Screen overlays allow fixing
/// images to the `GeoView`, and may be used for compasses, logos, legends, etc. Network links
/// give the ability to reference remote .kml or .kmz files, and refresh them periodically.
///
/// Loading the ``KMLLayer`` also loads its underlying ``KMLDataset``, creating one if you
/// didn't supply one through a constructor. The structure of a KML document can be examined
/// through ``KMLDataset/rootNodes`` after the ``KMLDataset`` has successfully loaded.
/// Missing or inaccessible .kml and .kmz files would cause loading to fail. Missing resources
/// referenced by the KML document (such as images or files referenced via a network link will
/// not prevent the layer from loading.
///
/// Performance characteristics
/// KML files can vary significantly in the features they use, including 3D models, network
/// links, and refresh intervals. Not all features are supported in 2D and 3D. For example, 3D
/// models only appear when the KML layer is shown in a scene. Many KML files consist solely of a
/// pointer to another KML file and a refresh interval. For example, the National Weather Service
/// distributes forecast maps in the United States this way.
/// - Note: See Also: ``Layer``, ``KMLDataset``
/// - Since: 200.1
final public class KMLLayer : ArcGIS.Layer, ArcGIS.TimeAware {

    /// Creates a KML layer.
    ///
    /// KML layers are read-only and do not allow authoring or editing.
    /// - Parameter dataset: The KML dataset.
    public convenience init(dataset: ArcGIS.KMLDataset)

    /// Creates a new KML layer object from a portal item.
    /// - Parameter item: A ``PortalItem``.
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// The KML dataset providing the content for the layer.
    ///
    /// The KML dataset associated with this KML layer.
    /// The KML dataset is the authoritative source for the layer's KML data. The KML dataset should be used when access to the tree of KML nodes is needed (for example to build a legend or toggle node visibility).
    /// - Note: See Also: ``KMLDataset``
    final public var dataset: ArcGIS.KMLDataset { get }

    /// The full time extent of the object.
    @ArcGIS.Streamed final public var fullTimeExtent: ArcGIS.TimeExtent? { get }

    final public var $fullTimeExtent: AsyncStream<ArcGIS.TimeExtent?> { get }

    /// A flag indicating whether the object supports filtering its contents by time values with the extent set on the owning `GeoView`.
    final public var supportsTimeFiltering: Bool { get }

    /// A flag indicating whether the object must use the time extent defined on the owning `GeoView` to filter its data.
    final public var timeFilteringIsEnabled: Bool

    /// The suggested time slider step size for this time aware object.
    ///
    /// Can be `nil` if no time interval is suggested for this time aware object.
    final public var timeInterval: ArcGIS.TimeValue? { get }

    /// The time offset applied to this object.
    /// The offset is subtracted from the time extent set on the owning `GeoView`.
    /// This allows for data from different periods of time to be compared.
    final public var timeOffset: ArcGIS.TimeValue?
}

/// Specifies the drawing style (color, color mode, and line width) for all line geometry. Line geometry includes
/// the outlines of outlined polygons and the extruded "tether" of Placemark icons (if extrusion is enabled).
/// - Since: 200.1
final public class KMLLineStyle : ArcGIS.KMLColorStyle {

    /// Creates a KML line style with a specified line color and width.
    /// - Parameters:
    ///   - color: The KML line style's color. Default is RGBA(255,255,255,255).
    ///   - width: Width of the KML line style, in pixels. Default is 1.0.
    public convenience init(color: UIColor = .white, width: Double = 1)

    /// Width of the KML line style, in pixels. Default is 1.0.
    final public var width: Double
}

/// The list of KML list item types.
///
/// Defines how visibility selection should work, enabling either single or multiple selection of child nodes of a document, folder, or network link.
/// - Since: 200.1
public enum KMLListItemType {

    /// (default) All child nodes can be enabled for display. In a table of contents, nodes should be shown with checkboxes to enable multiple selection.
    case check

    /// Only one child node can be enabled for display at any one time. In a table of contents, nodes should be shown with radio buttons. When a child node is selected for display, sibling nodes will be hidden automatically.
    case radioFolder

    /// All child nodes should be enabled for display, but they should not be shown in the table of contents.
    case checkHideChildren

    /// Everything in the container or network link can be turned off all at once. Prevents nodes from becoming visible simultaneously.
    /// Child nodes must be enabled individually. This is useful if the container or network link contains a large amount of data.
    case checkOffOnly

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.KMLListItemType, b: ArcGIS.KMLListItemType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension KMLListItemType : Equatable {
}

extension KMLListItemType : Hashable {
}

/// A KML NetworkLink object.
///
/// A KML NetworkLink is a reference to a KML file or KMZ archive on a local or remote network.
/// - Since: 200.1
final public class KMLNetworkLink : ArcGIS.KMLNode {

    /// Creates a KML network link from the provided URI to a KML/KMZ file.
    ///
    /// Creates a KML network link that references a KML file or KMZ archive on a local or remote network.
    /// - Parameter sourceURL: The location of the file, either on disk or from the network.
    public convenience init(sourceURL: URL)

    /// `true` if the app should zoom to the KML network link when it refreshes, `false` otherwise.
    ///
    /// When this is defined, the app should zoom to the viewpoint defined on the associated NetworkLinkControl or
    /// the network links' top-level KML node upon refresh of the link. The app will not automatically
    /// fly to the node on refresh. It is the application developer's responsibility to implement this behavior,
    /// if desired.
    /// You can listen for the refresh status changed event to detect when the geoview's viewpoint should be updated.
    /// This is defined in the flyToView tag in the network link.
    final public var canFlyToNode: Bool

    /// The KML network link's child nodes.
    final public var childNodes: [ArcGIS.KMLNode] { get }

    /// `true` if the visibility selection is preserved for nodes in a network link after refresh, `false` otherwise.
    ///
    /// This corresponds to the 'refreshVisibility' property in the source KML file.
    final public var hasRefreshVisibility: Bool

    /// `true` if the KML network link is open, `false` otherwise.
    final public var isOpen: Bool

    /// `true` if the KML network link is partially visible, `false` otherwise.
    final public var isPartiallyVisible: Bool { get }

    /// The network link's list item type.
    ///
    /// This defines how visibility selection should work, enabling either single or multiple selection of child nodes when shown in a list (for example, a legend).
    /// When the item type is ``KMLListItemType/radioFolder``, making a node visible will hide its sibling nodes.
    /// See the OGC specification for more details.
    final public var listItemType: ArcGIS.KMLListItemType?

    /// The KML network link refresh interval, in milliseconds.
    /// - Note: See Also: ``KMLRefreshMode``
    final public var refreshInterval: Int

    /// The KML network link refresh mode.
    /// - Note: See Also: ``KMLRefreshMode``, ``refreshInterval``
    final public var refreshMode: ArcGIS.KMLRefreshMode

    /// The KML network link URI.
    ///
    /// After setting a new URI you should call `KMLNetworkLink.refresh()` to fetch the data from the new URI.
    /// If the refresh mode of the network link is ``KMLRefreshMode/onInterval`` when the URI is changed, the
    /// refresh operation executed on the following interval will use the new URI value.
    final public var url: URL

    /// The KML network link view refresh mode.
    /// - Note: See Also: ``KMLViewRefreshMode``, ``viewRefreshTime``
    final public var viewRefreshMode: ArcGIS.KMLViewRefreshMode

    /// The KML network link view refresh time, in milliseconds.
    /// - Note: See Also: ``KMLViewRefreshMode``
    final public var viewRefreshTime: Int

    /// Refreshes the KML network link.
    /// - Note: See Also: ``KMLRefreshMode``
    final public func refresh()
}

/// A KML node object.
///
/// KML is a file format used to display geographic data (geometric shapes, symbology and attributes).
/// KML uses a tag-based structure with nested elements and attributes and is based on the XML standard.
/// The KML files are often distributed in KMZ files, which are zipped KML files with a .kmz extension.
/// - Since: 200.1
public class KMLNode {

    /// The list of KML refresh status event types.
    public enum RefreshStatus {

        /// This event is raised when a KML node refresh starts.
        case inProgress

        /// This event is raised when a KML node refresh completes.
        case completed

        /// This event is raised when a KML node refresh fails.
        case failed

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.KMLNode.RefreshStatus, b: ArcGIS.KMLNode.RefreshStatus) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The address of the KML node.
    ///
    /// Represents an unstructured address such as a street, city, state address, and/or a postal code.
    public var address: String

    /// The color to be used for the KML node balloon.
    ///
    /// A color mask that can be used to color the balloon of a KML node.
    /// This color can be used for the UI "chrome" that presents the ``balloonContent``, such as the background color of a callout.
    public var balloonBackgroundColor: UIColor? { get }

    /// The balloon content that should be displayed in a balloon popup for the KML node.
    ///
    /// The provided HTML is suitable for display in a web view.
    public var balloonContent: String { get }

    /// The description of the KML node.
    public var description: String

    /// The extent for the KML node.
    public var extent: ArcGIS.Envelope? { get }

    /// The KML node's highlight style.
    ///
    /// This style is used when the KML node has been highlighted / selected.
    /// - Note: See Also: ``KMLStyle``
    public var highlightStyle: ArcGIS.KMLStyle?

    /// The ID of the KML node.
    ///
    /// The ID is a standard XML ID and can be empty.
    public var id: String

    /// A flag indicating if the KML node is highlighted.
    ///
    /// Highlights the node if is_highlighted is `true`, unhighlights it otherwise. All of the connected map views will be updated.
    /// This controls whether the default style or an alternate 'highlighted' style (if present) is used for rendering the node.
    /// This is unrelated to the concept of selection in this API.
    public var isHighlighted: Bool

    /// A flag indicating if the KML node is visible.
    ///
    /// Makes the node visible if is_visible is `true`, hides it otherwise. All of the connected map views will be updated.
    /// In order for a node to be visible, all of its ancestors must also be visible.
    /// Changing the visibility of one node may affect visibility of other nodes in the dataset hierarchy, such as child nodes.
    public var isVisible: Bool

    /// The name of the KML node.
    public var name: String

    /// The KML node's parent.
    weak public var parent: ArcGIS.KMLNode? { get }

    /// The KML node's refresh error.
    public var refreshError: Error? { get }

    /// The KML node's refresh status.
    ///
    /// Use the node refresh status to update the node's properties and update application UI.
    @ArcGIS.Streamed public var refreshStatus: ArcGIS.KMLNode.RefreshStatus? { get }

    public var $refreshStatus: AsyncStream<ArcGIS.KMLNode.RefreshStatus?> { get }

    /// The KML node's snippet.
    ///
    /// Snippets can be defined for KML nodes as an additional short description for UI display.
    /// If no snippet is specified, you can take the first few lines of the ``description``.
    /// The maximum number of lines to display is specified by the ``snippetMaxLines`` property.
    public var snippet: String

    /// The maximum number of lines of snippet to be shown in the UI.
    public var snippetMaxLines: Int

    /// The KML node's style.
    /// - Note: See Also: ``KMLStyle``
    public var style: ArcGIS.KMLStyle?

    /// The KML node's time extent.
    ///
    /// Represents the ``TimeExtent`` equivalent of a KML node's
    /// https://docs.opengeospatial.org/is/12-007r2/12-007r2.html#1168 or
    /// https://docs.opengeospatial.org/is/12-007r2/12-007r2.html#1181.
    /// A ``KMLContainer`` node such as ``KMLDocument`` or ``KMLFolder`` may have its own ``TimeExtent`` independent of its child nodes.
    /// All KML TimeStamps and TimeSpans specified in a KML/KMZ file are converted to their UTC ``TimeExtent`` equivalents.
    ///
    /// Examples:
    ///
    /// Kml TimeStamp       | ``TimeExtent/startDate``    | ``TimeExtent/endDate``
    /// ------------------- | --------------------------- | -------------------------
    /// 2021                | 2021-01-01T00:00:00         | 2021-12-31T23:59:59
    /// 2021-01             | 2021-01-01T00:00:00         | 2021-01-31T23:59:59
    /// 2021-01-01          | 2021-01-01T00:00:00         | 2021-01-01T23:59:59
    /// 2021-01-01T12:34:56 | 2021-01-01T12:34:56         | 2021-01-01T12:34:56
    ///
    /// Kml TimeSpan           | ``TimeExtent/startDate``   | ``TimeExtent/endDate``
    /// ---------------------- | ---------------------------| --------------------------
    /// 2021         - 2022    | 2021-01-01T00:00:00        | 2022-12-31T23:59:59
    /// 2021-01      - 2021-02 | 2021-01-01T00:00:00        | 2021-02-28T23:59:59
    /// No beginning - 2021    | Infinite start time        | 2021-12-31T23:59:59
    /// 2021         - No end  | 2021-01-01T00:00:00        | Infinite end time
    /// - Note: See Also: ``TimeExtent``
    public var timeExtent: ArcGIS.TimeExtent?

    /// The UX icon of a KML node.
    ///
    /// Use this icon to represent the KML node in the TOC or list item or any UI element.
    public var uxIcon: UIImage? { get }

    /// The color mask used to tint the node's icon.
    ///
    /// A color mask that can be used to blend the image associated with the KML node.
    /// Pixels in the image are multiplied by this color channel-by-channel. Colors in KML are specified in ABGR
    /// order. When no UX icon is specified, you can use this color to draw a placeholder for use in the UI (for
    /// example, a legend). UX icons are not pre-tinted; it is the application's responsibility to apply the tint
    /// color to the UX icon before displaying it.
    public var uxIconColor: UIColor? { get }

    /// The UX icon id.
    ///
    /// The icon id associate with KML node.
    public var uxIconID: Int { get }

    /// The KML node's viewpoint.
    ///
    /// The KML viewpoint is the specified vantage point for looking at the node.
    /// This can be used to zoom to a node (for example, if a user selected it in a TOC).
    /// - Note: See Also: ``KMLViewpoint``
    public var viewpoint: ArcGIS.KMLViewpoint?

    /// Saves the node and any referenced local files into a zipped KMZ archive.
    ///
    /// The node will be saved to a KMZ file to ensure that any referenced files are available locally when sharing the file with others.
    /// If this method is called on a leaf node (e.g. KMLPlacemark, KMLGroundOverlay, etc), only that node and its referenced files will be saved.
    /// If this method is called on container node (e.g. KMLDocument, KMLFolder), the node and all of its children and referenced files will be saved.
    /// If this method is called on a KMLNetworkLink, the link will be saved but the children will not. This is because the children will simply be
    /// refetched when the saved KMLNetworkLink is loaded.
    /// Saving referenced files will differ based on the type of reference. For HTTP paths, the path will be saved as is but the referenced file will
    /// not be zipped into the archive, as it will simply be refetched when the new KMZ is loaded. For relative paths, the path will be saved as is
    /// and the referenced file will be zipped relative to the root of the KMZ file. For absolute paths, the path will be converted to a relative path,
    /// and the referenced file will be zipped into a "files" folder at the root of the KMZ file. For example, "C:/icons/some_icon.png" would be converted
    /// to "files/some_icon.png" and stored at that location in the KMZ file.
    /// The filename supports unicode characters as well as nested directories. It must be non-empty and there must not be an existing file located there.
    /// Saving a node to a KMZ file requires an ArcGIS Runtime 'Standard' license level.
    /// - Parameter url: The KMZ filepath to which the node should be saved.
    public func save(to url: URL) async throws
}

extension KMLNode.RefreshStatus : Equatable {
}

extension KMLNode.RefreshStatus : Hashable {
}

/// A KML PhotoOverlay object.
///
/// KML PhotoOverlay is an photo overlay draped on a shape.
/// - Since: 200.1
final public class KMLPhotoOverlay : ArcGIS.KMLNode {
}

/// A KML Placemark object.
///
/// A KML Placemark is a KML node with associated Geometry.
/// - Since: 200.1
final public class KMLPlacemark : ArcGIS.KMLNode, ArcGIS.GeoElement {

    /// The list of KML graphic types.
    ///
    /// This is used to determine KML node type.
    /// - Note: See Also: ``KMLPlacemark``
    public enum GraphicType {

        /// A point.
        case point

        /// A polyline.
        case polyline

        /// A polygon.
        case polygon

        /// An extruded point.
        case extrudedPoint

        /// An extruded polyline.
        case extrudedPolyline

        /// An extruded polygon.
        case extrudedPolygon

        /// A model.
        case model

        /// A multi-geometry. This is a container for geometries.
        case multiGeometry

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.KMLPlacemark.GraphicType, b: ArcGIS.KMLPlacemark.GraphicType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a KML placemark from a specified KML geometry.
    /// - Parameter geometry: Geometry to use for the new placemark.
    public convenience init(geometry: ArcGIS.KMLGeometry)

    /// The KML geometries for the KML placemark.
    ///
    /// A collection of ``KMLGeometry``. The collection will contain one ``KMLGeometry`` for non multi-geometry.
    final public var geometries: [ArcGIS.KMLGeometry] { get }

    /// Adds a sequence of `KMLGeometry` values to the end of the `geometries` property.
    /// - Parameter newGeometries: The new `KMLGeometry` values to append.
    final public func addGeometries<S>(_ newGeometries: S) where S : Sequence, S.Element == ArcGIS.KMLGeometry

    /// Adds a `KMLGeometry` value to the end of the `geometries` property.
    /// - Parameter newGeometry: The new `KMLGeometry` value to append.
    final public func addGeometry(_ newGeometry: ArcGIS.KMLGeometry)

    /// Inserts a collection of `KMLGeometry` values into the `geometries` property at the specified position.
    /// - Parameters:
    ///   - newGeometries: The new `KMLGeometry` values to insert.
    ///   - index: The position at which to insert the new `KMLGeometry` values.
    final public func insertGeometries<C>(_ newGeometries: C, at index: Int) where C : Collection, C.Element == ArcGIS.KMLGeometry

    /// Inserts a `KMLGeometry` value into the `geometries` property at the specified position.
    /// - Parameters:
    ///   - newGeometry: The new `KMLGeometry` value to insert.
    ///   - index: The position at which to insert the new `KMLGeometry` value.
    final public func insertGeometry(_ newGeometry: ArcGIS.KMLGeometry, at index: Int)

    /// Removes all values from the `geometries` property.
    final public func removeAllGeometries()

    /// Removes a sequence of `KMLGeometry` values from the `geometries` property.
    /// - Parameter geometries: The `KMLGeometry` values to remove.
    final public func removeGeometries<S>(_ geometries: S) where S : Sequence, S.Element == ArcGIS.KMLGeometry

    /// Removes a `KMLGeometry` value from the `geometries` property.
    /// - Parameter geometry: The `KMLGeometry` value to remove.
    final public func removeGeometry(_ geometry: ArcGIS.KMLGeometry)

    /// The type of the graphic in the KML placemark.
    final public var graphicType: ArcGIS.KMLPlacemark.GraphicType? { get }

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    final public var attributes: [String : Any] { get }

    final public func setAttributeValue(_ value: Any?, forKey key: String)

    /// The geometry defines the shape and location of the ``GeoElement``.
    final public var geometry: ArcGIS.Geometry?
}

extension KMLPlacemark.GraphicType : Equatable {
}

extension KMLPlacemark.GraphicType : Hashable {
}

/// Specifies the drawing style for all polygons, including polygon extrusions (which look like the walls of buildings) and line extrusions (which look like solid fences).
///
/// Controls how the \<fill\> of a ``KMLNode`` is displayed and whether or not the \<outline\> of a ``KMLNode`` is displayed. If the outline is displayed, the outline
/// will use the current ``KMLLineStyle``. Corresponds to a \<PolyStyle\> in a KML document.
/// - Since: 200.1
final public class KMLPolygonStyle : ArcGIS.KMLColorStyle {

    /// Creates a KML polygon style with a specified fill color. Default is RGBA(255,255,255,255).
    /// - Parameter fillColor: The KML polygon style's fill color.
    public convenience init(fillColor: UIColor = .white)

    /// Specifies whether or not to display the polygon with a filled symbol. Default is `true`.
    final public var isFilled: Bool

    /// Specifies whether or not to display the polygon with an outline symbol using the current ``KMLLineStyle``. Default is `true`.
    final public var isOutlined: Bool
}

/// The list of KML refresh modes.
///
/// Defines the time-based refresh behavior of a KML network link.
/// - Since: 200.1
public enum KMLRefreshMode {

    /// (default) Refresh when the file is loaded and whenever the Link parameters change.
    case onChange

    /// Refresh every n milliseconds, where n is specified by refresh interval.
    /// If no refresh interval is set, the default value is 4000 milliseconds.
    /// - Note: See Also: ``KMLNetworkLink/refreshInterval``
    case onInterval

    /// Refresh the file when the expiration time is reached. If a fetched file has a NetworkLinkControl,
    /// the "expires" time takes precedence over expiration times specified in HTTP headers. If no
    /// "expires" time is specified, the HTTP max-age header is used (if present). If max-age is not
    /// present, the Expires HTTP header is used (if present). Currently this is treated the same
    /// as if the mode were onChange.
    case onExpire

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.KMLRefreshMode, b: ArcGIS.KMLRefreshMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension KMLRefreshMode : Equatable {
}

extension KMLRefreshMode : Hashable {
}

/// A KML ScreenOverlay object.
///
/// KML ScreenOverlay is an image overlay fixed to the screen.
/// ScreenOverlays may be used for compasses, logos and heads-up displays.
/// - Since: 200.1
final public class KMLScreenOverlay : ArcGIS.KMLNode {

    /// Creates a screen overlay with the specified icon.
    ///
    /// If the icon is `nil`, a rectangle is drawn using the color and size defined by ``color`` and ``size``.
    /// - Parameter icon: The icon associated to the screen overlay.
    public convenience init(icon: ArcGIS.KMLIcon?)

    /// The color mask to be applied to the KML screen overlay's image buffer.
    ///
    /// A color mask that can be used to blend the image associate with KML screen overlay.
    /// Pixels in the overlay image are multiplied by this color channel-by-channel.
    final public var color: UIColor

    /// The KML screen overlay's draw order.
    final public var drawOrder: Int

    /// The KML screen overlay icon.
    ///
    /// If the icon is `nil`, a rectangle is drawn using the color and size defined by ``color`` and ``size``.
    final public var icon: ArcGIS.KMLIcon?

    /// Specifies a point on (or outside of) the overlay image that is mapped to the screen coordinate (``screenCoordinate``). It requires x and y values, and the units for those values.
    ///
    /// The x and y values can be specified in three different ways: as pixels ("pixels"), as fractions of the image ("fraction"), or as inset pixels ("insetPixels"), which is an offset in pixels from the upper right corner of the image.
    /// The x and y positions can be specified in different waysfor example, x can be in pixels and y can be a fraction.
    /// The origin of the coordinate system is in the lower left corner of the image.
    /// If not specified, the default is the center of the overlay image.
    /// - Note: See Also: ``screenCoordinate``
    final public var overlayCoordinate: ArcGIS.KMLImageCoordinate?

    /// Indicates the angle of rotation of the parent object. A value of 0 means no rotation.
    ///
    /// The value is an angle in degrees counterclockwise starting from north.
    /// The center of the rotation, if not specified in rotation coordinate (``rotationCoordinate``), is the center of the overlay image.
    final public var rotation: Double

    /// Point relative to the screen about which the screen overlay is rotated.
    ///
    /// If not specified, the rotation point is the center of the screen.
    final public var rotationCoordinate: ArcGIS.KMLImageCoordinate?

    /// Specifies a point relative to the screen origin that the overlay image is mapped to.
    ///
    /// The x and y values can be specified in three different ways: as pixels ("pixels"), as fractions of the screen ("fraction"), or as inset pixels ("insetPixels"), which is an offset in pixels from the upper right corner of the screen.
    /// The x and y positions can be specified in different waysfor example, x can be in pixels and y can be a fraction.
    /// The origin of the coordinate system is in the lower left corner of the screen.
    /// If not specified, the default is the center of the screen.
    /// - Note: See Also: ``overlayCoordinate``
    final public var screenCoordinate: ArcGIS.KMLImageCoordinate?

    /// Specifies the size of the image for the screen overlay.
    ///
    /// A value of 1 indicates to use the native dimension
    /// A value of 0 indicates to maintain the aspect ratio
    /// A value of n sets the value of the dimension
    /// For example:
    /// A x value of -1 and y value of -1 in fractions indicates the image size equals its original x and y dimensions.
    /// A x value of -1 and y value of 0.2 in fractions indicates the image size equals its original x dimension and 20% of its y dimension.
    /// A x value of 100 and y value of 500 in pixels indicates the image is of size 100 pixels by 500 pixels.
    /// If not specified, the default is the original size of the image.
    final public var size: ArcGIS.KMLImageCoordinate?
}

/// Specifies the drawing style for a ``KMLNode``.
///
/// Controls the drawing style for the icon, line, polygon, and/or label or a ``KMLNode``. A ``KMLStyle`` is made
/// up of several substyles, including ``KMLIconStyle``, ``KMLLineStyle``, ``KMLPolygonStyle``, and ``KMLLabelStyle``.
/// Not all node types support styling. For example, a ``KMLTour`` node cannot be stylized.
/// - Since: 200.1
final public class KMLStyle {

    /// Creates a KML style. Substyles can be modified.
    public convenience init()

    /// Specifies how icons for point Placemarks are drawn.
    final public var iconStyle: ArcGIS.KMLIconStyle?

    /// Specifies how Placemark labels are drawn.
    final public var labelStyle: ArcGIS.KMLLabelStyle?

    /// Specifies the drawing style for all lines.
    final public var lineStyle: ArcGIS.KMLLineStyle?

    /// Specifies the drawing style for polygons.
    final public var polygonStyle: ArcGIS.KMLPolygonStyle?
}

/// A KML Tour object.
///
/// KML Tour is an executed Playlist commands.
/// - Since: 200.1
final public class KMLTour : ArcGIS.KMLNode {

    /// The list of KML tour status event types.
    public enum Status {

        /// The KML tour is not initialized. This is the default status.
        /// Set the tour on a tour controller to initialize it.
        /// Also, this event is raised when a tour is reset.
        case notInitialized

        /// This event is raised as soon as a KML tour is set on a tour controller.
        case initializing

        /// This event is raised when a KML tour is successfully initialized.
        /// if initialization fails, the status is set to not initialized.
        case initialized

        /// This event is raised when a KML tour starts playing.
        case playing

        /// This event is raised when a KML tour is paused.
        case paused

        /// This event is raised when a KML tour is completed.
        case completed

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.KMLTour.Status, b: ArcGIS.KMLTour.Status) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The KML tour's status.
    @ArcGIS.Streamed final public var status: ArcGIS.KMLTour.Status { get }

    final public var $status: AsyncStream<ArcGIS.KMLTour.Status> { get }
}

extension KMLTour.Status : Equatable {
}

extension KMLTour.Status : Hashable {
}

/// A KML tour controller object.
///
/// Use KML tour controller to play, pause or reset a KML tour
/// It notifies the application to play sound cues or show/hide balloon popups as specified in a tour playlist.
/// - Since: 200.1
final public class KMLTourController {

    /// The current position of the tour associated with a tour controller.
    @ArcGIS.Streamed final public var currentPosition: TimeInterval { get }

    final public var $currentPosition: AsyncStream<TimeInterval> { get }

    /// The total duration of the tour associated with a tour controller.
    @ArcGIS.Streamed final public var totalDuration: TimeInterval { get }

    final public var $totalDuration: AsyncStream<TimeInterval> { get }

    /// The KML tour on a tour controller and initializes it.
    ///
    /// To initialize and play a tour, set it on a tour controller.
    final public var tour: ArcGIS.KMLTour?

    /// Pauses the associated tour.
    final public func pause()

    /// Plays the associated tour, which may include audio content.
    ///
    /// If the tour is in the paused state, playing will resume where the tour was left off.
    final public func play()

    /// Resets the associated tour.
    ///
    /// Use this to reset the tour to the beginning, which includes resetting any KML content to its
    /// original state before the tour was played.
    final public func reset()
}

extension KMLTourController {

    /// Creates a KML tour controller, which can be used to control the playback
    /// of KML tours.
    /// - Parameter tour: The tour with which the controller should be created.
    /// The default value is `nil`.
    public convenience init(tour: ArcGIS.KMLTour? = nil)
}

/// The list of KML view refresh modes.
///
/// Defines the view-based refresh behavior of a KML network link.
/// - Since: 200.1
public enum KMLViewRefreshMode {

    /// (default) Ignore changes in the view.
    case never

    /// Refresh the file n milliseconds after movement stops, where n is specified by view refresh time.
    /// If no view refresh time is set, the default value is 4000 milliseconds.
    /// - Note: See Also: ``KMLNetworkLink/viewRefreshTime``
    case onStop

    /// Refresh the file only when the user explicitly requests it.
    case onRequest

    /// Refresh the file when the Region becomes active.
    case onRegion

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.KMLViewRefreshMode, b: ArcGIS.KMLViewRefreshMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension KMLViewRefreshMode : Equatable {
}

extension KMLViewRefreshMode : Hashable {
}

/// A KML viewpoint object.
///
/// A KML viewpoint contains all information about the KML camera and look at point.
/// - Since: 200.1
final public class KMLViewpoint {

    /// The list of view types.
    ///
    /// This is used to determine the KML viewpoint types.
    /// - Note: See Also: ``KMLViewpoint``
    public enum Kind {

        /// The view type is a camera.
        case camera

        /// The view type is a look at point.
        case lookAt

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.KMLViewpoint.Kind, b: ArcGIS.KMLViewpoint.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a KML viewpoint from a viewpoint.
    /// Returns `nil` if the spatial reference of the target geometry of the provided viewpoint is `nil` or could not be projected.
    ///
    /// KML viewpoint defines either a look at point or a camera,
    /// whereas a viewpoint must always have a look at point, and optionally also have a camera.
    /// A viewpoint that has a camera will create a KML viewpoint of type ``Kind-swift.enum/camera``.
    /// A viewpoint that has no camera will create a KML viewpoint of type ``Kind-swift.enum/lookAt``.
    /// - Parameter viewpoint: The viewpoint ``Viewpoint``.
    public convenience init?(viewpoint: ArcGIS.Viewpoint)

    /// The KML viewpoint's altitude mode.
    final public var altitudeMode: ArcGIS.KMLAltitudeMode? { get }

    /// The KML viewpoint's heading.
    ///
    /// The heading associated with this viewpoint. This is defined in terms of degrees from 0 (North) to 360, with 90 being East.
    final public var heading: Double { get }

    /// The KML viewpoint's type (Camera or LookAt).
    ///
    /// A ``Kind-swift.enum/camera`` viewpoint defines the position of the camera directly.
    /// A ``Kind-swift.enum/lookAt`` viewpoint defines the position of the camera relative to a point of interest.
    /// See [Google's KML reference](https://developers.google.com/kml/documentation/kmlreference#camera) for
    /// details about KML viewpoint (abstractView) specification, including diagrams.
    final public var kind: ArcGIS.KMLViewpoint.Kind { get }

    /// The KML viewpoint's location.
    ///
    /// The location associated with this viewpoint, which can be an observed point
    /// (https://developers.google.com/kml/documentation/kmlreference#lookat in KML) or the position of
    /// a https://developers.google.com/kml/documentation/kmlreference#camera.
    final public var location: ArcGIS.Point { get }

    /// The KML viewpoint's pitch.
    ///
    /// Angle in degrees between the camera and the target ``location``. Ranges between 0 and 90 for LookAt viewpoints, 0 and 180 for Camera viewpoints.
    /// 0 means the camera is pointing straight down towards the Earth and 90 means the camera is looking from/towards the horizon.
    /// For Camera viewpoints, values between 90 and 180 indicate the camera is looking towards the sky.
    /// Corresponds to 'tilt' in the KML specification.
    final public var pitch: Double { get }

    /// The KML viewpoint's range, which defines the distance between the camera and ``location``.
    ///
    /// The distance between the camera and the LookAt viewpoint's target location. This only applies to 'LookAt' viewpoints.
    final public var range: Double { get }

    /// The KML viewpoint's roll.
    ///
    /// The rotation in degrees of the viewpoint camera around the Z axis. Values range from -180 to 180 degrees.
    /// Only applies to 'Camera' type viewpoints.
    final public var roll: Double { get }

    /// Creates a KML viewpoint from the provided camera location.
    /// Returns `nil` if the provided location's spatial reference is `nil` or could not be projected.
    ///
    /// KML viewpoint defines either a standalone camera independent of the point of interest being observed
    /// or a virtual camera in relation to the point of interest being observed.
    /// - Parameters:
    ///   - location: The location of the camera.
    ///   - heading: The heading of the camera.
    ///   - pitch: The pitch of the camera.
    ///   - roll: The roll of the camera.
    ///   - altitudeMode: The KML altitude mode ``KMLAltitudeMode``.
    /// - Returns: A ``KMLViewpoint``.
    final public class func camera(at location: ArcGIS.Point, heading: Double, pitch: Double, roll: Double, altitudeMode: ArcGIS.KMLAltitudeMode) -> ArcGIS.KMLViewpoint?

    /// Creates a KML viewpoint from the provided look at location.
    /// Returns `nil` if the provided location's spatial reference is `nil` or could not be projected.
    ///
    /// KML viewpoint defines either a standalone camera independent of the point of interest being observed
    /// or a virtual camera in relation to the point of interest being observed.
    /// - Parameters:
    ///   - location: The observed location.
    ///   - heading: The heading of the look at point.
    ///   - pitch: The pitch of the look at point.
    ///   - range: The distance between the point being observed and the location from where it is being observed.
    ///   - altitudeMode: The KML altitude mode ``KMLAltitudeMode``.
    /// - Returns: A ``KMLViewpoint``.
    final public class func look(at location: ArcGIS.Point, heading: Double, pitch: Double, range: Double, altitudeMode: ArcGIS.KMLAltitudeMode) -> ArcGIS.KMLViewpoint?
}

extension KMLViewpoint.Kind : Equatable {
}

extension KMLViewpoint.Kind : Hashable {
}

/// An enum that describes when an item in the keychain is accessible.
/// - Since: 200.1
public enum KeychainAccess {

    /// Item data can only be accessed once the device has been unlocked after a restart.
    /// This is recommended for items that need to be accesible by background
    /// applications. Items with this attribute will migrate to a new device
    /// when using encrypted backups.
    case afterFirstUnlock

    /// Item data can only be accessed once the device has been unlocked after a restart.
    /// This is recommended for items that need to be accessible by background
    /// applications. Items with this attribute will never migrate to a new
    /// device, so after a backup is restored to a new device these items will
    /// be missing.
    case afterFirstUnlockThisDeviceOnly

    /// Item data can only be accessed while the device is unlocked. This is
    /// recommended for items that only need be accesible while the application
    /// is in the foreground. Items with this attribute will migrate to a new device
    /// when using encrypted backups.
    case whenUnlocked

    /// Item data can only be accessed while the device is unlocked.
    /// This is recommended for items that only need be accesible while
    /// the application is in the foreground. Items with this attribute will
    /// never migrate to a new device, so after a backup is restored to a new device,
    /// these items will be missing.
    case whenUnlockedThisDeviceOnly

    /// Item data can only be accessed while the device is unlocked. This is recommended
    /// for items that only need to be accessible while the application is in the
    /// foreground and requires a passcode to be set on the device. Items with
    /// this attribute will never migrate to a new device, so after a backup
    /// is restored to a new device, these items will be missing. This
    /// attribute will not be available on devices without a passcode. Disabling
    /// the device passcode will cause all previously protected items to
    /// be deleted.
    case whenPasscodeSetThisDeviceOnly

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.KeychainAccess, b: ArcGIS.KeychainAccess) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension KeychainAccess : Equatable {
}

extension KeychainAccess : Hashable {
}

/// Specifies how to calculate the angular position and layout direction for labels on or around point feature symbols.
///
/// The angular position may be different for each feature (driven by one or more feature attributes)
/// or constant for all features (specified by a fixed number).
/// - Since: 200.1
final public class LabelAngle : ArcGIS.JSONSerializable {

    /// How the placement angle should be interpreted.
    ///
    /// The type of rotation applied to the ``LabelAngle/angleExpression`` should be interpreted
    /// as ``arithmetic`` (counter-clockwise from East)
    /// or ``geographic`` (clockwise from North).
    public enum RotationType {

        /// The angle uses the default interpretation (``arithmetic``).
        case automatic

        /// The angle is interpreted as arithmetic i.e. counterclockwise from East.
        case arithmetic

        /// The angle is interpreted as geographic i.e. clockwise from North.
        case geographic

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelAngle.RotationType, b: ArcGIS.LabelAngle.RotationType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a ``LabelAngle`` with the specified ``ArcadeExpression`` and ``RotationType-swift.enum``.
    /// - Parameters:
    ///   - arcadeExpression: The Arcade expression script.
    ///   - rotationType: Whether the angle should be interpreted as arithmetic or geographic.
    public convenience init(arcadeExpression: ArcGIS.ArcadeExpression, rotationType: ArcGIS.LabelAngle.RotationType = .automatic)

    /// Specifies how the angle (in degrees) is calculated from the feature attributes,
    /// using an Arcade expression.
    ///
    /// The calculation may use attributes, fixed numbers, or a combination of both.
    /// The default value is an ``ArcadeExpression`` containing an empty expression string,
    /// which will produce a zero angle when evaluated.
    /// Warning: If the expression attempts to use attributes which don't exist then no label will be produced.
    /// This is distinct from the attribute existing but having a `nil` or empty value,
    /// which will be interpreted as a zero angle.
    final public var angleExpression: ArcGIS.ArcadeExpression

    /// Whether the angle should be interpreted as arithmetic or geographic.
    ///
    /// The default value is ``RotationType-swift.enum/automatic``
    /// (which will be interpreted as ``RotationType-swift.enum/arithmetic``).
    final public var rotationType: ArcGIS.LabelAngle.RotationType

    /// Clones the ``LabelAngle``.
    /// - Returns: A new ``LabelAngle`` with the same values as the current ``LabelAngle``.
    final public func clone() -> Self

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension LabelAngle.RotationType : Equatable {
}

extension LabelAngle.RotationType : Hashable {
}

/// The weight of features when considered as barriers to labeling.
///
/// An ``AnnotationLayer`` or a ``DimensionLayer``,
/// which has no ``LabelDefinition`` of its own,
/// can be added to a map's operational layers.
/// Their features will be automatically considered by the labeling process,
/// to block labels being placed overlapping the features.
/// This ``LabelBarrierWeight`` property controls how much
/// labels must avoid the layer's features.
///
/// Note: Other layer types, which have their own ``LabelDefinition``,
/// can also have their features treated as barriers,
/// but this is controlled by their
/// ``LabelDefinition/featureBoundaryOverlapStrategy`` and
/// ``LabelDefinition/featureInteriorOverlapStrategy`` properties.
/// - Since: 200.1
public enum LabelBarrierWeight {

    /// The feature will not act as an barrier to labels.
    case noWeight

    /// The feature will be avoided by labels unless that's the only way they can be placed.
    ///
    /// Labels will still overlap this feature if that is the only way they can be placed.
    case low

    /// The feature will be avoided by labels unless that's the only way they can be placed after trying some additional positions.
    ///
    /// Labels will still overlap this feature if that is the only way they can be placed.
    /// This is similar to ``LabelBarrierWeight/low``,
    /// but the labeling process can try additional intermediate alternative positions.
    /// Not all styles of labeling will have additional positions to try.
    case medium

    /// The feature is an exclusion zone for labels.
    ///
    /// Labels that overlap the feature will not be placed unless the label is
    /// using a deconfliction strategy of
    /// ``LabelDefinition/DeconflictionStrategy-swift.enum/noDeconfliction`` or
    /// ``LabelDefinition/DeconflictionStrategy-swift.enum/dynamicNeverRemove``.
    case high

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.LabelBarrierWeight, b: ArcGIS.LabelBarrierWeight) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension LabelBarrierWeight : Equatable {
}

extension LabelBarrierWeight : Hashable {
}

/// An object that defines the text, appearance, and position of labels for features within a given scale range.
///
/// A ``LabelDefinition`` describes a class of labels.
///
/// A collection of label definitions can be attached to a feature data source (example
/// ``FeatureLayer``).
/// Each ``LabelDefinition`` specifies:
/// * Which features are covered by the definition, by applying the
///   ``whereClause`` SQL constraint
/// * What text should be displayed, based on the individual feature's attributes and the
///   chosen
///   ``expression`` formula
/// * How the text should appear, using the label definition's ``TextSymbol``
/// * Where the text should appear, with respect to its feature, using the
///   ``placement``
/// * How to move or avoid other labels or features that would overlap each label
/// - Since: 200.1
final public class LabelDefinition : ArcGIS.JSONSerializable {

    /// The strategy for moving labels to avoid overlapping point symbols or higher priority labels.
    public enum DeconflictionStrategy {

        /// The label will use the default deconfliction strategy (``static``).
        ///
        /// This value corresponds to no value being specified for a ``LabelDefinition/deconflictionStrategy-swift.property`` property.
        case automatic

        /// Place the label in the preferred location, but move to an alternative location to not overlap higher priority labels or feature/graphic symbols.
        ///
        /// This label is placed only if it can be moved to a location
        /// that will not overlap a higher priority label.
        case dynamic

        /// Place the label in the preferred location, regardless of overlaps with other features, graphics or labels.
        case noDeconfliction

        /// Place the label in the preferred location, unless it would overlap a higher priority label or feature/graphic symbol.
        ///
        /// If it overlaps a lower priority label, then the lower priority label may disappear or move
        /// (depending on its ``LabelDefinition/deconflictionStrategy-swift.property``).
        /// If this label overlaps a higher priority label, then this label is not placed.
        case `static`

        /// Place the label in the preferred location, but move to an alternative location to minimize overlapping higher priority labels or feature/graphic symbols.
        ///
        /// This label is always placed, even if it overlaps a higher priority label.
        case dynamicNeverRemove

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.DeconflictionStrategy, b: ArcGIS.LabelDefinition.DeconflictionStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for whether another label is allowed to be placed over this feature or label.
    public enum LabelOverlapStrategy {

        /// The other label will use the default overlap behavior which depends on the object being overlapped.
        ///
        /// This value corresponds to no value being specified for a ``LabelDefinition`` overlap property.
        case automatic

        /// The other label will be allowed to place itself in its preferred location, ignoring this obstacle.
        case allow

        /// The other label will move to minimize overlapping this obstacle, but will overlap if necessary.
        ///
        /// The other label can only move if its ``LabelDefinition/deconflictionStrategy-swift.property`` allows.
        case avoid

        /// The other label will not be placed rather than overlap this obstacle.
        ///
        /// The other label can only move if its ``LabelDefinition/deconflictionStrategy-swift.property`` allows.
        /// If it cannot move, or if there is no free position available, then the other
        /// label will not be placed.
        case exclude

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.LabelOverlapStrategy, b: ArcGIS.LabelDefinition.LabelOverlapStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for whether line features with the same label, and matching end vertices, should be joined before sharing a label.
    public enum LineConnection {

        /// The default approach for connectable features is to connect them (``minimizeLabels``)
        ///
        /// This value corresponds to no value being specified for a ``LabelDefinition/lineConnection-swift.property`` property.
        case automatic

        /// Line geometries with the same label and coincident end vertices should be considered together as a single, continuous geometry when placing labels.
        ///
        /// For example, if a single label is being placed on a line feature,
        /// then the single location will be chosen along the combined geometries.
        /// This combining will ignore junctions, so it may be ambiguous which
        /// line feature after a junction is the continuation of the earlier geometry.
        case minimizeLabels

        /// Keep one label per line feature geometry.
        case separateLabels

        /// Line geometries with the same label and coincident end vertices should be joined, until they hit a junction.
        ///
        /// For example, if a single label is being placed on a line geometry
        /// (composed of multiple features' geometries, but all having the same label text),
        /// then a label will be placed on both sides of any junction, to make it
        /// unambiguous which geometries are the continuation of the initial geometry.
        case unambiguousLabels

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.LineConnection, b: ArcGIS.LabelDefinition.LineConnection) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Whether ``LabelDefinition/placement`` above or below a line geometry will be interpreted as above or below on the `screen`, or with respect to the `direction` of line's geometry (that is, the digitization order in which the vertices are listed).
    public enum LineOrientation {

        /// ``LabelDefinition/placement`` above will mean that the label will be offset perpendicularly **left** from its line segment.
        /// ``LabelDefinition/placement`` below will mean that the label will be offset perpendicularly **right** from its line segment.
        case direction

        /// ``LabelDefinition/placement`` above will mean that the label will be offset perpendicularly from its line segment towards the **top** of the screen.
        /// ``LabelDefinition/placement`` below will mean that the label will be offset perpendicularly from its line segment towards the **bottom** of the screen.
        case screen

        /// The label will be offset perpendicularly to whichever side of the line geometry has space (defaulting to `Above`, in the `screen` sense).
        case unconstrained

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.LineOrientation, b: ArcGIS.LabelDefinition.LineOrientation) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for the number of labels to be placed on a multi-part feature.
    public enum MultipartStrategy {

        /// Labeling will use the default distribution of labels across multi-part features.
        ///
        /// This depends on Feature type:
        /// * Polygon labels will use ``LabelDefinition/MultipartStrategy-swift.enum/labelLargest``
        /// * Point and Line labels will use ``LabelDefinition/MultipartStrategy-swift.enum/labelPerPart``
        case automatic

        /// If a feature consists of multiple parts, only the largest one will be assigned a label.
        ///
        /// If a line feature consists of multiple part geometries,
        /// or a polygon feature consists of multiple ring geometries,
        /// only the largest one will be assigned a label.
        ///
        /// If the largest part of the feature is not currently visible on the `MapView` or `SceneView`,
        /// then the label will not be visible. It will not automatically move to the
        /// largest visible part.
        case labelLargest

        /// One label per feature, but not supported yet in this API.
        ///
        /// The intended use is to place one label to represent each feature,
        /// even if the feature is made up of multiple parts.
        /// For example, a single label is placed at the center of a group of point parts,
        /// not necessarily at the position of any individual part.
        ///
        /// This value can be set when labeling is authored in ArcGIS Pro, but is not supported yet in this API.
        /// If used, the placement will be as for ``LabelDefinition/MultipartStrategy-swift.enum/labelPerPart``.
        case labelPerFeature

        /// If a feature consists of multiple geometries, each geometry will be assigned a label.
        ///
        /// If a line feature consists of multiple line geometries,
        /// or a polygon feature consists of multiple ring geometries,
        /// each geometry will be assigned a label.
        case labelPerPart

        /// One label per segment, but not supported yet in this API.
        ///
        /// The intended use is to place a label on each segment of each line geometry.
        ///
        /// This value can be set when labeling is authored in ArcGIS Pro, but is not supported yet in this API.
        /// If used, the placement with be as for ``LabelDefinition/MultipartStrategy-swift.enum/labelPerPart``.
        case labelPerSegment

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.MultipartStrategy, b: ArcGIS.LabelDefinition.MultipartStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for whether a label should be visible at viewing scales where the feature is too small for the label to fit.
    public enum OverrunStrategy {

        /// The label will use the default overrun behavior which depends on the object being overrun.
        /// This value corresponds to no value being specified for the ``LabelDefinition/overrunStrategy-swift.property`` property.
        case automatic

        /// The label cannot run past the ends of its line geometry or edges of its polygon geometry.
        case disallow

        /// The label can run past the ends of its line geometry or edges or its polygon geometry.
        case allow

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.OverrunStrategy, b: ArcGIS.LabelDefinition.OverrunStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for whether labels should be removed if they have the same text as other labels,
    /// to reduce clutter and free up space.
    public enum RemoveDuplicatesStrategy {

        /// The default approach to duplicate labels to is keep them (``noRemoval``).
        ///
        /// This value corresponds to no value being specified for a ``LabelDefinition/removeDuplicatesStrategy-swift.property`` property.
        case automatic

        /// Remove nearby duplicate labels.
        ///
        /// The distance within which to look for duplicates is controlled
        /// by ``LabelDefinition/removeDuplicatesDistance``.
        case all

        /// Remove nearby duplicate labels, if they belong to the same Feature Type.
        ///
        /// Two features are considered the same type if they are
        /// both point features, both line features or both polygon features.
        /// The distance within which to look for duplicates is controlled
        /// by ``LabelDefinition/removeDuplicatesDistance``.
        case featureType

        /// Remove nearby duplicate labels, if they below to the same Label Class.
        ///
        /// Two labels are considered the same Label Class if they are
        /// both created from the same ``LabelDefinition``.
        /// The distance within which to look for duplicates is controlled
        /// by ``LabelDefinition/removeDuplicatesDistance``.
        case labelClass

        /// No duplicates should be removed.
        ///
        /// Place all labels on the map, regardless of duplicates.
        case noRemoval

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.RemoveDuplicatesStrategy, b: ArcGIS.LabelDefinition.RemoveDuplicatesStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for whether a label should have multiple copies created and placed along or across the same feature.
    public enum RepeatStrategy {

        /// Labeling will use the default repetition for the feature type.
        ///
        /// Line feature labels will use ``LabelDefinition/RepeatStrategy-swift.enum/repeat``.
        /// Polygon feature labels will use ``LabelDefinition/RepeatStrategy-swift.enum/noRepeats``.
        /// Point feature labels will use ``LabelDefinition/RepeatStrategy-swift.enum/noRepeats``.
        case automatic

        /// Only place one label per feature.
        case noRepeats

        /// Repeat the label along or across the feature.
        ///
        /// The frequency of repetition is controlled by the ``LabelDefinition/repeatDistance`` property.
        case `repeat`

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.RepeatStrategy, b: ArcGIS.LabelDefinition.RepeatStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for how multi-row (stacked) text should be horizontally aligned.
    ///
    /// Multi-row text labels can each be horizontally aligned on the left, right or at their center.
    /// By using the ``LabelDefinition/StackAlignment-swift.enum``, the user can choose
    /// to use the ``TextSymbol/horizontalAlignment-swift.property`` property for all labels,
    /// or can choose to have the most aesthetic alignment calculated case-by-case
    /// for each label depending on its placement position around its feature.
    /// This is particularly useful for labels of dense point features, where labels may move above,
    /// below, left or right of their point symbol, in order to fit on the display.
    public enum StackAlignment {

        /// The default behavior is to use ``textSymbol``.
        ///
        /// This value corresponds to no value being specified for a ``LabelDefinition/stackAlignment-swift.property`` property.
        case automatic

        /// Set the alignment depending upon the label's position with respect to its feature.
        ///
        /// Have the alignment decided case-by-case for each label depending on
        /// its placement position around its feature.
        /// This is particularly useful for labels of dense point features, where labels may move above,
        /// below, left or right of their point symbol, in order to fit on the display.
        /// For example, a stack to the right of a point symbol will be left-aligned.
        case dynamic

        /// Follow the alignment specified by the ``TextSymbol/horizontalAlignment-swift.property``.
        case textSymbol

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.StackAlignment, b: ArcGIS.LabelDefinition.StackAlignment) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for whether a row of text should be broken before or after it exceeds the ideal length.
    ///
    /// If stacking is turned on, label placement can insert a line break before or after
    /// the word that overruns the maximum number of characters per row.
    public enum StackBreakPosition {

        /// Use the default break position (``after``).
        case automatic

        /// Insert the line break after a word that has broken the stackRowLength limit.
        ///
        /// This means rows will generally be longer than the ``LabelDefinition/stackRowLength``.
        case after

        /// Insert the line break before a word that will break the stackRowLength limit.
        ///
        /// This means rows will generally be shorter than the ``LabelDefinition/stackRowLength``
        /// (although they will overrun for individual words larger than this count).
        case before

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.StackBreakPosition, b: ArcGIS.LabelDefinition.StackBreakPosition) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The strategy for whether the text should be stacked or wrapped, rather than place long trailing labels across the map.
    public enum StackStrategy {

        /// Stacking will be enabled for some feature types.
        ///
        /// The default stacking behavior for labels will depend on their feature type:
        /// * Point feature labels may stack
        /// * Line feature labels will not stack
        /// * Polygon feature labels may stack
        case automatic

        /// The text should not be broken, no matter how long it is.
        case disallow

        /// The label placement engine can break the text into two or more rows,
        /// if the rows are longer than the ``LabelDefinition/stackRowLength`` limit.
        case allow

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.StackStrategy, b: ArcGIS.LabelDefinition.StackStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The layout to use for label text, which can be either horizontal, straight, perpendicular, or follow the line
    /// feature.
    public enum TextLayout {

        /// The text layout will be determined by the individual feature type.
        ///
        /// For each label, the layout will be determined by the feature geometry type:
        /// * Point feature labels will use ``LabelDefinition/TextLayout-swift.enum/horizontal``
        /// * Line feature labels will use ``LabelDefinition/TextLayout-swift.enum/followFeature``
        /// * Polygon feature labels will use ``LabelDefinition/TextLayout-swift.enum/horizontal``
        case automatic

        /// Text will be written horizontally (with respect to the screen).
        ///
        /// If the map is rotated within the screen,
        /// then the text will be redrawn (and possibly repositioned)
        /// to remain horizontal with respect to the screen.
        case horizontal

        /// Text will be written perpendicular to the ``straight`` text layout.
        case perpendicular

        /// Text will be written along a straight line, following the point positioning angle or at a tangent to the line feature.
        ///
        /// An angle for placement and orientation will be calculated for each label
        /// if the "labelAngleInfo" json property for the ``LabelDefinition`` has been specified.
        ///
        /// Centered point labels will stay centered on the point feature,
        /// but will be rotated to the angle
        /// (or horizontal, if none has been defined).
        ///
        /// Offset point labels will be positioned around the point feature,
        /// at the position specified by the angle.
        /// The text will lie along this angle, so that it stretches radially
        /// from the edge of the point feature.
        ///
        /// Note that if a label has an angle of zero
        /// then its text will be drawn horizontally with respect to the map.
        /// If the map is rotated within the screen, the text will rotate with the map.
        ///
        /// Line labels will be positioned as usual, but then rotated (around their midpoint)
        /// to lie on a straight line at a tangent to the line geometry at that point.
        case straight

        /// Text will bend to follow a curved or multi-segment line feature.
        ///
        /// Individual characters will be angled to follow the changes in angle of the
        /// line geometry.
        ///
        /// If the text overruns the beginning or end of the line geometry,
        /// then the remaining characters will be laid out in a straight line
        /// extrapolated from the last geometry segment.
        case followFeature

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.TextLayout, b: ArcGIS.LabelDefinition.TextLayout) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The orientation of label text.
    public enum TextOrientation {

        /// Use the default text orientation (``screen``).
        case automatic

        /// Text follows the placement angle direction, even if it means being drawn upside-down.
        case direction

        /// Text follows the screen orientation, and flips if necessary.
        ///
        /// Text should be flipped through 180 degrees to keep it readable on the screen.
        /// The text will flip whenever the feature determines that the text is angled upside-down,
        /// or if the map is rotated within the screen to make the text upside-down
        /// (with respect to the screen).
        case screen

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelDefinition.TextOrientation, b: ArcGIS.LabelDefinition.TextOrientation) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a ``LabelDefinition`` with the specified ``LabelExpression`` and ``TextSymbol``.
    /// - Parameters:
    ///   - labelExpression: The expression script used to calculate the label text.
    ///   - textSymbol: The text symbol which describes the overall appearance of label text (e.g. font and size).
    public convenience init(labelExpression: ArcGIS.LabelExpression, textSymbol: ArcGIS.TextSymbol?)

    /// The angular positions and layout directions for labels on or around point feature symbols.
    ///
    /// This optional object specifies how to position a label following the direction of an angle.
    /// The angular position may be different for each feature (driven by one or more feature attributes)
    /// or constant for all features (specified by a fixed number).
    ///
    /// The ``placement`` will still be used to indicate
    /// whether offset or centered positioning is required,
    /// but the exact position will be overridden by the angle calculated for the feature.
    /// Once the position has been determined, ``textLayout-swift.property`` and
    /// ``textOrientation-swift.property`` are used to specify the layout of the text at that position.
    /// Warning: If the expression attempts to use attributes which don't exist then no label will be produced.
    /// This is distinct from the attribute existing but having a `nil` or empty value,
    /// which will be interpreted as a zero angle.
    final public var angle: ArcGIS.LabelAngle?

    /// The strategy for moving labels to avoid overlapping feature, annotation, dimension or graphic symbols or higher priority labels. In 3D ``DeconflictionStrategy-swift.enum/static`` is selected by default.
    ///
    /// The default is ``DeconflictionStrategy-swift.enum/automatic``
    /// (which will be interpreted as ``DeconflictionStrategy-swift.enum/static`` i.e.
    /// use preferred location unless it would overlap an obstacle).
    final public var deconflictionStrategy: ArcGIS.LabelDefinition.DeconflictionStrategy

    /// The expression script used to calculate the label text.
    ///
    /// The expression may be a combination of literal text and attribute values
    /// from the feature being labeled.
    /// The syntax of the expression is determined by which label expression object is used:
    /// ``ArcadeLabelExpression``, ``SimpleLabelExpression`` or ``WebmapLabelExpression``.
    ///
    /// A label expression using one scripting language can be replaced by an expression
    /// using a different scripting language just by creating an object of the new
    /// ``LabelExpression`` subclass and assigning it to ``expression``.
    ///
    /// The default value is an empty ``ArcadeLabelExpression``,
    /// which will evaluate to an empty text label.
    ///
    /// The expression needs to create a text string which will be used as the label text.
    /// The text string can be any legal UTF16 characters.
    ///
    /// The text string can also include HTML-style formatting tags e.g.
    ///
    /// "Hello <BOL>World</BOL>"
    ///
    /// where the angle-bracketed tags will not appear in the label,
    /// but may change the presentation of the text.
    /// In the example, the "World" will appear in bold.
    ///
    /// The available tags are:
    /// - "<BOL></BOL>" for bold text
    /// - "<UND></UND>" for underlined text
    /// - "<ITA></ITA>" for italic text
    /// - "<CLR red='256'></CLR>" for colored text
    /// - "<FNT name='Arial' size='18'></FNT>" for text using a different size or font (if available on client).
    ///
    /// Tags can be upper or lower case, but not a mixture.
    /// Tags can be nested e.g. "<ITA>Hello <BOL>World</BOL></ITA>".
    ///
    /// Full documentation of the tag parameters is available at
    /// https://pro.arcgis.com/en/pro-app/latest/help/mapping/text/text-formatting-tags.htm.
    ///
    /// Note that not all ArcGISPro tags are currently supported in this API.
    /// The "<CLR>" tag is currently only supported for text in 2D views.
    /// Any unsupported tags will be ignored and not written as part of the label text.
    /// Warning: If the expression attempts to use attributes which don't exist then no label will be produced.
    /// This is distinct from the attribute existing but having a `nil` or empty value,
    /// which can form part of the produced text label.
    final public var expression: ArcGIS.LabelExpression

    /// The strategy for whether other labels are allowed to overlap the boundary of polygon features/graphics being labeled by this ``LabelDefinition``. In 3D scenes, labels will be allowed to overlap the boundaries of polygon features.
    ///
    /// The default is ``LabelOverlapStrategy-swift.enum/automatic``, which will give the same behavior as
    /// ``LabelOverlapStrategy-swift.enum/allow``.
    final public var featureBoundaryOverlapStrategy: ArcGIS.LabelDefinition.LabelOverlapStrategy

    /// The strategy for whether other labels are allowed to overlap the interior of polygon features/graphics being labeled by this ``LabelDefinition``. In 3D scenes, labels will be allowed to overlap the interiors of polygon features.
    ///
    /// The default is ``LabelOverlapStrategy-swift.enum/automatic`` which
    /// will give the same behavior as ``LabelOverlapStrategy-swift.enum/allow``.
    final public var featureInteriorOverlapStrategy: ArcGIS.LabelDefinition.LabelOverlapStrategy

    /// The strategy for whether other labels are allowed to overlap labels created by this ``LabelDefinition``. In 3D, labels will not be allowed to overlap other labels. Overlapping labels will not be displayed until the user zooms in further so that the labels don't overlap.
    ///
    /// The default is ``LabelOverlapStrategy-swift.enum/automatic`` which
    /// will give the same behavior as ``LabelOverlapStrategy-swift.enum/exclude``.
    final public var labelOverlapStrategy: ArcGIS.LabelDefinition.LabelOverlapStrategy

    /// The strategy for whether line features with the same label, and matching end vertices, should be joined before sharing a label. 3D line features will be treated as independent features with their own label.
    ///
    /// The default is ``LineConnection-swift.enum/automatic``,
    /// which will be interpreted as ``LineConnection-swift.enum/minimizeLabels``.
    final public var lineConnection: ArcGIS.LabelDefinition.LineConnection

    /// The strategy for whether ``placement`` above or below a line geometry will be interpreted as above or below on the `screen`, or with respect to the `direction` of line's geometry (that is, the digitization order in which the vertices are listed).
    ///
    /// If the ``lineOrientation-swift.property`` is set to ``LineOrientation-swift.enum/screen`` then ``placement`` above means the label will be offset perpendicularly from its line segment towards the **top** of the screen.
    /// If the ``lineOrientation-swift.property`` is set to ``LineOrientation-swift.enum/direction`` then ``placement`` above means the label will be offset perpendicularly **left** from its line segment.
    /// If the ``lineOrientation-swift.property`` is set to ``LineOrientation-swift.enum/unconstrained`` then the label will be offset perpendicularly to whichever side of the line geometry has space (defaulting to above in the `screen` sense).
    /// ``placement`` below would have the corresponding interpretations.
    /// The default is ``LineOrientation-swift.enum/screen``.
    final public var lineOrientation: ArcGIS.LabelDefinition.LineOrientation

    /// The maximum scale at which labels will be visible. In 3D scenes,the scale range is between individual label and view plane instead of map and view plane. If `nil`, there is no maximum.
    ///
    /// Labels will only be visible when the viewing scale is smaller than (or equal to) the maxScale.
    ///
    /// For example, if the viewing scale is 1:12000 and the ``maxScale`` is 1:10000,
    /// then the labels will be visible (because 1/12000 <= 1/10000).
    /// A ``maxScale`` of 0, which is the default, indicates no upper limit on the viewing scale.
    final public var maxScale: Double?

    /// The minimum scale at which labels will be visible. In 3D scenes, the scale range is between individual label and view plane instead of map and view plane. If `nil`, there is no minimum.
    ///
    /// Labels will only be visible when the viewing scale is larger than (or equal to) the minScale.
    ///
    /// For example, if the viewing scale is 1:12000 and the ``minScale`` is 1:20000,
    /// then the labels will be visible (because 1/12000 >= 1/20000).
    /// A ``minScale`` of 0, which is the default, indicates no lower limit on the viewing scale.
    final public var minScale: Double?

    /// The strategy for how many labels should be placed on each polyline or polygon (multi-ring) feature.
    ///
    /// The default is ``MultipartStrategy-swift.enum/automatic``.
    final public var multipartStrategy: ArcGIS.LabelDefinition.MultipartStrategy

    /// Text name for the class of labels.
    ///
    /// This name is assigned by the map author to clarify the purpose of this label definition.
    /// It is used for display or debugging purposes.
    /// If no name is explicitly assigned, then an empty text string is stored.
    final public var name: String

    /// The distance (in points i.e. 1/72 inches) that text should be moved away from its features.
    ///
    /// The distance is measured from the point symbol radius or line feature symbology edge.
    /// The distance is measured on the screen (i.e. not in the map) in points, comparable to the text font size.
    ///
    /// This can be a negative value, to pull the label closer to the feature if, for example,
    /// the average size for a point symbol is overly conservative for the actual graphic shown.
    ///
    /// If no value is set, then 1 point is assumed.
    final public var offsetDistance: Double

    /// The strategy for whether a label will be visible at scales where the feature is too small for the label to fit. Not supported by 3D scenes.
    ///
    /// The default is ``OverrunStrategy-swift.enum/automatic`` which
    /// will give different behavior depending on the type of feature that the label might overrun.
    final public var overrunStrategy: ArcGIS.LabelDefinition.OverrunStrategy

    /// The preferred position of the text label, with respect to its feature geometry.
    ///
    /// The default is ``LabelingInfo/LabelPlacement-swift.enum/automatic``. The effect of this is the same as one
    /// of the following, depending on the type of feature geometry:
    /// * ``LabelingInfo/LabelPlacement-swift.enum/pointAboveRight`` for point features
    /// * ``LabelingInfo/LabelPlacement-swift.enum/polygonAlwaysHorizontal`` for polygon features
    /// * ``LabelingInfo/LabelPlacement-swift.enum/lineAboveAlong`` for line features
    final public var placement: ArcGIS.LabelingInfo.LabelPlacement?

    /// Defines which labels are placed first, and can also supplant existing lower-priority labels (e.g. during panning).
    ///
    /// Lower values indicate more important labels i.e.:
    /// * 0 is the most important
    /// * 5 is high priority
    /// * 15 is medium priority
    /// * Higher values indicate lower priority
    ///
    /// If set to -1 or not set at all, then default values are used, depending on the geometry
    /// types of the features:
    /// * 12 for point features
    /// * 15 for line features
    /// * 18 for polygon features
    ///
    /// This value does not have to be an integer because
    /// it is just a continuum of values for comparison.
    /// Users can use this to specify that a class of labels should have priority
    /// between two other classes with close priorities.
    ///
    /// For example, PreferredRoutes might be given priority 13 to appear
    /// ahead of general line feature labels, but after general point feature labels.
    /// And HistoricSites might be given priority 12.5 to appear
    /// ahead of PreferredRoute labels, but still after general point feature labels.
    final public var priority: Double

    /// A value that controls the duplicate thinning radius (in points i.e. 1/72 inches).
    ///
    /// The distance is measured on the screen (i.e. not in the map) in points, comparable to the text font size.
    /// This value is only used if ``removeDuplicatesStrategy-swift.property`` is enabled.
    /// The default value is 0. This indicates that duplicates should be removed from the entire extent.
    final public var removeDuplicatesDistance: Double

    /// The strategy for whether labels are removed if other features have the same text label. This can reduce clutter and free up space.
    ///
    /// The default is ``RemoveDuplicatesStrategy-swift.enum/automatic``,
    /// which will be interpreted as ``RemoveDuplicatesStrategy-swift.enum/noRemoval`` indicating that all
    /// labels should be shown if possible.
    ///
    /// The distance within which to look for duplicates is controlled
    /// by ``removeDuplicatesDistance``.
    final public var removeDuplicatesStrategy: ArcGIS.LabelDefinition.RemoveDuplicatesStrategy

    /// The distance apart (in points i.e. 1/72 inches) that the repetitions should be. In 3D scenes, only one label will be placed per line feature.
    ///
    /// This value is only used if ``repeatStrategy-swift.property`` is enabled.
    /// The distance is measured on the screen along the line feature. As the user zooms in closer,
    /// two repetitions move further apart on the screen, until there is room for a new repetition between them.
    /// The default is 216 points i.e. line labels should be repeated
    /// approximately every 3 inches along long features.
    ///
    /// The distance is considered a guide for the approximate label separation and
    /// should not be used for precise distance markings.
    ///
    /// A distance of 0 disables label repetition.
    final public var repeatDistance: Double

    /// The strategy for whether a label should have multiple copies created and placed along or across the same feature. In 3D scenes, only label will be placed per line feature.
    ///
    /// The default is ``RepeatStrategy-swift.enum/automatic``.
    ///
    /// The frequency of repetition is controlled by the ``repeatDistance`` property.
    ///
    /// This property is currently only supported for line features, but will be extended to polygons in the future.
    final public var repeatStrategy: ArcGIS.LabelDefinition.RepeatStrategy

    /// The strategy for how multi-row (stacked) text should be aligned.
    ///
    /// Multi-row text labels can be horizontally aligned on the left, right or at its center.
    /// This preference can be specified by the ``TextSymbol`` assigned to the ``LabelDefinition``.
    /// By using the ``stackAlignment-swift.property`` property, the user can choose
    /// to use the ``TextSymbol/horizontalAlignment-swift.property`` property for all labels,
    /// or can choose to have the most aesthetic alignment calculated case-by-case
    /// for each label depending on its placement position around its feature.
    /// This is particularly useful for labels of dense point features, where labels may move above,
    /// below, left or right of their point symbol, in order to fit on the display.
    ///
    /// The default value is ``StackAlignment-swift.enum/automatic``
    /// (which will have the same effect on labels as ``StackAlignment-swift.enum/textSymbol``).
    ///
    /// This property has no effect if ``stackStrategy-swift.property`` = ``StackStrategy-swift.enum/disallow``.
    final public var stackAlignment: ArcGIS.LabelDefinition.StackAlignment

    /// The strategy for whether a row of text should be broken before or after it exceeds the ideal length.
    ///
    /// If stacking is turned on, label placement can insert a line break before or after
    /// the word that overruns the maximum number of characters per row.
    /// Using the ``StackBreakPosition-swift.enum/before`` option means rows
    /// will generally be shorter than the ``stackRowLength``
    /// (although will overrun for individual words larger than this count).
    ///
    /// The default is ``StackBreakPosition-swift.enum/automatic``
    /// (which will have the same effect on labels as ``StackBreakPosition-swift.enum/after``).
    ///
    /// This property has no effect if ``stackStrategy-swift.property`` = ``StackStrategy-swift.enum/disallow``.
    final public var stackBreakPosition: ArcGIS.LabelDefinition.StackBreakPosition

    /// A value that limits the number of characters in a row of stacked text.
    ///
    /// This length guides the decision on when to break long text strings into separate rows.
    /// The line break will be inserted between words, not in the middle of a word,
    /// so rows may be longer or shorter than the ideal.
    /// Depending on ``stackBreakPosition-swift.property``,
    /// the break may be inserted before the breaking word, or after.
    ///
    /// The default value is -1. This means that a default length of 13 characters is currently used.
    ///
    /// This property has no effect if ``stackStrategy-swift.property`` = ``StackStrategy-swift.enum/disallow``.
    final public var stackRowLength: Double

    /// The stack separators that should be used for automatic line breaking of label text.
    ///
    /// Each ``LabelStackSeparator`` specifies a code point to be looked for in the text.
    /// A code point is often thought of as a single character in the text, but may need
    /// several chars in a `String` to describe it. So each ``LabelStackSeparator/separator``
    /// is a `String` intended to describe one code point.
    ///
    /// For example:
    /// * To use a comma as a separator, the ``LabelStackSeparator/separator`` string would be
    ///   just ","
    /// * To use a Hebrew punctuation Paseq as a separator, the
    ///   ``LabelStackSeparator/separator`` would need to encode the code point with utf16
    ///   value "\u05c0" if your SDK uses utf16 strings (e.g. Java, C#) or with the utf8 string
    ///   "\x30\x35\x63\x30" if your SDK uses utf8 strings
    /// * To use higher range unicode code points such as Aegean Word Separator Dot which has
    ///   utf32 hex value 10101, the ``LabelStackSeparator/separator`` would need to encode the
    ///   code point with utf16 value "\ud800\udd01" if your SDK uses utf16 strings (e.g. Java,
    ///   C#) or with the utf8 string "\xf0\x90\x84\x81" if your SDK uses utf8 strings
    ///
    /// If it is found, then the ``LabelStackSeparator`` also specifies whether:
    /// * The text should always be broken here
    /// * Whether the separator code point should remain visible
    /// * Whether the separator code point should appear at the end of one row, or the
    ///   beginning of the next
    ///
    /// Three default separators are provided: a comma, a space, and a hyphen. Custom
    /// separators can be added, and default separators can be removed if not required.
    ///
    /// Note that a carriage-return (\n) in the label will always be considered a forced
    /// separator.
    ///
    /// This property has no effect if ``stackStrategy-swift.property`` = ``StackStrategy-swift.enum/disallow``.
    final public var stackSeparators: [ArcGIS.LabelStackSeparator] { get }

    /// Adds a sequence of `LabelStackSeparator` values to the end of the `stackSeparators` property.
    /// - Parameter newStackSeparators: The new `LabelStackSeparator` values to append.
    final public func addStackSeparators<S>(_ newStackSeparators: S) where S : Sequence, S.Element == ArcGIS.LabelStackSeparator

    /// Adds a `LabelStackSeparator` value to the end of the `stackSeparators` property.
    /// - Parameter newStackSeparator: The new `LabelStackSeparator` value to append.
    final public func addStackSeparator(_ newStackSeparator: ArcGIS.LabelStackSeparator)

    /// Inserts a collection of `LabelStackSeparator` values into the `stackSeparators` property at the specified position.
    /// - Parameters:
    ///   - newStackSeparators: The new `LabelStackSeparator` values to insert.
    ///   - index: The position at which to insert the new `LabelStackSeparator` values.
    final public func insertStackSeparators<C>(_ newStackSeparators: C, at index: Int) where C : Collection, C.Element == ArcGIS.LabelStackSeparator

    /// Inserts a `LabelStackSeparator` value into the `stackSeparators` property at the specified position.
    /// - Parameters:
    ///   - newStackSeparator: The new `LabelStackSeparator` value to insert.
    ///   - index: The position at which to insert the new `LabelStackSeparator` value.
    final public func insertStackSeparator(_ newStackSeparator: ArcGIS.LabelStackSeparator, at index: Int)

    /// Removes all values from the `stackSeparators` property.
    final public func removeAllStackSeparators()

    /// Removes a sequence of `LabelStackSeparator` values from the `stackSeparators` property.
    /// - Parameter stackSeparators: The `LabelStackSeparator` values to remove.
    final public func removeStackSeparators<S>(_ stackSeparators: S) where S : Sequence, S.Element == ArcGIS.LabelStackSeparator

    /// Removes a `LabelStackSeparator` value from the `stackSeparators` property.
    /// - Parameter stackSeparator: The `LabelStackSeparator` value to remove.
    final public func removeStackSeparator(_ stackSeparator: ArcGIS.LabelStackSeparator)

    /// The strategy for whether the text should be stacked or wrapped, rather than placed as long trailing labels across the map.
    ///
    /// This property controls whether stacking is allowed, or not,
    /// or should be calculated automatically based on feature type.
    /// The default is ``StackStrategy-swift.enum/automatic``, meaning that
    /// stacking will be enabled for point and polygon features and disabled for line features.
    final public var stackStrategy: ArcGIS.LabelDefinition.StackStrategy

    /// The layout of the text, which can be either horizontal, straight, perpendicular,
    /// or follow the line feature.
    ///
    /// Optional specification of whether, once the text is positioned,
    /// it should be written:
    /// * Horizontally
    /// * Straight (i.e. parallel) to the tangent to the line feature
    /// * Straight in line with the point feature positioning angle
    /// * Perpendicular to the tangent or positioning angle
    /// * following the geometry of the line feature
    ///
    /// The default is ``TextLayout-swift.enum/automatic``, which will be interpreted as:
    /// * ``TextLayout-swift.enum/horizontal`` for labels attached to point features
    /// * ``TextLayout-swift.enum/followFeature`` for labels attached to line features
    /// * ``TextLayout-swift.enum/horizontal`` for labels attached to polygon features
    final public var textLayout: ArcGIS.LabelDefinition.TextLayout

    /// The orientation of the text, which can be either angle direction or screen-oriented. Not supported by 3D scenes.
    ///
    /// Optional specification of whether text should follow the placement angle direction
    /// even if it means being rendered upside-down,
    /// or whether text should be flipped through 180 degrees to keep it screen-oriented.
    /// This setting will take effect whenever the feature geometry determines that the text is angled upside-down,
    /// or if the map is rotated within the screen to make the text upside-down
    /// (with respect to the screen).
    /// The default is ``TextOrientation-swift.enum/automatic``,
    /// which is interpreted as ``TextOrientation-swift.enum/screen``.
    final public var textOrientation: ArcGIS.LabelDefinition.TextOrientation

    /// The text symbol which describes the overall appearance of label text (e.g. font and size).
    ///
    /// If no ``textSymbol`` has been set, then no labels can be created.
    final public var textSymbol: ArcGIS.TextSymbol?

    /// Specifies whether the data source should translate domain identifiers into meanings using a ``CodedValueDomain``.
    ///
    /// For any translation to occur, the data source must have one or more ``CodedValueDomain`` s set up
    /// for the attribute fields.
    /// The default value is `true` i.e. translation will be done.
    ///
    /// This property only affects Simple label expressions.
    /// Arcade expressions can use functions to specify when code translations should be carried out.
    /// Coded value translation for Webmap expressions is not currently supported.
    final public var usesCodedValues: Bool

    /// A SQL where clause expression that limits the set of features for which labels will be generated and placed.
    ///
    /// This is a SQL where clause that can refer to the attributes of the feature. For
    /// example:
    /// * "" (no limitations)
    /// * "NAME LIKE 'A%'" (Only label features with NAME attribute values starting with 'A')
    /// * "(LENGTH > CAPACITY) and (TYPE = 1)" (Only label features whose attributes satisfy
    ///   the SQL condition)
    ///
    /// The default value is "" which will allow all features in the data source and extent to
    /// be labeled.
    final public var whereClause: String

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension LabelDefinition.DeconflictionStrategy : Equatable {
}

extension LabelDefinition.DeconflictionStrategy : Hashable {
}

extension LabelDefinition.LabelOverlapStrategy : Equatable {
}

extension LabelDefinition.LabelOverlapStrategy : Hashable {
}

extension LabelDefinition.LineConnection : Equatable {
}

extension LabelDefinition.LineConnection : Hashable {
}

extension LabelDefinition.LineOrientation : Equatable {
}

extension LabelDefinition.LineOrientation : Hashable {
}

extension LabelDefinition.MultipartStrategy : Equatable {
}

extension LabelDefinition.MultipartStrategy : Hashable {
}

extension LabelDefinition.OverrunStrategy : Equatable {
}

extension LabelDefinition.OverrunStrategy : Hashable {
}

extension LabelDefinition.RemoveDuplicatesStrategy : Equatable {
}

extension LabelDefinition.RemoveDuplicatesStrategy : Hashable {
}

extension LabelDefinition.RepeatStrategy : Equatable {
}

extension LabelDefinition.RepeatStrategy : Hashable {
}

extension LabelDefinition.StackAlignment : Equatable {
}

extension LabelDefinition.StackAlignment : Hashable {
}

extension LabelDefinition.StackBreakPosition : Equatable {
}

extension LabelDefinition.StackBreakPosition : Hashable {
}

extension LabelDefinition.StackStrategy : Equatable {
}

extension LabelDefinition.StackStrategy : Hashable {
}

extension LabelDefinition.TextLayout : Equatable {
}

extension LabelDefinition.TextLayout : Hashable {
}

extension LabelDefinition.TextOrientation : Equatable {
}

extension LabelDefinition.TextOrientation : Hashable {
}

/// Abstract base class for the different types of expressions that can be used to create label text.
///
/// Users can read the expression script using the ``expression`` property.
/// To specify an expression script, users create an object of type
/// ``ArcadeLabelExpression``, ``SimpleLabelExpression`` or ``WebmapLabelExpression``
/// with the required expression script and assign it to the label expression object.
/// - Since: 200.1
public class LabelExpression {

    /// The label expression script string.
    ///
    /// The expression is expected to be a complete, self-contained label expression
    /// in the language specified by the label expression subclass object.
    /// Warning: If the expression attempts to use attributes which don't exist then no label will be produced.
    /// This is distinct from the attribute existing but having a `nil` or empty value,
    /// which can form part of the produced text label.
    public var expression: String

    /// Clones the ``LabelExpression``.
    /// - Returns: A new ``LabelExpression`` with the same values as the current ``LabelExpression``.
    public func clone() -> Self
}

/// A separator character in a label, where a line break may be inserted in long text.
///
/// A single separator consists of:
/// * The separator character that should potentially be replaced by a line break
/// * If the separator should always be used for line break
/// * If the separator should remain visible
/// * If the separator should appear at the end of one row, or the beginning of the next
/// - Since: 200.1
final public class LabelStackSeparator : ArcGIS.JSONSerializable {

    /// The position where the separator character in a label will be written, if used.
    ///
    /// Whether the separator code point should appear at the end of one row, or the beginning of the next.
    /// This does not matter if the separator is not to be visible when used.
    public enum BreakPosition {

        /// Use the default position (``after``).
        case automatic

        /// Write the separator after the line break, at the start of the next row of text.
        case after

        /// Write the separator before the line break, at the end of the previous row of text.
        case before

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelStackSeparator.BreakPosition, b: ArcGIS.LabelStackSeparator.BreakPosition) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a label stack separator with default values.
    ///
    /// The default separator has an empty ``separator``
    /// and will be ignored.
    public convenience init()

    /// The position where the separator will be written, if used and remaining visible.
    ///
    /// Whether the separator code point should appear at the end of one row, or the beginning
    /// of the next, if chosen as a line break position. This does not matter if the separator
    /// is not to be visible when used.
    ///
    /// The default value is ``BreakPosition-swift.enum/automatic`` which will give the
    /// same behavior as ``BreakPosition-swift.enum/after``.
    final public var breakPosition: ArcGIS.LabelStackSeparator.BreakPosition

    /// Whether a line break must be inserted when the ``separator`` is encountered.
    ///
    /// The default value is `false`.
    final public var isForced: Bool

    /// Whether the separator should still be visible, if chosen as a line break position.
    ///
    /// For example, a user may wish to keep a hyphenation mark at the end of a row of text,
    /// but hide a comma.
    ///
    /// The default value is `false`.
    final public var isVisible: Bool

    /// A `String` intended to describe one code point.
    ///
    /// Each ``LabelStackSeparator`` specifies a code point to be looked for in the text.
    /// A code point is often thought of as a single character in the text, but may need several
    /// chars in a `String` to describe it.
    /// For example:
    /// * To use a comma as a separator, the ``separator`` string would be
    ///   just ","
    /// * To use a Hebrew punctuation Paseq as a separator, the
    ///   ``separator`` would need to encode the code point with utf16
    ///   value "\u05c0" if your SDK uses utf16 strings (e.g., Java, C#)
    ///   or with the utf8 string "\x30\x35\x63\x30" if your SDK uses utf8 strings
    /// * To use higher range unicode code points such as Aegean Word Separator Dot which has
    ///   utf32 hex value 10101, the ``separator`` would need to encode
    ///   the code point with utf16 value "\ud800\udd01" if your SDK uses utf16 strings (e.g.,
    ///   Java, C#) or with the utf8 string "\xf0\x90\x84\x81" if your SDK uses utf8 strings
    ///
    /// The default value is an empty string, meaning that the ``LabelStackSeparator`` will be
    /// ignored.
    final public var separator: String

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension LabelStackSeparator.BreakPosition : Equatable {
}

extension LabelStackSeparator.BreakPosition : Hashable {
}

/// An object that defines the text, appearance and position of labels for features for a given scale range.
///
/// A ``LabelingInfo`` describes a class of labels.
///
/// Each ``LabelingInfo`` specifies:
/// * Which features are covered by the definition, by applying the ``whereClause`` SQL
///   constraint
/// * What text should be displayed, based on the individual feature's attributes and the
///   ``labelExpression`` formula
/// * How the text should appear, using the ``symbol``
/// * Where the text should appear, with respect to its feature, using the
///   ``labelPlacement-swift.property``
///
/// ``LabelingInfo`` describes a very limited subset of the ``LabelDefinition`` properties.
/// - Since: 200.1
final public class LabelingInfo {

    /// An enumeration of labeling placement options.
    ///
    /// This is used to specify the preferred position of the text label, with respect to its feature geometry.
    public enum LabelPlacement {

        /// Default position for the label, dependent on the type of feature being labeled.
        case automatic

        /// Lower-left corner of label is at final geometry coord; label extrapolates the last geometry segment.
        case lineAboveAfter

        /// Lower midpoint of label prefers the midpoint of the geometry; label follows the geometry segments.
        case lineAboveAlong

        /// Lower right corner of label is at first geometry coord; label extrapolates the first geometry segment.
        case lineAboveBefore

        /// Lower right corner of label is at final geometry coord; label follows the last geometry segments.
        case lineAboveEnd

        /// Lower left corner of label is at first geometry coord, label follows the first geometry segments.
        case lineAboveStart

        /// Upper left corner of label is at final geometry coord, label extrapolates the last geometry segment.
        case lineBelowAfter

        /// Upper midpoint of label prefers the midpoint of the geometry, label follows the geometry segments.
        case lineBelowAlong

        /// Upper right corner of label is at first geometry coord, label extrapolates the first geometry segment.
        case lineBelowBefore

        /// Upper right corner of label is at final geometry coord, label follows the last geometry segments.
        case lineBelowEnd

        /// Upper left corner of label is at first geometry coord, label follows the first geometry segments.
        case lineBelowStart

        /// Left midpoint of label is at final geometry coord, label extrapolates the last geometry segment.
        case lineCenterAfter

        /// Center of label prefers the midpoint of the geometry, label follows the geometry segments.
        case lineCenterAlong

        /// Right midpoint of label is at first geometry coord, label extrapolates the first geometry segment.
        case lineCenterBefore

        /// Right midpoint of label is at final geometry coord, label follows the last geometry segments.
        case lineCenterEnd

        /// Left midpoint of label is at first geometry coord, label follows the first geometry segments.
        case lineCenterStart

        /// Lower midpoint of label is offset north of point symbol.
        case pointAboveCenter

        /// Lower-right corner of the label is offset northwest of point symbol.
        case pointAboveLeft

        /// Lower left corner of the label is offset North-east of point symbol.
        case pointAboveRight

        /// Upper midpoint of label is offset South of point symbol.
        case pointBelowCenter

        /// Upper right corner of the label is offset South-west of point symbol.
        case pointBelowLeft

        /// Upper left corner of the label is offset South-east of point symbol.
        case pointBelowRight

        /// Center of label is placed on geometry point.
        case pointCenterCenter

        /// Right midpoint of label is offset West of point symbol.
        case pointCenterLeft

        /// Left midpoint of label is offset East of point symbol.
        case pointCenterRight

        /// Center of label is as far inside polygon as possible.
        case polygonAlwaysHorizontal

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LabelingInfo.LabelPlacement, b: ArcGIS.LabelingInfo.LabelPlacement) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Simple expression describing how to build the text label for a feature, often using attributes of the feature.
    ///
    /// The default is an empty expression and no labels will be produced.
    ///
    /// The Simple expression format is described at
    /// https://developers.arcgis.com/documentation/common-data-types/labeling-objects.htm
    /// e.g., "\"Addr: \" CONCAT [Name] CONCAT \" Street\"" (the outer quotes are not part of
    /// the expression, but quotes are needed around the literal text).
    final public var labelExpression: String { get }

    /// The preferred position of the text label, with respect to its feature geometry.
    ///
    /// The default depends on the type of feature geometry:
    /// * ``LabelPlacement-swift.enum/pointAboveRight`` for point features
    /// * ``LabelPlacement-swift.enum/polygonAlwaysHorizontal`` for polygon features
    /// * ``LabelPlacement-swift.enum/lineAboveAlong`` for line features
    final public var labelPlacement: ArcGIS.LabelingInfo.LabelPlacement? { get }

    /// Labels will only be visible when the viewing scale is smaller than (or equal to) the maxScale. If `nil`, there is no maximum.
    ///
    /// For example, if the viewing scale is 1:12000 and the ``maxScale`` is
    /// 1:10000, then the labels will be visible (because 1/12000 <= 1/10000).
    ///
    /// A ``maxScale`` of 0, which is the default, indicates no upper limit on the
    /// viewing scale.
    final public var maxScale: Double? { get }

    /// Labels will only be visible when the viewing scale is larger than (or equal to) the minScale. If `nil`, there is no minimum.
    ///
    /// For example, if the viewing scale is 1:12000 and the ``minScale`` is
    /// 1:20000, then the labels will be visible (because 1/12000 >= 1/20000).
    ///
    /// A ``minScale`` of 0, which is the default, indicates no lower limit on the
    /// viewing scale.
    final public var minScale: Double? { get }

    /// The text symbol which describes the overall appearance of label text (e.g. font and size).
    ///
    /// If no ``symbol`` has been set, then no labels can be created.
    final public var symbol: ArcGIS.TextSymbol? { get }

    /// Whether the data source should translate domain identifiers into meanings using a ``CodedValueDomain``.
    ///
    /// For any translation to occur, the data source must have one or more
    /// ``CodedValueDomain`` values set up for the attribute fields.
    ///
    /// The default value is `false` i.e. no translation will be done.
    final public var usesCodedValues: Bool { get }

    /// Limit the set of features for which labels will be generated and placed.
    ///
    /// This is a SQL expression that can refer to the attributes of the feature e.g.:
    /// * "" (no limitations)
    /// * "NAME LIKE 'A%'" (Only label features with NAME attribute values starting with 'A')
    /// * "(LENGTH > CAPACITY) and (TYPE = 1)" (Only label features whose attributes satisfy
    /// the SQL condition)
    ///
    /// The default value is "".
    final public var whereClause: String { get }
}

extension LabelingInfo.LabelPlacement : Equatable {
}

extension LabelingInfo.LabelPlacement : Hashable {
}

/// A grid consisting of east-west lines of latitude and
/// north-south lines of longitude.
///
/// This class represents graticules--lines showing parallels of
/// latitude and meridians of longitude for the earth.
///
/// The position of the graticules are based on the WGS84 ellipsoid,
/// irrespective of the spatial reference used by the map view.
///
/// To display graticules, create a LatitudeLongitudeGrid and set it as
/// the grid property within the MapView.
///
/// LatitudeLongitudeGrid extends Grid, adding the label unit property.
/// - Note: See Also: `MapView.grid`
/// - Since: 200.1
final public class LatitudeLongitudeGrid : ArcGIS.Grid {

    /// The format to use when labeling a ``LatitudeLongitudeGrid``.
    /// - Note: See Also: ``LatitudeLongitudeGrid``
    public enum LabelFormat {

        /// Label the grid lines (graticules) in decimal degrees.
        case decimalDegrees

        /// Label the grid lines (graticules) in degrees, minutes and seconds.
        case degreesMinutesSeconds

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LatitudeLongitudeGrid.LabelFormat, b: ArcGIS.LatitudeLongitudeGrid.LabelFormat) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Constructs a grid consisting of east-west lines of latitude and
    /// north-south lines of longitude (also known as graticules).
    ///
    /// The grid is supported in spatial references which are continuously
    /// pannable or some polar spatial references.
    /// You can check the ``SpatialReference/isPannable`` property is `true` on your
    /// spatial reference.  Examples of continuously pannable spatial
    /// references include WGS84 (WKID 4326) and Web Mercator Auxiliary
    /// Sphere (WKID 102113, 102100, or 3857).
    ///
    /// The following polar spatial references are also supported:
    /// * North pole Azimuthal Equidistant (WKID 102016)
    /// * North pole gnomic (WKID 102034)
    /// * North pole Lambert equal area (WKID 102017)
    /// * North pole orthographic (WKID 102035)
    /// * North pole stereographic (WKID 102018)
    /// * NSIDE EASE North (WKID 3408)
    /// * NSIDC Sea Ice polar stereographic north (WKID 3411)
    /// * WGS 1984 NSIDC Sea Ice Polar Stereographic North (WKID 3413)
    /// * UPS North (WKID 32661)
    /// * South pole Azimuthal Equidistant (WKID 102019)
    /// * South pole gnomic (WKID 102036)
    /// * South pole Lambert equal area (WKID 102020)
    /// * South pole orthographic (WKID 102037)
    /// * South pole stereographic (WKID 102021)
    /// * NSIDE EASE South (WKID 3409)
    /// * NSIDC Sea Ice polar stereographic South (WKID 3412)
    /// * UPS South (WKID 32761)
    /// * WGS1984 Antarctic polar stereographic (WKID 3031)
    public convenience init()

    /// The format used for labeling the grid.
    final public var labelFormat: ArcGIS.LatitudeLongitudeGrid.LabelFormat
}

extension LatitudeLongitudeGrid.LabelFormat : Equatable {
}

extension LatitudeLongitudeGrid.LabelFormat : Hashable {
}

/// A base class for all layers.
///
/// ``Layer`` is the base class for all layer types. A layer is a representation of
/// geographic data portrayed using symbols and text labels. Multiple layers can be 'stacked'
/// to enhance the information displayed. Layers are displayed in a ``Map`` inside a `MapView` control.
/// Layers are drawn bottom-to-top, so the first layer in a map's layer collection is drawn
/// first (on the bottom) and each subsequent layer is drawn on top of it.
/// <table>
/// <tr>
///     <th>Layer type</th>
///     <th>2D/3D</th>
///     <th>Time-aware</th>
///     <th>Online/offline</th>
///     <th>Sources</th>
/// </tr>
/// <tr>
///     <td>Annotation layer (``AnnotationLayer``)</td>
///     <td>2D</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>ArcGIS feature service, portal item, mobile map package (.mmpk)</td>
/// </tr>
/// <tr>
///     <td>ArcGIS map image layer (``ArcGISMapImageLayer``)</td>
///     <td>Both</td>
///     <td>Yes</td>
///     <td>Online</td>
///     <td>ArcGIS map service</td>
/// </tr>
/// <tr>
///     <td>ArcGIS scene layer (``ArcGISSceneLayer``)</td>
///     <td>3D</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>Scene service or scene package</td>
/// </tr>
/// <tr>
///     <td>ArcGIS tiled layer (``ArcGISTiledLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>ArcGIS tile service, tile package (.tpk/.tpkx)</td>
/// </tr>
/// <tr>
///     <td>ArcGIS vector tiled layer (``ArcGISVectorTiledLayer``)</td>
///     <td>2D</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>ArcGIS vector tile service, vector tile package (.vtpk)</td>
/// </tr>
/// <tr>
///     <td>Bing maps layer (``BingMapsLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Online</td>
///     <td>Bing maps</td>
/// </tr>
/// <tr>
///     <td>Dimension layer (``DimensionLayer``)</td>
///     <td>2D</td>
///     <td>Yes</td>
///     <td>Offline</td>
///     <td>Mobile map package (.mmpk)</td>
/// </tr>
/// <tr>
///     <td>Dynamic entity layer (``DynamicEntityLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Online</td>
///     <td>ArcGIS stream service</td>
/// </tr>
/// <tr>
///     <td>ENC layer (``ENCLayer``)</td>
///     <td>2D</td>
///     <td>No</td>
///     <td>Offline</td>
///     <td>ENC exchange set, ENC cell</td>
/// </tr>
/// <tr>
///     <td>Feature collection layer (``FeatureCollectionLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>Portal item, web map, feature set / query result</td>
/// </tr>
/// <tr>
///     <td>Feature layer (``FeatureLayer``)</td>
///     <td>Both</td>
///     <td>Yes</td>
///     <td>Both</td>
///     <td>ArcGIS feature service, WFS, shapefile, GeoPackage, geodatabase, OGC API Features</td>
/// </tr>
/// <tr>
///     <td>Group layer (``GroupLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>Other layers and group layers</td>
/// </tr>
/// <tr>
///     <td>KML layer (``KMLLayer``)</td>
///     <td>Both</td>
///     <td>Yes</td>
///     <td>Both</td>
///     <td>KML file (.kml, .kmz)</td>
/// </tr>
/// <tr>
///     <td>Integrated mesh layer (``IntegratedMeshLayer``)</td>
///     <td>3D</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>Scene layer package (.slpk)</td>
/// </tr>
/// <tr>
///     <td>Mobile basemap layer (``MobileBasemapLayer``)</td>
///     <td>2D</td>
///     <td>No</td>
///     <td>Offline</td>
///     <td>Mobile map package (.mmpk)</td>
/// </tr>
/// <tr>
///     <td>OpenStreetMap layer (``OpenStreetMapLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Online</td>
///     <td>OpenStreetMap.org</td>
/// </tr>
/// <tr>
///     <td>Point cloud layer (``PointCloudLayer``)</td>
///     <td>3D</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>Portal item, scene layer package (.slpk) </td>
/// </tr>
/// <tr>
///     <td>Raster layer (``RasterLayer``)</td>
///     <td>Both</td>
///     <td>Yes</td>
///     <td>Both</td>
///     <td>GeoPackage, raster file, ArcGIS Image service</td>
/// </tr>
///
/// <tr>
///     <td>Subtype feature layer (``SubtypeFeatureLayer``)</td>
///     <td>2D</td>
///     <td>No</td>
///     <td>Both</td>
///     <td>ArcGIS feature service, geodatabase</td>
/// </tr>
/// <tr>
///     <td>Web tiled layer (``WebTiledLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Online</td>
///     <td>Web tile service</td>
/// </tr>
/// <tr>
///     <td>WMS layer (``WMSLayer``)</td>
///     <td>Both</td>
///     <td>Yes</td>
///     <td>Online</td>
///     <td>WMS service</td>
/// </tr>
/// <tr>
///     <td>WMTS layer (``WMTSLayer``)</td>
///     <td>Both</td>
///     <td>No</td>
///     <td>Online</td>
///     <td>WMTS service</td>
/// </tr>
/// </table>
/// - Since: 200.1
public class Layer : ArcGIS.LayerContent, ArcGIS.Loadable {

    public struct ID : CustomStringConvertible, Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        public init?(_ rawValue: String)

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The attribution text for the layer.
    /// - Note: See Also: `String`
    public var attribution: String { get }

    /// The description for the layer.
    ///
    /// The description of the layer.
    /// - Note: See Also: `String`
    public var description: String

    /// The full extent of this layer, which is the extent where all layer data is contained.
    ///
    /// You can use this to zoom
    /// to all of the data contained in this layer. For feature layers, the extent is retrieved from the tables extent.
    /// - Note: See Also: ``FeatureTable/extent``
    public var fullExtent: ArcGIS.Envelope? { get }

    /// The unique identifying string for the layer, for example specified in a map or scene.
    ///
    /// The id is used by other parts of this API to refer to a specific ``Layer``, such as in a
    /// set of ``FeatureFenceParameters`` or a ``FacilityLayerDefinition``. If not supplied, all
    /// layers will be assigned a unique id when created.
    ///
    /// It is not recommended to change this property when the layer is obtained from a map or
    /// scene. If changed, ensure that the string is unique, for example based on a generated
    /// GUID.
    public var id: ArcGIS.Layer.ID?

    /// Whether the layer supports identify.
    ///
    /// If the layer is not loaded it may return `false` if identify support is determined by metadata that is not yet available.
    public var identifyIsEnabled: Bool { get }

    /// The item the layer has been created from.
    /// - Note: See Also: ``ArcGISTiledLayer/init(item:)``, ``ArcGISVectorTiledLayer/init(item:)``, ``ArcGISMapImageLayer/init(item:)``, ``FeatureLayer/init(featureServiceItem:layerID:)``, ``ArcGISMapImageLayer/init(url:)``, ``ArcGISTiledLayer/init(url:)``
    public var item: ArcGIS.Item? { get }

    /// The maximum scale for the layer. If `nil`, there is no maximum.
    ///
    /// This controls the maximum scale level the layer can zoom to.
    /// All of the connected map views will be updated.
    public var maxScale: Double?

    /// The minimum scale for the layer. If `nil`, there is no minimum.
    ///
    /// This controls the minimum scale level the layer can zoom to.
    /// All of the connected map views will be updated.
    public var minScale: Double?

    /// The opacity for the layer.
    ///
    /// All of the connected map views will be updated.
    public var opacity: Float

    /// The spatial reference of the layer.
    public var spatialReference: ArcGIS.SpatialReference? { get }

    /// Clones the ``Layer``.
    /// - Returns: A new ``Layer`` with the same values as the current ``Layer``.
    public func clone() -> Self

    /// A flag indicating whether the layer content's visibility can be changed.
    ///
    /// A flag indicating whether the layer content visibility can be changed.
    public var canChangeVisibility: Bool { get }

    /// The layer content's visibility.
    ///
    /// The layer content visibility.
    @ArcGIS.Streamed public var isVisible: Bool

    public var $isVisible: AsyncStream<Bool> { get }

    /// Fetches the list of legend info.
    public var legendInfos: [ArcGIS.LegendInfo] { get async throws }

    /// The layer content's name.
    ///
    /// The layer content name.
    public var name: String

    /// A flag indicating whether the layer content participates in the legend.
    ///
    /// A flag indicating whether the layer content is shown in the legend.
    public var shouldShowInLegend: Bool

    /// The sub layer contents of a layer content.
    @ArcGIS.Streamed public var subLayerContents: [ArcGIS.LayerContent] { get }

    public var $subLayerContents: AsyncStream<[ArcGIS.LayerContent]> { get }

    /// Returns the layer content's effective visibility at the specified scale.
    ///
    /// Returns the effective layer content visibility. This effective visibility takes care of the effective visibility of the parents at the specified scale.
    /// - Parameter scale: The scale the visibility has to be calculated for.
    /// - Returns: A bool.
    public func isVisible(atScale scale: Double) -> Bool

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

/// A key in a layer capabilities dictionary.
public typealias LayerCapabilityKey = ArcGIS.LayerKey

/// A interface for building a Table of Contents.
///
/// This interface is implemented by ``Layer``, ``ArcGISSublayer``
/// - Since: 200.1
public protocol LayerContent : AnyObject {

    /// A flag indicating whether the layer content's visibility can be changed.
    ///
    /// A flag indicating whether the layer content visibility can be changed.
    var canChangeVisibility: Bool { get }

    /// The layer content's visibility.
    ///
    /// The layer content visibility.
    var isVisible: Bool { get set }

    /// Fetches the list of legend info.
    var legendInfos: [ArcGIS.LegendInfo] { get async throws }

    /// The layer content's name.
    ///
    /// The layer content name.
    var name: String { get }

    /// A flag indicating whether the layer content participates in the legend.
    ///
    /// A flag indicating whether the layer content is shown in the legend.
    var shouldShowInLegend: Bool { get set }

    /// The sub layer contents of a layer content.
    var subLayerContents: [ArcGIS.LayerContent] { get }

    /// Returns the layer content's effective visibility at the specified scale.
    ///
    /// Returns the effective layer content visibility. This effective visibility takes care of the effective visibility of the parents at the specified scale.
    /// - Parameter scale: The scale the visibility has to be calculated for.
    /// - Returns: A bool.
    func isVisible(atScale scale: Double) -> Bool
}

/// A key in a layer errors dictionary.
public typealias LayerErrorKey = ArcGIS.LayerKey

/// Describes how features in a ``FloorAware`` layer are associated with floor levels of a facility.
///
/// ``LayerFloorDefinition`` defines the properties that are used to filter the levels, or floors, of a facility.
/// - Note: See Also: ``GeoModelFloorDefinition``
/// - Since: 200.1
final public class LayerFloorDefinition : ArcGIS.JSONSerializable {

    /// Creates a new ``LayerFloorDefinition`` object with a name of an attribute field.
    /// - Parameter floorField: The name of the attribute field that contains each floor level's ID.
    public convenience init(floorField: String)

    /// The name of the attribute field that contains each floor level's ID.
    final public var floorField: String { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

/// A dictionary key that wraps a layer.
/// - Since: 200.1
public struct LayerKey {

    /// The wrapped layer.
    public let layer: ArcGIS.Layer

    /// Creates a layer key.
    /// - Parameter layer: The layer to wrap as the dictionary key.
    public init(_ layer: ArcGIS.Layer)
}

extension LayerKey : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.LayerKey, rhs: ArcGIS.LayerKey) -> Bool
}

extension LayerKey : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A key in a layer results dictionary.
public typealias LayerResultKey = ArcGIS.LayerKey

/// provides access to scene specific properties.
///
/// Scene properties can be retrieved from the ``GraphicsOverlay``
/// and used to set scene specific properties defining the behavior in 3D.
/// - Since: 200.1
final public class LayerSceneProperties {

    /// Creates a new scene view properties object.
    /// - Parameter surfacePlacement: To apply to the scene view properties ``SurfacePlacement``.
    public convenience init(surfacePlacement: ArcGIS.SurfacePlacement = .drapedBillboarded)

    /// The altitude offset from the Scene Properties.
    final public var altitudeOffset: Double

    /// The surface placement form the Scene Properties.
    final public var surfacePlacement: ArcGIS.SurfacePlacement
}

/// Metadata about a Layer or Sublayers support for time.
///
/// It contains various information needed to be able
/// to perform time based queries such as the time fields, the native time reference and the time extent.
/// - Since: 200.1
final public class LayerTimeInfo {

    /// The name of the field that contains the end time for each feature in the layer.
    ///
    /// This is available for feature data that has a start and end time stored in two separate fields,
    /// where a feature's time is valid for a duration between the start time and the end time.
    final public var endTimeField: String { get }

    /// Whether there is live data.
    ///
    /// If `true`, export and identify operations will default the
    /// time extent to start time = (current server time - time interval), end time = current server time.
    final public var hasLiveData: Bool { get }

    /// The time interval of the data in the layer.
    ///
    /// This is useful for the implementation of a time slider control.
    final public var interval: ArcGIS.TimeValue? { get }

    /// The name of the field that contains the start time for each feature in the layer.
    ///
    /// This is available for feature data that has time stored in either a single field where a feature's time
    /// is valid for an instant in time, or in two fields where a feature's time is valid for a duration between the start
    /// time and the end time.
    final public var startTimeField: String { get }

    /// The time extent that is inclusive of all the data in the layer.
    final public var timeExtent: ArcGIS.TimeExtent? { get }

    /// Information about the time reference used for time values in the layer.
    ///
    /// This includes information about the time zone and whether the layer respects daylight savings time.
    final public var timeReference: ArcGIS.TimeReference? { get }

    /// The field name that defines the track ID.
    ///
    /// Values in the track ID field uniquely identify individual objects to allow observations of the same object
    /// at different times to be represented by different features in the layer.
    final public var trackIDField: String { get }
}

/// The state of a layer in a `GeoView`.
///
/// This object allows you to know the current state of a layer in a view.
/// - Since: 200.1
final public class LayerViewState {

    /// The status of a layer in the `GeoView`.
    ///
    /// This status is used to determine whether a layer is displaying in a `GeoView` or whether it is still loading,
    /// not visible, out of scale, or has encountered an error or warning. Each layer can have multiple states at the
    /// same time. For example, a layer could be both ``notVisible`` and ``outOfScale``,
    /// or it could be ``notVisible`` and ``loading``. These multiple states are
    /// represented using a flag enumeration.
    ///
    /// A status of ``active`` indicates that the layer is being displayed in the view. Note, that some
    /// of the layer view states are not possible together. For example, a layer cannot be both
    /// ``active`` and ``notVisible`` at the same time.
    ///
    /// If you implement a layer list in a table of contents (TOCs), you can use the layer view status to manage the TOC
    /// user interface. For example, you could gray out the layer if it is ``outOfScale``, or you could
    /// show a spinning icon if the layer is ``loading``. If the layer list contains a ``GroupLayer``
    /// that is ``notVisible`` then its child layers will be ``notVisible``. If, the
    /// ``GroupLayer`` is visible then each child layer can be either visible or ``notVisible``.
    ///
    /// If the layer completely fails to load or render you will encounter a ``error``. If the layer
    /// fails to render some of its content then you will encounter a ``warning``. This could be due to
    /// the temporary loss of a network connection, failing layer requests or exceeding the max feature count. In both
    /// cases you will find more details about the problem in the ``LayerViewState/error``.
    /// - Note: See Also: ``LayerViewState``
    public struct Status : OptionSet {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: Int)

        /// = 1, The layer in the view is active.
        ///
        /// A status of ``LayerViewState/Status-swift.struct/active`` indicates that the layer is being displayed in the view.
        public static let active: ArcGIS.LayerViewState.Status

        /// = 2, The layer in the view is not visible.
        public static let notVisible: ArcGIS.LayerViewState.Status

        /// = 4, The layer in the view is out of scale.
        ///
        /// A status of ``LayerViewState/Status-swift.struct/outOfScale`` indicates that the view is zoomed outside of the scale range
        /// of the layer. If the view is zoomed too far in (e.g. to a street level) it is beyond the max scale defined
        /// for the layer. If the view has zoomed to far out (e.g. to global scale) it is beyond the min scale defined for the layer.
        public static let outOfScale: ArcGIS.LayerViewState.Status

        /// = 8, The layer in the view is loading.
        ///
        /// Once loading has completed, the layer will be available for display in the view.
        /// If there was a problem loading the layer, the status will be set to ``LayerViewState/Status-swift.struct/error``
        /// and the ``LayerViewState/error`` property will provide details on the specific problem.
        public static let loading: ArcGIS.LayerViewState.Status

        /// = 16, The layer in the view has an unrecoverable error.
        ///
        /// When the status is ``LayerViewState/Status-swift.struct/error``, the layer cannot be rendered in the view.
        /// For example, it may have failed to load, be an unsupported layer type or contain
        /// invalid data.
        ///
        /// The ``LayerViewState/error`` property will provide more details about the specific
        /// problem which was encountered. Depending on the type of problem, you could:
        /// * Call ``Layer/retryLoad()``
        /// * Remove the layer from the ``Map`` or ``Scene``
        /// * Inspect the data
        public static let error: ArcGIS.LayerViewState.Status

        /// = 32, The layer in the view has encountered an error which may be temporary.
        ///
        /// When the status is ``LayerViewState/Status-swift.struct/warning``, the layer may still be displayed in the
        /// view. It is possible for the status to be both ``LayerViewState/Status-swift.struct/active`` and
        /// ``LayerViewState/Status-swift.struct/warning``.
        ///
        /// A warning status indicates that the layer has encountered a problem but may still be
        /// usable. For example, some tiles or features may be failing to load due to network
        /// failure or server error.
        ///
        /// You should be aware that when a ``LayerViewState/Status-swift.struct/warning`` is received, the layer may
        /// not be showing all data or it may be showing data which is not up-to-date.
        ///
        /// The ``LayerViewState/error`` property will provide more details about the specific
        /// problem which was encountered. Depending on the type of problem, you could:
        /// * Check your network connection
        /// * Check whether an online service is experiencing problems
        public static let warning: ArcGIS.LayerViewState.Status

        /// The type of the elements of an array literal.
        public typealias ArrayLiteralElement = ArcGIS.LayerViewState.Status

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        public typealias Element = ArcGIS.LayerViewState.Status

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = Int
    }

    /// The error that describes a problem encountered when displaying layers in a `GeoView`.
    ///
    /// For your application, an error may be critical for the user's interaction with the view's data content.
    /// Depending on the type of problem encountered, you could:
    /// * Call ``Layer/retryLoad()``
    /// * Remove the layer from the ``Map`` or ``Scene``
    /// * Inspect the data
    /// * Check your network connection
    /// * Check whether an online service is experiencing problems
    /// - Note: See Also: ``LayerViewState``
    final public var error: Error? { get }

    /// The status of a layer in the view.
    /// - Note: See Also: ``LayerViewState``
    final public var status: ArcGIS.LayerViewState.Status { get }
}

/// This object represents a legend item.
///
/// You can get this object from the LayerContent.fetchLegendInfosAsync method of objects that implement the
/// ``LayerContent`` interface (e.g. ``ArcGISSublayer/legendInfos``).
/// - Note: See Also: ``LayerContent``, ``LayerContent/legendInfos``
/// - Since: 200.1
final public class LegendInfo {

    /// The name of the legend item.
    final public var name: String { get }

    /// The symbol of a legend item.
    ///
    /// The symbol of the legend item.
    final public var symbol: ArcGIS.Symbol? { get }
}

extension LegendInfo : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.LegendInfo, rhs: ArcGIS.LegendInfo) -> Bool
}

extension LegendInfo : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// Defines the properties of the layer that contains floor levels for a floor-aware map or scene.
///
/// A floor level describes the footprint of each occupiable floor contained in a managed facility.
/// - Note: See Also: ``GeoModelFloorDefinition``
/// - Since: 200.1
final public class LevelLayerDefinition : ArcGIS.JSONSerializable {

    /// Creates a new ``LevelLayerDefinition`` object using the specified ``Layer/id-swift.property``, level id field, level number field, short name field, long name field, vertical order field, and facility id field.
    /// - Parameters:
    ///   - layerID: An ID that specifies a layer in the map or scene that describes floor levels.
    ///   - levelIDField: The name of the attribute field that contains each level feature's unique identifier.
    ///   - levelNumberField: The name of the attribute field that contains each level feature's level number specific to its facility.
    ///   - shortNameField: The name of the attribute field that contains each level feature's short name.
    ///   - longNameField: The name of the attribute field that contains each level feature's long name.
    ///   - verticalOrderField: The name of the attribute field that contains each level feature's vertical order.  The vertical order defines the order of display in a floor filtering UI component, and it also references the floor levels of an Indoor Positioning System.
    ///   - facilityIDField: The name of the attribute field that contains each level feature's facility identifier (a foreign key to the layer that contains facility features).
    public convenience init(layerID: ArcGIS.Layer.ID, levelIDField: String, levelNumberField: String, shortNameField: String, longNameField: String, verticalOrderField: String, facilityIDField: String)

    /// The name of the attribute field that contains each floor level feature's facility identifier (a foreign key to the layer that contains facility features).
    final public var facilityIDField: String { get }

    /// An ID that specifies a layer in the map or scene that contains floor level features.
    final public var layerID: ArcGIS.Layer.ID { get }

    /// The name of the attribute field that contains each floor level feature's unique identifier.
    final public var levelIDField: String { get }

    /// The name of the attribute field that contains each floor level feature's level number specific to its facility.
    final public var levelNumberField: String { get }

    /// The name of the attribute field that contains each floor level feature's long name.
    final public var longNameField: String { get }

    /// The name of the attribute field that contains each floor level feature's short name.
    final public var shortNameField: String { get }

    /// The name of the attribute field that contains each floor level feature's vertical order.
    ///
    /// The vertical order defines the order of display in a floor filtering UI component,
    /// and it also references the floor levels of an Indoor Positioning System.
    final public var verticalOrderField: String { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

/// This object represents a level of detail (LOD) in a tile scheme.
///
/// You can get this object from ``TileInfo/levelsOfDetail``.
/// - Note: See Also: ``TileInfo``
/// - Since: 200.1
public struct LevelOfDetail : Hashable {

    /// The level of the level of detail.
    public var level: Int

    /// The resolution of the level of detail.
    public var resolution: Double

    /// The scale of the level of detail.
    public var scale: Double

    /// Creates a new level of detail (LOD) object.
    /// - Parameters:
    ///   - level: The level of the LOD.
    ///   - resolution: The resolution of the LOD.
    ///   - scale: The scale of the LOD.
    public init(level: Int, resolution: Double, scale: Double)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.LevelOfDetail, b: ArcGIS.LevelOfDetail) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Details of license.
///
/// Until an app is licensed, it runs at the Developer license level. All functionality is available, but the map
/// display is watermarked and a message is logged stating that the app is in developer mode.
///
/// A deployed app needs to be run at minimum with the Lite license level to disable the map watermark. The Lite,
/// Basic, Standard, or Advanced license level is set by calling `ArcGISEnvironment.setLicense(with:extensions:)`
/// with a license string obtained from the ArcGIS for Developers website or Esri Customer Service. With the varying
/// license levels, a subset of functionality is available. Any attempt to use licensed functionality that is not
/// available at the current license level will log or emit error messages.
///
/// To get Lite, Basic, Standard, or Advanced license level functionality, a user app is licensed in one of two ways:
///
/// * With license information retrieved after logging in to a portal (Lite and Basic levels).
/// * With a license string acquired from the ArcGIS for Developers website or Esri Customer Service.
///
/// To license with a license string, call `ArcGISEnvironment.setLicense(with:extensions:)`.
///
/// To validate with information from a portal, you need a ``LicenseInfo`` instance. You can get one by calling
/// `Portal.licenseInfo`. Pass the ``LicenseInfo`` to `ArcGISEnvironment.setLicense(from:)`.
///
/// Both of these methods return a ``LicenseResult`` that reports the status of the license. Note that there is a
/// 30-day timeout when using ``LicenseInfo``. If the app is licensed using this method, the user must log in to
/// the portal again before licensing the app. When this period has expired, calling
/// `ArcGISEnvironment.setLicense(from:)` returns a ``LicenseResult`` which contains license status
/// of ``Status-swift.enum/loginRequired``, and the app continues to run at the current license level (default is ``Level-swift.enum/developer``).
/// - Since: 200.1
final public class License {

    /// The different license types.
    ///
    /// Each of the possible license types that the application could be licensed as.
    /// - Note: See Also: ``License``
    public enum Kind {

        /// The license type has not been set and will run in developer mode.
        case developer

        /// Using a subscription license from a named user account.
        case namedUser

        /// Licensed from a license string.
        case licenseKey

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.License.Kind, b: ArcGIS.License.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The different license levels.
    ///
    /// Each of different license levels.
    /// - Note: See Also: ``License``
    public enum Level {

        /// Application will run in developer mode: full functionality but with a watermarked view.
        case developer

        /// Lite mode: no watermark and functionality available at the lowest level.
        case lite

        /// Basic mode: no watermark and functionality available at the basic level.
        case basic

        /// Standard mode: no watermark and functionality available at the standard level.
        case standard

        /// Advanced mode: no watermark and functionality available at the advanced level.
        case advanced

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.License.Level, b: ArcGIS.License.Level) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The different license statuses that occur from setting a license.
    ///
    /// Each of different license statuses.
    /// - Note: See Also: ``License``
    public enum Status {

        /// License is invalid.
        case invalid

        /// License is expired.
        case expired

        /// License has passed the 30-day timeout period for a named user.
        case loginRequired

        /// License is valid.
        case valid

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.License.Status, b: ArcGIS.License.Status) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// License expiry date and time in UTC.
    ///
    /// This is either the expiry date of a license set with `ArcGISEnvironment.setLicense(with:extensions:)`
    /// or the portal subscription expiry when using `ArcGISEnvironment.setLicense(from:)`.
    final public var expirationDate: Date { get }

    /// The collection of extension licenses for the app.
    ///
    /// For valid extension license keys supplied when calling
    /// `ArcGISEnvironment.setLicense(with:extensions:)`, this collection is populated with
    /// information about the extension licenses. Use this function to iterate extension licenses available
    /// for the app.
    ///
    /// Note that, although this collection is empty when running an app in developer mode, all extension
    /// licensed functionality will be available.
    final public var extensions: [ArcGIS.ExtensionLicense] { get }

    /// `true` if a license is perpetual, `false` otherwise.
    ///
    /// Typically this returns `true` for apps licensed with a license string with 'none' for the
    /// expiration date field.
    final public var isPermanent: Bool { get }

    /// The license type of the current license.
    ///
    /// In developer mode, this function returns ``Kind-swift.enum/developer``. Otherwise, it can return ``Kind-swift.enum/namedUser`` if the app was licensed by logging in to a portal and acquiring a ``LicenseInfo``, or ``Kind-swift.enum/licenseKey`` if the app was licensed from a license string. The license type can change while an app runs. For instance, the app may start running licensed with a Lite license key (``Kind-swift.enum/licenseKey``) and later become licensed from ``LicenseInfo`` (``Kind-swift.enum/namedUser``).
    final public var kind: ArcGIS.License.Kind { get }

    /// The current license level set in the app. See ``Level-swift.enum`` for available levels.
    ///
    /// By default, unless a deployment license is provided, apps run with a ``Level-swift.enum/developer`` license.
    final public var level: ArcGIS.License.Level { get }

    /// The current license status of the provided license.
    final public var status: ArcGIS.License.Status { get }
}

extension License.Kind : Equatable {
}

extension License.Kind : Hashable {
}

extension License.Level : Equatable {
}

extension License.Level : Hashable {
}

extension License.Status : Equatable {
}

extension License.Status : Hashable {
}

/// A class that contains encrypted JSON information pertaining to a licensed named user.
/// - Since: 200.1
final public class LicenseInfo : ArcGIS.JSONSerializable {

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

/// A value used to specify an ArcGIS license.
/// - Since: 200.1
@frozen public struct LicenseKey : RawRepresentable, Hashable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: String

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    public init?(_ rawValue: String)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = String
}

extension LicenseKey : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension LicenseKey : Sendable {
}

/// The status of the license and any extension licenses.
/// - Since: 200.1
final public class LicenseResult {

    /// A mapping of key-value pairs for extension license name to license status.
    ///
    /// The value type should be casted to a ``License/Status-swift.enum`` enumeration value.
    final public var extensionStatuses: [String : ArcGIS.License.Status] { get }

    /// The license status from a call to `ArcGISEnvironment.setLicense(with:extensions:)`.
    final public var licenseStatus: ArcGIS.License.Status { get }
}

/// An error than can occur when dealing with licensing.
/// - Since: 200.1
public enum LicensingError : Error {

    /// Unlicensed feature.
    case unlicensedFeature

    /// License level fixed.
    case licenseLevelFixed

    /// License level is already set.
    case licenseLevelAlreadySet

    /// Main license is not set.
    case mainLicenseNotSet

    /// Unlicensed extension.
    case unlicensedExtension

    /// Portal user with no license.
    case portalUserWithNoLicense

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension LicensingError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.LicensingError, b: ArcGIS.LicensingError) -> Bool
}

extension LicensingError : Hashable {
}

/// This base class contains common functionality for all LineOfSight analysis objects.
///
/// LineOfSight is a base class for LocationLineOfSight and GeoElementLineOfSight.
/// - Since: 200.1
public class LineOfSight : ArcGIS.Analysis {

    /// Describes the visibility state between an observer and target in a line of sight analysis.
    /// - Note: See Also: ``LineOfSight/targetVisibility-swift.property``
    public enum TargetVisibility {

        /// Target is visible from the observer.
        case visible

        /// Target is not visible from the observer because the line of sight is obstructed.
        case obstructed

        /// Target visibility from the observer cannot be accurately evaluated with the currently loaded data.
        case unknown

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LineOfSight.TargetVisibility, b: ArcGIS.LineOfSight.TargetVisibility) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Gets the line width used to render LineOfSight analysis results.
    ///
    /// This property is applied to all LineOfSight analyses in the view.
    public class var lineWidth: CGFloat

    /// Gets the color used to render segments that are not visible along LineOfSight analysis results.
    ///
    /// Sections of the line between the observer and the target that are obstructed (not visible) are drawn with the specified color.
    /// This property is applied to all LineOfSight analyses in the view.
    public class var obstructedColor: UIColor

    /// The target visibility state.
    ///
    /// Use ``targetVisibility-swift.property`` to handle changes in target visibility.
    /// - Note: See Also: ``TargetVisibility-swift.enum``
    @ArcGIS.Streamed public var targetVisibility: ArcGIS.LineOfSight.TargetVisibility { get }

    public var $targetVisibility: AsyncStream<ArcGIS.LineOfSight.TargetVisibility> { get }

    /// Gets the color used to render segments that are visible along LineOfSight analysis results.
    ///
    /// Sections of the line between the observer and the target that are visible are drawn with the specified color.
    /// This property is applied to all LineOfSight analyses in the view.
    public class var visibleColor: UIColor
}

extension LineOfSight.TargetVisibility : Equatable {
}

extension LineOfSight.TargetVisibility : Hashable {
}

/// A line segment represents a straight line from its start to end point. It is derived from a segment object.
/// - Note: See Also: ``Segment``
/// - Since: 200.1
final public class LineSegment : ArcGIS.Segment {

    /// Creates a line segment based on two points and a spatial reference.
    ///
    /// Use this method to create a line segment representing a straight line between two points.
    /// The spatial reference parameter is used if the points have a `nil` spatial reference. If more than one
    /// spatial reference is supplied (as a parameter or as a property of a ``Point`` parameter), they must all be
    /// equal.
    /// - Parameters:
    ///   - startPoint: The start point.
    ///   - endPoint: The end point.
    ///   - spatialReference: A spatial reference
    /// - Precondition: All spatial references supplied must be equal.
    public convenience init(startPoint: ArcGIS.Point, endPoint: ArcGIS.Point, spatialReference: ArcGIS.SpatialReference? = nil)

    /// Creates a line segment based on coordinates.
    ///
    /// Use this method to create a line segment representing a straight line between two points.
    /// - Parameters:
    ///   - xStart: The X coordinate of start point.
    ///   - yStart: The Y coordinate of start point.
    ///   - xEnd: The X coordinate of end point.
    ///   - yEnd: The Y coordinate of end point.
    ///   - spatialReference: A spatial reference
    /// - Precondition: `!xStart.isNaN`
    /// - Precondition: `!yStart.isNaN`
    /// - Precondition: `!xEnd.isNaN`
    /// - Precondition: `!yEnd.isNaN`
    public convenience init(xStart: Double, yStart: Double, xEnd: Double, yEnd: Double, spatialReference: ArcGIS.SpatialReference? = nil)

    /// Creates a line segment based on 3D coordinates and a spatial reference.
    ///
    /// Use this method to create a line segment representing a straight line between two points.
    /// - Parameters:
    ///   - xStart: The X coordinate of start point.
    ///   - yStart: The Y coordinate of start point.
    ///   - zStart: The Z coordinate of start point.
    ///   - xEnd: The X coordinate of end point.
    ///   - yEnd: The Y coordinate of end point.
    ///   - zEnd: The Z coordinate of end point.
    ///   - spatialReference: A spatial reference
    /// - Precondition: `!xStart.isNaN`
    /// - Precondition: `!yStart.isNaN`
    /// - Precondition: `!zStart.isNaN`
    /// - Precondition: `!xEnd.isNaN`
    /// - Precondition: `!yEnd.isNaN`
    /// - Precondition: `!zEnd.isNaN`
    public convenience init(xStart: Double, yStart: Double, zStart: Double, xEnd: Double, yEnd: Double, zEnd: Double, spatialReference: ArcGIS.SpatialReference? = nil)
}

extension LineSegment {

    /// Creates a line segment of the specified length and angle from a given start point.
    /// - Remark: The spatial reference of the point is used to determine the segment's spatial reference.
    /// The angle is specified in radians relative to the X axis.
    /// The length is in the units of the spatial reference.
    /// - Parameters:
    ///   - startPoint: The start point of the line segment.
    ///   - angleRadians: The angle of the line in radians relative to the X axis.
    ///   - length: The length of the line.
    /// - Precondition: `!startPoint.isEmpty`.
    /// - Precondition: `angleRadians.isFinite`.
    /// - Precondition: `length.isFinite`.
    public convenience init(startPoint: ArcGIS.Point, angleRadians: Double, length: Double)
}

/// A base class for line symbols. You would typically work with one or more sub-classes of this class.
///
/// Use line symbols to display graphics and features that are based on polyline geometries.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
public class LineSymbol : ArcGIS.Symbol {

    /// The color for the line symbol.
    ///
    /// When getting the color (or tint color) from a symbol, the consensus value (for all layers) is
    /// reported. If there is no consensus (one or more layers have different colors), a `nil` value is
    /// reported for the color. Likewise, setting a value for color on a symbol will apply that color to
    /// all layers the symbol contains.
    ///
    /// If you don't want changes to the symbol color to propagate to some of the symbol layers it contains,
    /// you can lock the color (or tint color) for those layers. If a symbol layer is color-locked,
    /// changes to the parent symbol will not affect the symbol layer. This also means that the layer will
    /// not be considered when determining a consensus color for the symbol as a whole.
    public var color: UIColor

    /// A Boolean value that indicates whether to apply antialiasing to the line symbol.
    public var isAntialiased: Bool

    /// The width of the line symbol.
    public var width: CGFloat
}

/// Defines a linear unit of measurement.
///
/// The linear unit class is derived from the unit class.
/// - Note: See Also: ``Unit``
/// - Since: 200.1
final public class LinearUnit : ArcGIS.Unit {

    /// Defines a list of the most commonly-used units of linear measurement.
    ///
    /// These values can be used to create instances ``Unit``, as an alternative to using well-known IDs (WKIDs).
    /// In addition to the units in this enumeration, you can also use less commonly-used units, by passing a WKID of a
    /// linear unit to the inherited `Unit.fromWKID(_:)` factory method.
    /// The function ``Unit/wkid`` returns the WKID of the unit.
    /// - Note: See Also: `Unit.objectType`
    public enum ID {

        /// Indicates a linear measurement in centimeters.
        /// This unit has a WKID of 1033.
        case centimeters

        /// Indicates a linear measurement in feet.
        /// This unit has a WKID of 9002.
        case feet

        /// Indicates a linear measurement in inches.
        /// This unit has a WKID of 109008.
        case inches

        /// Indicates a linear measurement in kilometers.
        /// This unit has a WKID of 9036.
        case kilometers

        /// Indicates a linear measurement in meters.
        /// This unit has a WKID of 9001.
        case meters

        /// Indicates a linear measurement in statute miles.
        /// This unit has a WKID of 9093.
        case miles

        /// Indicates a linear measurement in millimeters.
        /// This unit has a WKID of 1025.
        case millimeters

        /// Indicates a linear measurement in nautical miles.
        /// This unit has a WKID of 9030.
        case nauticalMiles

        /// Indicates a linear measurement in yards.
        /// This unit has a WKID of 9096.
        case yards

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LinearUnit.ID, b: ArcGIS.LinearUnit.ID) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a unit given its known id.
    /// - Parameter linearID: The known id of the unit.
    public convenience init(linearID: ArcGIS.LinearUnit.ID)

    /// Creates an linear unit given an area unit.
    ///
    /// Creates a unit given an area unit.
    /// - Parameter areaUnit: The area unit.
    public convenience init?(areaUnit: ArcGIS.AreaUnit)

    /// The ``ID`` of the given Linear unit.
    final public var linearID: ArcGIS.LinearUnit.ID? { get }

    /// Converts a value in another UOM into this UOM.
    /// - Parameters:
    ///   - unit: The UOM to convert from.
    ///   - value: The value to convert.
    /// - Returns: The value in this UOM or `nan` if the conversion fails.
    final public func convert(from unit: ArcGIS.LinearUnit, value: Double) -> Double

    /// Converts a value in this UOM into another UOM.
    /// - Parameters:
    ///   - unit: The UOM to convert to.
    ///   - value: The value to convert.
    /// - Returns: The value in the target UOM or `nan` if the conversion fails.
    final public func convert(to unit: ArcGIS.LinearUnit, value: Double) -> Double

    /// Converts a meter value to this UOM.
    /// - Parameter value: The value to convert.
    /// - Returns: The value in this UOM or `nan` if the conversion fails.
    final public func fromMeters(value: Double) -> Double

    /// Converts a value in this UOM to meters.
    /// - Parameter value: The value to convert.
    /// - Returns: The value in meters or `nan` if the conversion fails.
    final public func toMeters(value: Double) -> Double
}

extension LinearUnit {

    /// A linear unit representing meters.
    public static let meters: ArcGIS.LinearUnit

    /// A linear unit representing kilometers.
    public static let kilometers: ArcGIS.LinearUnit

    /// A linear unit representing feet.
    public static let feet: ArcGIS.LinearUnit

    /// A linear unit representing miles.
    public static let miles: ArcGIS.LinearUnit
}

extension LinearUnit.ID : Equatable {
}

extension LinearUnit.ID : Hashable {
}

/// This class allows you to specify how the map/scene should treat feature layers.
///
/// Represents load settings.
/// - Since: 200.1
final public class LoadSettings {

    /// Creates a new load settings object.
    public convenience init()

    /// The request mode to use for requesting features. Default is ``FeatureRequestMode/onInteractionCache``.
    final public var featureRequestMode: ArcGIS.FeatureRequestMode

    /// The session type to use for branch-versioned ``ServiceGeodatabase`` objects.  Default is ``FeatureServiceSessionType/transient``.
    final public var featureServiceSessionType: ArcGIS.FeatureServiceSessionType

    /// The feature tiling mode in use. Sets the feature tiling mode of each feature layer that is loaded.
    /// Default is ``FeatureTilingMode/enabledWhenSupported``.
    ///
    /// Changes how feature tiling is handled by each feature layer. Individual feature layers can override these settings.
    /// - Note: See Also: ``FeatureTilingMode``
    final public var featureTilingMode: ArcGIS.FeatureTilingMode

    /// The preferred rendering mode for point and multi-point based feature layers. The layer will attempt to render in the specified mode if this is supported.
    /// If for example DYNAMIC is not supported by a layer's rendering mode then it will fall back to rendering in STATIC mode.
    final public var preferredPointFeatureRenderingMode: ArcGIS.FeatureLayer.RenderingMode

    /// The preferred rendering mode for polygon based feature layers. The layer will attempt to render in the specified mode if this is supported.
    /// If for example DYNAMIC is not supported by a layer's rendering mode then it will fall back to rendering in STATIC mode.
    final public var preferredPolygonFeatureRenderingMode: ArcGIS.FeatureLayer.RenderingMode

    /// The preferred rendering mode for polyline based feature layers. The layer will attempt to render in the specified mode if this is supported.
    /// If for example DYNAMIC is not supported by a layer's rendering mode then it will fall back to rendering in STATIC mode.
    final public var preferredPolylineFeatureRenderingMode: ArcGIS.FeatureLayer.RenderingMode

    /// Whether or not to use advanced symbology. Default is `true`.
    final public var usesAdvancedSymbology: Bool
}

/// The load status for the object.
///
/// This is used to determine the status of an object that is loadable.
/// - Since: 200.1
@frozen public enum LoadStatus {

    /// The object is not loaded and some functionality may not work.
    case notLoaded

    /// The object is currently being loaded and some functionality may not
    /// work.
    case loading

    /// The object is fully loaded and ready to use.
    case loaded

    /// The object failed to load and some functionality may not work.
    case failed

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension LoadStatus : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.LoadStatus, b: ArcGIS.LoadStatus) -> Bool
}

extension LoadStatus : Hashable {
}

extension LoadStatus : Sendable {
}

/// A type that supports loading associated metadata asynchronously.
///
/// A resource that is capable of loading its metadata asynchronously is
/// referred to as a loadable. It could represent a remote service or a dataset
/// on disk.
/// - Since: 200.1
public protocol Loadable : AnyObject {

    /// The load status.
    var loadStatus: ArcGIS.LoadStatus { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    var loadError: Error? { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    func cancelLoad() async
}

/// An object that represents a loadable image.
///
/// A loadable image implements the loadable pattern (``Loadable``) and allows getting the underlying image (through ``image``) once the image is loaded.
/// For ``LocalItem`` thumbnail, the image is read from JSON and is automatically loaded.
/// For ``PortalItem`` thumbnail, the loadable image is initialized with the thumbnail URI and needs to be loaded before calling ``image``.
/// - Note: See Also: ``Item/thumbnail``
/// - Since: 200.1
final public class LoadableImage : ArcGIS.Loadable {

    /// The image.
    ///
    /// Image is `nil` while the loadable image is not loaded.
    final public var image: UIImage? { get }

    /// The URI.
    final public var url: URL? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension LoadableImage : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.LoadableImage, rhs: ArcGIS.LoadableImage) -> Bool
}

/// A namespace for types related to the ``Loadable`` protocol.
/// - Since: 200.1
public enum Loadables {
}

extension Loadables {

    /// Posted when a loadable's load status changes.
    public static let loadStatusDidChange: Notification.Name
}

/// An object that represents a pending feature edit specifying
/// its edit operation and most recent edit time.
/// - Since: 200.1
final public class LocalFeatureEdit {

    /// The date and time when the most recent edit occurred.
    final public var editDate: Date { get }

    /// The edited feature.
    final public var feature: ArcGIS.Feature { get }

    /// The type of the feature edit.
    ///
    /// A newly added feature will keep the ``EditOperation/add`` edit operation
    /// even if it has been updated since being added.
    final public var operation: ArcGIS.EditOperation? { get }
}

/// An object that represents the ``LocalFeatureEdit`` results
/// in ascending order based on edit time.
/// - Since: 200.1
final public class LocalFeatureEditsResult {

    /// Returns the feature edit iterator
    /// - Returns: An `AnySequence` that returns ``LocalFeatureEdit`` objects.
    final public func edits() -> AnySequence<ArcGIS.LocalFeatureEdit>
}

/// An object that represents a local item.
/// - Note: See Also: ``Layer/item``, ``GeoModel/item``, ``Basemap/item``
/// - Since: 200.1
final public class LocalItem : ArcGIS.Item {

    /// An enumeration of various types of local items.
    public enum Kind {

        /// A mobile map.
        case mobileMap

        /// A mobile scene.
        case mobileScene

        /// A mobile map package.
        case mobileMapPackage

        /// A mobile scene package.
        case mobileScenePackage

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LocalItem.Kind, b: ArcGIS.LocalItem.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The local item path.
    ///
    /// This path can be empty when the item is contained within a ``MobileMapPackage`` or ``MobileScenePackage``.
    final public var fileURL: URL? { get }

    /// The local item type.
    final public var kind: ArcGIS.LocalItem.Kind? { get }

    /// The original portal item ID.
    final public var originalPortalItemID: ArcGIS.Item.ID? { get }

    /// The URL of the portal from which this local item was downloaded.
    ///
    /// This property can be used in conjunction with the ``originalPortalItemID`` to find the URL of the portal from which this local item
    /// was downloaded. This can be useful when following offline map workflows as it allows you to find the URL of the online webmap.
    ///
    /// This property will be empty when the local item was not created from an online resource - for example if exported from ArcGIS Pro.
    final public var portalURL: URL? { get }
}

extension LocalItem.Kind : Equatable {
}

extension LocalItem.Kind : Hashable {
}

/// A location data object.
///
/// This object contains a location data, including its position point, velocity, accuracy, course etc.
/// - Since: 200.1
public class Location {

    /// The timestamp of the location.
    public var timestamp: Date { get }

    /// Creates a location object with timestamp and additional source properties.
    ///
    /// - Remark: A Location can be created from a variety of sources and using different technologies.
    /// By supplying ``additionalSourceProperties`` you can allow users of this Location to
    /// find out how the data was captured.
    /// - Parameters:
    ///   - position: The geographic coordinates of the location.
    ///   - horizontalAccuracy: The horizontal accuracy in meters. Positive values or `nan` are supported.
    ///   - verticalAccuracy: The vertical accuracy in meters. Positive values or `nan` are supported.
    ///   - speed: The location's speed in meters per second.
    ///   - course: The location's course in degrees (clockwise), `0` being true North.
    ///   - isLastKnown: Indicates whether this is an outdated device position retrieved and cached earlier and therefore
    ///   not guaranteed to represent the current location. Setting this to true will render with the
    ///   ``LocationDisplay/acquiringSymbol``, typically a grayed out location symbol.
    ///   - timestamp: A timestamp when location was received.
    ///   - additionalSourceProperties: A set of key-value pairs providing additional meta-data and properties
    ///   about the source of this location.
    public convenience init(position: ArcGIS.Point, horizontalAccuracy: Double, verticalAccuracy: Double, speed: Double, course: Double, isLastKnown: Bool = false, timestamp: Date = .now, additionalSourceProperties: [ArcGIS.Location.SourcePropertyKey : Any] = [:])

    /// A set of key-value pairs providing additional meta-data and properties about the source of this ``Location``.
    ///
    /// A ``Location`` object can be created manually or by a variety of
    /// ``LocationDataSource`` types, for example from the default platform data source or
    /// external GPS. When user code receives a new ``Location``, it can be important to
    /// determine how the information was obtained.
    ///
    /// In addition, mobile devices may provide different details about their in-built location
    /// services. For example, Android systems can provide data on the number of satellites
    /// used to find a position, whereas on iOS this information is not available. When a given
    /// property is not available to the data source the entry should be omitted from the
    /// ``additionalSourceProperties``.
    ///
    /// The ``additionalSourceProperties`` provide a means for the creator of a
    /// ``Location`` object to record flexible information such as:
    /// * The confidence level associated with the location
    /// * The method used to obtain the location
    /// * The provenance of the location
    ///
    /// Information is provided as a set of key-value pairs, where the `String` key describes
    /// the type of data held in the `Any` value. Values must be basic data types such as
    /// string, numeric, boolean or date. The creator of the ``Location`` can use any string
    /// for the key - but this API recognizes a number of well known keys which should
    /// be used if available. See ``SourcePropertyKey``:
    /// * "floor" (an integer value). The floor number of the ``Location`` when in a building.
    ///   Use ``SourcePropertyKey/floor`` to reference this key.
    /// * "satelliteCount" (an integer value). The number of satellites used to fix the
    ///   ``Location``. Use ``SourcePropertyKey/satelliteCount`` to reference this
    ///   key.
    /// * "positionSource" (a string value). This key can be used to indicate the position
    ///    source: GNSS, AppleIPS, BLE, WIFI, CELL, IP. GNSS indicates global navigation satellite
    ///    system and AppleIPS is Apples indoor positioning technology. It is possible to have
    ///    multiple position sources. In that case positionSource is a list with comma-separated values.
    ///
    /// Keys are case-sensitive.
    public var additionalSourceProperties: [ArcGIS.Location.SourcePropertyKey : Any] { get }

    /// The course of the location in degrees clockwise, 0 being `true` North.
    public var course: Double { get }

    /// The horizontal accuracy of the location in meters.
    public var horizontalAccuracy: Double { get }

    /// Indicates whether this is an outdated device position retrieved and cached earlier and therefore not guaranteed to represent the current location.
    public var isLastKnown: Bool { get }

    /// The position of the location.
    public var position: ArcGIS.Point { get }

    /// The speed of the location in meters per second.
    public var speed: Double { get }

    /// The vertical accuracy of the location in meters.
    public var verticalAccuracy: Double { get }
}

extension Location {

    /// Keys that may exist in ``additionalSourceProperties``.
    public struct SourcePropertyKey : RawRepresentable, Hashable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// Creates an instance with the specified raw value.
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(_ rawValue: String)

        /// This key can be used to indicate the floor number of a location when in a building where
        /// the ground floor is `0`. Negative numbers indicate floors below ground level.
        /// This key should be associated with an `Int` value in
        /// `Location.additionalSourceProperties`.
        public static let floor: ArcGIS.Location.SourcePropertyKey

        /// This key can be used to get the unique ID of the feature stored in the levels ``ArcGISFeatureTable`` in accordance with the ArcGIS Indoors Information Model.
        ///
        /// For more information about the levels table and ArcGIS Indoors Information Model
        /// see [the ArcGIS Pro documentation](https://pro.arcgis.com/en/pro-app/latest/help/data/indoors/arcgis-indoors-information-model.htm#ESRI_SECTION2_31525AA777E54CDD884C7F2B31F7D51B).
        ///
        /// This key should be associated with a `String` value in ``Location/additionalSourceProperties``.
        public static let floorLevelID: ArcGIS.Location.SourcePropertyKey

        /// This key can be used to indicate the position source of a location:
        /// GNSS, BLE, WIFI, CELL, IP. Where GNSS indicates global navigation satellite system.
        /// It is possible to have multiple position sources. In that case `positionSource` is a
        /// list with comma-separated values.
        /// This key should be associated with a `String` value in
        /// ``Location/additionalSourceProperties``.
        public static let positionSource: ArcGIS.Location.SourcePropertyKey

        /// This key can be used to indicate the number of satellites used to fix a location.
        /// This key should be associated with an `Int` value in
        /// ``Location/additionalSourceProperties``.
        public static let satelliteCount: ArcGIS.Location.SourcePropertyKey

        /// This key can be used to indicate the number of transmitters used to create an indoor
        /// positioning system (IPS) position.
        /// This key should be associated with an `Int` value in
        /// ``Location/additionalSourceProperties``.
        public static let transmitterCount: ArcGIS.Location.SourcePropertyKey

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }
}

/// A location data source object.
///
/// This object is to provide the location data to the location display.
/// - Since: 200.1
public class LocationDataSource {

    /// The list of possible LocationDataSource statuses.
    ///
    /// This is used to determine the status of a LocationDataSource.
    /// - Note: See Also: ``LocationDataSource``
    public enum Status {

        /// The data source is stopped.
        /// - Note: See Also: ``LocationDataSource``
        case stopped

        /// The data source is starting.
        /// - Note: See Also: ``LocationDataSource``
        case starting

        /// The data source has started.
        /// - Note: See Also: ``LocationDataSource``
        case started

        /// The data source is stopping.
        /// - Note: See Also: ``LocationDataSource``
        case stopping

        /// The data source has failed to start.
        case failedToStart

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LocationDataSource.Status, b: ArcGIS.LocationDataSource.Status) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An error that describes a problem encountered while starting or running the ``LocationDataSource``.
    ///
    /// This property is used to notify the user about errors that occur in ``LocationDataSource``. Such errors are
    /// critical for ``LocationDataSource`` and will cause it stop. If ``LocationDataSource`` cannot be started, or
    /// it stopped after a successful start, this property will store information related to what caused
    /// ``LocationDataSource`` to stop.
    @ArcGIS.Streamed public var error: Error? { get }

    public var $error: AsyncStream<Error?> { get }

    /// Heading changes from the data source.
    public var headings: AsyncStream<Double> { get }

    /// Location changes from the data source.
    public var locations: AsyncStream<ArcGIS.Location> { get }

    /// ``LocationDataSource`` status.
    @ArcGIS.Streamed public var status: ArcGIS.LocationDataSource.Status { get }

    public var $status: AsyncStream<ArcGIS.LocationDataSource.Status> { get }

    /// Start the location data source asynchronously.
    public func start() async throws
}

extension LocationDataSource {

    /// Stops the location data source asynchronously.
    public func stop() async
}

extension LocationDataSource.Status : Equatable {
}

extension LocationDataSource.Status : Hashable {
}

/// A location display object.
///
/// By default, the location display uses a blue, round symbol to show the current location. Depending on
/// signal strength, satellite positions, and other factors, the accuracy of the reported location can vary. An
/// additional blue circle around the location symbol indicates the estimated range of accuracy for the current
/// location. As locations are read from the configured ``LocationDataSource``, this outer circle may contract
/// and expand as accuracy increases or decreases.
/// - Note: See Also: `MapView.locationDisplay`
/// - Since: 200.1
final public class LocationDisplay {

    /// An enumeration of the various modes that define how the map view extent reacts to location changes.
    /// - Note: See Also: ``LocationDisplay``
    public enum AutoPanMode : CaseIterable {

        /// Displays the location symbol at the current location without adjusting the map view's extent, so no auto-panning is performed.
        case off

        /// Centers the map view at the current location, and shows the location symbol. When the current location
        /// changes, the map view is automatically panned to re-center at the new location.
        /// Behavior is affected by the wander extent factor.
        case recenter

        /// Pans the map view so that the current location symbol is shown near the bottom of the map view, and rotates
        /// the map view to align it with the direction of travel. When the current location or direction of travel
        /// changes the map view is automatically panned and rotated to maintain this position. To use this mode
        /// effectively, the device location must be moving at a speed greater than 0 meters per second.
        /// Behavior is affected by the navigation point height factor.
        case navigation

        /// Centers the map view at the current location, rotates the map view to align with the direction in which the
        /// device is currently, and shows the location symbol. When the current location or position of the
        /// device changes, the map view is automatically panned and rotated to maintain this position, thus if the
        /// device is spun in a circle, the map view stays aligned with the real world.
        case compassNavigation

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.LocationDisplay.AutoPanMode, b: ArcGIS.LocationDisplay.AutoPanMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.LocationDisplay.AutoPanMode]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.LocationDisplay.AutoPanMode] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The symbol used to represent location accuracy.
    final public var accuracySymbol: ArcGIS.Symbol

    /// The acquiring symbol. The symbol used to display last known location is being acquired.
    /// The display symbol will be changed until a new location fix is found.
    final public var acquiringSymbol: ArcGIS.Symbol

    /// Defines how location changes affect the current map view extent.
    ///
    /// Any default zooming behavior (besides scrolling) or any operation that modifies the `GeoView`
    /// viewpoint will automatically set ``autoPanMode-swift.property`` to `false`.
    /// - Note: See Also: ``AutoPanMode-swift.enum``
    @ArcGIS.Streamed final public var autoPanMode: ArcGIS.LocationDisplay.AutoPanMode

    final public var $autoPanMode: AsyncStream<ArcGIS.LocationDisplay.AutoPanMode> { get }

    /// The course symbol to display the moving location when the auto pan mode is in navigation mode.
    /// if location not moving, the default symbol will be used instead.
    final public var courseSymbol: ArcGIS.Symbol

    /// The location data source.
    final public var dataSource: ArcGIS.LocationDataSource

    /// The symbol of the default location display.
    final public var defaultSymbol: ArcGIS.Symbol

    /// The current heading value.
    final public var heading: Double { get }

    /// The heading symbol of the location display. The symbol is used for the location when the auto pan mode is in the compass mode.
    final public var headingSymbol: ArcGIS.Symbol

    /// The initial zoom scale.The map extent is zoomed in to the scale if current map extent scale is greater than the scale.
    final public var initialZoomScale: Double

    /// The last location object.
    @ArcGIS.Streamed final public var location: ArcGIS.Location? { get }

    final public var $location: AsyncStream<ArcGIS.Location?> { get }

    /// The current location point in the map projection.
    final public var mapLocation: ArcGIS.Point? { get }

    /// The navigation point height factor. The factor will decide the location symbol position vertically
    /// from the bottom of the map when the pan mode is in navigation mode.
    /// When navigating in a map, the current location is typically vertically
    /// positioned near the bottom of the map, and horizontally centered in the map, so that the map displays as
    /// much of the route ahead as possible.
    final public var navigationPointHeightFactor: Float

    /// The opacity value for the symbols of the location display, the value should be between 0 and 1.
    final public var opacity: Float

    /// The symbol used for indicating location updating.
    final public var pingAnimationSymbol: ArcGIS.Symbol

    /// The boolean value to control whether the accuracy symbol is shown.
    final public var showsAccuracy: Bool

    /// A boolean value to turn on or off for all location symbols.
    final public var showsLocation: Bool

    /// A boolean value to control whether the ping animation symbol is shown.
    final public var showsPingAnimationSymbol: Bool

    /// `true` if the course symbol on movement is used.
    final public var usesCourseSymbolOnMovement: Bool

    /// The wander extent factor.The value will control re-centering behavior of location, e.g. the value is set to 0.5,
    /// if the current moving location is out of half of map extent, the map will be re-centered.
    final public var wanderExtentFactor: Float
}

extension LocationDisplay {

    /// Create a location display with the provided location data source.
    /// - Parameter dataSource: A data source for the new location display.
    /// The default value is a ``SystemLocationDataSource`` object.
    public convenience init(dataSource: ArcGIS.LocationDataSource = SystemLocationDataSource())
}

extension LocationDisplay.AutoPanMode : Equatable {
}

extension LocationDisplay.AutoPanMode : Hashable {
}

/// An analysis object that evaluates direct, vertical, and horizontal distances between two points defined by start and end point locations.
///
/// LocationDistanceMeasurement measures the distance between a start and an end location (each using Point geometry).
/// Three distances components are calculated:
/// * Direct distance - the direct distance between the start and end location
/// * Horizontal distance - the horizontal component of the direct distance
/// * Vertical distance - the vertical component of the direct distance
/// - Note: See Also: ``Analysis``
/// - Since: 200.1
final public class LocationDistanceMeasurement : ArcGIS.Analysis {

    /// Creates a LocationDistanceMeasurement analysis object that defines a start and an end location using Point objects.
    ///
    /// The LocationDistanceMeasurement analysis result is a distance measurement between the start and end locations with direct, horizontal, and vertical components.
    /// - Parameters:
    ///   - startLocation: A point that defines the start location of the measurement.
    ///   - endLocation: A point that defines the end location of the measurement.
    /// - Precondition: `!startLocation.isEmpty`
    /// - Precondition: `startLocation.hasZ`
    /// - Precondition: `startLocation.z!.isFinite`
    /// - Precondition: `!endLocation.isEmpty`
    /// - Precondition: `endLocation.hasZ`
    /// - Precondition: `endLocation.z!.isFinite`
    public convenience init(startLocation: ArcGIS.Point, endLocation: ArcGIS.Point)

    /// The direct distance component of the LocationDistanceMeasurement.
    ///
    /// Will return `nil` before the measurement is calculated.
    final public var directDistance: Measurement<UnitLength>? { get }

    /// The end location of the LocationDistanceMeasurement.
    ///
    /// The point coordinates (x,y,z) define the end location in 3D space.
    final public var endLocation: ArcGIS.Point

    /// The horizontal distance component of the LocationDistanceMeasurement.
    ///
    /// Will return `nil` before the measurement is calculated.
    final public var horizontalDistance: Measurement<UnitLength>? { get }

    /// The new measurement when any of the distance components have changed.
    final public var measurements: AsyncStream<(directDistance: Measurement<UnitLength>, horizontalDistance: Measurement<UnitLength>, verticalDistance: Measurement<UnitLength>)> { get }

    /// The start location of the LocationDistanceMeasurement.
    ///
    /// The point coordinates (x,y,z) define the start location in 3D space.
    final public var startLocation: ArcGIS.Point

    /// The Unit System of the LocationDistanceMeasurement.
    ///
    /// The Unit System under which distances are calculated.
    final public var unitSystem: ArcGIS.UnitSystem

    /// The vertical distance component of the LocationDistanceMeasurement.
    ///
    /// Will return `nil` before the measurement is calculated.
    final public var verticalDistance: Measurement<UnitLength>? { get }
}

/// Feed data for a ``Geotrigger`` created from a ``LocationDataSource``.
///
/// The ``GeotriggerFeed`` is the dynamic component of a ``Geotrigger``. Typically, it
/// is the data that moves around and triggers the condition. For example, if the condition is
/// "notify me when my position comes within 50 meters of one of my target areas", the
/// feed data is "my position".
///
/// To receive location updates, the underlying location data source must be started.
/// If you call `GeotriggerMonitor.stop()`, the underlying ``LocationDataSource`` will not be
/// stopped for you. For example, it may continue to receive GPS readings.
///
/// If the ``LocationGeotriggerFeed`` is from a ``Geotrigger`` defined in a
/// ``GeotriggersInfo``, you must supply a ``LocationDataSource`` to
/// provide the device location. Set the ``locationDataSource`` to your
/// ``LocationDataSource`` - for example, using the ``LocationDisplay/dataSource``.
///
/// A ``FenceGeotrigger`` can also take into account floors within buildings. If the feature
/// table used to create the ``FeatureFenceParameters`` is referenced by a ``FeatureLayer`` that
/// is ``FloorAware``, and the ``LocationDataSource`` used to create the ``GeotriggerFeed``
/// includes ``Location/SourcePropertyKey/floor`` information, then fences will only be
/// entered when they are intersected by a ``Location`` on the correct floor. If the fence or
/// location data does not include valid floor information, the floor is ignored and the fence
/// is entered when it is intersected by the location.
///
/// A floor aware feature layer or table must be part of a ``GeoModel`` that includes a valid
/// ``GeoModelFloorDefinition``. All layers and tables that are used by the floor definition
/// are loaded when the ``GeotriggerMonitor`` is started.
///
/// A ``Location`` can contain floor property as part of
/// ``Location/additionalSourceProperties``. This is populated automatically by
/// ``IndoorsLocationDataSource``, or can be supplied as part of your own implementation.
/// - Since: 200.1
final public class LocationGeotriggerFeed : ArcGIS.GeotriggerFeed {

    /// An ``ArcadeExpression`` that controls whether an update from the ``LocationGeotriggerFeed`` is sent to a ``GeotriggerMonitor``.
    ///
    /// The expression uses the Arcade language to determine whether feed entity updates are
    /// suitable for monitoring. The ``ArcadeExpression`` must evaluate to a boolean where:
    ///
    /// * `true` indicates that the update will be used.
    /// * `false` indicates that the update will not be used.
    ///
    /// Filtering out undesirable updates reduces inaccurate notifications from your
    /// ``GeotriggerMonitor``. For example, you could filter out GPS updates where the
    /// horizontal accuracy is poor, to avoid `false` enter and exit notifications.
    ///
    /// With a ``LocationGeotriggerFeed``, the expression inspects a new ``Location`` object and
    /// returns `true` if it is suitable and `false` if not. Typically, your expression excludes
    /// ``Location`` objects where the ``Location/horizontalAccuracy`` does not meet your
    /// criteria - but it could also consider other properties such as ``Location/speed`` and
    /// ``Location/course``.
    ///
    /// Arcade gives you access to the properties of the feed entity with the $locationupdate
    /// profile variable. This represents a new ``Location`` received from your device GPS. For
    /// example, an ``ArcadeExpression`` with the following string rejects ``Location`` updates
    /// with a horizontal accuracy greater than 10 meters:
    ///
    /// return $locationupdate.horizontalaccuracy <= 10;
    final public var filter: ArcGIS.ArcadeExpression?

    /// The location data source that provides updates for the device location.
    ///
    /// To receive location updates, the underlying location data source must be
    /// started. If you call `GeotriggerMonitor.stop()`, the underlying
    /// ``LocationDataSource`` is not stopped for you. In other words, it may continue to
    /// receive GPS readings.
    final public var locationDataSource: ArcGIS.LocationDataSource?
}

extension LocationGeotriggerFeed {

    /// Creates an instance with the given location data source.
    /// - Parameter locationDataSource: A location data source that provides
    /// updates for the device location. The default value is `nil`.
    public convenience init(locationDataSource: ArcGIS.LocationDataSource? = nil)
}

/// An analysis object that evaluates visibility along a line defined by observer and target point objects.
///
/// LocationLineOfSight renders a line between an observer location and a target location, each defined using a Point geometry.
/// Visible and obstructed portions of the line are displayed with unique colors (green and red by default).
/// - Note: See Also: ``LineOfSight``, ``Analysis``
/// - Since: 200.1
final public class LocationLineOfSight : ArcGIS.LineOfSight {

    /// Creates a LineOfSight analysis object that defines an observer and a target using Point objects.
    ///
    /// The LineOfSight analysis result is a line rendered between the observer and target locations with distinct colors representing visible and obstructed segments.
    /// - Parameters:
    ///   - observerLocation: A point that defines the location of the observer.
    ///   - targetLocation: A point that defines the location of the target.
    public convenience init(observerLocation: ArcGIS.Point, targetLocation: ArcGIS.Point)

    /// The observer location of the LocationLineOfSight.
    ///
    /// The point coordinates (x,y,z) define the observer location in 3D space.
    final public var observerLocation: ArcGIS.Point

    /// The target point location of the LocationLineOfSight.
    ///
    /// The point coordinates (x,y,z) define the target location in 3D space.
    final public var targetLocation: ArcGIS.Point
}

/// A type that can provide locations and headings asynchronously.
public protocol LocationProvider {

    /// The type of the locations sequence provided by this provider.
    associatedtype Locations : AsyncSequence where Self.Locations.Element == ArcGIS.Location

    /// The type of the headings sequence provided by this provider.
    associatedtype Headings : AsyncSequence where Self.Headings.Element == Double

    /// An asynchronous sequence of locations.
    var locations: Self.Locations { get }

    /// An asynchronous sequence of headings.
    var headings: Self.Headings { get }
}

/// Status regarding the network location associated with a stop.
/// - Since: 200.1
public enum LocationStatus {

    /// A not located status.
    case notLocated

    /// Located on closest network element.
    case onClosest

    /// Located on closest network element which is not restricted.
    case onClosestNotRestricted

    /// The network location can't be arrived at by the solver.
    case notReached

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.LocationStatus, b: ArcGIS.LocationStatus) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension LocationStatus : Equatable {
}

extension LocationStatus : Hashable {
}

/// LocationViewshed is an analysis object that renders a viewshed for a specified point location.
///
/// LocationViewshed determines visible and non-visible areas in a scene view for an observer defined with a map location (point).
/// - Note: See Also: ``Viewshed``, ``Analysis``
/// - Since: 200.1
final public class LocationViewshed : ArcGIS.Viewshed {

    /// The observer's heading.
    ///
    /// The heading represents the azimuth of the observer's direction of view. The value provided will be normalized to a value between 0 and 360 degrees.
    final public var heading: Double

    /// The observer location of the viewshed.
    final public var location: ArcGIS.Point

    /// The pitch of the observer's field of vision.
    ///
    /// Pitch is the angle of the observer's field of vision relative to the surface. Valid values are from 0 (looking straight down) to 180 (straight up).
    final public var pitch: Double

    /// Updates the frustum of the viewshed using the properties of the supplied Camera.
    ///
    /// The Camera is used to update the position, pitch, and heading of the viewshed frustum.
    /// - Parameter camera: A Camera from which the viewshed will be updated.
    final public func update(from camera: ArcGIS.Camera)
}

extension LocationViewshed {

    /// Creates a viewshed analysis object whose observer is defined using a point location.
    /// - Remark: Visible and non-visible areas are determined for an area defined by the camera and the min/max distance range.
    /// The parameters define the frustum over which visibility is calculated from the camera/observer location.
    /// Terrain and other obstacles between the observer and the minimum distance are excluded
    /// from the analysis, as are areas beyond the maximum distance.
    /// - Parameters:
    ///   - camera: A camera to define the frustum of the viewshed. The camera location is that of the observer.
    ///   - minDistance: The minimum distance from the observer at which visibility will be evaluated.
    ///   The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - maxDistance: The maximum distance from the observer at which visibility will be evaluated.
    ///   The value should be greater than or equal to zero. If `nil`, there is no maximum.
    public convenience init(camera: ArcGIS.Camera, minDistance: Double? = nil, maxDistance: Double? = nil)

    /// Creates a viewshed analysis object whose observer is defined using a point location.
    /// - Remark: Visible and non-visible areas are determined for an area defined by the observer location,
    /// view angles, and the min/max distance range. The parameters define the frustum over which visibility
    ///  is calculated from the observer location. The horizontal and vertical angles must be greater than zero to define a valid
    /// frustum and are constrained to a maximum of `120` degrees. Terrain and other obstacles between the
    /// observer and the minimum distance are excluded from the analysis, as are areas beyond the maximum distance.
    /// - Parameters:
    ///   - location: A geographic point location for the observer.
    ///   - heading: The heading value (azimuth) that defines the observer's view direction.
    ///   - pitch: The pitch value (angle) of the observer's view relative to the surface. Valid values
    ///   are from `0` (looking straight down) to `180` (straight up).
    ///   - horizontalAngle: The horizontal angle of the observer's view.
    ///   - verticalAngle: The vertical angle of the observer's view.
    ///   - minDistance: The minimum distance from the observer at which visibility will be evaluated.
    ///   The value should be greater than or equal to zero. If `nil`, there is no minimum.
    ///   - maxDistance: The maximum distance from the observer at which visibility will be evaluated.
    ///   The value should be greater than or equal to zero. If `nil`, there is no maximum.
    ///   - Precondition: `!location.isEmpty`
    ///   - Precondition: `horizontalAngle > 0 && horizontalAngle <= 360`
    ///   - Precondition: `verticalAngle > 0 && verticalAngle <= 360`
    public convenience init(location: ArcGIS.Point, heading: Double, pitch: Double, horizontalAngle: Double, verticalAngle: Double, minDistance: Double? = nil, maxDistance: Double? = nil)
}

/// A class that declares description of attributes.
/// - Since: 200.1
final public class LocatorAttribute {

    /// Display name.
    ///
    /// Display name (alias) of attribute.
    final public var displayName: String { get }

    /// Required status of locator attribute.
    ///
    /// Determines attribute is mandatory.
    final public var isRequired: Bool { get }

    /// Name.
    ///
    /// Name of attribute.
    final public var name: String { get }
}

/// A class that contains information about supports the ability and return attributes.
///
/// Class containing the information for a ``LocatorTask``, either an online locator created from an
/// ArcGIS geocode service, or a local locator created from local data.
/// - Since: 200.1
final public class LocatorInfo {

    /// Description of locator.
    final public var description: String { get }

    /// Intersection result attributes.
    ///
    /// Array of output fields for intersections geocoding. Empty if intersections geocoding is not supported.
    /// - Note: See Also: `Array`, ``LocatorAttribute``
    final public var intersectionResultAttributes: [ArcGIS.LocatorAttribute] { get }

    /// Name of locator.
    final public var name: String { get }

    /// Properties of locator task.
    /// - Note: See Also: `Dictionary`
    final public var properties: [String : String] { get }

    /// Result attributes.
    ///
    /// Array of output fields for addresses geocoding.
    /// - Note: See Also: `Array`, ``LocatorAttribute``
    final public var resultAttributes: [ArcGIS.LocatorAttribute] { get }

    /// Search attributes.
    ///
    /// Array of input fields for multiline addresses geocoding.
    /// - Note: See Also: `Array`, ``LocatorAttribute``
    final public var searchAttributes: [ArcGIS.LocatorAttribute] { get }

    /// Spatial reference.
    ///
    /// Locator task internal spatial reference.
    /// - Note: See Also: ``SpatialReference``
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// Supports of addresses.
    ///
    /// `true` if addresses (point address or street address) are supported by locator task.
    final public var supportsAddresses: Bool { get }

    /// Supports of intersections.
    ///
    /// `true` if intersections a supported by locator task.
    final public var supportsIntersections: Bool { get }

    /// Supports of POI.
    ///
    /// `true` if POI is supported by locator task.
    final public var supportsPOI: Bool { get }

    /// Supports of suggestions.
    ///
    /// `true` if suggest is supported by locator task.
    final public var supportsSuggestions: Bool { get }

    /// Version of locator task.
    final public var version: String { get }
}

/// A class can be used to convert an address to a point (geocode) or vice-versa (reverse geocode).
///
/// ``LocatorTask`` involves finding matching locations for a given address.
/// Reverse-geocoding is the opposite and involves finding corresponding addresses for a given location.
/// - Since: 200.1
final public class LocatorTask : ArcGIS.APIKeyResource, ArcGIS.Loadable {

    /// Creates a new locator task object.
    /// - Parameter url: The URI of online service or local locator.
    public convenience init(url: URL)

    /// Locator info.
    ///
    /// Information about locator.
    /// - Note: See Also: ``LocatorInfo``
    final public var locatorInfo: ArcGIS.LocatorInfo? { get }

    /// The URI of online service or local locator.
    /// - Note: See Also: `String`
    final public var url: URL? { get }

    /// Geocodes address with parameters and returns candidates.
    ///
    /// Executes a geocoding operation to find location candidates for a given address.
    /// - Parameters:
    ///   - searchText: Address inputs.
    ///   - parameters: Geocode method parameters.
    /// - Returns: An `Array` of ``GeocodeResult``
    /// - Note: See Also: ``GeocodeResult``, ``GeocodeResult``
    final public func geocode(forSearchText searchText: String, using parameters: ArcGIS.GeocodeParameters? = nil) async throws -> [ArcGIS.GeocodeResult]

    /// Geocodes multiline address with parameters and returns candidates.
    ///
    /// Executes a geocoding operation to find location candidates for a given multiline address.
    /// - Parameters:
    ///   - searchValues: Multiline address inputs.
    ///   - parameters: Geocode method parameters.
    /// - Returns: An `Array` of ``GeocodeResult``
    /// - Note: See Also: ``GeocodeResult``, ``GeocodeResult``
    final public func geocode(forSearchValues searchValues: [String : String], using parameters: ArcGIS.GeocodeParameters? = nil) async throws -> [ArcGIS.GeocodeResult]

    /// Geocodes suggest with parameters and returns candidates.
    ///
    /// Executes geocoding based on result of suggestion.
    /// - Parameters:
    ///   - suggestResult: Suggest method result.
    ///   - parameters: Geocode parameters.
    /// - Returns: An `Array` of ``GeocodeResult``
    /// - Note: See Also: ``GeocodeResult``, ``GeocodeResult``
    final public func geocode(forSuggestResult suggestResult: ArcGIS.SuggestResult?, using parameters: ArcGIS.GeocodeParameters? = nil) async throws -> [ArcGIS.GeocodeResult]

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension LocatorTask {

    /// Performs a reverse geocode operation to find address candidates for the provided location.
    /// - Parameters:
    ///   - location: The location point to reverse geocode.
    ///   - parameters: The reverse geocode parameters to refine the results returned.
    /// - Returns: The results of the reverse geocode operation.
    final public func reverseGeocode(forLocation location: ArcGIS.Point, parameters: ArcGIS.ReverseGeocodeParameters? = nil) async throws -> [ArcGIS.GeocodeResult]

    /// Suggests an address with parameters and returns possible variants.
    /// - Remark: Geocoding suggestions provide a mechanism for implementing character-by-character auto-complete.
    /// Using a text input and suggest parameters, suggested addresses can be quickly found and
    /// presented to the user. Suggestions are not limited to addresses, they can also be used for POIs
    /// (Points of Interest). To return a focused set of suggestions, set the ``SuggestParameters/preferredSearchLocation``
    /// or the ``SuggestParameters/searchArea``. Using the ``SuggestParameters/preferredSearchLocation`` is
    /// similar to how ArcGIS Pro limits the suggestions returned.
    /// - Parameters:
    ///   - searchText: The search text to find suggestions for.
    ///   - parameters: The suggest parameters to refine the results returned.
    /// - Returns: The results of the suggest operation.
    final public func suggest(forSearchText searchText: String, parameters: ArcGIS.SuggestParameters? = nil) async throws -> [ArcGIS.SuggestResult]
}

/// A class that represents the display of the Military Grid
/// Reference System (MGRS) on the map view.
///
/// The military grid reference system is the geocoordinate standard
/// used by various militaries for locating points on the earth. The
/// MGRS grid is derived from the Universal Transverse Mercator (UTM)
/// grid system and the universal polar stereographic (UPS) grid system,
/// but uses a different labeling convention. MGRS is used for the
/// entire earth.
///
/// To display the MGRS grid, create a MGRSGrid and set it as the grid
/// property within the MapView.
///
/// MGRSGrid inherits from Grid and adds a property for the label unit
/// to use.
/// - Note: See Also: `MapView.grid`
/// - Since: 200.1
final public class MGRSGrid : ArcGIS.Grid {

    /// The unit to use when labeling a ``MGRSGrid``.
    /// - Note: See Also: ``MGRSGrid``
    public enum LabelUnit {

        /// Label the grid in either Kilometers or Meters, depending on the
        /// scale of the map view.
        case kilometersMeters

        /// Label the grid in Meters.
        case meters

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.MGRSGrid.LabelUnit, b: ArcGIS.MGRSGrid.LabelUnit) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Constructs an MGRS grid for displaying on a map view.
    ///
    /// The grid is supported in spatial references which are continuously
    /// pannable or some polar spatial references.
    /// You can check the ``SpatialReference/isPannable`` property is `true` on your
    /// spatial reference.  Examples of continuously pannable spatial
    /// references include WGS84 (WKID 4326) and Web Mercator Auxiliary
    /// Sphere (WKID 102113, 102100, or 3857).
    ///
    /// The following polar spatial references are also supported:
    /// * North pole Azimuthal Equidistant (WKID 102016)
    /// * North pole gnomic (WKID 102034)
    /// * North pole Lambert equal area (WKID 102017)
    /// * North pole orthographic (WKID 102035)
    /// * North pole stereographic (WKID 102018)
    /// * NSIDE EASE North (WKID 3408)
    /// * NSIDC Sea Ice polar stereographic north (WKID 3411)
    /// * WGS 1984 NSIDC Sea Ice Polar Stereographic North (WKID 3413)
    /// * UPS North (WKID 32661)
    /// * South pole Azimuthal Equidistant (WKID 102019)
    /// * South pole gnomic (WKID 102036)
    /// * South pole Lambert equal area (WKID 102020)
    /// * South pole orthographic (WKID 102037)
    /// * South pole stereographic (WKID 102021)
    /// * NSIDE EASE South (WKID 3409)
    /// * NSIDC Sea Ice polar stereographic South (WKID 3412)
    /// * UPS South (WKID 32761)
    /// * WGS1984 Antarctic polar stereographic (WKID 3031)
    public convenience init()

    /// The units used for labeling the grid.
    final public var labelUnit: ArcGIS.MGRSGrid.LabelUnit
}

extension MGRSGrid.LabelUnit : Equatable {
}

extension MGRSGrid.LabelUnit : Hashable {
}

/// Filter features from the display based on the specified active display filter.
///
/// This is useful when making visual comparisons of the data, or filtering out specific pieces of data.
/// - Note: See Also: ``ScaleDisplayFilterDefinition``
/// - Since: 200.1
final public class ManualDisplayFilterDefinition : ArcGIS.DisplayFilterDefinition {

    /// Creates a new ``ManualDisplayFilterDefinition`` with the specified active and available filters.
    /// - Parameters:
    ///   - activeFilter: A display filter from ``availableFilters`` to apply.
    ///   - availableFilters: The collection of display filters that can be applied.
    public convenience init(activeFilter: ArcGIS.DisplayFilter?, availableFilters: [ArcGIS.DisplayFilter])

    /// A display filter from ``availableFilters`` to apply.
    ///
    /// To enable display filter on a layer, specify a filter that is part of ``availableFilters``.
    /// If no active filter is set, then no display filter is applied.
    final public var activeFilter: ArcGIS.DisplayFilter?

    /// The collection of display filters that can be applied.
    ///
    /// To enable display filter on a layer, specify a ``activeFilter``
    /// that is part of this collection.
    ///
    /// If the specified ``activeFilter`` does not appear to be applied,
    /// check the layer's ``LayerViewState`` for a ``LayerViewState/Status-swift.struct/warning`` as there might be a
    /// ``LayerViewState/error`` describing that display filter's where clause is not valid.
    ///
    /// Note that should collection contain a ``ScaleRangeDisplayFilter``, its ``ScaleRangeDisplayFilter/minScale``
    /// and ``ScaleRangeDisplayFilter/maxScale`` are both ignored.
    /// - Note: See Also: ``DisplayFilter``, ``ScaleRangeDisplayFilter``
    final public var availableFilters: [ArcGIS.DisplayFilter] { get }

    /// Adds a sequence of `DisplayFilter` values to the end of the `availableFilters` property.
    /// - Parameter newAvailableFilters: The new `DisplayFilter` values to append.
    final public func addAvailableFilters<S>(_ newAvailableFilters: S) where S : Sequence, S.Element == ArcGIS.DisplayFilter

    /// Adds a `DisplayFilter` value to the end of the `availableFilters` property.
    /// - Parameter newAvailableFilter: The new `DisplayFilter` value to append.
    final public func addAvailableFilter(_ newAvailableFilter: ArcGIS.DisplayFilter)

    /// Inserts a collection of `DisplayFilter` values into the `availableFilters` property at the specified position.
    /// - Parameters:
    ///   - newAvailableFilters: The new `DisplayFilter` values to insert.
    ///   - index: The position at which to insert the new `DisplayFilter` values.
    final public func insertAvailableFilters<C>(_ newAvailableFilters: C, at index: Int) where C : Collection, C.Element == ArcGIS.DisplayFilter

    /// Inserts a `DisplayFilter` value into the `availableFilters` property at the specified position.
    /// - Parameters:
    ///   - newAvailableFilter: The new `DisplayFilter` value to insert.
    ///   - index: The position at which to insert the new `DisplayFilter` value.
    final public func insertAvailableFilter(_ newAvailableFilter: ArcGIS.DisplayFilter, at index: Int)

    /// Removes all values from the `availableFilters` property.
    final public func removeAllAvailableFilters()

    /// Removes a sequence of `DisplayFilter` values from the `availableFilters` property.
    /// - Parameter availableFilters: The `DisplayFilter` values to remove.
    final public func removeAvailableFilters<S>(_ availableFilters: S) where S : Sequence, S.Element == ArcGIS.DisplayFilter

    /// Removes a `DisplayFilter` value from the `availableFilters` property.
    /// - Parameter availableFilter: The `DisplayFilter` value to remove.
    final public func removeAvailableFilter(_ availableFilter: ArcGIS.DisplayFilter)
}

/// A map is a container for layers. Use a map together with a `MapView` to display layers of geographic data in 2D.
///
/// ``Map`` contains layers of mapping data and information such as basemaps, popups, renderers, and labels which
/// define the map's capabilities. You can access ``Map`` content directly or visualize the map in a `MapView`.
///
/// In an MVC architecture, ``Map`` represents the model and `MapView` represents the view. ``Map``
/// specifies how the geographic data is organized, and `MapView` renders the data on the screen and
/// allows users to interact with it.
///
/// A map can contain a basemap and one or more operational layers:
///
/// * A basemap is a map layer that helps orient the user of the map. Typically it sits behind operational layers and shows roads and parcel boundaries to give context to operational layers. Basemaps can also contain layers which are drawn over the top operational layers such as label layers.
/// * An operational layer provides content that is of unique interest to the app and the task at hand, such as data about earthquakes, traffic, or weather. Its content might change frequently.
///
/// You can create a map from an existing web map using its URL or ``PortalItem``. Alternatively,
/// you can get a map directly from a ``MobileMapPackage/maps`` collection. ``Map`` properties
/// will be hydrated when the map is loaded.
///
/// If you create a new map, the spatial reference of the first layer you add, which is typically
/// the first layer in the ``Basemap``, defines the spatial reference of the entire map,
///
/// See [Maps 2D](https://developers.arcgis.com/documentation/mapping-apis-and-services/maps/maps-2d/) for more information about maps.
/// - Note: See Also: ``GeoModel/operationalLayers``, ``GeoModel/basemap``
/// - Since: 200.1
final public class Map : ArcGIS.GeoModel, ArcGIS.JSONSerializable {

    /// Creates a map with a ``Basemap``.
    /// - Parameter basemap: A basemap object.
    public convenience init(basemap: ArcGIS.Basemap)

    /// Creates a map with a ``Basemap/Style``.
    /// - Parameter basemapStyle: The basemap style.
    /// - Note: See Also: ``Basemap/Style``
    public convenience init(basemapStyle: ArcGIS.Basemap.Style)

    /// Creates a map with a portal item of type ``PortalItem/Kind-swift.enum/webMap``.
    ///
    /// The ``PortalItem`` automatically loads when the ``Map`` loads. If the loaded ``Item`` is not
    /// a portal item of type ``PortalItem/Kind-swift.enum/webMap``, the map fails to load.
    /// - Parameter item: A web map ``PortalItem``.
    public convenience init(item: ArcGIS.Item)

    /// Creates a map with the specified spatial reference.
    /// - Parameter spatialReference: A spatial reference object.
    public convenience init(spatialReference: ArcGIS.SpatialReference? = nil)

    /// Creates a map with the URL to a web map.
    ///
    /// If the specified URL is a portal item URL, the underlying ``PortalItem`` is created and can be
    /// accessed through ``GeoModel/item``. The URL can be a URL to web map JSON content or the URL of a portal item.
    ///
    /// Examples of supported URL formats:
    /// * The web map viewer page, for example:
    ///   https://www.arcgis.com/apps/mapviewer/index.html?webmap=55ebf90799fa4a3fa57562700a68c405
    /// * The web map viewer page (classic), for example:
    ///   https://www.arcgis.com/home/webmap/viewer.html?webmap=55ebf90799fa4a3fa57562700a68c405
    /// * The web map item details page, for example:
    ///   https://www.arcgis.com/home/item.html?id=55ebf90799fa4a3fa57562700a68c405
    /// * The REST sharing API data page, for example:
    ///   https://www.arcgis.com/sharing/rest/content/items/55ebf90799fa4a3fa57562700a68c405/data
    /// * The REST sharing API page (with or without the query parameter f=json), for example:
    ///   https://www.arcgis.com/sharing/rest/content/items/55ebf90799fa4a3fa57562700a68c405?f=json
    /// - Parameter url: URL of a web map on ArcGIS Online or ArcGIS Enterprise portal.
    /// - Note: See Also: ``PortalItem``, ``PortalItem/init(url:)``, ``GeoModel/item``
    public convenience init?(url: URL)

    /// The background color of the map.
    ///
    /// This value specifies the color to be displayed behind the map. This color will be displayed in
    /// transparent areas of the map and areas where there is no basemap or operational data.
    ///
    /// When a map is set on a `MapView`, changes to ``backgroundColor`` take immediate effect.
    ///
    /// The default value is `nil`. In this case, the `MapView.backgroundGrid` specifies the background color.
    final public var backgroundColor: UIColor?

    /// The extent that constrains the display to a specific region.
    ///
    /// The max extent is initialized when the map loads or when you set it explicitly. This value limits
    /// panning in the `MapView` to a specific area of the map.
    ///
    /// If the max extent is `nil` when the map loads, or you set it to `nil`, max extent is calculated from the
    /// union of the full extent of all basemap layers. If there is no basemap, it is set as the full extent
    /// of the map's first operational layer.
    ///
    /// If the ``GeoModel/initialViewpoint`` is not set, the max extent is used as the initial viewpoint. If
    /// the ``GeoModel/initialViewpoint`` is set, but is outside of the max extent, the max extent
    /// takes precedence and the display will initially show the max extent.
    final public var maxExtent: ArcGIS.Envelope?

    /// The maximum scale for the map. If `nil`, there is no maximum.
    ///
    /// Will be `nil` if the map is not loaded or if there is no maximum scale and the user can zoom in indefinitely.
    final public var maxScale: Double?

    /// The minimum scale for the map. If `nil`, there is no minimum.
    ///
    /// Will be `nil` if the map is not loaded or if there is no minimum scale and the user can zoom out indefinitely.
    final public var minScale: Double?

    /// Offline settings configured by the author of an online web map (if appropriate).
    ///
    /// Offline settings optimize the data that is delivered during download and synchronization. For example,
    /// they can control feature and attachment delivery or define whether the map's basemap is created using
    /// a tile package already on the device.
    ///
    /// This property is `nil` unless the map represents an online web map and the author has configured the
    /// offline settings.
    final public var offlineSettings: ArcGIS.OfflineSettings? { get }

    /// The reference scale for the map. If `nil`, there is no reference scale.
    ///
    /// The reference scale is the scale at which feature symbols and text will appear at their authored
    /// size. If the viewing scale is different from the reference scale, then the symbology and text
    /// graphics will be scaled to keep the same size on the map. Only those layers for which
    /// scaleSymbols is `true` will be scaled. For example, ``FeatureLayer/scalesSymbols``.
    ///
    /// The default value is 0.0. Zero reference scale means that no reference scale is set and all symbology and text graphics will be drawn at their default screen size.
    ///
    /// Updates to the reference scale will redraw other layers that use the reference scale,
    /// and may redraw other layers that depend on them. For example, dynamic labels may need to
    /// re-position to avoid overlaps.
    final public var referenceScale: Double?

    /// The URI for the map.
    /// - Note: See Also: ``Map``
    final public var url: URL? { get }

    /// The utility networks in the map.
    ///
    /// This collection of ``UtilityNetwork`` is specific to this map.
    ///
    /// A ``Map`` created with a web map portal item with utility networks will pre-populate this collection.
    ///
    /// When this ``Map`` is used to create an ``UtilityNetwork``, the ``UtilityNetwork`` that was created will
    /// be added to this collection.
    ///
    /// Only an ``UtilityNetwork`` that is not loaded may be added to this collection. An attempt to add an ``UtilityNetwork``
    /// that is loaded or loading will throw a `CoreErrorCode.commonInvalidCall` error.
    ///
    /// An attempt to add an ``UtilityNetwork`` that is already part of a ``utilityNetworks`` to this collection
    /// will throw a `CoreErrorCode.commonObjectAlreadyOwned` error.
    ///
    /// An attempt to add a `nil` ``UtilityNetwork`` to this collection will throw a `CoreErrorCode.commonNullPtr` error.
    final public var utilityNetworks: [ArcGIS.UtilityNetwork] { get }

    /// Adds a sequence of `UtilityNetwork` values to the end of the `utilityNetworks` property.
    /// - Parameter newUtilityNetworks: The new `UtilityNetwork` values to append.
    final public func addUtilityNetworks<S>(_ newUtilityNetworks: S) where S : Sequence, S.Element == ArcGIS.UtilityNetwork

    /// Adds an `UtilityNetwork` value to the end of the `utilityNetworks` property.
    /// - Parameter newUtilityNetwork: The new `UtilityNetwork` value to append.
    final public func addUtilityNetwork(_ newUtilityNetwork: ArcGIS.UtilityNetwork)

    /// Inserts a collection of `UtilityNetwork` values into the `utilityNetworks` property at the specified position.
    /// - Parameters:
    ///   - newUtilityNetworks: The new `UtilityNetwork` values to insert.
    ///   - index: The position at which to insert the new `UtilityNetwork` values.
    final public func insertUtilityNetworks<C>(_ newUtilityNetworks: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityNetwork

    /// Inserts an `UtilityNetwork` value into the `utilityNetworks` property at the specified position.
    /// - Parameters:
    ///   - newUtilityNetwork: The new `UtilityNetwork` value to insert.
    ///   - index: The position at which to insert the new `UtilityNetwork` value.
    final public func insertUtilityNetwork(_ newUtilityNetwork: ArcGIS.UtilityNetwork, at index: Int)

    /// Removes all values from the `utilityNetworks` property.
    final public func removeAllUtilityNetworks()

    /// Removes a sequence of `UtilityNetwork` values from the `utilityNetworks` property.
    /// - Parameter utilityNetworks: The `UtilityNetwork` values to remove.
    final public func removeUtilityNetworks<S>(_ utilityNetworks: S) where S : Sequence, S.Element == ArcGIS.UtilityNetwork

    /// Removes an `UtilityNetwork` value from the `utilityNetworks` property.
    /// - Parameter utilityNetwork: The `UtilityNetwork` value to remove.
    final public func removeUtilityNetwork(_ utilityNetwork: ArcGIS.UtilityNetwork)

    /// Returns a collection of all the ``UtilityNamedTraceConfiguration`` objects referenced by
    /// ``UtilityNetwork``'s map.
    ///
    /// An empty collection is returned if the ``UtilityNetwork`` does not belong to the map or if the map
    /// does not contain any ``UtilityNamedTraceConfiguration`` objects.
    /// - Parameter utilityNetwork: The ``UtilityNetwork``.
    /// - Returns: An array of the ``UtilityNamedTraceConfiguration`` objects referenced by the ``UtilityNetwork``'s map.
    /// - Note: See Also: ``UtilityNamedTraceConfiguration``
    final public func namedTraceConfigurations(from utilityNetwork: ArcGIS.UtilityNetwork) async throws -> [ArcGIS.UtilityNamedTraceConfiguration]

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension Map {

    /// Unknown data from the source JSON.
    /// - Remark: Unknown JSON is a dictionary of values that was in the source JSON but was unparsed by this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    final public var _unknownJSON: [String : Any] { get }

    /// Unsupported data from the source JSON.
    /// - Remark: Unsupported JSON is a dictionary of values that are supported by webmaps, but not exposed by this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    final public var _unsupportedJSON: [String : Any] { get }
}

extension Map {

    /// Saves this map as a new web map on the specified portal with the given title in the given
    /// folder.
    ///
    /// Once completed, the map's `item` property will be populated with the new portal item. Note
    /// that if the map already has a valid item property (either because the map was created using
    /// an item or was previously saved), that property will be replaced with a new item, effectively
    /// 'duplicating' the map on the portal.
    /// - Parameters:
    ///   - portal: The portal to save the map to.
    ///   - title: The title of the map.
    ///   - forceSaveToSupportedVersion: A Boolean value indicating whether the map should be saved
    ///   to the supported web map version that the API supports (see system requirements). This may
    ///   cause data loss as unknown data is not saved. If `true`, unknown data will be removed and
    ///   the map will be saved. If `false`, the operation will fail if the map contains unknown data
    ///   that will not be saved. This flag can be used to provide a warning to users that some map
    ///   data may be lost when the map is saved.
    ///   - folder: The folder in which to save the map. If `nil` is passed it will be added to the
    ///   user's root folder.
    ///   - description: The description of the map.
    ///   - thumbnail: The thumbnail of the map. The recommended thumbnail image size is 200 pixels
    ///   wide by 133 pixels high. Acceptable image formats are PNG, GIF, and JPEG with a maximum
    ///   file size of 1 MB.
    ///   - tags: The tags to be associated with the newly created portal item.
    ///   - extent: The extent of the item. If `nil`, ``Map/maxExtent`` will be used.
    final public func save(to portal: ArcGIS.Portal, title: String, forceSaveToSupportedVersion: Bool, folder: ArcGIS.PortalFolder? = nil, description: String = "", thumbnail: UIImage? = nil, tags: [String] = [], extent: ArcGIS.Envelope? = nil) async throws

    /// Updates this map back to the item it originated from.
    ///
    /// An error will occur if the map does not have a valid `item` property. A map has a valid item
    /// property if it was created using either ``Map/init(item:)`` or ``Map/init(url:)``, or has
    /// been previously saved as a new item using ``Map/save(to:title:forceSaveToSupportedVersion:folder:description:thumbnail:tags:extent:)``.
    /// - Parameter forceSaveToSupportedVersion: A Boolean value indicating whether the map should be
    /// saved to the supported web map version that the API supports (see system requirements). This
    /// may cause data loss as unknown data is not saved. If `true`, unknown data will be removed and
    /// the map will be saved. If `false`, the operation will fail if the map contains unknown data
    /// that will not be saved. This Boolean value can be used to provide a warning to users that
    /// some map data may be lost when the map is saved.
    final public func update(forceSaveToSupportedVersion: Bool) async throws
}

/// Indicates the capabilities of an ArcGIS map service, including whether it supports exporting map images, data
/// and query operations.
/// - Since: 200.1
@frozen public struct MapServiceCapabilities : OptionSet, Hashable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: Int

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: Int)

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = ArcGIS.MapServiceCapabilities

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = ArcGIS.MapServiceCapabilities

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int
}

extension MapServiceCapabilities {

    /// Indicates that the map service supports various data operations.
    /// - Remark: These include operations like find, query, and related
    /// records. All ArcGIS REST API operations define their required capability
    /// in the REST API help documentation.
    public static let data: ArcGIS.MapServiceCapabilities

    /// Indicates that the map service supports the map capability.
    /// - Remark: This includes operations like exporting map images and listing
    /// all layers and tables. All ArcGIS REST API operations define their
    /// required capability in the REST API help documentation.
    public static let map: ArcGIS.MapServiceCapabilities

    /// Indicates that the map service supports query operations.
    /// - Remark: This includes operations like identify and  accessing
    /// attachment data. All ArcGIS REST API operations define their required
    /// capability in the REST API help documentation.
    public static let query: ArcGIS.MapServiceCapabilities

    /// Indicates that the map service supports tile map.
    public static let tileMap: ArcGIS.MapServiceCapabilities

    /// Indicates that the map service supports tiles only.
    /// - Remark: You can't create an ``ArcGISMapImageLayer`` instance from a
    /// service that supports tiles only.
    public static let tilesOnly: ArcGIS.MapServiceCapabilities
}

extension MapServiceCapabilities : Sendable {
}

/// The image formats supported by ArcGIS map services or ArcGIS image services.
/// - Since: 200.1
public enum MapServiceImageFormat {

    /// To use service-defined default image format.
    case `default`

    /// PNG. Supported in Map Service only.
    case png

    /// 8-bit PNG. Supported in both Image Service and Map Service.
    case png8

    /// 24bit PNG. Supported in both Image Service and Map Service.
    case png24

    /// PNG32. Supported in Image Service and Map Service.
    case png32

    /// JPEG. Supported in both Image Service and Map Service.
    case jpg

    /// JPG | PNG. Supported in Image Service only.
    ///
    /// Note that support for the jpgpng format was added at 10.0. This
    /// format returns a JPG if there are no transparent pixels in the requested
    /// extent, otherwise it returns a PNG.
    case jpgPNG

    /// BMP.
    case bmp

    /// GIF.
    case gif

    /// TIFF.
    case tiff

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.MapServiceImageFormat, b: ArcGIS.MapServiceImageFormat) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension MapServiceImageFormat : Equatable {
}

extension MapServiceImageFormat : Hashable {
}

/// An object that represents the sub layer metadata for a Map service.
///
/// The ``MapServiceLayerIDInfo`` class is derived from the ``IDInfo`` class.
/// - Note: See Also: ``IDInfo``, ``ArcGISMapServiceInfo/layerInfos``
/// - Since: 200.1
final public class MapServiceLayerIDInfo : ArcGIS.IDInfo {

    /// The sublayer's default visibility.
    ///
    /// The sublayer default visibility.
    final public var isVisibleByDefault: Bool { get }

    /// The sublayer's max scale. If `nil`, there is no maximum.
    ///
    /// The sublayer max scale.
    final public var maxScale: Double? { get }

    /// The sublayer's min scale. If `nil`, there is no minimum.
    ///
    /// The sublayer min scale.
    final public var minScale: Double? { get }

    /// The type of data held in the layer on the service.
    final public var serviceType: ArcGIS.ArcGISMapServiceSublayerInfo.SublayerType? { get }

    /// The sublayer IDs.
    /// - Note: See Also: `Array`
    final public var sublayerIDs: [Int] { get }
}

extension MapServiceLayerIDInfo {

    /// The sublayer's parent id.
    /// - Remark: The sublayer parent id. If `nil`, an error occurred or the sublayer has no parent.
    final public var parentLayerID: Int? { get }
}

/// A map sublayer source refers to a layer in the current map service.
///
/// If supported, use the geodatabase version property to specify an alternate geodatabase version.
/// - Note: See Also: ``TableSublayerSource``, ``TableJoinSublayerSource``, ``TableQuerySublayerSource``, ``RasterSublayerSource``, `MapSublayerSource.Type`
/// - Since: 200.1
final public class MapSublayerSource : ArcGIS.SublayerSource {

    /// Create a map sublayer source from a map sublayer id.
    /// - Parameter id: The map sublayer id.
    public convenience init(id: Int)

    /// The geodatabase version.
    final public var geodatabaseVersion: String

    /// The map sublayer id of the map sublayer source.
    final public var mapSublayerID: Int { get }
}

/// A view that displays 2D geographic content from a `Map`.
/// - Since: 200.1
@MainActor public struct MapView : View {

    /// Creates a map view.
    /// - Parameters:
    ///   - map: The map to be displayed by the map view.
    ///   - viewpoint: A viewpoint that corresponds to the area of the map to
    ///   display.
    ///   - timeExtent: A binding to a time extent that corresponds to the time extent of
    ///   the map to display.
    ///   - graphicsOverlays: The graphics overlays to display on top of the map
    ///   view's content.
    @MainActor public init(map: ArcGIS.Map, viewpoint: ArcGIS.Viewpoint? = nil, timeExtent: Binding<ArcGIS.TimeExtent?>? = nil, graphicsOverlays: [ArcGIS.GraphicsOverlay] = [])

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    public typealias Body = some View
}

extension MapView : ArcGIS.GeoView {

    /// Sets the visibility of this geo view's attribution bar.
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    /// attribution bar.
    @MainActor public func attributionBarHidden(_ hidden: Bool) -> ArcGIS.MapView

    /// Displays a callout when the specified placement is a non-`nil` value.
    /// - Parameters:
    ///   - placement: Binding to the placement for which to display a callout.
    ///   When the wrapped value of the binding is not `nil`, then the callout
    ///   is displayed.
    ///   - content: The content to be displayed within the callout.
    @MainActor public func callout(placement: Binding<ArcGIS.CalloutPlacement?>, @ViewBuilder content: @escaping (ArcGIS.CalloutPlacement) -> some View) -> ArcGIS.MapView

    /// Sets whether to disable flicking for this geo view.
    /// - Parameter disabled: A Boolean value that indicates whether flicking is
    ///   disabled.
    @MainActor public func flickingDisabled(_ disabled: Bool) -> ArcGIS.MapView

    /// Sets a closure to perform when this geo view's attribution text changes.
    /// - Parameter action: The closure to perform when the attribution text has
    ///   changed.
    @MainActor public func onAttributionTextChanged(perform action: @escaping (String) -> Void) -> ArcGIS.MapView

    /// Sets a closure to perform when this geo view's draw status changes.
    /// - Parameter action: The closure to perform when the draw status has
    /// changed.
    @MainActor public func onDrawStatusChanged(perform action: @escaping (ArcGIS.DrawStatus) -> Void) -> ArcGIS.MapView

    /// Sets a closure to perform when the view state of a layer of this geo
    /// view changes.
    /// - Parameter action: The closure to perform when a layer's view state has
    ///   changed.
    @MainActor public func onLayerViewStateChanged(perform action: @escaping (ArcGIS.Layer, ArcGIS.LayerViewState) -> Void) -> ArcGIS.MapView

    /// Sets a closure to perform when this geo view's navigation status
    /// changes.
    ///
    /// The navigation status indicates whether the viewpoint is changing, due
    /// to either user interaction (panning and/or zooming) or a viewpoint
    /// animation.
    /// - Parameter action: The closure to perform when the navigation status
    /// has changed.
    @MainActor public func onNavigatingChanged(perform action: @escaping (Bool) -> Void) -> ArcGIS.MapView

    /// Sets a closure to perform when this geo view's spatial reference
    /// changes.
    /// - Parameter action: The closure to perform when the spatial reference
    /// has changed.
    @MainActor public func onSpatialReferenceChanged(perform action: @escaping (ArcGIS.SpatialReference?) -> Void) -> ArcGIS.MapView

    /// Sets a closure to perform when the viewpoint of this geo view changes.
    ///
    /// Viewpoints received by the `action` closure will not have a camera.
    /// - Parameters:
    ///   - kind: The kind of viewpoint passed to the `action` closure.
    ///   - action: The closure to perform when the viewpoint has changed.
    @MainActor public func onViewpointChanged(kind: ArcGIS.Viewpoint.Kind, perform action: @escaping (ArcGIS.Viewpoint) -> Void) -> ArcGIS.MapView

    /// Sets the selection color for all graphic overlays and selectable layers
    /// of this geo view.
    ///
    /// The default selection color is cyan.
    /// - Parameter color: The selection color to use for this geo view.
    @MainActor public func selectionColor(_ color: Color) -> ArcGIS.MapView

    /// Sets the zoom factor for this geo view.
    /// - Parameter zoomFactor: The zoom factor for animated zooming in and out
    ///   in this geo view.
    @MainActor public func zoomFactor(_ zoomFactor: Double) -> ArcGIS.MapView
}

extension MapView {

    /// Sets whether to hide labels and if label animations should be active for this map view.
    /// - Parameters:
    ///   - hidden: A Boolean value that indicates whether labels are hidden. The default is `false`.
    ///   - animated: A Boolean value that indicates whether labeling animations are active.
    @MainActor public func mapLabels(hidden: Bool, animated: Bool = false) -> ArcGIS.MapView
}

extension MapView {

    /// Sets the user interactions for this map view.
    /// - Parameter interactionModes: The user interactions to which the map
    /// view responds.
    @MainActor public func interactionModes(_ interactionModes: ArcGIS.MapViewInteractionModes) -> ArcGIS.MapView

    /// Sets the background grid for this map view.
    ///
    /// The map displays on top of the background grid or the background color
    /// to determine what is displayed under transparent areas of the map.
    ///
    /// If ``Map/backgroundColor`` is not `nil`, then the background grid is ignored and
    /// the background color will be used as the background color of the map.
    /// - Parameter backgroundGrid: The background grid to use for the map view.
    @MainActor public func backgroundGrid(_ backgroundGrid: ArcGIS.BackgroundGrid) -> ArcGIS.MapView

    /// Sets the grid for this map view.
    ///
    /// A coordinate system grid to display on top of the map view.
    /// - Remark: The ``Grid`` is a collection of horizontal and vertical lines which can be rendered over the top of a
    /// map view to help show the location of the current ``Viewpoint``. Supported grids include Military Grid
    /// Reference System (``MGRSGrid``), United States National Grid (``USNGGrid``), Universal Transverse Mercator
    /// (``UTMGrid``), and a grid of latitude and longitude lines (``LatitudeLongitudeGrid``). You can configure
    /// these grids by toggling their visibility and modifying their default layout and appearance. A grid will
    /// not display in the map view until a map has been loaded.
    @MainActor public func grid(_ grid: ArcGIS.Grid?) -> ArcGIS.MapView

    /// Sets the snap to north threshold for this map view.
    ///
    /// The default threshold is `12.0`.
    /// - Parameter snapToNorthThreshold: Threshold angle (in degrees) to snap
    /// to north while rotating. Angle is with respect of either side of north
    /// and will be clamped to `0` to `30` degrees. Set `0` to disable snapping
    /// to north.
    @MainActor public func snapToNorthThreshold(_ snapToNorthThreshold: CGFloat) -> ArcGIS.MapView

    /// Sets a closure to perform when a single tap occurs on the map view.
    /// - Parameters:
    ///   - action: The closure to perform upon single tap. The closure
    ///   will not be called if the tap occurs before the map view has a spatial
    ///   reference.
    ///   - screenPoint: The location of the tap in the map view's coordinate
    ///   space.
    ///   - mapPoint: The location of the tap in the map's coordinate space.
    @MainActor public func onSingleTapGesture(perform action: @escaping (_ screenPoint: CGPoint, _ mapPoint: ArcGIS.Point) -> Void) -> ArcGIS.MapView

    /// Sets an action to perform when the map view recognizes a long press
    /// gesture.
    /// - Parameters:
    ///   - action: The action to perform when a long press is recognized.
    ///   - screenPoint: The location of the long press in the map view's
    ///   coordinate space.
    ///   - mapPoint: The location of the long press in the map's coordinate
    ///   space.
    @MainActor public func onLongPressGesture(perform action: @escaping (_ screenPoint: CGPoint, _ mapPoint: ArcGIS.Point) -> Void) -> ArcGIS.MapView

    /// Sets the location display for this map view.
    /// - Parameter locationDisplay: A location display.
    @MainActor public func locationDisplay(_ locationDisplay: ArcGIS.LocationDisplay) -> ArcGIS.MapView

    /// Sets a closure to perform when the map view's rotation changes.
    /// - Parameters:
    ///   - action: The closure to perform when the rotation has changed.
    ///   - rotation: The new rotation.
    @MainActor public func onRotationChanged(perform action: @escaping (_ rotation: Double) -> Void) -> ArcGIS.MapView

    /// Sets a closure to perform when the map view's scale changes.
    /// - Parameters:
    ///   - action: The closure to perform when the scale has changed.
    ///   - scale: The new scale.
    @MainActor public func onScaleChanged(perform action: @escaping (_ scale: Double) -> Void) -> ArcGIS.MapView

    /// Allows you to set the edges where the map view is obscured by some other
    /// UI. This is important so that the location display is anchored
    /// appropriately. Setting this also affects the way viewpoints are set and
    /// reported by the map view. For example, setting a viewpoint with a center
    /// will cause the geographic center of the viewpoint to be contained within
    /// the area affected by the insets.
    /// - Parameter contentInsets: The insets from the edges where the map view
    /// content is obscured.
    @MainActor public func contentInsets(_ contentInsets: EdgeInsets) -> ArcGIS.MapView

    /// Sets a closure to perform when the units per point of the map view
    /// changes.
    /// - Parameters:
    ///   - action: The closure to perform when the units per point has changed.
    ///   - unitsPerPoint: The new units per point.
    @MainActor public func onUnitsPerPointChanged(perform action: @escaping (_ unitsPerPoint: Double) -> Void) -> ArcGIS.MapView

    /// Sets a closure to perform when the visible area of the map view changes.
    /// - Parameter action: The closure to perform when the visible area has
    /// changed.
    @MainActor public func onVisibleAreaChanged(perform action: @escaping (ArcGIS.Polygon) -> Void) -> ArcGIS.MapView

    /// Sets the geometry editor for this map view.
    /// - Parameter geometryEditor: The geometry editor to assign to this map view.
    @MainActor public func geometryEditor(_ geometryEditor: ArcGIS.GeometryEditor?) -> ArcGIS.MapView

    /// Sets the wrap around mode for this map view.
    ///
    /// The wrap around mode determines whether continuous panning across the
    /// international date line is enabled. By default, the map view attempts to
    /// wrap the map across the international date line for a continuous panning
    /// user experience. The eastern and western hemispheres wrap to form a
    /// continuous map, giving the impression that the map is endless.
    ///
    /// To enable wrap around when certain conditions are met, use
    /// ``MapViewWrapAroundMode/enabledWhenSupported``. To disable wrap around
    /// altogether, use ``MapViewWrapAroundMode/disabled``.
    ///
    /// If wraparound is enabled, visible area geometries may have coordinates
    /// outside the domain of the spatial reference of the map. Before using
    /// such geometries to perform spatial queries, address finding, or as
    /// feature geometries in a geodatabase, normalize them to lie within the
    /// spatial reference domain using
    /// ``GeometryEngine/normalizeCentralMeridian(of:)``.
    ///
    /// The default value is ``MapViewWrapAroundMode/enabledWhenSupported``.
    /// - Parameter wrapAroundMode: The wrap around mode to use for the map
    /// view.
    @MainActor public func wrapAroundMode(_ wrapAroundMode: ArcGIS.MapViewWrapAroundMode) -> ArcGIS.MapView
}

/// Options that indicate the user interactions to which the map view responds.
/// - Since: 200.1
public struct MapViewInteractionModes : OptionSet {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: Int

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: Int)

    /// The type of the elements of an array literal.
    public typealias ArrayLiteralElement = ArcGIS.MapViewInteractionModes

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    public typealias Element = ArcGIS.MapViewInteractionModes

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int
}

extension MapViewInteractionModes {

    /// The map view allows all interaction modes.
    public static let all: ArcGIS.MapViewInteractionModes

    /// The map view allows the user to pan the map.
    public static let pan: ArcGIS.MapViewInteractionModes

    /// The map view allows the user to zoom the map.
    public static let zoom: ArcGIS.MapViewInteractionModes

    /// The map view allows the user to rotate the map.
    public static let rotate: ArcGIS.MapViewInteractionModes
}

/// A proxy for access to the operations of the ``MapView``.
///
/// This proxy can be obtained in the closure when creating an instance of ``MapViewReader``.
/// - Note: See Also: ``setViewpoint(_:duration:)``, ``identify(on:screenPoint:tolerance:returnPopupsOnly:maximumResults:)-2ln7x``
/// - Since: 200.1
public struct MapViewProxy {
}

extension MapViewProxy {

    /// Converts a geographical coordinate within the map view's spatial
    /// reference to a screen point in the view coordinate space of the map
    /// view.
    /// - Remark: If the wraparound mode is active, this method returns the
    /// closest screen point matching the specified geographical location.
    /// Meaning, if the converted screen coordinate is within the view then
    /// return that location. Otherwise the passed in geographical location will
    /// be translated to the closest corresponding geographical location to the
    /// center of the view, and then it will be converted to a screen
    /// coordinate.
    /// - Parameter location: A geographical location defined within the map
    /// view's spatial reference.
    /// - Returns: A screen point in the view coordinate space of the map view
    /// or `nil` if the map view does not have a spatial reference.
    public func screenPoint(fromLocation location: ArcGIS.Point) -> CGPoint?

    /// Converts a screen coordinate to a geographical location within the map
    /// view's spatial reference.
    /// - Parameter screenPoint: The screen point to convert.
    /// - Returns: A geographical location or `nil` if the map view does not
    /// have a spatial reference.
    public func location(fromScreenPoint screenPoint: CGPoint) -> ArcGIS.Point?

    /// Creates an envelope from the given rectangle.
    /// - Parameter viewRect: The rectangle to create an envelope of.
    /// - Returns: An envelope of the given rectangle.
    public func envelope(fromViewRect viewRect: CGRect) -> ArcGIS.Envelope?

    /// Creates a rectangle from the given envelope.
    /// - Parameter envelope: The envelope to create a rectangle of.
    /// - Returns: A rectangle of the given envelope.
    public func viewRect(fromEnvelope envelope: ArcGIS.Envelope) -> CGRect?
}

extension MapViewProxy : ArcGIS.GeoViewProxy {

    /// A Boolean value indicating whether the view's content wraps around the dateline.
    /// - Precondition: The geo view reader must contain a single geo view.
    public var wrapAroundIsEnabled: Bool { get }

    /// Provides an image depicting the view's current display.
    /// - Returns: An image of the view's current display.
    public func exportImage() async throws -> UIImage

    /// Performs an identify operation on the specified graphics overlay.
    /// - Parameters:
    ///   - graphicsOverlay: The overlay on which to perform the identify.
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify
    ///   a circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only overlays with popups will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/popups``. If
    ///   `false`, all overlays (with or without popups) will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/graphics``.
    ///   - maximumResults: The maximum number of graphics which can be
    ///   identified. A value of `1` means that only the top-most graphic will
    ///   be identified. A value of `nil` means that the number of results will
    ///   not be limited.
    /// - Returns: An ``IdentifyGraphicsOverlayResult`` value.
    public func identify(on graphicsOverlay: ArcGIS.GraphicsOverlay, screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResults: Int? = 1) async throws -> ArcGIS.IdentifyGraphicsOverlayResult

    /// Performs an identify operation on all graphics overlays.
    /// - Remark: Results are returned in top-to-bottom order.
    /// - Parameters:
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only overlays with popups will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/popups``. If
    ///   `false`, all overlays (with or without popups) will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/graphics``.
    ///   - maximumResultsPerOverlay: The maximum number of graphics which can
    ///   be identified per overlay. A value of `1` means only the top-most
    ///   graphic per overlay will be identified. A value of `nil` means that
    ///   the number of results per layer will not be limited.
    /// - Returns: An array of ``IdentifyGraphicsOverlayResult`` values.
    public func identifyGraphicsOverlays(screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResultsPerOverlay: Int? = 1) async throws -> [ArcGIS.IdentifyGraphicsOverlayResult]

    /// Performs an identify operation on the specified layer.
    /// - Parameters:
    ///   - layer: The layer on which to perform the identify.
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only layers with popups will be identified and the
    ///   results will be in ``IdentifyLayerResult/popups``. If `false`, all
    ///   overlays (with or without popups) will be identified and the results
    ///   will be in ``IdentifyLayerResult/geoElements``.
    ///   - maximumResults: The maximum number of elements which can be
    ///   identified. A value of `1` indicates only the top-most element per
    ///   layer and sublayer will be identified. A value of `nil` means that
    ///   the number of results per layer will not be limited.
    /// - Returns: An ``IdentifyLayerResult`` value.
    public func identify(on layer: ArcGIS.Layer, screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResults: Int? = 1) async throws -> ArcGIS.IdentifyLayerResult

    /// Performs an identify operation on all layers in the geo view.
    /// - Parameters:
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only layers with popups will be identified and the
    ///   results will be in ``IdentifyLayerResult/popups``. If `false`, all
    ///   layers (with or without popups) will be identified.
    ///   - maximumResultsPerLayer: The maximum number of elements which can be
    ///   identified per layer or sublayer. A value of `1` means that only
    ///   the top-most element per layer and sublayer will be identified. A
    ///   value of `nil` means that the number of results per layer will not be
    ///   limited.
    /// - Returns: An array of ``IdentifyLayerResult`` values.
    public func identifyLayers(screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResultsPerLayer: Int? = 1) async throws -> [ArcGIS.IdentifyLayerResult]

    /// Sets the viewpoint of the geo view to that of the provided bookmark.
    /// - Parameter bookmark: The bookmark whose viewpoint will be used.
    /// - Returns: A Boolean value indicating whether the operation continued
    /// until the end without any interruption.
    @discardableResult
    public func setBookmark(_ bookmark: ArcGIS.Bookmark) async throws -> Bool

    /// Retrieves the current view state for the specified layer.
    /// - Parameter layer: The layer to get the view state for.
    /// - Returns: A ``LayerViewState`` value.
    /// - Precondition: The geo view reader must contain a single geo view.
    public func viewState(for layer: ArcGIS.Layer) -> ArcGIS.LayerViewState?
}

extension MapViewProxy {

    /// Pan or zoom the geo view using animation to the specified viewpoint. Animation
    /// takes place over the specified duration.
    /// - Parameters:
    ///   - viewpoint: The viewpoint.
    ///   - duration: The amount of time in seconds to move to the new viewpoint.
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Geo view reader must contain a geo view.
    @discardableResult
    public func setViewpoint(_ viewpoint: ArcGIS.Viewpoint, duration: TimeInterval? = nil) async -> Bool

    /// Centers the map view at the provided center point and zooms to the given scale.
    /// - Parameters:
    ///   - center: The location at which to center the map view.
    ///   - scale: The scale at which the map is to be displayed.
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Map view reader must contain a map view.
    @discardableResult
    public func setViewpointCenter(_ center: ArcGIS.Point, scale: Double? = nil) async -> Bool

    /// Zooms and pans the map view to the extent of the provided geometry with additional padding.
    /// - Parameters:
    ///   - geometry: The geometry to zoom to.
    ///   - padding: The minimum amount of padding around the bounding geometry in points.
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Map view reader must contain a map view.
    @discardableResult
    public func setViewpointGeometry(_ geometry: ArcGIS.Geometry, padding: CGFloat? = nil) async -> Bool

    /// Rotates the map view to the provided angle.
    /// - Remark: The angle will be normalized between 0 and 360 degrees.
    /// - Parameter angleDegrees: The degrees to rotate to (in counterclockwise direction).
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Map view reader must contain a map view.
    @discardableResult
    public func setViewpointRotation(_ angleDegrees: Double) async -> Bool

    /// Zooms the map view to the provided scale around its current center point.
    /// - Parameter scale: The scale to zoom to. For example, `50_000` is a scale of 1:50,000.
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Map view reader must contain a map view.
    @discardableResult
    public func setViewpointScale(_ scale: Double) async -> Bool
}

/// A view whose child is defined as a function of a ``MapViewProxy`` targeting
/// the map view within the child.
/// - Since: 200.1
public struct MapViewReader<Content> : View where Content : View {

    /// The view builder that creates the reader's content.
    public var content: (ArcGIS.MapViewProxy) -> Content

    /// Creates an instance that can perform programmatic actions of its
    /// child map view.
    /// - Parameter content: The reader's content, containing one map view. This
    /// view builder receives a ``MapViewProxy`` instance that you use to
    /// perform actions on the map view.
    public init(@ViewBuilder content: @escaping (ArcGIS.MapViewProxy) -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    public typealias Body = some View
}

/// Should wrap around be used or not.
///
/// Allows you to change the wrap around mode.
/// - Note: See Also: `MapView`
/// - Since: 200.1
public enum MapViewWrapAroundMode {

    /// Enable wrap around if it is supported.
    ///
    /// Wraparound can only be applied to a map view if the following requirements are met.
    /// * The map's full extent covers the entire world.
    /// * The `MapView.spatialReference` is either WGS 84 or Web Mercator Auxiliary Sphere.
    /// * Dynamic layers in the map are based on map services from ArcGIS Server 10.0 or higher.
    case enabledWhenSupported

    /// Disable wrap around.
    case disabled

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.MapViewWrapAroundMode, b: ArcGIS.MapViewWrapAroundMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension MapViewWrapAroundMode : Equatable {
}

extension MapViewWrapAroundMode : Hashable {
}

/// An error than can occur when dealing with mapping capabilities.
/// - Since: 200.1
public enum MappingError : Error {

    /// Spatial reference is missing.
    case missingSpatialReference

    /// Initial viewpoint is missing.
    case missingInitialViewpoint

    /// Invalid request response.
    case invalidResponse

    /// Bing maps key is missing.
    case missingBingMapsKey

    /// Layer type is not supported.
    case unsupportedLayerType

    /// Sync not enabled.
    case syncNotEnabled

    /// Tile export is not enabled.
    case tileExportNotEnabled

    /// Required item property is missing.
    case missingItemProperty

    /// Web map version is not supported.
    case webmapNotSupported

    /// Spatial reference invalid or incompatible.
    case spatialReferenceInvalid

    /// Package needs to be unpacked before it can be used.
    case packageUnpackRequired

    /// Elevation source data format is not supported.
    case unsupportedElevationFormat

    /// Web scene version or viewing mode is not supported.
    case websceneNotSupported

    /// Loadable object is not loaded when it is expected to be loaded.
    case notLoaded

    /// Update packages for an offline map area are not supported.
    case scheduledUpdatesNotSupported

    /// Trace operation failed.
    case utilityNetworkTraceFailed

    /// Arcade expression is invalid.
    case invalidArcadeExpression

    /// Requested extent contains too many associations.
    case utilityNetworkTooManyAssociations

    /// A layer has requested more features than the service maximum feature count.
    case maxFeatureCountExceeded

    /// Feature service does not support branch versioning.
    case branchVersioningNotSupportedByService

    /// Packaging of data for the offline map area is not complete and it is not ready for download.
    case packagingNotComplete

    /// An upload sync direction is not supported.
    case syncDirectionUploadNotSupported

    /// Tile export in .tpkx format is not supported.
    case tileCacheCompactV2ExportNotEnabled

    /// The specified layer does not intersect the area of interest.
    case layerDoesNotIntersectAreaOfInterest

    /// Local edits must be sent to a service (using a sync direction of upload) before update packages can download a replacement geodatabase.
    case scheduledUpdateUploadRequired

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension MappingError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.MappingError, b: ArcGIS.MappingError) -> Bool
}

extension MappingError : Hashable {
}

/// A base class for scene marker symbols. You would typically work with one or more sub-classes of this class.
///
/// Scene marker symbols are used to display graphics that are based on point or multipoint geometry.
///
/// The scene marker symbol class is derived from the symbol class.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
public class MarkerSceneSymbol : ArcGIS.Symbol {

    /// The list of possible scene symbol anchor placements.
    ///
    /// This is used to determine the position of the scene marker symbol.
    public enum AnchorPosition {

        /// The top of the symbol is the anchor point.
        case top

        /// The bottom of the symbol is the anchor point.
        case bottom

        /// The center of the symbol is the anchor point.
        case center

        /// The origin of the symbol is the anchor point.
        case origin

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.MarkerSceneSymbol.AnchorPosition, b: ArcGIS.MarkerSceneSymbol.AnchorPosition) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The anchor position of the simple marker scene symbol.
    ///
    /// The anchor position of the simple marker scene symbol ``AnchorPosition-swift.enum``.
    public var anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition

    /// The currently set symbol color.
    ///
    /// The symbol color of the simple marker scene symbol.
    public var color: UIColor

    /// The depth (in meters) of the simple marker scene symbol.
    public var depth: Double

    /// The heading (in degrees) of the scene marker symbol.
    public var heading: Float

    /// The height (in meters) of the simple marker scene symbol.
    public var height: Double

    /// The pitch (in degrees) of the scene marker symbol.
    public var pitch: Float

    /// The roll (in degrees) of the scene marker symbol.
    public var roll: Float

    /// The width (in meters) of the simple marker scene symbol.
    public var width: Double
}

extension MarkerSceneSymbol.AnchorPosition : Equatable {
}

extension MarkerSceneSymbol.AnchorPosition : Hashable {
}

/// A base class for marker symbols. You would typically work with one or more sub-classes of this class.
///
/// Marker symbols are used to display graphics that are based on point or multipoint geometry.
///
/// The marker symbol class is derived from the symbol class.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
public class MarkerSymbol : ArcGIS.Symbol {

    /// The angle (in degrees) of the marker symbol.
    public var angle: Float

    /// The symbol angle alignment of the marker symbol.
    ///
    /// The angle alignment of the marker symbol.
    public var angleAlignment: ArcGIS.SymbolAngleAlignment

    /// The leader offset X of the marker symbol.
    public var leaderOffsetX: CGFloat

    /// The leader offset Y of the marker symbol.
    public var leaderOffsetY: CGFloat

    /// The offset X of the marker symbol.
    public var offsetX: CGFloat

    /// The offset Y of the marker symbol.
    public var offsetY: CGFloat
}

/// A base class for marker symbol layers, representing a symbol layer used to display a marker.
///
/// ``MarkerSymbolLayer`` draws a shape or picture at a specific location relative to point
/// geometry. A marker symbol layer is most often used in point symbols, but they can also be
/// included in polyline and polygon symbols to draw a symbol at locations along lines and
/// outlines, or within areas (the center of a polygon, for example).
///
/// The following types of marker symbol layers are supported:
/// * ``VectorMarkerSymbolLayer`` - Vector geometry defines the shape and appearance of the
///   marker
/// * ``PictureMarkerSymbolLayer`` - Uses an image file (specified using a URI or image data)
///   to define the marker
///
/// This symbol layer controls many common operations vital for working with markers.
///
/// Anchors, angles, offsets, and size properties are controlled on ``MarkerSymbolLayer``.
///
/// The ``MarkerSymbolLayer`` has methods affecting both 2D and 3D markers. Some properties
/// apply only to 3D markers, such as angleX, or offsetZ. These properties have no effect on
/// markers in 2D. Properties on 2D markers, such as offsetX, affect the marker's position in
/// screen space, not world space. This means that the x-axis for a 2D marker runs from
/// negative-x on the West edge of the screen to positive-x on the East edge of the screen.
/// Negative-y to positive-y runs from the South edge of the screen to the North edge of the
/// screen.
///
/// Properties that apply only to 3D markers affect the marker's position in world space,
/// rather than screen space. This means that the x, y, and z-axes to which the class methods
/// are the axes of the world, with the following layout: from negative to positive, the x-axis
/// spans from world West to world East, the y-axis from world South to world North, and the
/// z-axis from directly into the surface to the sky.
///
/// While a simple text symbol (``TextSymbol``) can be used to display a character as a marker,
/// proper display is dependent on the referenced font being available on the machine or device
/// running the app. If the exact font is not found, which is likely to occur on many mobile
/// devices, a fallback mechanism is used to find the best available font to use. A character
/// marker symbol authored from ArcGIS Pro, however, is represented by a vector marker symbol.
/// This symbol stores the geometry that represents the character, is not dependent on the font
/// to render the shape of the marker, and displays as expected on all devices.
/// - Since: 200.1
public class MarkerSymbolLayer : ArcGIS.SymbolLayer {

    /// The anchor object of a marker symbol layer.
    ///
    /// The ``SymbolAnchor`` determines how the ``MarkerSymbolLayer`` is anchored.
    /// ``SymbolAnchor`` specifies the marker's anchor point and anchor placement mode.
    /// The default symbol anchor is at XYZ(0, 0, 0) and uses 'relative' mode.
    /// See the ``SymbolAnchor`` documentation for a detailed description of the object.
    public var anchor: ArcGIS.SymbolAnchor

    /// The marker symbol layer's heading: the angle of rotation about the anchor point.
    ///
    /// The input value can be any real number. The default value is 0. This property affects markers
    /// in both maps and scenes. Positive angles rotate the marker counterclockwise.
    ///
    /// Angle for ``MarkerSymbolLayer`` is measured in degrees counterclockwise from 0 to 360. Marker
    /// symbol layers can have a separate heading value defined (which is also 0 by default). Setting a
    /// heading for a marker symbol layer does not affect the angle of the point symbol. When an angle
    /// value is set for the point symbol, however, that value is applied cumulatively to all the
    /// marker symbol layers it contains. The heading for individual symbol layers must be re-fetched
    /// in order to see the updated value. In 2D, the rotation applies around the anchor point of the
    /// 2D marker. For 3D markers, the rotation applies around the z-axis.
    public var heading: Double

    /// The marker symbol layer's x-offset.
    ///
    /// The input value can be any real number. The default value is 0. This property affects markers
    /// in both Maps and Scenes. The x-offset is a delta applied to the marker in the direction corresponding
    /// to the given value. For example, a positive x-offset moves the marker in the positive-x direction.
    public var offsetX: CGFloat

    /// The marker symbol layer's y-offset.
    ///
    /// The input value can be any real number. The default value is 0. This property affects markers
    /// in both Maps and Scenes. The y-offset is a delta applied to the marker in the direction corresponding
    /// to the given value. For example, a positive y-offset moves the marker in the positive-y direction.
    public var offsetY: CGFloat

    /// The size of marker symbol layer.
    ///
    /// The input value can be any positive number. The default value is 13.333 DIPs (10 points).
    /// A larger size means a larger marker.
    public var size: CGFloat
}

/// Represents a pop-up element of type media that is displayed in a pop-up for a geoelement.
/// - Note: See Also: `PopupElement.Type`, ``PopupElement``
/// - Since: 200.1
final public class MediaPopupElement : ArcGIS.PopupElement {

    /// Creates a new media pop-up element with the given `Array` of ``PopupMedia``.
    /// - Parameter media: An `Array` of ``PopupMedia`` objects that define images and charts displayed in the pop-up window.
    public convenience init(media: [ArcGIS.PopupMedia] = [])

    /// A string value describing the element in detail. Can be an empty string.
    final public var description: String

    /// An `Array` of ``PopupMedia`` objects that define images and charts displayed in the pop-up window.
    final public var media: [ArcGIS.PopupMedia] { get }

    /// Adds a sequence of `PopupMedia` values to the end of the `media` property.
    /// - Parameter newMedia: The new `PopupMedia` values to append.
    final public func addMedia<S>(_ newMedia: S) where S : Sequence, S.Element == ArcGIS.PopupMedia

    /// Adds a `PopupMedia` value to the end of the `media` property.
    /// - Parameter newMedia: The new `PopupMedia` value to append.
    final public func addMedia(_ newMedia: ArcGIS.PopupMedia)

    /// Inserts a collection of `PopupMedia` values into the `media` property at the specified position.
    /// - Parameters:
    ///   - newMedia: The new `PopupMedia` values to insert.
    ///   - index: The position at which to insert the new `PopupMedia` values.
    final public func insertMedia<C>(_ newMedia: C, at index: Int) where C : Collection, C.Element == ArcGIS.PopupMedia

    /// Inserts a `PopupMedia` value into the `media` property at the specified position.
    /// - Parameters:
    ///   - newMedia: The new `PopupMedia` value to insert.
    ///   - index: The position at which to insert the new `PopupMedia` value.
    final public func insertMedia(_ newMedia: ArcGIS.PopupMedia, at index: Int)

    /// Removes all values from the `media` property.
    final public func removeAllMedia()

    /// Removes a sequence of `PopupMedia` values from the `media` property.
    /// - Parameter media: The `PopupMedia` values to remove.
    final public func removeMedia<S>(_ media: S) where S : Sequence, S.Element == ArcGIS.PopupMedia

    /// Removes a `PopupMedia` value from the `media` property.
    /// - Parameter media: The `PopupMedia` value to remove.
    final public func removeMedia(_ media: ArcGIS.PopupMedia)

    /// A string value indicating what the element represents. Can be an empty string.
    final public var title: String
}

/// The minimum/maximum stretch parameters object.
/// - Since: 200.1
final public class MinMaxStretchParameters : ArcGIS.StretchParameters {

    /// Creates a minimum/maximum stretch parameters object with the specified minimum/maximum values.
    /// - Parameters:
    ///   - minValues: The min values.
    ///   - maxValues: The max values.
    public convenience init(minValues: [Double], maxValues: [Double])

    /// Max values from a minimum/maximum stretch parameters object.
    final public var maxValues: [Double] { get }

    /// Min values from a minimum/maximum stretch parameters object.
    final public var minValues: [Double] { get }
}

/// A layer that can visualize the basemap layer of a map from mobile map package.
///
/// A mobile basemap layer can render feature, tiled, vector tiled and raster data together in a group as a single
/// basemap layer. This layer abstracts the complexity of multiple layers into one simple-to-use layer.
///
/// You can create a basemap layer using ArcGIS Pro and package it, along with its map, into a mobile map package
/// (.mmpk) for use offline. Each package may contain one or more maps, each of which can contain a basemap with
/// basemap layers.
///
/// If a basemap layer contains features, they will be stored in a compressed format that can be displayed quickly
/// along with any associated labels. This compressed format does not support feature selection, query, identify
/// and time.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class MobileBasemapLayer : ArcGIS.Layer {

    /// The path of mobile basemap layer.
    /// - Note: See Also: `String`
    final public var fileURL: URL { get }

    /// The sublayer IDs.
    /// - Note: See Also: `Array`
    final public var sublayerIDs: [Int] { get }

    override final public func load() async throws
}

/// A mobile map package.
///
/// Mobile map packages allow you to work with maps on a mobile device. A mobile map package
/// contains all of the files necessary to work with your maps and is stored on a device as
/// either:
/// * A single archive file with an .mmpk extension
/// * A directory containing an unpacked mobile map package
///
/// You can create a mobile map package using either:
/// * ArcGIS Pro (from version 1.3). This API version supports any ``MobileMapPackage`` up to
/// major version 5. Mobile map packages created with ArcGIS Pro are stored in a file with an
/// .mmpk extension.
/// * Use the `OfflineMapTask.makeGenerateOfflineMapJob(parameters:downloadDirectory:overrides:)` method to generate and download a mobile map
/// package on-demand, or use the `OfflineMapTask.makeDownloadPreplannedOfflineMapJob(parameters:downloadDirectory:)` to download a
/// mobile map package already prepared by the map author. Mobile map packages created with the
/// ``OfflineMapTask`` are stored in a directory containing an unpacked mobile map package.
///
/// A mobile map package can encapsulate one or more maps along with their layers and data.
/// Each package contains an ``Item`` with metadata about the package (description, thumbnail,
/// etc.).
///
/// Mobile map packages created with ArcGIS Pro can also include transportation networks,
/// locators, and links to online services. You can choose whether to use:
/// * A tile package (such as .tpkx or .vptk) or an online basemap as the ``GeoModel/basemap``
/// * A mobile geodatabase (.geodatabase) or an online feature service as one of the
/// ``GeoModel/operationalLayers``. Online services (such as traffic or weather) can provide
/// excellent contextual information for your users. If the mobile map package is going to be
/// used in areas of poor connectivity, however, you must ensure that data critical to your
/// workflow is stored locally on the device.
///
/// Mobile map packages implement the ``Loadable`` interface; you need to load the
/// ``MobileMapPackage`` before you can access its content. Once loaded you can:
/// * Determine the version of this package using the ``version`` property.
///   This API currently supports mobile map packages up to and including major version
///   5. If the package is from an unsupported version, it will fail to load.
/// * Discover whether the mobile map package has expired using the
///   ``expiration`` property
/// * Access the individual maps and display them in a `MapView`
/// * Programmatically add, modify, and remove layers in the map. Mobile map packages, however,
///   are read-only and these changes to maps or layers are not persisted.
/// - Note: See Also: ``Loadable``
/// - Since: 200.1
final public class MobileMapPackage : ArcGIS.Loadable {

    /// Create a ``MobileMapPackage`` with a path.
    ///
    /// The path can refer to a file with an .mmpk extension or a directory containing an unpacked mobile map package.
    /// - Parameter fileURL: A path to mobile map package.
    public convenience init(fileURL: URL)

    /// Expiration details for this mobile map package, if provided.
    ///
    /// Expiration details provide:
    /// * The packages expiration date and time
    /// * Whether the maps can be accessed after expiration
    /// * Any messages relevant for the user
    ///
    /// These expiration details can be specified when the author creates a mobile map package
    /// using ArcGIS Pro (from version 2.4). This requires the ArcGIS Pro Publisher Extension.
    /// Mobile map packages created with the ``OfflineMapTask`` do not support expiration.
    ///
    /// By publishing a package with expiration details, the author can control the experience
    /// an end-user has when they try to access information that is no longer valid. For
    /// example, for time limited data (such as major sporting events), the author can ensure
    /// that the data cannot be accessed after the expiry date.
    ///
    /// During package loading, this API will determine whether the mobile map
    /// package was authored with expiration. If so, then this property will be populated.
    ///
    /// If the package has expired and was authored as ``Expiration/Kind-swift.enum/preventExpiredAccess``,
    /// loading will fail and you will not be able to access the maps. The expiration details
    /// will be accessible for you to examine and/or communicate to the user.
    final public var expiration: ArcGIS.Expiration? { get }

    /// The path to the mobile map package.
    ///
    /// The path can refer to a file with an .mmpk extension or a directory containing an unpacked mobile map package.
    /// - Note: See Also: `String`
    final public var fileURL: URL { get }

    /// The mobile map package's ``Item`` describing metadata about the package.
    ///
    /// The item includes the metadata about the mobile map package, such as:
    /// * Title
    /// * Snippet (summary)
    /// * Description
    /// * Tags
    /// * Thumbnail
    /// If the package was created with ArcGIS Pro, the metadata was provided by the package
    /// author. If the package was created using the ``OfflineMapTask``, the metadata was
    /// provided by the originating web map.
    ///
    /// A package's item will be an instance of a ``LocalItem``.
    ///
    /// Returns `nil` if the package is not loaded.
    /// - Note: See Also: ``Item``
    final public var item: ArcGIS.Item? { get }

    /// A ``LocatorTask`` from the mobile map package.
    ///
    /// Use this task to geocode and reverse-geocode addresses and places. There is only one ``LocatorTask`` in each
    /// mobile map package but it can be used by all maps.
    ///
    /// Returns `nil` if there is no ``LocatorTask`` in the package or the package is not loaded.
    /// - Note: See Also: ``LocatorTask``
    final public var locatorTask: ArcGIS.LocatorTask? { get }

    /// A collection of ``Map`` from the ``MobileMapPackage``.
    ///
    /// To use the maps in a ``MobileMapPackage``, you first need to load the package.
    /// If the mobile map package was created with ArcGIS Pro, the maps are presented in the same order in which
    /// they were packaged. Mobile map packages created with the ``OfflineMapTask`` will only contain one map.
    ///
    /// If you display the map by setting the map to a `MapView`, the map will automatically load. If you only
    /// need to access the map's content or metadata, you will need to load it by calling ``GeoModel/load()``.
    /// If the package is not loaded, an empty collection is returned.
    /// - Note: See Also: `Array`
    final public var maps: [ArcGIS.Map] { get }

    /// The mobile map package's version.
    ///
    /// The mobile map package version is set when the package is authored in ArcGIS Pro or
    /// when it is generated by the ``OfflineMapTask``.
    ///
    /// This property will be populated when you attempt to load the package. The version
    /// property will always be populated for you to examine, even if the package is an
    /// unsupported version.
    ///
    /// This API currently supports mobile map packages up to and including major version 5.
    ///
    /// You may wish to check the version property before trying to access specific
    /// functionality. For example:
    /// * Expiration details are only available from mobile map package version 3.1 onwards
    /// * Links to online services are only available from mobile map package version 4.0
    ///   onwards
    ///
    /// If the package fails to load, check that the version number has not exceeded the
    /// supported major version.
    /// - Note: See Also: `String`
    final public var version: String { get }

    /// Closes a mobile map package.
    ///
    /// Closes a mobile map package and frees file locks on the underlying .mmpk file or directory.
    ///
    /// All references to mobile map package data (maps, layers, tables, networks, locators, etc.)
    /// should be released before closing the package. If active references to mobile map package
    /// data exist, this method will still close the package, but subsequent rendering and data
    /// access methods will fail. Results of accessing mobile map package data after
    /// `MobileMapPackage.close()` are undefined.
    ///
    /// After closing a mobile map package, the underlying .mmpk file or directory can be moved or deleted.
    ///
    /// Closing a mobile map package is not necessary if the package has not been loaded.
    /// - Note: See Also: `Geodatabase.close()`
    final public func close()

    /// Unpacks a mobile map package file (.mmpk) to an output directory.
    ///
    /// If the last level of the output_directory is not present, it will be created as part of the unpack task.
    /// The returned task can be canceled with `CoreFuture.cancel()` to abort the unpack.
    /// The unpack task writes the full content of the mobile map package to the output directory. Care should be taken on
    /// devices with limited storage space, especially if the original package is very large. After unpacking, you can
    /// remove the original .mmpk file from the device.
    ///
    /// Note that unpacking will fail if the package is expired and was authored as ``Expiration/Kind-swift.enum/preventExpiredAccess``.
    /// - Parameters:
    ///   - fileURL: the path to a mobile map package file (.mmpk)
    ///   - outputDirectoryURL: a path to a directory to write the mobile map package contents.
    final public class func unpack(at fileURL: URL, to outputDirectoryURL: URL) async throws

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A mobile scene package.
///
/// Mobile scene packages allow you to work with 3D scenes on a mobile device. A mobile scene
/// package contains all of the files necessary to work with your scenes and is stored on a
/// device as either:
/// * A single archive file with an .mspk extension
/// * A directory containing an unpacked mobile scene package
///
/// A mobile scene package can encapsulate one or more scenes, their layers and data,
/// transportation networks, and a locator. The mobile scene package also contains an ``Item``
/// with metadata about the package (description, thumbnail, etc.). You can use these packages
/// to share scenes across ArcGIS products and to allow your users to work with scenes in
/// the field. Mobile scene packages also allow you to continue working when you have limited or no connectivity.
///
/// Starting with ArcGIS Pro 2.3 you can create mobile scene packages for use by this API.
/// Mobile scene packages are supported up to major version 3.
///
/// Mobile scene packages can contain links to online services, but be aware that these
/// services will be unavailable if your device is offline. You can choose whether to use:
/// * A tile package (.tpkx) or an online basemap as the ``GeoModel/basemap``
/// * A mobile geodatabase (.geodatabase) or an online feature service as one of the
///   ``GeoModel/operationalLayers``
/// * Local raster data (such as a DTED, GeoTIFF) or online image services as the elevation
///   sources in a ``Scene/baseSurface``
///
/// Online services (such as traffic or weather) can provide excellent contextual information
/// for your users. If the mobile scene package is going to be used in areas of poor
/// connectivity, however, you must ensure that data critical to your workflow is stored
/// locally on the device.
///
/// Mobile scene packages implement the ``Loadable`` interface; you need to load the
/// ``MobileScenePackage`` before you can access its content. Once loaded you can:
/// * Determine the version of this package using the ``version`` property.
///   This API supports mobile scene packages up to and including major version 3. If the package
///   is from an unsupported version it will fail to load.
/// * Discover whether the package has expired using the ``expiration``
///   property
/// * Access the individual scenes and display them in a `SceneView`
/// * Programmatically add, modify, and remove layers in the scene. Mobile scene packages,
///   however, are read-only and these changes to scenes or layers will not be persisted to the
///   device.
/// - Note: See Also: ``Loadable``
/// - Since: 200.1
final public class MobileScenePackage : ArcGIS.Loadable {

    /// Create a ``MobileScenePackage`` with a path.
    ///
    /// The path can refer to a file with an .mspk extension or a directory containing an unpacked mobile scene package.
    /// - Parameter fileURL: A path to a mobile scene package.
    public convenience init(fileURL: URL)

    /// Expiration details for this mobile scene package, if provided.
    ///
    /// Expiration details provide:
    /// * The packages expiration date and time
    /// * Whether the scenes can be accessed after expiration
    /// * Any messages relevant for the user
    ///
    /// By publishing a package with expiration details, the author can control the experience
    /// an end-user has when they try to access information that is no longer valid. For
    /// example, for time limited data (such as major sporting events), the author can ensure
    /// that the data cannot be accessed after the expiry date.
    ///
    /// These expiration details can be specified when the author creates a mobile scene
    /// package using ArcGIS Pro (from version 2.4). This requires the ArcGIS Pro Publisher
    /// Extension.
    ///
    /// During package loading, this API will determine whether the mobile scene package was
    /// authored with expiration. If so, then this property will be populated.
    ///
    /// If the package has expired and was authored as ``Expiration/Kind-swift.enum/preventExpiredAccess``,
    /// loading will fail and you will not be able to access the scenes. The expiration details
    /// will be accessible for you to examine and/or communicate to the user.
    final public var expiration: ArcGIS.Expiration? { get }

    /// The path to the mobile scene package.
    ///
    /// The path can refer to a file with an .mspk extension or a directory containing an unpacked mobile scene package.
    /// - Note: See Also: `String`
    final public var fileURL: URL { get }

    /// The mobile scene package's ``Item`` describing metadata about the package.
    ///
    /// The item includes the metadata that was provided by the mobile scene package author in
    /// ArcGIS Pro. This includes information such as:
    /// * Title
    /// * Snippet (summary)
    /// * Description
    /// * Tags
    /// * Thumbnail
    ///
    /// A mobile scene package's item will be an instance of a ``LocalItem``.
    ///
    /// Returns `nil` if the package is not loaded.
    /// - Note: See Also: ``Item``
    final public var item: ArcGIS.Item? { get }

    /// A ``LocatorTask`` from the mobile scene package.
    ///
    /// Use this task to geocode and reverse-geocode addresses and places. There is only one ``LocatorTask`` in each
    /// mobile scene package but it can be used by all scenes.
    ///
    /// Returns `nil` if there is no ``LocatorTask`` in the package, or the package is not loaded.
    /// - Note: See Also: ``LocatorTask``
    final public var locatorTask: ArcGIS.LocatorTask? { get }

    /// A collection of ``Scene`` from the ``MobileScenePackage``.
    ///
    /// To use the scenes in a ``MobileScenePackage``, you first need to load the package.
    /// The scenes are presented in the same order in which they were packaged with ArcGIS Pro. To display a
    /// ``Scene`` set the scene to a `SceneView`. This will automatically load the scene and all of
    /// its content. If you only need to access the scene's content or metadata, then you need to load it by
    /// calling ``GeoModel/load()``.
    /// If the package is not loaded, an empty collection is returned.
    /// - Note: See Also: `Array`, ``Scene``
    final public var scenes: [ArcGIS.Scene] { get }

    /// The mobile scene package's version.
    ///
    /// The mobile scene package version was set when the package was authored in ArcGIS Pro.
    ///
    /// This property is populated when you attempt to load the package. The version property
    /// will always be populated, for you to examine, even if the package is an unsupported
    /// version.
    ///
    /// This API supports mobile scene packages up to and including major version 3.
    ///
    /// You may wish to check the version property before trying to access specific
    /// functionality. For example:
    /// * Expiration details are only available in mobile scene package from version 1.1
    ///   onwards
    /// * Links to online services are only available in mobile scene package from version 3.0
    ///   onwards
    ///
    /// If the package fails to load, check that the version number does not exceeded the
    /// supported major version.
    final public var version: String { get }

    /// Closes a mobile scene package.
    ///
    /// Closes a mobile scene package and frees file locks on the underlying .mspk file or directory.
    ///
    /// All references to mobile scene package data (scenes, layers, tables, locators, etc.)
    /// should be released before closing the package. If active references to mobile scene package
    /// data exist, this method will still close the package, but subsequent rendering and data
    /// access methods will fail. Results of accessing mobile scene package data after
    /// `MobileScenePackage.close()` are undefined.
    ///
    /// After closing a mobile scene package, the underlying .mspk file or directory can be moved or deleted.
    ///
    /// Closing a mobile scene package is not necessary if the package has not been loaded.
    /// - Note: See Also: `MobileMapPackage.close()`, `Geodatabase.close()`
    final public func close()

    /// Unpacks a mobile scene package file (.mspk) to an output directory.
    ///
    /// If the last level of the output_directory is not present, it will be created as part of the unpack task.
    /// The returned task can be canceled with `CoreFuture.cancel()` to abort the unpack.
    /// The unpack task writes the full content of the mobile scene package to the output directory. Care should
    /// be taken on devices with limited storage space, especially if the package is very large. After unpacking,
    /// you can remove the original .mspk file from the device.
    ///
    /// Note that unpacking will fail if the package has expired and was authored as
    /// ``Expiration/Kind-swift.enum/preventExpiredAccess``.
    /// - Parameters:
    ///   - fileURL: the path to a mobile scene package file (.mspk)
    ///   - outputDirectoryURL: a path to a directory to write the mobile scene package contents.
    final public class func unpack(at fileURL: URL, to outputDirectoryURL: URL) async throws

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// Used to display point or multipoint geoelements in a scene using a 3D model.
///
/// By default, the symbol will be positioned using the centroid of the model object. Note that this
/// may not be the same as the center of its bounding extent. Model scene symbols cannot be used with
/// a static graphics rendering mode.
/// The supported model file types are:
///   * 3D Max (.3ds)
///   * Collada (.dae)
///   * Filmbox (.fbx)
///   * GL Transmission Format (.gltf, .glb)
///   * Wavefront (.obj)
/// - Note: See Also: ``MarkerSceneSymbol``, ``Symbol``
/// - Since: 200.1
final public class ModelSceneSymbol : ArcGIS.MarkerSceneSymbol, ArcGIS.Loadable {

    /// The list of possible size units for symbols.
    ///
    /// It describes the size units that can be applied to the symbols.
    /// For instance using DIPs for ``ModelSceneSymbol``.
    public enum SymbolSizeUnits {

        /// Render the affected symbol by interpreting the size values as DIPs. Symbols in this mode remain the same screen space size no matter the camera's distance from the symbol itself.
        case dips

        /// Render the affected symbol by interpreting the size values as meters. Symbols in this mode remain the same world space size no matter the camera's distance from the symbol itself.
        case meters

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ModelSceneSymbol.SymbolSizeUnits, b: ArcGIS.ModelSceneSymbol.SymbolSizeUnits) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a model scene symbol.
    /// - Parameters:
    ///   - url: URI of the model.
    ///   - scale: Scaling factor to apply to the model.
    /// - Precondition: `scale > 0`
    public convenience init(url: URL, scale: Float = 1.0)

    /// The size unit of the model scene symbol.
    ///
    /// Default is 'meters'.
    final public var symbolSizeUnits: ArcGIS.ModelSceneSymbol.SymbolSizeUnits

    /// The URI of the model scene symbol.
    final public var url: URL { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension ModelSceneSymbol.SymbolSizeUnits : Equatable {
}

extension ModelSceneSymbol.SymbolSizeUnits : Hashable {
}

/// The mosaic dataset object which is derived from a raster object.
/// - Since: 200.1
final public class MosaicDatasetRaster : ArcGIS.Raster {

    /// Creates a mosaic dataset raster.
    /// - Parameters:
    ///   - databaseURL: Path of the SQLite file that contains mosaic dataset, can be local path or network path.
    ///   - name: The name of the mosaic dataset raster
    public convenience init(databaseURL: URL, name: String)

    /// Adds rasters to mosaic dataset raster.
    /// - Parameter parameters: The add rasters parameters object.
    final public func addRasters(using parameters: ArcGIS.AddRastersParameters) async throws

    /// Creates a mosaic dataset raster with input geodatabase, name, and the desired spatial reference.
    /// - Parameters:
    ///   - geodatabase: The geodatabase object.
    ///   - name: Name of the mosaic dataset raster to be created.
    ///   - spatialReference: The spatial reference of the mosaic dataset raster to be created.
    /// - Returns: A new mosaic dataset raster object.
    final public class func create(in geodatabase: ArcGIS.Geodatabase, name: String, spatialReference: ArcGIS.SpatialReference? = nil) -> ArcGIS.MosaicDatasetRaster

    /// Creates a mosaic dataset raster with the specified database path, name, and the desired spatial reference.
    /// - Parameters:
    ///   - databaseURL: Path of the SQLite file to be created that will contain the mosaic dataset raster.
    ///   - name: Name of the mosaic dataset raster to be created.
    ///   - spatialReference: The spatial reference of the mosaic dataset raster to be created.
    /// - Returns: A new mosaic dataset raster object.
    final public class func create(inDatabaseAt databaseURL: URL, name: String, spatialReference: ArcGIS.SpatialReference? = nil) -> ArcGIS.MosaicDatasetRaster

    /// Returns mosaic dataset table names in the SQLite database.
    ///
    /// This function will retrieve mosaic dataset table names from the input SQLite database. Returns an `Array` of `String`.
    /// - Parameter databaseURL: A SQLite database file.
    /// - Returns: Mosaic dataset table names.
    final public class func names(fromDatabaseAt databaseURL: URL) -> [String]

    /// Deletes mosaic dataset raster from the specified geodatabase.
    /// - Parameters:
    ///   - name: Name of the mosaic dataset raster to be deleted.
    ///   - geodatabase: The geodatabase object.
    final public class func removeRaster(named name: String, from geodatabase: ArcGIS.Geodatabase)
}

/// A rule determining how a requested image should participate in the mosaic
///
/// An image service uses a mosaic rule to mosaic multiple rasters on-the-fly. A mosaic rule parameter is used by
/// many image service operations, such as export image and identify operations.
/// - Note: See Also: https://desktop.arcgis.com/en/arcmap/10.6/manage-data/raster-and-images/understanding-the-mosaicking-rules-for-a-mosaic-dataset.htm
/// - Since: 200.1
final public class MosaicRule {

    /// The mosaic operator is used to define how overlapping cells from various rasters in a mosaic dataset will be resolved in the mosaicked image.
    public enum Operation : CaseIterable {

        /// The overlapping areas will contain the cells from the first raster dataset listed in the mosaic dataset.
        case first

        /// The overlapping areas will contain the cells from the last raster dataset listed in the mosaic dataset.
        case last

        /// The overlapping areas will contain the minimum cell values from all the overlapping cells.
        case min

        /// The overlapping areas will contain the maximum cell values from all the overlapping cells.
        case max

        /// The overlapping areas will contain the mean cell values from all the overlapping cells.
        case mean

        /// The overlapping areas will be a blend of the cell values that overlap; this blend value relies on an algorithm
        /// that is weight based and dependent on the distance from the cells to the edge within the overlapping area.
        ///
        /// You will want to set Blend when using the ``MosaicRule/SortMethod/seamline``.
        case blend

        /// The overlapping areas will contain the total sum of the cell values from all the overlapping cells.
        case sum

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.MosaicRule.Operation, b: ArcGIS.MosaicRule.Operation) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.MosaicRule.Operation]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.MosaicRule.Operation] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A mosaic method specifies how multiple rasters in a ``MosaicDatasetRaster`` are sorted.
    ///
    /// An ``ImageServiceRaster`` may not support every mosaic method. Check the service's metadata
    /// for "Allowed Mosaic Methods" to see which methods are supported. Mosaic methods that are
    /// "view-dependent" order rasters based on where the camera is located while "view-independent"
    /// order rasters the same regardless of where the camera is located.
    /// - Note: See Also: https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/mosaic-operators.htm
    public enum SortMethod : CaseIterable {

        /// Orders rasters based on the order (ObjectID) in the mosaic dataset attribute table. Mosaic results are view-independent.
        case objectID

        /// Orders rasters based on the distance between each raster's center and the view center. Mosaic results are view-dependent.
        case center

        /// Orders rasters based on the distance between each raster's center and the northwest point of the service. Mosaic results are view-independent.
        case northwest

        /// Orders rasters based on the distance between each raster's nadir position and view center. Mosaic results are view-dependent.
        ///
        /// Nadir is defined as the point on the ground vertically beneath the perspective center of the camera lens that captured the image.
        case nadir

        /// Orders rasters based on the distance between each raster's center and a user defined view point. Mosaic results are view-independent.
        case viewpoint

        /// Orders rasters based on the absolute distance between their values of an attribute and a base value.
        /// Only numeric or date fields are applicable. The attribute is specified by ``MosaicRule/sortField``
        /// and the value is specified by ``MosaicRule/sortValue``. Mosaic results are view-independent.
        case attribute

        /// Displays only the selected rasters specified in ``MosaicRule/lockRasterIDs``. Mosaic results are view-independent.
        case lockRaster

        /// Orders rasters based on the predefined seamline. The ``MosaicRule/isAscending`` property is defined by the seamline so is not
        /// applicable anymore. Only two mosaic operations are applicable as listed below. Mosaic results are view-independent.
        ///
        /// https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/mosaic-dataset-seamlines.htm
        case seamline

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.MosaicRule.SortMethod, b: ArcGIS.MosaicRule.SortMethod) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.MosaicRule.SortMethod]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.MosaicRule.SortMethod] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a mosaic rule object
    public convenience init()

    /// Indicates whether this MosaicRule is ascending.
    ///
    /// The default value is the value used when the mosaic data was created, if unavailable, the default value is `true`.
    final public var isAscending: Bool

    /// Rendering rule applied on items before mosaic operation.
    final public var itemRenderingRule: ArcGIS.RenderingRule?

    /// The collection of raster IDs for image service rasters forced to be visible at all scales.
    ///
    /// Used with ``SortMethod/lockRaster``. Cannot be greater than the maximum mosaic image count of the service.
    final public var lockRasterIDs: [Int] { get }

    /// Adds a sequence of `Int` values to the end of the `lockRasterIDs` property.
    /// - Parameter newLockRasterIDs: The new `Int` values to append.
    final public func addLockRasterIDs<S>(_ newLockRasterIDs: S) where S : Sequence, S.Element == Int

    /// Adds an `Int` value to the end of the `lockRasterIDs` property.
    /// - Parameter newLockRasterID: The new `Int` value to append.
    final public func addLockRasterID(_ newLockRasterID: Int)

    /// Inserts a collection of `Int` values into the `lockRasterIDs` property at the specified position.
    /// - Parameters:
    ///   - newLockRasterIDs: The new `Int` values to insert.
    ///   - index: The position at which to insert the new `Int` values.
    final public func insertLockRasterIDs<C>(_ newLockRasterIDs: C, at index: Int) where C : Collection, C.Element == Int

    /// Inserts an `Int` value into the `lockRasterIDs` property at the specified position.
    /// - Parameters:
    ///   - newLockRasterID: The new `Int` value to insert.
    ///   - index: The position at which to insert the new `Int` value.
    final public func insertLockRasterID(_ newLockRasterID: Int, at index: Int)

    /// Removes all values from the `lockRasterIDs` property.
    final public func removeAllLockRasterIDs()

    /// Removes a sequence of `Int` values from the `lockRasterIDs` property.
    /// - Parameter lockRasterIDs: The `Int` values to remove.
    final public func removeLockRasterIDs<S>(_ lockRasterIDs: S) where S : Sequence, S.Element == Int

    /// Removes an `Int` value from the `lockRasterIDs` property.
    /// - Parameter lockRasterID: The `Int` value to remove.
    final public func removeLockRasterID(_ lockRasterID: Int)

    /// Specifies the type of ``SortMethod`` used for sorting resters in a mosaic dataset.
    ///
    /// The default value is the value used when the mosaic data was created, if unavailable, the default value is MosaicMethod.none.
    final public var mosaicMethod: ArcGIS.MosaicRule.SortMethod

    /// Specifies the ``Operation`` used to resolve overlapped pixel values from various rasters in a mosaic dataset.
    ///
    /// The default value is the value used when the mosaic data was created, if unavailable, the default value is MosaicOperation.first.
    final public var mosaicOperation: ArcGIS.MosaicRule.Operation

    /// The collection of raster IDs specifying a subset of rasters used in the mosaic.
    ///
    /// Any of the specified rasters may not be visible at all scales.
    final public var rasterIDs: [Int] { get }

    /// Adds a sequence of `Int` values to the end of the `rasterIDs` property.
    /// - Parameter newRasterIDs: The new `Int` values to append.
    final public func addRasterIDs<S>(_ newRasterIDs: S) where S : Sequence, S.Element == Int

    /// Adds an `Int` value to the end of the `rasterIDs` property.
    /// - Parameter newRasterID: The new `Int` value to append.
    final public func addRasterID(_ newRasterID: Int)

    /// Inserts a collection of `Int` values into the `rasterIDs` property at the specified position.
    /// - Parameters:
    ///   - newRasterIDs: The new `Int` values to insert.
    ///   - index: The position at which to insert the new `Int` values.
    final public func insertRasterIDs<C>(_ newRasterIDs: C, at index: Int) where C : Collection, C.Element == Int

    /// Inserts an `Int` value into the `rasterIDs` property at the specified position.
    /// - Parameters:
    ///   - newRasterID: The new `Int` value to insert.
    ///   - index: The position at which to insert the new `Int` value.
    final public func insertRasterID(_ newRasterID: Int, at index: Int)

    /// Removes all values from the `rasterIDs` property.
    final public func removeAllRasterIDs()

    /// Removes a sequence of `Int` values from the `rasterIDs` property.
    /// - Parameter rasterIDs: The `Int` values to remove.
    final public func removeRasterIDs<S>(_ rasterIDs: S) where S : Sequence, S.Element == Int

    /// Removes an `Int` value from the `rasterIDs` property.
    /// - Parameter rasterID: The `Int` value to remove.
    final public func removeRasterID(_ rasterID: Int)

    /// The field name used together with ``SortMethod/attribute`` method.
    final public var sortField: String

    /// The base sort value used together with ``SortMethod/attribute`` method. This value is compared with
    /// the value of the field specified by ``sortField`` parameter.
    final public var sortValue: String

    /// The viewpoint used along with ``SortMethod/viewpoint`` method.
    final public var viewpoint: ArcGIS.Viewpoint?

    /// SQL WHERE clause to define a subset of rasters used in the mosaic.
    ///
    /// Any of the rasters in the subset may not be visible at all scales.
    final public var whereClause: String
}

extension MosaicRule.Operation : Equatable {
}

extension MosaicRule.Operation : Hashable {
}

extension MosaicRule.SortMethod : Equatable {
}

extension MosaicRule.SortMethod : Hashable {
}

/// An error than can occur when dealing with motion sensors.
/// - Since: 200.1
public enum MotionSensorError : Error {

    /// Device doesn't support accelerometer.
    case accelerometerNotSupported

    /// Device doesn't support gyroscope.
    case gyroscopeNotSupported

    /// Device doesn't support magnetometer.
    case magnetometerNotSupported

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension MotionSensorError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.MotionSensorError, b: ArcGIS.MotionSensorError) -> Bool
}

extension MotionSensorError : Hashable {
}

/// Multilayer Point symbol
///
/// This is a point symbol with multiple layers. Each layer has its own properties, such as offset,
/// anchor, and rotation, that can be combined to create a point symbol with special effects
/// (concentric circles or a pushpin, for example). These symbols are rendered with point geometry.
/// - Note: See Also: ``Symbol``, ``MultilayerSymbol``
/// - Since: 200.1
final public class MultilayerPointSymbol : ArcGIS.MultilayerSymbol {

    /// Creates a multilayer point symbol object with symbol layers and ``SymbolReferenceProperties``.
    /// - Parameters:
    ///   - symbolLayers: A collection of symbol layers that make up the symbol.
    ///   - referenceProperties: The symbol reference properties for the symbol
    public convenience init(symbolLayers: [ArcGIS.SymbolLayer], referenceProperties: ArcGIS.SymbolReferenceProperties? = nil)

    /// The angle in degrees.
    ///
    /// Angle for multilayer point symbols is measured in degrees counterclockwise from the east,
    /// from 0 to 360. The angle for a multilayer point symbol defaults to 0. Marker symbol layers
    /// can have a separate heading value defined (which is also 0 by default). Setting a heading
    /// for a marker symbol layer does not affect the angle of the point symbol. When an angle
    /// value is set for the point symbol, however, that value is applied cumulatively to all the
    /// marker symbol layers it contains. The heading for individual symbol layers must be re-fetched
    /// in order to see the updated value.
    final public var angle: Float

    /// The symbol angle alignment of the multilayer point symbol.
    ///
    /// The angle alignment of the multilayer point symbol.
    final public var angleAlignment: ArcGIS.SymbolAngleAlignment

    /// The symbol size in DIPs.
    ///
    /// When getting the size from a multilayer point symbol, the value reported is the largest size
    /// of all the symbol layers it contains. The symbol size is updated when its symbol layer sizes
    /// change (if there is a new largest layer size). When setting a new size at the point symbol
    /// level, the size of the largest symbol layer is given the provided value, and all the smaller
    /// layers are sized proportionately. An individual symbol layer can be given a specific size without
    /// affecting the other layers.
    final public var size: CGFloat
}

/// Multilayer Polygon symbol
///
/// This is a polygon symbol with multiple layers. Each layer has its own properties like width, height,
/// and offset, that can be combined to create polygon symbols with special effects (a polygon
/// with a marker in the center, for example). These symbols are rendered with polygon geometry.
/// - Note: See Also: ``Symbol``, ``MultilayerSymbol``
/// - Since: 200.1
final public class MultilayerPolygonSymbol : ArcGIS.MultilayerSymbol {

    /// Creates a multilayer polygon symbol object with symbol layers and ``SymbolReferenceProperties``.
    /// - Parameters:
    ///   - symbolLayers: A collection of symbol layers that make up the symbol.
    ///   - referenceProperties: The symbol reference properties for the symbol.
    public convenience init(symbolLayers: [ArcGIS.SymbolLayer], referenceProperties: ArcGIS.SymbolReferenceProperties? = nil)
}

/// Multilayer Polyline symbol
///
/// This is a polyline symbol with multiple layers. Each layer has its own properties, like width and dash patterns,
/// that can be combined to create line symbols with special effects (a solid road with dashed pattern on top
/// to show the center line, for example). These symbols are rendered with polyline geometry.
/// - Note: See Also: ``Symbol``, ``MultilayerSymbol``
/// - Since: 200.1
final public class MultilayerPolylineSymbol : ArcGIS.MultilayerSymbol {

    /// Creates a multilayer polyline symbol object with symbol layers and ``SymbolReferenceProperties``.
    /// - Parameters:
    ///   - symbolLayers: A collection of symbol layers that make up the symbol.
    ///   - referenceProperties: The symbol reference properties for the symbol
    public convenience init(symbolLayers: [ArcGIS.SymbolLayer], referenceProperties: ArcGIS.SymbolReferenceProperties? = nil)

    /// The width of the symbol in device-independent pixels (DIPs).
    ///
    /// When getting the width from a multilayer polyline symbol, the value reported is the largest
    /// width of all the symbol layers it contains. The symbol width is updated when its symbol
    /// layer widths change (if there is a new largest layer width). When setting a new width at
    /// the polyline symbol level, the width of the largest symbol layer is given the provided value,
    /// and all the smaller layers are sized proportionately. An individual symbol layer can be
    /// given a specific width without affecting the other layers.
    final public var width: CGFloat
}

/// A base class for multilayer symbols. Multilayer symbols are built from multiple layers of symbols, which
/// combine to let you add complex symbols to maps and scenes.
///
/// Multilayer symbols can be returned from feature layers based on web maps, feature services (with Use Advanced
/// Symbology set to `true`), or mobile map packages. They can also be created from JSON by calling
/// ``Symbol/fromJSON(_:)``. You can programmatically create and change them using the
/// ``MultilayerPointSymbol``, ``MultilayerPolylineSymbol``, and ``MultilayerPolygonSymbol`` subclasses. You can
/// also access the layers that comprise the symbol through ``symbolLayers`` and modify their
/// properties, such as the color of a multilayer symbol. Some subclasses also expose additional symbol properties.
///
/// The symbol layers that comprise the symbol can be of different types. For example, a polyline geometry may be
/// drawn with a ``MultilayerPolylineSymbol`` that has line (stroke) symbol layers that draw the line geometry,
/// and also point (marker) symbol layers that are drawn at specified point locations relative to the line
/// geometry. When you save an ArcGIS Pro map as a web map, any multilayer symbols in the map are converted to
/// simple symbols. In general, point symbols are converted to picture marker symbols optimized for the web, and
/// line and polygon symbols are simplified while representing the original symbol as closely as possible. If
/// you're authoring a feature service from ArcGIS Pro or ArcGIS Desktop, however, both the original symbols and
/// the simplified symbols are stored. The stored symbols allow clients that support advanced symbols to
/// render the features as originally symbolized, while those that do not support advanced symbols (such as ArcGIS
/// Online Map Viewer) can use the simple symbols for display. Having both sets of symbols allows you to retain the
/// advanced symbology where available and still share the feature service as widely as possible. Symbols used by
/// web scenes are also multilayer but use a different symbol specification than ArcGIS Pro and this API.
/// When you read symbols from a web scene in your app, you get a representation of the multilayer symbol.
/// Symbol layers in a multilayer symbol are in reverse order of how they appear in the JSON representation from
/// the server.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
public class MultilayerSymbol : ArcGIS.Symbol {

    /// The consensus color of all layers in the symbol (excluding those that are color-locked).
    ///
    /// Because ``MultilayerSymbol`` may have multiple symbol layers, this property represents the value
    /// of all color and tint color properties of constituent symbol layers, excluding any
    /// ``StrokeSymbolLayer`` in a ``MultilayerPolygonSymbol``, as those symbol layers are
    /// outlines. The property defines the color and tint color of symbols contained in
    /// ``VectorMarkerSymbolElement``. Constituent symbol layers whose colorLocked property is
    /// `true` do not change color as a result of this function. To change outline colors, modify the
    /// outline symbol layer colors individually.
    public var color: UIColor

    /// The ``SymbolReferenceProperties`` for this symbol.
    public var referenceProperties: ArcGIS.SymbolReferenceProperties?

    /// The symbol layers of the multilayer symbol.
    ///
    /// Symbol layers in a multilayer symbol are in reverse order of how they appear in the JSON representation from the server.
    public var symbolLayers: [ArcGIS.SymbolLayer] { get }

    /// Adds a sequence of `SymbolLayer` values to the end of the `symbolLayers` property.
    /// - Parameter newSymbolLayers: The new `SymbolLayer` values to append.
    public func addSymbolLayers<S>(_ newSymbolLayers: S) where S : Sequence, S.Element == ArcGIS.SymbolLayer

    /// Adds a `SymbolLayer` value to the end of the `symbolLayers` property.
    /// - Parameter newSymbolLayer: The new `SymbolLayer` value to append.
    public func addSymbolLayer(_ newSymbolLayer: ArcGIS.SymbolLayer)

    /// Inserts a collection of `SymbolLayer` values into the `symbolLayers` property at the specified position.
    /// - Parameters:
    ///   - newSymbolLayers: The new `SymbolLayer` values to insert.
    ///   - index: The position at which to insert the new `SymbolLayer` values.
    public func insertSymbolLayers<C>(_ newSymbolLayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.SymbolLayer

    /// Inserts a `SymbolLayer` value into the `symbolLayers` property at the specified position.
    /// - Parameters:
    ///   - newSymbolLayer: The new `SymbolLayer` value to insert.
    ///   - index: The position at which to insert the new `SymbolLayer` value.
    public func insertSymbolLayer(_ newSymbolLayer: ArcGIS.SymbolLayer, at index: Int)

    /// Removes all values from the `symbolLayers` property.
    public func removeAllSymbolLayers()

    /// Removes a sequence of `SymbolLayer` values from the `symbolLayers` property.
    /// - Parameter symbolLayers: The `SymbolLayer` values to remove.
    public func removeSymbolLayers<S>(_ symbolLayers: S) where S : Sequence, S.Element == ArcGIS.SymbolLayer

    /// Removes a `SymbolLayer` value from the `symbolLayers` property.
    /// - Parameter symbolLayer: The `SymbolLayer` value to remove.
    public func removeSymbolLayer(_ symbolLayer: ArcGIS.SymbolLayer)
}

/// Defines common members for polyline and polygon multipart geometries.
/// - Remark: Multipart geometries are based upon the parent ``Geometry`` class.
/// The geometry class is immutable which means that you cannot change its shape
/// once it is created. If you need to modify a multipart once it has been
/// created, use the ``MultipartBuilder`` class instead. The
/// ``GeometryBuilder/toGeometry()`` method provides you with the base geometry
/// object.
///
/// A multipart geometry is comprised of a collection of shapes (of the same
/// type) that is managed as a single geometry. A classic example is a set of
/// islands that represent a single country or state. The individual island
/// shapes are distinct, but ArcGIS considers it a single geometry.
///
/// ``Polygon`` and ``Polyline`` inherit from `Multipart`, which in turn
/// inherits from ``Geometry``. Multipart provides access to the geometry's
/// ``PartCollection`` via the ``Multipart/parts`` property. Each ``Part`` in
/// the collection is a collection of ``Segment`` objects. You can iterate
/// through the segments or points in each part.
/// - Note: See Also: ``Geometry``
/// - Since: 200.1
public protocol Multipart : ArcGIS.Geometry {

    /// Creates an instance with the given parts.
    ///
    /// The spatial reference of the instance will be either the spatial
    /// reference of the first part or `nil` if there are no parts.
    /// - Parameter parts: The parts with which to create the instance. All
    /// parts must have the same spatial reference.
    init<S>(parts: S) where S : Sequence, S.Element == ArcGIS.MutablePart
}

extension Multipart {

    /// The parts for the multipart.
    public var parts: ArcGIS.PartCollection { get }

    /// Creates an instance with a single part made up of the given points.
    ///
    /// The spatial reference of the instance will be either the spatial
    /// reference of the first point or `nil` if there are no points.
    /// - Parameter points: The points with which to create the instance. All
    /// points must have the same spatial reference.
    public init<S>(points: S) where S : Sequence, S.Element == ArcGIS.Point

    /// Creates an instance with a single part made up of the given points.
    /// - Parameters:
    ///   - points: The points with which to create the instance. The spatial
    ///   reference of each point must either be `nil` or equal to
    ///   `spatialReference`.
    ///   - spatialReference: The spatial reference for the instance.
    public init<S>(points: S, spatialReference: ArcGIS.SpatialReference?) where S : Sequence, S.Element == ArcGIS.Point
}

/// A geometry builder that builds a multipart geometry.
/// - Since: 200.1
public protocol MultipartBuilder : ArcGIS.GeometryBuilder<Self.Buildable> {

    /// The type of geometry buildable by this builder.
    associatedtype Buildable : ArcGIS.Multipart

    /// Creates a builder with the given spatial reference.
    /// - Parameter spatialReference: The spatial reference for the builder.
    init(spatialReference: ArcGIS.SpatialReference?)
}

extension MultipartBuilder {

    /// The parts for the multipart builder.
    public var parts: ArcGIS.MutablePartCollection

    /// Creates a builder with the given parts.
    ///
    /// The spatial reference of the builder will be either the spatial
    /// reference of the first part or `nil` if there are no parts.
    /// - Parameter parts: The parts with which to create the builder. All parts
    /// must have the same spatial reference.
    public init<S>(parts: S) where S : Sequence, S.Element == ArcGIS.MutablePart

    /// Adds a new point to the end of the last part of the multipart.
    /// - Remark: If there are no parts, then an initial part is created and the
    /// point is added to that. The point becomes the end point of a line
    /// segment in the part.
    /// - Parameter point: The point to add.
    /// - Returns: The point index of the new point in the last part.
    @discardableResult
    public func add(_ point: ArcGIS.Point) -> Int
}

/// An ordered collection of points that can be managed as a single geometry.
///
/// ``Multipoint`` geometries represent an ordered collection of points. They can be used as
/// the geometry of features and graphics, or as input or output for spatial operations. For
/// features that consist of a very large number of points that share the same set of attribute
/// values, multipoints may be more efficient to store and analyze in a geodatabase compared to
/// using multiple point features.
///
/// A ``Multipoint`` is composed of a single read-only collection of ``Point``. Use ``MultipointBuilder``
/// to build a multipoint one point at a time or to modify an existing ``Multipoint``.
/// - Note: See Also: ``Geometry``
/// - Since: 200.1
final public class Multipoint : ArcGIS.Geometry {

    /// The read-only collection of points for the multipoint.
    ///
    /// Use ``MultipointBuilder`` to build a multipoint one point at a time or to modify
    /// the points that compose an existing ``Multipoint``.
    final public var points: ArcGIS.PointCollection { get }
}

extension Multipoint {

    /// Creates a multipoint with the given points.
    ///
    /// The spatial reference of the multipoint will be either the spatial
    /// reference of the first point or `nil` if there are no points.
    /// - Parameter points: The points with which to create the multipoint. All
    /// points must have the same spatial reference.
    public convenience init<S>(points: S) where S : Sequence, S.Element == ArcGIS.Point

    /// Creates a multipoint with the given points and spatial reference.
    /// - Parameters:
    ///   - points: The points with which to create the multipoint.
    ///   - spatialReference: The spatial reference for the multipoint.
    public convenience init<S>(points: S, spatialReference: ArcGIS.SpatialReference?) where S : Sequence, S.Element == ArcGIS.Point
}

/// The multipoint builder object is used to create a multipoint.
/// - Since: 200.1
final public class MultipointBuilder : ArcGIS.GeometryBuilder<ArcGIS.Multipoint> {

    /// Creates a multipoint builder from a multipoint.
    /// - Parameter multipoint: A multipoint object.
    public convenience init(multipoint: ArcGIS.Multipoint)

    /// Creates a multipoint builder.
    /// - Parameter spatialReference: The builder's spatial reference.
    public convenience init(spatialReference: ArcGIS.SpatialReference? = nil)

    /// A mutable collection of points.
    ///
    /// Use this collection to add points to or remove points from the builder.
    final public var points: ArcGIS.MutablePointCollection
}

extension MultipointBuilder {

    /// Creates a builder with the given points.
    ///
    /// The spatial reference of the builder will be either the spatial
    /// reference of the first point or `nil` if there are no points.
    /// - Parameter points: The points with which to create the builder. All
    /// points must have the same spatial reference.
    public convenience init<S>(points: S) where S : Sequence, S.Element == ArcGIS.Point

    /// Creates a builder with the given points and spatial reference.
    /// - Parameters:
    ///   - points: The points with which to create the builder.
    ///   - spatialReference: The spatial reference for the builder.
    public convenience init<S>(points: S, spatialReference: ArcGIS.SpatialReference?) where S : Sequence, S.Element == ArcGIS.Point
}

/// Represents a single part of a multipart builder.
///
/// Multipart builder is the base class of ``PolygonBuilder`` or ``PolylineBuilder``.
/// A part is made up of a collection of segments making the edge of the multipart.
/// Additionally access and modified using the points (vertexes) of segments is available.
/// Adjacent segments which share an end point and a start point are connected and the shared vertex is not duplicated when accessing points.
/// The mutable part can represent gaps between one end point and an adjacent start.
/// However, this is only recommended as a temporary state while modifying a multipart builder,
/// when using `GeometryBuilder.toGeometry()` the gaps are closed with line segments.
///
/// Prior to v100.12, the only supported segment type was ``LineSegment``.
///
/// From v100.12, curve segments can be added to a ``MutablePart`` and used build polygon and polyline
/// geometries. A part may contain a mix of linear and curve segments.
/// - Note: See Also: ``CubicBezierSegment``, ``EllipticArcSegment``, ``LineSegment``
/// - Since: 200.1
final public class MutablePart {

    /// Creates a part with a specified spatial reference.
    /// - Parameter spatialReference: A spatial reference object, can be `nil`.
    public convenience init(spatialReference: ArcGIS.SpatialReference? = nil)

    /// The end point of the last segment in the part.
    /// Returns `nil` if the collection is empty.
    final public var endPoint: ArcGIS.Point? { get }

    /// Indicates if the part contains any curve segments.
    ///
    /// Prior to v100.12, only ``LineSegment`` linear segments were available to be added to mutable parts when
    /// building geometries.
    ///
    /// From v100.12, geometry builders support curve segments. This property returns `true` if any segments where
    /// ``Segment/isCurve`` is `true` have been added to the part.
    /// - Note: See Also: ``Geometry/hasCurves``, ``GeometryBuilder/hasCurves``, ``Segment/isCurve``
    final public var hasCurves: Bool { get }

    /// Indicates if the part contains no segments.
    final public var isEmpty: Bool { get }

    /// The spatial reference for the part.
    ///
    /// If the mutable_part does not have a spatial reference `nil` is returned.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The start point of the first segment in the part.
    /// Returns `nil` if the collection is empty.
    final public var startPoint: ArcGIS.Point? { get }
}

extension MutablePart : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.MutablePart, rhs: ArcGIS.MutablePart) -> Bool
}

extension MutablePart {

    /// A view into a mutable part as points.
    public struct PointView {
    }

    /// The points of the mutable part, as a view into the mutable part.
    final public var points: ArcGIS.MutablePart.PointView
}

extension MutablePart {

    /// A view into a mutable part as segments.
    public struct SegmentView {
    }

    /// The segments of the mutable part, as a view into the mutable part.
    final public var segments: ArcGIS.MutablePart.SegmentView
}

extension MutablePart {

    /// Creates a part with the given points.
    ///
    /// The spatial reference of the part will be either the spatial reference
    /// of the first point or `nil` if there are no points.
    /// - Parameter points: The points with which to create the part. All points
    /// must have the same spatial reference.
    public convenience init<S>(points: S) where S : Sequence, S.Element == ArcGIS.Point

    /// Creates a part with the given points and spatial reference.
    /// - Parameters:
    ///   - points: The points with which to create the part. The spatial
    ///   reference of each point must either be `nil` or equal to
    ///   `spatialReference`.
    ///   - spatialReference: The spatial reference for the part.
    public convenience init<S>(points: S, spatialReference: ArcGIS.SpatialReference?) where S : Sequence, S.Element == ArcGIS.Point

    /// Creates a part with the given segments.
    ///
    /// The spatial reference of the part will be either the spatial reference
    /// of the first segment or `nil` if there are no segments.
    /// - Parameter segments: The segments with which to create the part. All
    /// segments must have the same spatial reference.
    public convenience init<S>(segments: S) where S : Sequence, S.Element == ArcGIS.Segment

    /// Creates a part with the given segments and spatial reference.
    /// - Parameters:
    ///   - segments: The segments with which to create the part. The spatial
    ///   reference of each segment must either be `nil` or equal to
    ///   `spatialReference`.
    ///   - spatialReference: The spatial reference for the part.
    public convenience init<S>(segments: S, spatialReference: ArcGIS.SpatialReference?) where S : Sequence, S.Element == ArcGIS.Segment
}

extension MutablePart {

    /// Returns the index of the end point of the segment at the given index.
    /// - Parameter index: The index of a segment.
    /// - Returns: An index of a point or `nil` if `index` is not a valid index
    /// of a segment.
    final public func indexOfEndPointForSegment(at index: ArcGIS.MutablePart.SegmentView.Index) -> ArcGIS.MutablePart.PointView.Index?

    /// Returns the index of the segment whose end point is the point at the
    /// given index.
    /// - Parameter index: The index of a point.
    /// - Returns: An index of a segment or `nil` if `index` is not a valid
    /// index of a point.
    final public func indexOfSegmentWithEndPoint(at index: ArcGIS.MutablePart.PointView.Index) -> ArcGIS.MutablePart.SegmentView.Index?

    /// Returns the index of the segment whose start point is the point at the
    /// given index.
    /// - Parameter index: The index of a point.
    /// - Returns: An index of a segment or `nil` if `index` is not a valid
    /// index of a segment.
    final public func indexOfSegmentWithStartPoint(at index: ArcGIS.MutablePart.PointView.Index) -> ArcGIS.MutablePart.SegmentView.Index?

    /// Returns the index of the start point of the segment at the given index.
    /// - Parameter index: The index of a segment.
    /// - Returns: An index of a point or `nil` if `index` is not a valid index
    /// of a segment.
    final public func indexOfStartPointForSegment(at index: ArcGIS.MutablePart.SegmentView.Index) -> ArcGIS.MutablePart.PointView.Index?
}

extension MutablePart.PointView : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> ArcGIS.Point

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Point

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.MutablePart.PointView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.MutablePart.PointView>
}

extension MutablePart.PointView : RangeReplaceableCollection {

    /// Creates a new, empty collection.
    public init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where C : Collection, C.Element == ArcGIS.Point

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)
}

extension MutablePart.PointView : MutableCollection {
}

extension MutablePart.SegmentView : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> ArcGIS.Segment

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Segment

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.MutablePart.SegmentView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.MutablePart.SegmentView>
}

extension MutablePart.SegmentView : RangeReplaceableCollection {

    /// Creates a new, empty collection.
    public init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where C : Collection, C.Element == ArcGIS.Segment

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)
}

extension MutablePart.SegmentView : MutableCollection {
}

/// A collection object that can be changed containing parts for a geometry.
/// Each part is represented by a ``MutablePart``.
/// - Note: See Also: ``PartCollection``
/// - Since: 200.1
final public class MutablePartCollection {

    /// Creates a mutable part collection with a specified spatial reference.
    /// - Parameter spatialReference: A spatial reference object, can be `nil`.
    public convenience init(spatialReference: ArcGIS.SpatialReference?)

    /// The spatial reference for the mutable part collection.
    ///
    /// If the collection does not have a spatial reference `nil` is returned.
    final public var spatialReference: ArcGIS.SpatialReference? { get }
}

extension MutablePartCollection : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable final public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    final public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    final public subscript(position: Int) -> ArcGIS.MutablePart

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.MutablePart

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.MutablePartCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.MutablePartCollection>
}

extension MutablePartCollection : RangeReplaceableCollection {

    /// Creates a new, empty collection.
    public convenience init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    final public func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where C : Collection, C.Element == ArcGIS.MutablePart

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    final public func removeAll(keepingCapacity keepCapacity: Bool = false)
}

extension MutablePartCollection : MutableCollection {
}

extension MutablePartCollection {

    /// Creates a mutable part collection with the given parts and spatial
    /// reference.
    /// - Parameters:
    ///   - parts: The parts with which to create the collection. The spatial
    ///   reference of each parts must either be `nil` or equal to
    ///   `spatialReference`.
    ///   - spatialReference: The spatial reference for the collection.
    public convenience init<S>(parts: S, spatialReference: ArcGIS.SpatialReference? = nil) where S : Sequence, S.Element == ArcGIS.MutablePart
}

/// A collection object that can be changed containing points.
///
/// Contains a collection of points that can be changed.
/// - Note: See Also: ``PointCollection``
/// - Since: 200.1
final public class MutablePointCollection {

    /// Creates a mutable point collection with a specified spatial reference.
    /// - Parameter spatialReference: A spatial reference object, can be `nil`.
    public convenience init(spatialReference: ArcGIS.SpatialReference?)

    /// The spatial reference for the mutable point collection.
    ///
    /// If the collection does not have a spatial reference `nil` is returned.
    final public var spatialReference: ArcGIS.SpatialReference? { get }
}

extension MutablePointCollection : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable final public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    final public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    final public subscript(position: Int) -> ArcGIS.Point

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Point

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.MutablePointCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.MutablePointCollection>
}

extension MutablePointCollection : RangeReplaceableCollection {

    /// Creates a new, empty collection.
    public convenience init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    final public func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where C : Collection, C.Element == ArcGIS.Point

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    final public func removeAll(keepingCapacity keepCapacity: Bool = false)
}

extension MutablePointCollection : MutableCollection {
}

extension MutablePointCollection {

    /// Creates a mutable point collection with the given spatial reference and
    /// points.
    /// - Parameters:
    ///   - points: The points with which to create the collection. The spatial
    ///   reference of each point must either be `nil` or equal to
    ///   `spatialReference`.
    ///   - spatialReference: The spatial reference for the collection.
    public convenience init<S>(points: S, spatialReference: ArcGIS.SpatialReference? = nil) where S : Sequence, S.Element == ArcGIS.Point
}

/// Enumeration of supported GNSS (Global Navigation Satellite System) systems.
/// - Since: 200.1
public enum NMEAGNSSSystem {

    /// The Global Positioning System.
    case gps

    /// The Russian Global Navigation Satellite System.
    case glonass

    /// The European Union Global Navigation Satellite System.
    case galileo

    /// The BeiDou Navigation Satellite System.
    ///
    /// Is a Chinese satellite navigation system.
    case bds

    /// The Quasi-Zenith Satellite System.
    ///
    /// Is a Japanese satellite navigation system.
    case qzss

    /// The Navigation Indian Constellation.
    ///
    /// Was renamed from IRNSS (Indian Regional Navigation Satellite System).
    case navIC

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.NMEAGNSSSystem, b: ArcGIS.NMEAGNSSSystem) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension NMEAGNSSSystem : Equatable {
}

extension NMEAGNSSSystem : Hashable {
}

/// An NMEA location object.
///
/// Contains information about parsed NMEA location.
/// - Since: 200.1
final public class NMEALocation : ArcGIS.Location {

    /// The list of NMEA accuracy types.
    /// - Note: See Also: ``NMEALocation/accuracyType-swift.property``
    public enum AccuracyType {

        /// An accuracy calculated from GST (pseudo-range error statistics) message.
        case gst

        /// An accuracy calculated from GSA (DOP and active satellites) message.
        case gsa

        /// An accuracy calculated from GGA (time, position, and fix-related data) message.
        case gga

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.NMEALocation.AccuracyType, b: ArcGIS.NMEALocation.AccuracyType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of NMEA fix types.
    ///
    /// Indicates the type of signal or technique being used by the GPS receiver to determine its location.
    /// For example it indicates the quality of the signal, or the accuracy and reliability of the location being reported.
    /// The fix type is determined by the receiver based on number of satellites visible,
    /// the type of GPS receiver and the GPS technology being used.
    /// - Note: See Also: ``NMEALocation/fixType-swift.property``
    public enum FixType {

        /// An invalid GPS fix type.
        /// Indicates that there is no satellite signal being received or there are not enough satellites available for proper location determination.
        case invalid

        /// A standard GPS fix type. Indicates a standard GPS signal, or Standard Positioning Service (SPS) is being used.
        /// SPS is the standard specified level of positioning and timing accuracy that is available,
        /// without qualification or restrictions, to any user on a continuous worldwide basis.
        case standard

        /// A differential GPS fix type. Indicates that Differential GPS is being used to provide increased accuracy over SPS.
        /// This technique uses a network of fixed ground based reference stations to broadcast the difference between the positions
        /// indicated by the satellite systems and the known fixed positions.
        case dgps

        /// A PPS GPS fix type. Indicates that Precise Positioning System, encrypted for government use is being used by the receiver.
        /// PPS is the most accurate positioning, velocity, and timing information continuously available, worldwide, from the basic GPS.
        case pps

        /// A real time kinematic GPS fix type.
        /// A technique used in land survey based on the use of carrier phase measurements of the GPS signals
        /// where a single reference station provides the real-time corrections of even to a centimeter level of accuracy.
        case rtk

        /// A float real time kinematic GPS fix type.
        /// The type is very similar to the fixed RTK (``rtk``) method of calculating location,
        /// but is not as precise, typically around 20 cm to 1 meter accuracy range.
        case frtk

        /// An estimated GPS fix type.
        /// The type is the determination of a location based on computations of position given an accurately known point
        /// of origin and measurements of speed, heading and elapsed time.
        case estimated

        /// A manual input mode GPS fix type.
        /// Indicates that the location has been manually entered into the GPS receiver, and is not based on the satellite system.
        case manual

        /// A simulation mode GPS fix type.
        case simulation

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.NMEALocation.FixType, b: ArcGIS.NMEALocation.FixType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The accuracy type of the location.
    final public var accuracyType: ArcGIS.NMEALocation.AccuracyType { get }

    /// The DGPS age of the location in seconds.
    ///
    /// The DGPSAge shows the age of the differential data (in seconds) and the time elapsed since the last valid
    /// differential correction received. Because the validity of a differential correction depends on the difference
    /// between the time the differential signal is calculated and the time it is used by the receiver, smaller values are better.
    final public var dgpsAge: TimeInterval { get }

    /// The fix type of the location.
    /// - Note: See Also: ``FixType-swift.enum``
    final public var fixType: ArcGIS.NMEALocation.FixType { get }

    /// The geoidal separation in meters.
    final public var geoidalSeparation: Measurement<UnitLength> { get }

    /// The HDOP (horizontal dilution of precision) of the location, 0.5 through 99.9.
    final public var hdop: Double { get }

    /// The height above the geoid surface in meters.
    final public var heightAboveGeoid: Measurement<UnitLength> { get }

    /// The PDOP (positional dilution of precision) of the location 0.5 through 99.9.
    final public var pdop: Double { get }

    /// The position originally returned by the receiver.
    ///
    /// If the incoming data was projected this position may differ from the ``Location/position``.
    final public var receivedPosition: ArcGIS.Point { get }

    /// The reference station ID of the location.
    final public var referenceStationID: Int { get }

    /// The satellites info of the location.
    final public var satellites: [ArcGIS.NMEASatelliteInfo] { get }

    /// The VDOP (vertical dilution of precision) of the location, 0.5 through 99.9.
    final public var vdop: Double { get }
}

extension NMEALocation.AccuracyType : Equatable {
}

extension NMEALocation.AccuracyType : Hashable {
}

extension NMEALocation.FixType : Equatable {
}

extension NMEALocation.FixType : Hashable {
}

/// An NMEA location data source object.
/// - Remark: This object will parse specific NMEA messages pushed into it.  Valid GGA, GSA, GST, GSV, RMC, VTG messages are
/// parsed. This data source is based on NMEA version 4.11 (November 2018).
/// - Since: 200.1
final public class NMEALocationDataSource : ArcGIS.LocationDataSource {

    /// Creates an NMEA data source object.
    /// - Remark: Locations created from an NMEA data source object instantiated
    /// with this constructor will be projected from the spatial reference
    /// defined by the `receiverSpatialReference` parameter to the spatial
    /// reference defined by the `outputSpatialReference` parameter using
    /// `outputDatumTransformation`. If `outputSpatialReference` is `nil`, the
    /// locations will not be projected and the locations will be in
    /// `receiverSpatialReference`. If `outputDatumTransformation` is set it
    /// will be ignored. This initializer can be used when a receiver is
    /// outputting locations in a spatial reference other than WGS84, such as
    /// when using a reference base station, and/or the application requires the
    /// output locations to be projected to a different spatial reference using
    /// a datum transformation.
    /// - Parameters:
    ///   - receiverSpatialReference: The spatial reference of incoming NMEA
    ///   receiver data. The default value is a spatial reference of WGS84.
    ///   - outputSpatialReference: The spatial reference to project the
    ///   NMEA location to.
    ///   - outputDatumTransformation: The datum transformation to use to
    ///   project the NMEA location.
    public convenience init(receiverSpatialReference: ArcGIS.SpatialReference = SpatialReference(wkid: WKID(4326)!, verticalWKID: WKID(115700)!)!, outputSpatialReference: ArcGIS.SpatialReference? = nil, outputDatumTransformation: ArcGIS.DatumTransformation? = nil)

    /// Creates an NMEA data source object with the provided `EAAccessory`
    /// object and protocol string and reads input data from the connected NMEA
    /// hardware.
    /// - Remark: Use this initializer when you have a bluetooth connected NMEA
    /// hardware connected to your iOS device. When the data source is started,
    /// incoming data is automatically read, so you don't have to call
    /// ``pushData(_:)``. Note that you are still responsible for NMEA hardware
    /// device discoverabilty. Once connected via bluetooth, the connected
    /// accessories can be obtained by using the `connectedAccessories` property
    /// on the shared `EAAccessoryManager`. Locations created from an NMEA data
    /// source object instantiated with this initializer will have spatial
    /// reference of WGS84.
    /// - Parameters:
    ///   - accessory: The `EAAccessory` object for the NMEA hardware device to
    ///   which iOS device is connected via bluetooth.
    ///   - protocolString: The protocol string for the connected NMEA device.
    ///   Protocol string names are formatted as reverse-DNS strings. For
    ///   example, the string com.apple.myProtocol might represent a custom
    ///   protocol defined by Apple. Manufacturers can define custom protocols
    ///   for their accessories or work with other manufacturers and
    ///   organizations to define standard protocols for different accessory
    ///   types. The protocol strings of an accessory can be discovered using
    ///   the `protocolString` property on the `EAAccessory` object. You are required
    ///   to provide this protocol string in Information Property List Key
    ///   UISupportedExternalAccessoryProtocols. For more information, see [here](https://developer.apple.com/documentation/bundleresources/information_property_list/uisupportedexternalaccessoryprotocols?language=objc).
    public convenience init?(accessory: EAAccessory, protocol protocolString: String)

    /// The datum transformation to be used in the project operation.
    /// - Remark: If not `nil`, this property will be used as the datum
    /// transformation in the call to
    /// ``GeometryEngine/project(_:into:datumTransformation:)``.
    /// For this property to be used, ``outputSpatialReference`` must also not
    /// be `nil`.
    final public var outputDatumTransformation: ArcGIS.DatumTransformation? { get }

    /// If not `nil`, ``GeometryEngine/project(_:into:datumTransformation:)``
    /// is called to generate the output spatial reference.
    /// - Remark: The projected point will be stored in ``Location/position``.
    /// If this property is `nil`, ``Location/position`` will be the original
    /// incoming x,y,z values from the NMEA data sentence and the
    /// receiver spatial reference.
    final public var outputSpatialReference: ArcGIS.SpatialReference? { get }

    /// The spatial reference to be assigned to the output location, the default
    ///  is WGS84.
    /// - Remark: By default this will be WGS84 for its horizontal (WKID=4326)
    /// and vertical reference systems (WKID=115700), this can be set to a
    /// different spatial reference if a receiver returns locations in a
    /// different reference system.
    final public var receiverSpatialReference: ArcGIS.SpatialReference { get }

    /// A stream that produces a value when the satellites change for the location data source.
    final public var satellites: AsyncStream<[ArcGIS.NMEASatelliteInfo]> { get }

    /// Reads the input NMEA data creating an `NMEALocation` instance.
    /// - Remark: When pushing data:
    /// * Each sentence needs to begins with a '$'.
    /// * Each sentence needs to end with carriage return/line feed sequence.
    /// * Single or multiple sentences can be pushed at one time, all strings in
    /// the buffer will be parsed.
    /// * There is no explicit limit on the amount of data that can pushed at
    /// one time.
    /// * If a partial sentences are pushed the data source accumulates (and
    /// concatenates) the pushed data until a carriage return/line feed sequence
    /// is reached.
    /// * The data source parses these messages types: GGA, GSA, GST, GSV, RMC,
    /// VTG.
    /// * Each sentence's checksum is validated
    /// * Unknown/bad/incorrect sentences are ignored (they do not produce any
    /// location, satellite updates etc.).
    /// * Sentences support up to 256 characters (this is beyond the NMEA spec's
    /// 82 character limit to support receiver's that output longer sentences).
    /// * Messages should be of the form: "$XXYYY,[data]*[checksum]\r\n"
    /// * Example:
    /// * $GPGGA,092750.000,5321.6802,N,00630.3372,W,1,8,1.03,61.7,M,55.2,M,,*76
    /// * $GPGSA,A,3,10,07,05,02,29,04,08,13,,,,,1.72,1.03,1.38*0A
    /// * $GPGSV,3,1,11,10,63,137,17,07,61,098,15,05,59,290,20,08,54,157,30*70
    /// * see https://www.nmea.org/ for more information on the NMEA standard.
    /// - Parameter data: The data buffer that contains NMEA data.
    final public func pushData(_ data: Data)
}

/// An NMEA satellite info object.
///
/// Contains information about a satellite visible at the location.
/// - Since: 200.1
final public class NMEASatelliteInfo {

    /// The azimuth of the satellite info in degrees.
    final public var azimuth: Measurement<UnitAngle> { get }

    /// The elevation of the satellite info in degrees.
    final public var elevation: Measurement<UnitAngle> { get }

    /// The ID of the satellite info.
    final public var id: Int { get }

    /// Indicates if the satellite was used in the calculation of the location.
    final public var isInUse: Bool { get }

    /// The GNSS (Global Navigation Satellite System) system.
    ///
    /// Included in NMEA specification as of v4.11.
    final public var system: ArcGIS.NMEAGNSSSystem? { get }
}

/// An error than can occur when dealing with network analyst functionality.
/// - Since: 200.1
public enum NetworkAnalystError : Error {

    /// Network analyst invalid route settings.
    case invalidRouteSettings

    /// Network analyst no solution.
    case noSolution

    /// Network analyst task canceled.
    case taskCanceled

    /// Network analyst invalid network.
    case invalidNetwork

    /// Network analyst directions error.
    case directionsError

    /// Network analyst insufficient number of stops.
    case insufficientNumberOfStops

    /// Network analyst stop unlocated.
    case stopUnlocated

    /// Network analyst stop located on non traversable element.
    case stopLocatedOnNonTraversableElement

    /// Network analyst point barrier invalid added cost attribute name.
    case pointBarrierInvalidAddedCostAttributeName

    /// Network analyst line barrier invalid scaled cost attribute name.
    case lineBarrierInvalidScaledCostAttributeName

    /// Network analyst polygon barrier invalid scaled cost attribute name.
    case polygonBarrierInvalidScaledCostAttributeName

    /// Network analyst polygon barrier invalid scaled cost attribute value.
    case polygonBarrierInvalidScaledCostAttributeValue

    /// Network analyst polyline barrier invalid scaled cost attribute value.
    case polylineBarrierInvalidScaledCostAttributeValue

    /// Network analyst invalid impedance attribute.
    case invalidImpedanceAttribute

    /// Network analyst invalid restriction attribute.
    case invalidRestrictionAttribute

    /// Network analyst invalid accumulate attribute.
    case invalidAccumulateAttribute

    /// Network analyst invalid directions time attribute.
    case invalidDirectionsTimeAttribute

    /// Network analyst invalid directions distance attribute.
    case invalidDirectionsDistanceAttribute

    /// Network analyst invalid attribute parameters attribute name.
    case invalidAttributeParametersAttributeName

    /// Network analyst invalid attributes parameters parameter name.
    case invalidAttributeParametersParameterName

    /// Network analyst invalid attribute parameters restriction usage value.
    case invalidAttributeParametersRestrictionUsageValue

    /// Network analyst network has no hierarchy attribute.
    case networkHasNoHierarchyAttribute

    /// Network analyst no path found between stops.
    case noPathFoundBetweenStops

    /// Network analyst undefined output spatial reference.
    case undefinedOutputSpatialReference

    /// Network analyst directions time and impedance attribute mismatch.
    case directionsTimeAndImpedanceAttributeMismatch

    /// Network analyst invalid directions road class attribute.
    case invalidDirectionsRoadClassAttribute

    /// Network analyst stop cannot be reached.
    case stopIsUnreachable

    /// Network analyst stop time window starts before unix epoch.
    case stopTimeWindowStartsBeforeUnixEpoch

    /// Network analyst stop time window is inverted.
    case stopTimeWindowIsInverted

    /// Walking mode route too large.
    case walkingModeRouteTooLarge

    /// Stop has `nil` geometry.
    case stopHasNullGeometry

    /// Point barrier has `nil` geometry.
    case pointBarrierHasNullGeometry

    /// Polyline barrier has `nil` geometry.
    case polylineBarrierHasNullGeometry

    /// Polygon barrier has `nil` geometry.
    case polygonBarrierHasNullGeometry

    /// Online route task does not support search_where_clause condition.
    case unsupportedSearchWhereClause

    /// Network analyst insufficient number of facilities.
    case insufficientNumberOfFacilities

    /// Network analyst facility has `nil` geometry.
    case facilityHasNullGeometry

    /// Network analyst facility has invalid added cost attribute name.
    case facilityHasInvalidAddedCostAttributeName

    /// Network analyst facility has negative added cost attribute.
    case facilityHasNegativeAddedCostAttribute

    /// Network analyst facility has invalid impedance cutoff.
    case facilityHasInvalidImpedanceCutoff

    /// Network analyst insufficient number of incidents.
    case insufficientNumberOfIncidents

    /// Network analyst incident has `nil` geometry.
    case incidentHasNullGeometry

    /// Network analyst incident has invalid added cost attribute name.
    case incidentHasInvalidAddedCostAttributeName

    /// Network analyst incident has negative added cost attribute.
    case incidentHasNegativeAddedCostAttribute

    /// Network analyst invalid target facility count.
    case invalidTargetFacilityCount

    /// Network analyst incident has invalid impedance cutoff.
    case incidentHasInvalidImpedanceCutoff

    /// Network analyst start time is before Unix epoch.
    case startTimeIsBeforeUnixEpoch

    /// Network analyst invalid default impedance cutoff.
    case invalidDefaultImpedanceCutoff

    /// Network analyst invalid default target facility count.
    case invalidDefaultTargetFacilityCount

    /// Network analyst invalid polygon buffer distance.
    case invalidPolygonBufferDistance

    /// Network analyst polylines cannot be returned.
    case polylinesCannotBeReturned

    /// Network analyst solving non time impedance, but time windows applied.
    case timeWindowsWithNonTimeImpedance

    /// One or more stops have unsupported type.
    case unsupportedStopType

    /// Network analyst route starts or ends on a waypoint.
    case routeStartsOrEndsOnWaypoint

    /// Network analyst reordering stops (Traveling Salesman Problem) is not supported when the collection of stops contains waypoints or rest breaks.
    case waypointsAndRestBreaksForbiddenReordering

    /// Network analyst waypoint contains time windows.
    case waypointHasTimeWindows

    /// Network analyst waypoint contains added cost attribute.
    case waypointHasAddedCostAttribute

    /// Network analyst stop has unknown curb approach.
    case stopHasInvalidCurbApproach

    /// Network analyst point barrier has unknown curb approach.
    case pointBarrierHasInvalidCurbApproach

    /// Network analyst facility has unknown curb approach.
    case facilityHasInvalidCurbApproach

    /// Network analyst incident has unknown curb approach.
    case incidentHasInvalidCurbApproach

    /// Network dataset has no directions attributes.
    case networkDoesNotSupportDirections

    /// Desired direction language not supported by platform.
    case directionsLanguageNotFound

    /// Route result requires re-solving with current route task.
    case routeResultCannotBeUpdated

    /// Input route result does not have directions.
    case noDirections

    /// Input route result does not have stops.
    case noStops

    /// Input route result doesn't have the route with passed route index.
    case invalidRouteIndex

    /// Input remaining destinations count doesn't match with input routes stops collection.
    case invalidRemainingDestinationsCount

    /// Service doesn't support rerouting.
    case reroutingNotSupportedByService

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension NetworkAnalystError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.NetworkAnalystError, b: ArcGIS.NetworkAnalystError) -> Bool
}

extension NetworkAnalystError : Hashable {
}

/// Instances of this type represent a network authentication challenge.
///
/// A network authentication challenge is raised by the network authentication challenge handler of
/// the ``ArcGISEnvironment/authenticationManager`` if an ArcGIS secured resource requires network
/// credentials, such as Integrated Windows Authentication (IWA) or Client Certificate (PKI).
/// - Since: 200.1
public struct NetworkAuthenticationChallenge {

    /// The protection space of the request that caused the challenge.
    public let protectionSpace: URLProtectionSpace

    /// The URL response object representing the authentication failure.
    public var failureResponse: URLResponse?

    /// The kind of challenge.
    public var kind: ArcGIS.NetworkAuthenticationChallenge.Kind
}

extension NetworkAuthenticationChallenge {

    /// The host which led to this authentication challenge.
    public var host: String { get }
}

extension NetworkAuthenticationChallenge {

    /// The disposition for network authentication challenges.
    public enum Disposition : Hashable {

        /// Continue with the specified credential.
        case continueWithCredential(ArcGIS.NetworkCredential)

        /// Proceed as if the challenge handler is not implemented.
        /// The request which issued the authentication challenge may fail or succeed based on
        /// network security configuration setup on server as required or optional.
        case continueWithoutCredential

        /// The request which issued authentication challenge will fail with user cancelled error.
        case cancel

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.NetworkAuthenticationChallenge.Disposition, b: ArcGIS.NetworkAuthenticationChallenge.Disposition) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension NetworkAuthenticationChallenge {

    /// A type that describes the kind of authentication challenge.
    public enum Kind : Codable, CaseIterable {

        case ntlm

        case clientCertificate

        case serverTrust

        case basic

        case digest

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.NetworkAuthenticationChallenge.Kind, b: ArcGIS.NetworkAuthenticationChallenge.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.NetworkAuthenticationChallenge.Kind]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.NetworkAuthenticationChallenge.Kind] { get }

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: Decoder) throws
    }
}

extension NetworkAuthenticationChallenge.Kind : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension NetworkAuthenticationChallenge.Kind : Equatable {
}

extension NetworkAuthenticationChallenge.Kind : Hashable {
}

/// A type that is able to handle network authentication challenges.
/// - Since: 200.1
public protocol NetworkAuthenticationChallengeHandler {

    /// Returns a disposition indicating how the provided challenge should be handled.
    /// - Remark: The credential provided while handling a challenge is placed in the network
    /// credential store of the ``ArcGISEnvironment/authenticationManager`` and used by all
    /// subsequent requests that have a matching host.
    /// - Parameter challenge: The challenge that was received.
    /// - Returns: A network authentication challenge disposition.
    func handleNetworkAuthenticationChallenge(_ challenge: ArcGIS.NetworkAuthenticationChallenge) async -> ArcGIS.NetworkAuthenticationChallenge.Disposition
}

/// A credential that can be used to authenticate network connections.
/// - Since: 200.1
public enum NetworkCredential : Codable, Hashable {

    /// A network credential that uses a username and password for authentication.
    case password(ArcGIS.PasswordCredential)

    /// A network credential that uses a client-side certificate for authentication.
    case certificate(ArcGIS.CertificateCredential)

    /// A network credential that specifies that a server should be trusted.
    case serverTrust

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.NetworkCredential, b: ArcGIS.NetworkCredential) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

extension NetworkCredential {

    /// Creates a credential that specifies a username and password.
    /// - Parameters:
    ///   - username: The name of the user.
    ///   - password: The password for the user.
    public static func password(username: String, password: String) -> ArcGIS.NetworkCredential

    /// Creates a certificate credential.
    /// - Parameters:
    ///   - fileURL: The URL to a .p12 or .pfx certificate file on disk.
    ///   - password: The password for the certificate.
    public static func certificate(at fileURL: URL, password: String) throws -> ArcGIS.NetworkCredential
}

/// An actor that provides storage for network credentials.
///
/// The credential provided while handling an authentication challenge is placed in the store and
/// used by all subsequent requests that have a matching host.
/// - Note: See Also: ``NetworkCredential``
/// - Since: 200.1
public actor NetworkCredentialStore {

    /// Creates an empty network credential store.
    public init()

    /// Returns the credentials for a given host.
    /// - Parameter host: The host for which to look up what credentials for.
    /// - Returns: The set of credentials used for a particular host.
    public func credentials(forHost host: String) -> Set<ArcGIS.NetworkCredential>

    /// Removes all credentials from the store.
    public func removeAll() async

    /// Retrieve the executor for this actor as an optimized, unowned
    /// reference.
    ///
    /// This property must always evaluate to the same executor for a
    /// given actor instance, and holding on to the actor must keep the
    /// executor alive.
    ///
    /// This property will be implicitly accessed when work needs to be
    /// scheduled onto this actor.  These accesses may be merged,
    /// eliminated, and rearranged with other work, and they may even
    /// be introduced when not strictly required.  Visible side effects
    /// are therefore strongly discouraged within this property.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    nonisolated final public var unownedExecutor: UnownedSerialExecutor { get }
}

extension NetworkCredentialStore {

    /// Creates a credential store with a backing persistent storage that is in the device keychain.
    ///
    /// Any credentials in the keychain will be copied into the initialized in-memory credential
    /// store. Any changes to the in-memory credential store will be synchronized with the keychain.
    /// - Remark: Persisted items will be stored in the default group.
    /// To know more about what the default group would be you can find information about that [here](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps).
    /// - Warning: Any previously persisted credentials that cannot be read from the persistent store
    /// will be removed. This is a possibility when upgrading if the persistence format changes
    /// from a previous release.
    /// - Parameters:
    ///   - access: When the item can be accessed.
    ///   - synchronizesWithiCloud: A Boolean value indicating whether the store is synchronized with iCloud.
    public static func makePersistent(access: ArcGIS.KeychainAccess, synchronizesWithiCloud: Bool = false) async throws -> ArcGIS.NetworkCredentialStore
}

/// An enumeration of the various types of ``RouteTaskInfo/directionsSupport`` values
/// - Since: 200.1
public enum NetworkDirectionsSupport {

    /// Directions are unsupported.
    case unsupported

    /// Directions are supported.
    case supported

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.NetworkDirectionsSupport, b: ArcGIS.NetworkDirectionsSupport) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension NetworkDirectionsSupport : Equatable {
}

extension NetworkDirectionsSupport : Hashable {
}

/// References a specific location/position along a transportation network source feature.
/// - Since: 200.1
final public class NetworkLocation {

    /// Creates a network location instance.
    ///
    /// Creates a network location  object.
    public convenience init()

    /// On right side of source.
    ///
    /// `true` if network element on right side of network source, `false` - otherwise.
    final public var isOnRightSideOfSource: Bool

    /// Name of the network source.
    final public var sourceName: String

    /// Source object position.
    ///
    /// The position of network element on network source.
    /// - Note: See Also: ``SourceObjectPosition``
    final public var sourceObjectPosition: ArcGIS.SourceObjectPosition?
}

/// A type that is able to log network traffic.
/// - Since: 200.1
public protocol NetworkLogger : AnyObject {

    /// The currently running logging task. This needs to be provided by the network logger to
    /// support the default implementation of methods to start and stop logging.
    var loggingTask: Task<Void, Never>? { get set }

    /// Logs the details of a data task request. The default implementation of this method does nothing.
    /// - Parameter details: The details of the request that will be sent.
    func logDataTaskRequest(_ details: ArcGIS.DataTaskRequestDetails)

    /// Logs details of a data task result. The default implementation of this method does nothing.
    /// - Parameters:
    ///   - details: The details about the result of the request.
    func logDataTaskResult(_ details: ArcGIS.DataTaskResultDetails)

    /// Logs details of a download task request. The default implementation of this method
    /// does nothing.
    /// - Parameters:
    ///   - details: The details about the request that will be sent.
    func logDownloadTaskRequest(_ details: ArcGIS.DownloadTaskRequestDetails)

    /// Logs the details of a download task result. The default implementation of this method
    /// does nothing.
    /// - Parameters:
    ///   - details: The details about the result of the request.
    func logDownloadTaskResult(_ details: ArcGIS.DownloadTaskResultDetails)
}

extension NetworkLogger {

    /// Starts logging network traffic for given asynchronous sequences. If logging was previously
    /// started, then this will stop logging before starting again.
    public func startLogging(dataTasksRequests: AsyncStream<ArcGIS.DataTaskRequestDetails> = ArcGISURLSession.dataTaskRequestDetails, dataTasksResults: AsyncStream<ArcGIS.DataTaskResultDetails> = ArcGISURLSession.dataTaskResultDetails, downloadTasksRequests: AsyncStream<ArcGIS.DownloadTaskRequestDetails> = ArcGISURLSession.downloadTaskRequestDetails, downloadTaskResults: AsyncStream<ArcGIS.DownloadTaskResultDetails> = ArcGISURLSession.downloadTaskResultDetails)

    /// Stops logging network traffic.
    public func stopLogging()
}

extension NetworkLogger {

    /// Logs the details of a data task request. The default implementation of this method does nothing.
    /// - Parameter details: The details of the request that will be sent.
    public func logDataTaskRequest(_ details: ArcGIS.DataTaskRequestDetails)

    /// Logs details of a data task result. The default implementation of this method does nothing.
    /// - Parameters:
    ///   - details: The details about the result of the request.
    public func logDataTaskResult(_ details: ArcGIS.DataTaskResultDetails)

    /// Logs details of a download task request. The default implementation of this method
    /// does nothing.
    /// - Parameters:
    ///   - details: The details about the request that will be sent.
    public func logDownloadTaskRequest(_ details: ArcGIS.DownloadTaskRequestDetails)

    /// Logs the details of a download task result. The default implementation of this method
    /// does nothing.
    /// - Parameters:
    ///   - details: The details about the result of the request.
    public func logDownloadTaskResult(_ details: ArcGIS.DownloadTaskResultDetails)
}

/// An error denoting something was not found.
/// - Since: 200.1
public struct NotFoundError : Error {

    /// The error details.
    public let details: String
}

extension NotFoundError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.NotFoundError, b: ArcGIS.NotFoundError) -> Bool
}

/// The OAuth user configuration information used by an ``OAuthUserCredential``.
///
/// * The portal URL, client ID, and redirect URL are required to create an OAuth user credential.
/// See [register your application](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/tutorials/register-your-application/)
/// and [add a redirect URI](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/tutorials/add-redirect-uri/) for getting the
/// client ID and redirect URL.
/// * Use refresh token expiration and exchange intervals to configure the lifetime of an OAuth user credential.
/// * Use show cancel button, user interface style, etc. to configure the look and feel of the OAuth login page displayed
/// by an OAuth user credential.
/// - Since: 200.1
public struct OAuthUserConfiguration {

    /// Creates an OAuth configuration with the specified parameters.
    /// - Parameters:
    ///   - portalURL: The URL of the portal to authenticate with.
    ///   - clientID: A unique identifier associated with an application registered with the portal  that assists with client/server OAuth authentication.
    ///   - redirectURL: The URL that the OAuth login page redirects to when authentication completes.
    ///   - locale: The OAuth login page is displayed in the language specified by the given locale.
    ///   - refreshTokenExpirationInterval: The requested expiration interval for the OAuth refresh token.
    ///   - refreshTokenExchangeInterval: The requested exchange interval for the OAuth refresh token.
    ///   - federatedTokenExpirationMinutes: The requested expiration interval (in minutes) for federated tokens generated using the OAuth credential.
    ///   - showCancelButton: A Boolean value indicating whether to show "Cancel" button on the OAuth login page.
    ///   - userInterfaceStyle: Constants indicating the interface style for the OAuth login page.
    ///   - prefersPrivateWebBrowserSession: A Boolean value indicating whether the OAuth login session should ask the browser for a private authentication session.
    public init(portalURL: URL, clientID: String, redirectURL: URL, locale: Locale = .current, refreshTokenExpirationInterval: ArcGIS.OAuthUserConfiguration.RefreshTokenExpirationInterval = .default, refreshTokenExchangeInterval: ArcGIS.OAuthUserConfiguration.RefreshTokenExchangeInterval = .never, federatedTokenExpirationMinutes: Int? = nil, showCancelButton: Bool = true, userInterfaceStyle: UIUserInterfaceStyle = .unspecified, prefersPrivateWebBrowserSession: Bool = false)
}

extension OAuthUserConfiguration {

    /// A unique identifier associated with an application registered with the portal
    /// that assists with client/server OAuth authentication.
    public var clientID: String { get }

    /// The requested expiration interval (in minutes) for federated tokens generated using the OAuth credential.
    public var federatedTokenExpirationMinutes: Int? { get }

    /// The OAuth login page is displayed in the language specified by the given locale.
    ///
    /// If not explicitly set, `Locale.current` is used. If the given locale is not supported
    /// by the portal, OAuth login page will be displayed in the language corresponding to locale
    /// set in the portal/organization settings.
    public var locale: Locale { get }

    /// The URL of the portal to authenticate with.
    public var portalURL: URL { get }

    /// A Boolean value indicating whether the OAuth login session should ask the browser for a private authentication session.
    public var prefersPrivateWebBrowserSession: Bool { get }

    /// The URL that the OAuth login page will redirect to when authentication completes.
    public var redirectURL: URL { get }

    /// The requested exchange interval for the OAuth refresh token. Use this to exchange a refresh
    /// token before it expires. This will limit the number of times a user will have to login
    /// because of expiring tokens.
    ///
    ///
    /// - The default value is set to ``RefreshTokenExchangeInterval-swift.enum/never``.
    /// - If exchange interval is set to *0* or *less than 0*, then it will not be used.
    /// - To have any affect, this should be set to a value less than the ``refreshTokenExpirationInterval-swift.property``.
    /// - Setting this to ``RefreshTokenExchangeInterval-swift.enum/never`` means that refresh tokens will not be exchanged and will eventually expire, causing the user to have to log in again.
    /// - Setting it to a value greater than the ``refreshTokenExpirationInterval-swift.property`` will have the same effect as setting this to ``RefreshTokenExchangeInterval-swift.enum/never``.
    /// - It is recommended to keep this interval as low as possible because long lived refresh tokens may increase the security risk.
    /// - Note: See Also: ``refreshTokenExpirationInterval-swift.property``
    public var refreshTokenExchangeInterval: ArcGIS.OAuthUserConfiguration.RefreshTokenExchangeInterval { get }

    /// The requested expiration interval for the OAuth refresh token. The maximum interval can be
    /// overridden by the portal administrator.
    ///
    /// The default value is ``RefreshTokenExpirationInterval-swift.enum/default``.
    /// - Note: See Also: ``refreshTokenExchangeInterval-swift.property``
    public var refreshTokenExpirationInterval: ArcGIS.OAuthUserConfiguration.RefreshTokenExpirationInterval { get }

    /// A Boolean value indicating whether to show the "Cancel" button on the OAuth login page.
    public var showsCancelButton: Bool { get }

    /// Constants indicating the interface style for the OAuth login page.
    ///
    /// The default is `UIUserInterfaceStyle.unspecified`.
    public var userInterfaceStyle: UIUserInterfaceStyle { get }
}

extension OAuthUserConfiguration {

    /// Checks if this configuration can be used for the given URL.
    /// - Parameter url: The URL to check.
    /// - Returns: `true` if this configuration can be used, otherwise `false`.
    public func canBeUsed(for url: URL) -> Bool
}

extension OAuthUserConfiguration : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.OAuthUserConfiguration, rhs: ArcGIS.OAuthUserConfiguration) -> Bool
}

extension OAuthUserConfiguration : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension OAuthUserConfiguration {

    /// The requested expiration interval for the OAuth refresh token.
    public enum RefreshTokenExpirationInterval : Hashable, Codable {

        /// The refresh token expiration will not be specified and thus default to the
        /// expiration interval set on the portal (two weeks).
        case `default`

        /// The maximum refresh token supported by the portal (ninety days).
        case maximum

        /// The expiration interval in minutes.
        case minutes(Int)

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.OAuthUserConfiguration.RefreshTokenExpirationInterval, b: ArcGIS.OAuthUserConfiguration.RefreshTokenExpirationInterval) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: Decoder) throws
    }

    /// The exchange interval for the refresh token held by an OAuth credential.
    public enum RefreshTokenExchangeInterval : Hashable, Codable {

        /// The refresh token will not be exchanged. Once the refresh token expires the
        /// user will have to log in again.
        case never

        /// The exchange interval in minutes.
        case minutes(Int)

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.OAuthUserConfiguration.RefreshTokenExchangeInterval, b: ArcGIS.OAuthUserConfiguration.RefreshTokenExchangeInterval) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: Encoder) throws

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: Decoder) throws
    }
}

/// A credential for accessing OAuth token secured ArcGIS resources.
/// - Since: 200.1
final public class OAuthUserCredential : ArcGIS.ArcGISCredential {

    /// An authorization code to generate the OAuth token.
    final public var authorizationCode: String { get }

    /// The OAuth configuration details of an application that can sign into an ArcGIS Portal or ArcGIS Online using OAuth.
    /// - Note: See Also: [Register Your Application](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/tutorials/register-your-application/)
    final public var configuration: ArcGIS.OAuthUserConfiguration { get }

    /// Returns an instance of ``OAuthUserTokenInfo`` generated by this credential.
    ///
    /// If the access token has expired, this method regenerates it./nIf the ``OAuthUserConfiguration/refreshTokenExchangeInterval-swift.property`` is set, this method exchanges the refresh token at specified interval./nWhile regenerating the access token or exchanging the refresh token, if the refresh token is expired, an invalid token error is returned.
    final public var tokenInfo: ArcGIS.OAuthUserTokenInfo { get async throws }

    /// Creates an ``OAuthUserCredential`` with information needed to access an ArcGIS resource.
    /// This initiates the OAuth login process by presenting the OAuth login page.
    /// - Parameter configuration: The OAuth configuration details of an application that can sign into an ArcGIS Portal or ArcGIS Online using OAuth.
    /// - Returns: Returns an ``OAuthUserCredential``.
    final public class func credential(for configuration: ArcGIS.OAuthUserConfiguration) async throws -> ArcGIS.OAuthUserCredential

    /// Sends a network request to revoke OAuth refresh and access tokens.
    ///
    /// This call will fail if the tokens have not been successfully revoked.
    final public func revokeToken() async throws
}

/// The OAuth user token information that can be used by clients in exchange for user credentials.
/// - Since: 200.1
final public class OAuthUserTokenInfo {

    /// The access token to be used to make an authenticated request.
    final public var accessToken: String { get }

    /// The access token expiration date.
    final public var expirationDate: Date { get }

    /// A Boolean value indicating whether the token must be passed over HTTPS.
    final public var isSSLRequired: Bool { get }

    /// The refresh token to be used to refresh the access token.
    final public var refreshToken: String { get }

    /// The date that the refresh token should be exchanged.
    final public var refreshTokenExchangeDate: Date? { get }

    /// The date that the refresh token expires.
    ///
    /// This is available only for ArcGIS.com and ArcGIS Enterprise version 10.9.1 and above.
    final public var refreshTokenExpirationDate: Date? { get }
}

extension OAuthUserTokenInfo : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.OAuthUserTokenInfo, rhs: ArcGIS.OAuthUserTokenInfo) -> Bool
}

extension OAuthUserTokenInfo : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// Metadata of a layer (feature collection) in an OGC API - Features service.
///
/// Provides metadata (such as id, title, and description) that describes an
/// OGC API - Features feature collection.
/// - Since: 200.1
final public class OGCFeatureCollectionInfo {

    /// A unique identifier for the OGC API - Features feature collection.
    ///
    /// Collections from an ``OGCFeatureService``, described by ``OGCFeatureCollectionInfo`` objects, represent the "feature collections"
    /// defined in the OGC API - Features standard. The ``collectionID`` property is intended for use as a unique identifier for the collection.
    /// See ``title`` for a human-readable name.
    final public var collectionID: String { get }

    /// The OGC API - Features feature collection's description.
    final public var description: String { get }

    /// The minimum bounding extent that contains features in the OGC API - Features feature collection.
    final public var extent: ArcGIS.Envelope? { get }

    /// A descriptive (human-readable) title for the OGC API - Features feature collection.
    ///
    /// Unlike ``collectionID``, the title property does not uniquely identify an
    /// OGC API - Features feature collection. Instead, it provides a human-readable name for the collection.
    final public var title: String { get }
}

/// An OGC API - Features feature collection table.
///
/// To display data from an OGC feature collection table in a ``FeatureLayer`` use the
/// ``FeatureLayer/init(featureTable:)`` constructor where the ``OGCFeatureCollectionTable`` is the
/// parameter that is passed into the constructor. Note: The ``OGCFeatureCollectionTable``
/// should not be confused with ``FeatureCollectionTable`` which is used as an input to create a
/// ``FeatureCollectionLayer``.
///
/// This API provides building blocks for manipulating OGC Features on the Web. For more information
/// about the OGC API Features specification see the documents:
/// [OGC API - Features - Part 1](https://docs.opengeospatial.org/is/17-069r3/17-069r3.html)
/// and [OGC API - Features - Part 2](https://docs.opengeospatial.org/is/18-058/18-058.html).
///
/// The class includes two important members: the ``featureRequestMode``
/// property and the
/// `OGCFeatureCollectionTable.populateFromService(using:clearCache:outFields:)`
/// method. Only the
/// ``FeatureRequestMode/manualCache`` mode is supported. This means
/// `OGCFeatureCollectionTable.populateFromService(using:clearCache:outFields:)`
/// must be called to populate, query, and return features
/// from the service. For the ``QueryParameters/whereClause`` that is used by the
/// `OGCFeatureCollectionTable.populateFromService(using:clearCache:outFields:)`
/// method, you can put any CQL2-TEXT or CQL2-JSON string as defined in the document
/// [Common Query Language (CQL2)](https://docs.ogc.org/DRAFTS/21-065.html).
///
/// When populating or updating a local table from an OGC service, you can now request features
/// in a specified ``SpatialReference`` (also referred to as SRS in ArcGIS or CRS in OGC). This
/// leverages the power of the server to return features in the same spatial reference as your
/// map rather than having to re-project them on the client.
///
/// This class supports loading and querying of features from a non-spatial OGC feature collection table.
/// - Since: 200.1
final public class OGCFeatureCollectionTable : ArcGIS.FeatureTable {

    /// Creates a new OGC API - Features feature collection table
    /// - Parameter featureCollectionInfo: An ``OGCFeatureCollectionInfo``.
    public convenience init(featureCollectionInfo: ArcGIS.OGCFeatureCollectionInfo)

    /// Creates a new OGC API - Features feature collection table.
    /// - Parameters:
    ///   - url: The URL of the OGC API - Features service landing page that contains the feature collection.
    ///   - collectionID: The unique identifier for the collection from the service.
    public convenience init(url: URL, collectionID: String)

    /// The OGC API - Features feature collection metadata, which includes id, title, and description.
    final public var featureCollectionInfo: ArcGIS.OGCFeatureCollectionInfo? { get }

    /// The mode defining when features are requested from the service.
    /// - Warning: At v100.9, OGC API - Features collection table only supports ``FeatureRequestMode/manualCache`` but defaults to
    /// ``FeatureRequestMode/onInteractionCache``. Set the feature request mode to manual before attempting to populate the table.
    final public var featureRequestMode: ArcGIS.FeatureRequestMode

    /// The URL of the OGC API - Features service landing page.
    final public var url: URL { get }

    /// Populate the OGC API - Features feature collection table with the results of a query.
    ///
    /// Use the default (empty) ``QueryParameters`` to get all features from the service.
    /// Specifying `nil` or an empty `Array` for outfields will result in the default set of outfields being used.
    /// Spatial queries (those that specify geometries) must use the Intersects spatial relationship.
    /// - Parameters:
    ///   - parameters: Parameters that define how features are returned from the service.
    ///   - clearCache: If `true`, clears existing table data before populating it with features returned from the service.
    ///   - outFields: An `Array` containing `String`.
    /// - Returns: A ``FeatureQueryResult`` type.
    final public func populateFromService(using parameters: ArcGIS.QueryParameters?, clearCache: Bool, outFields: [String] = []) async throws -> ArcGIS.FeatureQueryResult
}

/// An "OGC API - Features" service.
///
/// Use ``OGCFeatureServiceInfo`` as an entry point to explore the "OGC API - Features" service metadata.
/// - Since: 200.1
final public class OGCFeatureService : ArcGIS.Loadable {

    /// Creates an ``OGCFeatureService``, taking a URL to the service landing page.
    /// - Parameter url: The URL of the "OGC API - Features" service landing page.
    public convenience init(url: URL)

    /// These vendor specific parameters are appended to all "OGC API - Features" HTTP requests.
    /// If the "OGC API - Features" service is loaded `CoreErrorCode.commonIllegalState` will be thrown.
    final public var customParameters: [String : String] { get }

    /// Sets a value in the `customParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setCustomParameterValue(_ value: String?, forKey key: String)

    /// The ``OGCFeatureServiceInfo`` that describes the "OGC API - Features" service.
    final public var serviceInfo: ArcGIS.OGCFeatureServiceInfo? { get }

    /// The service's landing page URL.
    ///
    /// If the "OGC API - Features" service is loaded `CoreErrorCode.commonIllegalState` is thrown.
    final public var url: URL { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// Metadata for an "OGC API - Features" service.
///
/// Provides metadata (such as name, title, and description) for an "OGC API - Features"
/// service and lists the feature collections it contains.
/// - Since: 200.1
final public class OGCFeatureServiceInfo {

    /// A description of the service.
    final public var description: String { get }

    /// Information about the feature collections provided by the service.
    ///
    /// This property can be used to discover the feature collections exposed by an
    /// "OGC API - Features" service in support of a browsing experience.
    final public var featureCollectionInfos: [ArcGIS.OGCFeatureCollectionInfo] { get }

    /// A descriptive (human-readable) name for the service.
    final public var title: String { get }
}

/// An error denoting an object was used that was already in use.
///
/// Certain objects can only be used in a single context. For example,
/// a layer instance can only be added to a single map and must be removed
/// from the first map before the layer can be added to a second map.
/// - Since: 200.1
public struct ObjectAlreadyInUseError : Error {

    /// The error details.
    public let details: String
}

extension ObjectAlreadyInUseError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ObjectAlreadyInUseError, b: ArcGIS.ObjectAlreadyInUseError) -> Bool
}

/// Describes whether a layer or table can be included in an offline map.
/// - Since: 200.1
final public class OfflineCapability {

    /// An error if the layer or table could not be included in the offline map, otherwise `nil`.
    final public var error: Error? { get }

    /// Indicates if this online only layer or table will be referenced from an offline map.
    ///
    /// This relates to the ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` property. If
    /// ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` is set to ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/exclude``,
    /// this property will always be `false`. If ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` is set to
    /// ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/include``, this property may be `true` for layers that cannot be taken offline.
    final public var remainsOnline: Bool { get }

    /// Indicates if this layer or table supports being taken offline.
    ///
    /// Note that if this property is `false` and the ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property``
    /// is set to ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/include``, the ``remainsOnline`` property may indicate
    /// that the layer or table will remain online and be referenced by the offline map.
    final public var supportsOffline: Bool { get }
}

/// Represents the capability of taking a map's layers and tables offline.
/// - Since: 200.1
final public class OfflineMapCapabilities {

    /// Indicates if there is at least one layer or table that cannot be included in the offline map.
    ///
    /// This property indicates whether the map contains any layers or tables that cannot be taken offline. This is
    /// not relevant to offline maps that reference online-only layers and tables. Setting
    /// ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property`` to ``GenerateOfflineMapParameters/OnlineOnlyServicesOption-swift.enum/include`` will allow
    /// online-only data to be included in the offline map and referenced by URL.
    final public var hasErrors: Bool { get }

    /// Layer capabilities for all layers in the map. The dictionary maps layer instances to offline capability.
    ///
    /// The Dictionary has keys of element type ``Layer`` with values of ``OfflineCapability``.
    final public var layerCapabilities: [ArcGIS.LayerCapabilityKey : ArcGIS.OfflineCapability] { get }

    /// Capabilities for all tables in the map. The dictionary maps table instances to offline capability.
    ///
    /// The Dictionary has keys of element type ``FeatureTable`` with values of ``OfflineCapability``.
    final public var tableCapabilities: [ArcGIS.TableCapabilityKey : ArcGIS.OfflineCapability] { get }
}

/// Contains properties to override the offline maps item properties.
/// - Since: 200.1
final public class OfflineMapItemInfo {

    /// Creates an offline map item info object.
    public convenience init()

    /// The access information for the offline map.
    final public var accessInformation: String

    /// The description text of the offline map.
    final public var description: String

    /// The snippet text of the offline map.
    final public var snippet: String

    /// The user defined tags that describe the offline map.
    final public var tags: [String] { get }

    /// Adds a sequence of `String` values to the end of the `tags` property.
    /// - Parameter newTags: The new `String` values to append.
    final public func addTags<S>(_ newTags: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `tags` property.
    /// - Parameter newTag: The new `String` value to append.
    final public func addTag(_ newTag: String)

    /// Inserts a collection of `String` values into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTags: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertTags<C>(_ newTags: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTag: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertTag(_ newTag: String, at index: Int)

    /// Removes all values from the `tags` property.
    final public func removeAllTags()

    /// Removes a sequence of `String` values from the `tags` property.
    /// - Parameter tags: The `String` values to remove.
    final public func removeTags<S>(_ tags: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `tags` property.
    /// - Parameter tag: The `String` value to remove.
    final public func removeTag(_ tag: String)

    /// The terms of use of the item.
    ///
    /// This property can contain HTML formatting.
    final public var termsOfUse: String

    /// The thumbnail to be used for the offline map.
    final public var thumbnail: UIImage?

    /// The title for the offline map's item.
    final public var title: String
}

/// A key comprising of a service URL and type of an online service.
/// The key is used to lookup values in a dictionary exposed by a ``GenerateOfflineMapParameterOverrides``.
///
/// ``GenerateOfflineMapParameterOverrides`` consist of instances of data type specific parameters
/// ``GenerateGeodatabaseParameters``, ``ExportTileCacheParameters`` and ``ExportVectorTilesParameters``.
/// Each instance is associated with the service URL that the parameters will be sent to when taking the given data offline.
/// The data type specific parameters can be retrieved from their respective dictionaries on
/// ``GenerateOfflineMapParameterOverrides`` with an instance of ``OfflineMapParametersKey``.
/// A key instance for a particular layer can be constructed by calling
/// ``init(layer:)``. For a table, call
/// ``init(table:)``.
/// For a utility network, call ``init(utilityNetwork:)``.
/// Use the key with the dictionary returned by one of these properties:
/// ``GenerateOfflineMapParameterOverrides/generateGeodatabaseParameters``,
/// ``GenerateOfflineMapParameterOverrides/exportVectorTilesParameters``,
/// ``GenerateOfflineMapParameterOverrides/exportTileCacheParameters``.
/// The particular dictionary property will be determined by the ``kind-swift.property``
/// property.
/// Note that a given parameters key/value pair may be shared by multiple layers in the map: for example a
/// single ``GenerateGeodatabaseParameters`` could represent the online settings for multiple feature layers and tables
/// which all access the same underlying feature service.
/// - Since: 200.1
final public class OfflineMapParametersKey {

    /// Indicates the type of parameters object used to take layers offline.
    public enum Kind {

        /// The parameter is of type ``GenerateGeodatabaseParameters``.
        case generateGeodatabase

        /// The parameter is of type ``ExportVectorTilesParameters``.
        case exportVectorTiles

        /// The parameter is of type ``ExportTileCacheParameters``.
        case exportTileCache

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.OfflineMapParametersKey.Kind, b: ArcGIS.OfflineMapParametersKey.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Create an offline map parameters key for the given table.
    ///
    /// The returned key can be used to retrieve a data type specific parameter object from the dictionary
    /// returned by ``GenerateOfflineMapParameterOverrides/generateGeodatabaseParameters``.
    /// - Parameter table: table that is to be used to access dictionaries in ``GenerateOfflineMapParameterOverrides`` object.
    public convenience init(table: ArcGIS.ServiceFeatureTable)

    /// Create an offline map parameters key for the given layer.
    ///
    /// Layers that are supported for offline use are:
    /// * ``FeatureLayer`` with a table which is a ``ServiceFeatureTable``
    /// * ``ArcGISTiledLayer`` with an online URL
    /// * ``ArcGISVectorTiledLayer`` with an online URL
    ///
    /// To construct a key the layer must be loaded, or if not loaded have a service URL available in the layer's properties.
    /// The returned key can be used to retrieve a data type specific parameters object from one of the three
    /// parameter overrides dictionaries. The dictionary that the key is valid for is indicated by its
    /// ``kind-swift.property`` property:
    /// | Parameter Type                                  | Dictionary                                                                |
    /// |-------------------------------------------------|---------------------------------------------------------------------------|
    /// | ``Kind-swift.enum/generateGeodatabase`` | ``GenerateOfflineMapParameterOverrides/generateGeodatabaseParameters`` |
    /// | ``Kind-swift.enum/exportVectorTiles``   | ``GenerateOfflineMapParameterOverrides/exportVectorTilesParameters``   |
    /// | ``Kind-swift.enum/exportTileCache``     | ``GenerateOfflineMapParameterOverrides/exportTileCacheParameters``     |
    /// If the layer type is not supported an error is returned with a `nil` handle
    /// - Parameter layer: layer that is to be used to access dictionaries in ``GenerateOfflineMapParameterOverrides`` object.
    public convenience init?(layer: ArcGIS.Layer)

    /// Create an offline map parameters key for the specified ``UtilityNetwork``.
    ///
    /// An ``UtilityNetwork`` with URI that points to a feature service which returns `true` for
    /// ``SyncCapabilities/supportsUtilityNetworkSystem`` is supported for offline use.
    ///
    /// The returned key can be used to retrieve a data type specific parameter object from the dictionary
    /// returned by ``GenerateOfflineMapParameterOverrides/generateGeodatabaseParameters``.
    ///
    /// If the ``UtilityNetwork`` does not support taking Utility Network data offline, an error is returned with a `nil` handle.
    /// - Parameter utilityNetwork: ``UtilityNetwork`` that is to be used to access dictionaries in ``GenerateOfflineMapParameterOverrides`` object.
    public convenience init?(utilityNetwork: ArcGIS.UtilityNetwork)

    /// The parameter type of this key.
    ///
    /// The type of this key indicates which ``GenerateOfflineMapParameterOverrides`` dictionary this key belongs to:
    /// | Parameter Type                                  | Dictionary                                                               |
    /// |-------------------------------------------------|--------------------------------------------------------------------------|
    /// | ``Kind-swift.enum/generateGeodatabase`` | ``GenerateOfflineMapParameterOverrides/generateGeodatabaseParameters`` |
    /// | ``Kind-swift.enum/exportVectorTiles``   | ``GenerateOfflineMapParameterOverrides/exportVectorTilesParameters``   |
    /// | ``Kind-swift.enum/exportTileCache``     | ``GenerateOfflineMapParameterOverrides/exportTileCacheParameters``     |
    final public var kind: ArcGIS.OfflineMapParametersKey.Kind? { get }

    /// Service URL of this key.
    ///
    /// The service URL is the URL associated with a data specific parameter object in one of the dictionaries
    /// owned by a ``GenerateOfflineMapParameterOverrides`` instance.
    final public var serviceURL: URL? { get }

    /// Clones the ``OfflineMapParametersKey``.
    /// - Returns: A new ``OfflineMapParametersKey`` with the same values as the current ``OfflineMapParametersKey``.
    final public func clone() -> Self
}

extension OfflineMapParametersKey : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.OfflineMapParametersKey, rhs: ArcGIS.OfflineMapParametersKey) -> Bool
}

extension OfflineMapParametersKey : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

extension OfflineMapParametersKey.Kind : Equatable {
}

extension OfflineMapParametersKey.Kind : Hashable {
}

/// A Job to synchronize an offline map's geodatabases with their
/// originating services.
///
/// Note that if this job is to be serialized to JSON, its map needs to be loaded first. An attempt to
/// serialize with a not loaded map will throw a `CoreErrorCode.mappingNotLoaded` exception.
/// - Since: 200.1
final public class OfflineMapSyncJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// Returns information on upload and download delta geodatabases generated during the sync process.
    ///
    /// Contains a collection of ``GeodatabaseDeltaInfo`` with one for each geodatabase synced. These provide
    /// information about the synced geodatabase along with the paths to its uploaded and downloaded deltas.
    ///
    /// Delta geodatabases allow you to troubleshoot sync problems - for example by inspecting the changes they
    /// contain or sending the file to the system administrator for the feature service.
    ///
    /// This collection will be updated even if the job fails and there are deltas on disk. This collection will
    /// only be updated if ``OfflineMapSyncParameters/keepsGeodatabaseDeltas`` is `true`, otherwise it will remain
    /// empty.
    @ArcGIS.Streamed final public var geodatabaseDeltaInfos: [ArcGIS.GeodatabaseDeltaInfo] { get }

    final public var $geodatabaseDeltaInfos: AsyncStream<[ArcGIS.GeodatabaseDeltaInfo]> { get }

    /// The parameters used by this job.
    final public var parameters: ArcGIS.OfflineMapSyncParameters { get }

    /// The type associated with the result of a successful job.
    public typealias Output = ArcGIS.OfflineMapSyncResult

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.OfflineMapSyncJob.Output, Error> { get async }
}

/// The result of an ``OfflineMapSyncJob`` for a single layer or table.
/// - Since: 200.1
final public class OfflineMapSyncLayerResult {

    /// The edit errors for a layer or table.
    ///
    /// The layer results returned contains information about row edit
    /// errors that occur on the server during the synchronization of a
    /// feature layer. Server-side errors of this kind are infrequent, so
    /// this array is typically empty.
    final public var editErrors: [ArcGIS.FeatureEditResult] { get }

    /// An error if the layer or table could not be synchronized, otherwise returns `nil`.
    final public var error: Error? { get }

    /// Indicates if an error has been encountered synchronizing this layer or table.
    final public var hasErrors: Bool { get }
}

/// Parameters used for creating an ``OfflineMapSyncJob``
/// - Since: 200.1
final public class OfflineMapSyncParameters {

    /// Enumerates options for downloading read-only preplanned updates from an online map area.
    public enum PreplannedScheduledUpdatesOption {

        /// No updates will be downloaded.
        case noUpdates

        /// All available updates for feature data will be downloaded.
        case downloadAllUpdates

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.OfflineMapSyncParameters.PreplannedScheduledUpdatesOption, b: ArcGIS.OfflineMapSyncParameters.PreplannedScheduledUpdatesOption) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates an offline map sync parameters object.
    public convenience init()

    /// Indicates whether or not the upload or downloaded delta geodatabases should be removed at the end of the sync job.
    ///
    /// A delta geodatabase is a file that contains the changes that have occurred since a
    /// mobile replica ``Geodatabase`` was last synchronized with its feature service. See
    /// https://developers.arcgis.com/rest/services-reference/enterprise/synchronize-replica.htm
    /// for an overview of the delta files used in synchronization.
    ///
    /// There are two types of delta geodatabase:
    /// * Local edits, performed on the user's device, are exported as an "upload" delta that
    ///   is applied to the originating feature service
    /// * Online edits, performed by other users are requested as a "download" delta which is
    ///   then applied to the local replica geodatabase
    ///
    /// Delta geodatabases allow you to troubleshoot sync problems. For example, you can
    /// inspect the geodatabase changes or you could send the file to the administrator of the
    /// feature service.
    ///
    /// You can choose to retain both the uploaded and downloaded delta geodatabases once the
    /// sync job has completed. Set to `true` to retain both delta geodatabases and set to `false`
    /// to have them deleted at the end of the sync job. Deltas will be retained regardless of
    /// whether the job succeeds or fails.  Note that when this property is set to `true`, the
    /// upload delta geodatabase will only be available if there are changes to upload and the
    /// sync direction is ``SyncDirection/upload`` or ``SyncDirection/bidirectional``. The
    /// download delta geodatabase will only be available when there are changes to download
    /// and the sync direction is ``SyncDirection/download`` or
    /// ``SyncDirection/bidirectional``. The default value is `false`.
    ///
    /// No geodatabase deltas will be retained if your geodatabase uses a scheduled updates
    /// workflow.
    final public var keepsGeodatabaseDeltas: Bool

    /// Determines whether update packages will be downloaded from an online map area and applied to the map's data.
    ///
    /// If your map was taken offline with a ``DownloadPreplannedOfflineMapParameters/updateMode-swift.property`` of
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdates`` or
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures`` then you can
    /// set this property to ``PreplannedScheduledUpdatesOption-swift.enum/downloadAllUpdates`` to download
    /// and apply update packages to your offline geodatabases.
    ///
    /// The default value is ``PreplannedScheduledUpdatesOption-swift.enum/downloadAllUpdates``.
    final public var preplannedScheduledUpdatesOption: ArcGIS.OfflineMapSyncParameters.PreplannedScheduledUpdatesOption

    /// Indicates if geodatabase feature service synchronization should roll back on a failure.
    ///
    /// The default is `false` (no rollback on failure).
    final public var shouldRollbackOnFailure: Bool

    /// The synchronization direction for geodatabases registered with feature services.
    ///
    /// This property applies to any geodatabases that are registered for feature service synchronization.
    /// It does not apply to geodatabases which use scheduled updates.
    ///
    /// The default value is ``SyncDirection/bidirectional``.
    ///
    /// If you select ``SyncDirection/upload``, any download only geodatabases (e.g. with
    /// ``FeatureServiceCapabilities/update`` = `false`) will not be updated and you will receive a
    /// `CoreErrorCode.mappingSyncDirectionUploadNotSupported` error in the associated
    /// ``OfflineMapSyncResult/layerResults``.
    final public var syncDirection: ArcGIS.SyncDirection
}

extension OfflineMapSyncParameters.PreplannedScheduledUpdatesOption : Equatable {
}

extension OfflineMapSyncParameters.PreplannedScheduledUpdatesOption : Hashable {
}

/// The result of an ``OfflineMapSyncJob``
/// - Since: 200.1
final public class OfflineMapSyncResult {

    /// Indicates if the offline map sync result has synchronization errors available.
    final public var hasErrors: Bool { get }

    /// The synchronization results for geodatabase feature layers.
    final public var layerResults: [ArcGIS.LayerResultKey : ArcGIS.OfflineMapSyncLayerResult] { get }

    /// Indicates whether the mobile map package must be closed and reopened with a new instance to allow the updates to take effect.
    ///
    /// In some cases, applying updates may require files such as mobile geodatabases to be
    /// replaced with a new version. When reopen is required, this property will be `true` and
    /// you need to:
    /// * Release all instances of the ``MobileMapPackage`` and its maps and layers. For
    ///   example, you should remove any ``Map`` instances from the `MapView` and remove
    ///   layers and geodatabases from custom views such as lists and tables of contents. This
    ///   will allow files to be closed.
    /// * Call `MobileMapPackage.close()` to close the mobile map package instance and files
    /// * Create a new ``MobileMapPackage`` instance with the same path
    /// * Load the new ``MobileMapPackage``. This will apply updates to geodatabases
    ///   that have been replaced via a scheduled updates workflow.
    ///
    /// If your offline map was created using
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures``, be aware that
    /// immediately following replacement, the new geodatabase will not contain the new features
    /// that have been synced up to the feature service. The uploaded features can be downloaded
    /// after the next scheduled update has executed and changes are available for download.
    final public var mobileMapPackageReopenIsRequired: Bool { get }

    /// The synchronization results for tables.
    final public var tableResults: [ArcGIS.TableResultKey : ArcGIS.OfflineMapSyncLayerResult] { get }
}

/// A task with methods related to synchronizing an offline map's
/// geodatabases with their originating services.
/// - Since: 200.1
final public class OfflineMapSyncTask : ArcGIS.Loadable {

    /// Creates an offline map sync task for synchronizing the geodatabases used by a map.
    /// - Parameter map: Map to synchronize.
    public convenience init(map: ArcGIS.Map)

    /// The map to be synchronized.
    final public var map: ArcGIS.Map { get }

    /// Describes the methods used for obtaining updates to the offline map that was used to create this task.
    ///
    /// You can use this property to determine whether an offline map is configured to use the
    /// update packages (see
    /// ``OfflineMapUpdateCapabilities/supportsScheduledUpdatesForFeatures``) or to sync
    /// directly with feature services (see
    /// ``OfflineMapUpdateCapabilities/supportsSyncWithFeatureServices``). If the offline map
    /// was created using ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures``,
    /// it will support both update modes, but you will only be able to upload newly created
    /// features.
    ///
    /// This property will return `nil` until the offline map sync task is loaded.
    final public var updateCapabilities: ArcGIS.OfflineMapUpdateCapabilities? { get }

    /// Returns ``OfflineMapUpdatesInfo`` for the offline map that was used to construct this task.
    ///
    /// The returned ``OfflineMapUpdatesInfo`` provides high level information on what updates
    /// are available for this offline map. Information is provided on:
    /// * Online changes that can be applied to update your offline map
    /// * Local changes from your offline map that can be sent back to the online services
    ///
    /// Calling this method provides high-level information on the available updates. It can
    /// help you to determine whether to call `OfflineMapSyncTask.makeSyncOfflineMapJob(parameters:)`
    /// immediately, based upon factors such as current disk space and network availability.
    /// Examine these properties before starting the potentially time-consuming offline map
    /// sync process.
    ///
    /// The resulting ``OfflineMapUpdatesInfo`` provides a snap-shot of available updates when
    /// this method was called.
    ///
    /// To check for new updates you need to call this method again.
    /// - Returns: An ``OfflineMapUpdatesInfo``.
    final public func checkForUpdates() async throws -> ArcGIS.OfflineMapUpdatesInfo

    /// Returns ``OfflineMapSyncParameters`` for the map that was used to construct this task.
    ///
    /// The parameters will be pre-populated with values appropriate for updating the
    /// feature data in this offline map.
    ///
    /// The default parameters will reflect the mobile geodatabases used by the offline map.
    /// - Returns: An ``OfflineMapSyncParameters``.
    final public func makeDefaultOfflineMapSyncParameters() async throws -> ArcGIS.OfflineMapSyncParameters

    /// Returns an offline map sync job.
    ///
    /// The resulting job will synchronize an offline map's geodatabases with their originating services.
    ///
    /// You should not execute more than one sync on a particular geodatabase at the same time.
    /// This includes any operations that export or import deltas from the local
    /// ``Geodatabase``:
    /// * `GeodatabaseSyncTask.exportDelta(from:to:)`
    /// * `GeodatabaseSyncTask.importDelta(from:into:)`
    /// * ``SyncGeodatabaseJob``
    /// * ``OfflineMapSyncJob``
    /// - Parameter parameters: Parameters controlling the synchronization.
    /// - Returns: A ``GenerateOfflineMapJob``.
    final public func makeSyncOfflineMapJob(parameters: ArcGIS.OfflineMapSyncParameters) -> ArcGIS.OfflineMapSyncJob

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A task used to take a map offline.
///
/// Taking a map offline involves downloading an online map and its data, including all the
/// supported layers, tables, renderers, web map configuration etc. so that it can be used
/// offline without a network connection. There are two workflows available for taking maps
/// offline:
/// * The ahead-of-time workflow (also sometimes referred to as the preplanned workflow)
/// * The on-demand workflow
///
/// Ahead-of-time workflow. In this workflow the author of a web map defines geographical areas
/// (offline map areas) to take offline. ArcGIS Online, or ArcGIS Enterprise, uses these to
/// prepare offline map content that is stored online. Download the offline map content to a device
/// using the ``DownloadPreplannedOfflineMapJob``. Note that this API refers to an offline
/// map area as a ``PreplannedMapArea``. For more information about authoring offline map areas,
/// see [Take web maps offline](https://doc.arcgis.com/en/arcgis-online/manage-data/take-maps-offline.htm).
///
/// On-demand workflow. Here the app passes a specific area of interest to a
/// ``GenerateOfflineMapJob`` to generate and download the map content to the device. Using
/// this workflow, you can choose to keep online only services (e.g. those that require a
/// network connection) in your offline map. Be aware that an offline map which uses online
/// only services will require a network connection and may require authentication.
/// - Since: 200.1
final public class OfflineMapTask : ArcGIS.Loadable {

    /// Create the offline map task for the provided online map. The online map must represent a web map.
    ///
    /// The online map must be of type ``PortalItem/Kind-swift.enum/webMap``, either on ArcGIS Online or an
    /// on-premise ArcGIS Enterprise Portal.
    /// - Parameter onlineMap: Online map specifying the map to take offline.
    public convenience init(onlineMap: ArcGIS.Map)

    /// Creates the offline map task with the provided portal item. The portal item must represent a web map.
    ///
    /// The ``PortalItem`` must be of type ``PortalItem/Kind-swift.enum/webMap``, either on ArcGIS Online or
    /// an on-premise ArcGIS Enterprise Portal.
    /// - Parameter portalItem: A ``PortalItem`` specifying a web map to take offline.
    public convenience init(portalItem: ArcGIS.PortalItem)

    /// The online map to be taken offline.
    ///
    /// The online map will be of type ``PortalItem/Kind-swift.enum/webMap``, either on ArcGIS Online or an
    /// on-premise ArcGIS Enterprise Portal.
    final public var onlineMap: ArcGIS.Map? { get }

    /// The portal item that specifies the map to be taken offline.
    ///
    /// The ``PortalItem`` will be of type ``PortalItem/Kind-swift.enum/webMap``, either on ArcGIS Online or
    /// an on-premise ArcGIS Enterprise Portal
    final public var portalItem: ArcGIS.PortalItem? { get }

    /// When successful this property will contain the preplanned map areas, if there are any.
    ///
    /// Note that accessing this property will load the offline map task if it is not already loaded.
    final public var preplannedMapAreas: [ArcGIS.PreplannedMapArea] { get async throws }

    /// Returns ``DownloadPreplannedOfflineMapParameters`` created from the specified ``PreplannedMapArea``.
    ///
    /// A convenience method to create ``DownloadPreplannedOfflineMapParameters`` with default values
    /// appropriate for taking the specified map area offline.
    ///
    /// The parameters will be populated using the values in the online map's
    /// ``OfflineSettings`` (if present).
    /// - Parameter preplannedMapArea: The offline map area that is to be downloaded from the online map.
    /// - Returns: A ``DownloadPreplannedOfflineMapParameters``
    final public func makeDefaultDownloadPreplannedOfflineMapParameters(preplannedMapArea: ArcGIS.PreplannedMapArea) async throws -> ArcGIS.DownloadPreplannedOfflineMapParameters

    /// Returns ``GenerateOfflineMapParameters`` created from the specified area of interest, min scale and max scale.
    /// - Parameters:
    ///   - areaOfInterest: The region of the online map that is to be taken offline. Sets the property ``GenerateOfflineMapParameters/areaOfInterest``.
    ///   - minScale: The minimum scale for offline tile caches. Use 0 for all far out levels. See the property ``GenerateOfflineMapParameters/minScale``.
    ///   - maxScale: The maximum scale for offline tile caches. Use 0 for closer in detailed levels. Sets the property ``GenerateOfflineMapParameters/maxScale``.
    /// - Returns: A ``GenerateOfflineMapParameters``.
    ///
    /// The supported geometry types for the area of interest are ``Envelope`` and ``Polygon``.
    /// The area of interest must have a spatial reference.
    ///
    /// Where a ``Polygon`` is supplied, features and tiles will be filtered according to the
    /// polygon geometry, which can help reduce the size of the resulting offline map. Note
    /// that the filtered set of tiles may vary, depending on the underlying service.
    ///
    /// The returned ``GenerateOfflineMapParameters`` has its itemInfo property initialized
    /// from the offline map task's portal item, if that is set.
    ///
    /// The ItemInfo's thumbnail will be copied from the portal item's thumbnail.
    ///
    /// If the online map contains an ``UtilityNetwork`` in the ``Map/utilityNetworks``, the
    /// ``GenerateGeodatabaseParameters/utilityNetworkSyncMode`` property is set to
    /// ``UtilityNetworkSyncMode/syncSystemTables``. This will include all the data layers and
    /// tables in the feature service in the ``GenerateGeodatabaseParameters/layerOptions``.
    /// The feature data of each layer or table is filtered by an area of interest
    /// if they are already part of the map, or by ``GenerateLayerOption/QueryOption-swift.enum/noneOrRelatedOnly`` if they
    /// are not. This allows the ``UtilityNetwork`` to query associations offline.
    /// To also enable tracing offline, you may use the result of
    /// `OfflineMapTask.makeGenerateOfflineMapParameterOverrides(parameters:)`
    /// to explicitly set ``GenerateGeodatabaseParameters/utilityNetworkSyncMode`` to
    /// ``UtilityNetworkSyncMode/syncSystemAndTopologyTables``. Alternatively, you may set
    /// ``GenerateGeodatabaseParameters/utilityNetworkSyncMode`` to ``UtilityNetworkSyncMode/noSync``
    /// or clear ``Map/utilityNetworks`` before calling this method to opt-out of the necessary
    /// and automatic inclusion of data or system layers that permit an ``UtilityNetwork`` to function offline.
    ///
    /// The default parameters will be populated using the values in the online map's
    /// ``OfflineSettings`` (if present).
    final public func makeDefaultGenerateOfflineMapParameters(areaOfInterest: ArcGIS.Geometry, minScale: Double? = nil, maxScale: Double? = nil) async throws -> ArcGIS.GenerateOfflineMapParameters

    /// Returns a job that is used to download the preplanned map area specified by the given parameters object.
    ///
    /// The job that is returned is dormant and needs to be explicitly started. The job will fail if the last directory in the download directory path cannot be created or is not empty.
    /// - Parameters:
    ///   - parameters: Specifies parameters for the job including the preplanned map area to be downloaded.
    ///   - downloadDirectoryURL: The path to a folder where the map content is stored on the device. For example, to create a new mobile map package "my_mobile_map_package" in a parent directory "[my root path]/my_mobile_maps", this property would be "[my root path]/my_mobile_maps/my_mobile_map_package".
    /// - Returns: a ``DownloadPreplannedOfflineMapJob`` to download a preplanned map area.
    final public func makeDownloadPreplannedOfflineMapJob(parameters: ArcGIS.DownloadPreplannedOfflineMapParameters, downloadDirectory downloadDirectoryURL: URL) -> ArcGIS.DownloadPreplannedOfflineMapJob

    /// Returns ``GenerateOfflineMapParameterOverrides`` created from the specified ``GenerateOfflineMapParameters`` parameters.
    ///
    /// When this method completes the ``GenerateOfflineMapParameterOverrides`` will be populated reflecting the values in the parameters. The overrides may be inspected and modified to change the offline data before passing onto creating a job with ``OfflineMapTask/makeGenerateOfflineMapJob(parameters:downloadDirectory:overrides:)``.
    ///
    ///  If there are errors with loading individual layers or tables, or they cannot be taken offline due to service settings, the outcome depends on the value of ``GenerateOfflineMapParameters/continuesOnErrors``.
    ///
    ///  If ``GenerateOfflineMapParameters/continuesOnErrors`` is true, the overrides correspond to the remaining layers and tables that can go offline.
    ///
    ///  The resulting offline map will not contain the layers or tables which had errors.
    ///
    ///  If ``GenerateOfflineMapParameters/continuesOnErrors`` is false, this method will throw from the failed layer or table.
    ///
    ///  To check upfront which layers or tables are valid for taking offline see ``OfflineMapTask/makeOfflineMapCapabilities(parameters:)``.
    ///
    ///  If ``GenerateOfflineMapParameters/referenceBasemapDirectoryURL`` is set, the overrides corresponding to online basemap layers will be omitted, since no basemap layers will be downloaded.
    /// - Parameter parameters: The generate offline map parameters from which the overrides will be populated.
    /// - Returns: A ``GenerateOfflineMapParameterOverrides``
    final public func makeGenerateOfflineMapParameterOverrides(parameters: ArcGIS.GenerateOfflineMapParameters) async throws -> ArcGIS.GenerateOfflineMapParameterOverrides

    /// Returns an offline map capabilities instance, when successful, the instance will contain information on which layers will be included in an offline map.
    /// - Parameter parameters: The parameters for taking a map offline.
    /// - Returns: An element of type ``OfflineMapCapabilities``.
    final public func makeOfflineMapCapabilities(parameters: ArcGIS.GenerateOfflineMapParameters) async throws -> ArcGIS.OfflineMapCapabilities

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension OfflineMapTask {

    /// Returns a job that is used to generate an offline map using the specified parameters.
    /// - Remark: The job that is returned is dormant and needs to be explicitly started. The job will
    /// fail if the last directory in the download directory path cannot be created or is not
    /// empty.
    ///
    /// The ``GenerateOfflineMapParameterOverrides`` class allows more control over the extracted data.
    ///
    /// To create an instance ``GenerateOfflineMapParameterOverrides``, use
    /// ``makeGenerateOfflineMapJob(parameters:downloadDirectory:overrides:)``.
    ///
    /// Some properties on ``GenerateOfflineMapParameters`` will be ignored when using
    /// ``GenerateOfflineMapParameterOverrides`` and replaced with equivalent properties for
    /// each service. The overridden properties are:
    /// - ``GenerateOfflineMapParameters/includesBasemap``
    /// - ``GenerateOfflineMapParameters/returnLayerAttachmentOption``
    /// - ``GenerateOfflineMapParameters/attachmentSyncDirection``
    /// - ``GenerateOfflineMapParameters/returnsSchemaOnlyForEditableLayers``
    /// - ``GenerateOfflineMapParameters/definitionExpressionFilterIsEnabled``
    /// - ``GenerateOfflineMapParameters/onlineOnlyServicesOption-swift.property``
    /// - Parameters:
    ///   - parameters: The parameters specify how to take a map offline. For example, specify the
    ///   area of interest, min and max scale, and layer attachment options.
    ///   - downloadDirectoryURL: The URL to the directory where the map content should be stored.
    ///   For example, to create a new mobile map package "my_mobile_map_package" in a parent
    ///   directory "[my root path]/my_mobile_maps", this property would be "[my root path]/my_mobile_maps/my_mobile_map_package".
    ///   - overrides: The overrides to the parameters.
    /// - Returns: A job to generate an offline map.
    final public func makeGenerateOfflineMapJob(parameters: ArcGIS.GenerateOfflineMapParameters, downloadDirectory downloadDirectoryURL: URL, overrides: ArcGIS.GenerateOfflineMapParameterOverrides? = nil) -> ArcGIS.GenerateOfflineMapJob
}

/// Describes supported methods for obtaining updates for an offline map.
/// - Note: See Also: ``PreplannedMapArea/updateCapabilities``
/// - Since: 200.1
final public class OfflineMapUpdateCapabilities {

    /// Whether an offline map supports downloading of read-only scheduled update packages.
    ///
    /// If this property is `true`, updates are generated whenever the online map area is
    /// refreshed. For example: according to its update schedule.
    ///
    /// Updates are prepared once and cached for download by all users of the offline map area.
    /// Sharing a single set of cached updates, rather than performing individual sync operations,
    /// reduces the load on the back-end services. This approach is scalable for large
    /// deployments. As updates are only downloaded, this approach can only be used with read-only
    /// workflows. The updates reflect a snapshot of the feature data at the time the online map
    /// area was refreshed. It does not reflect the most up-to-date feature data. For this approach
    /// the web map author must configure the online map to perform scheduled updates.
    ///
    /// If this property is `false`, no updates will be available for download.
    final public var supportsScheduledUpdatesForFeatures: Bool { get }

    /// Whether an offline map references feature services which are sync enabled.
    final public var supportsSyncWithFeatureServices: Bool { get }
}

/// Provides information on the available updates for an offline map.
///
/// This type provides high level information on what updates are available for an offline map.
/// Update information covers both:
/// * Online changes that can be applied to update your offline map
/// * Local changes from your offline map that can be sent back to the online services
/// - Since: 200.1
final public class OfflineMapUpdatesInfo {

    /// Enumerates whether offline data has updates, has no updates, or that the availability of updates cannot be determined.
    public enum Availability {

        /// There are updates available.
        case available

        /// There are no updates available.
        case noneAvailable

        /// It is not possible to determine whether updates are available, for example, because the operation is not supported.
        case indeterminate

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.OfflineMapUpdatesInfo.Availability, b: ArcGIS.OfflineMapUpdatesInfo.Availability) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Indicates whether there are changes available to download.
    ///
    /// If this property is ``Availability/available`` then there
    /// are online updates to apply to your offline map.
    ///
    /// If this property is ``Availability/noneAvailable`` then there are no online
    /// updates available for your offline map.
    ///
    /// Note that the availability of updates to download can only be determined for offline
    /// maps that use the scheduled updates workflow. See
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdates`` and
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures``. If your offline
    /// map is set up to download changes directly from the feature services (for example using
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/syncWithFeatureServices`` or created with a
    /// ``GenerateOfflineMapJob``), then this property will be
    /// ``Availability/indeterminate``.
    final public var downloadAvailability: ArcGIS.OfflineMapUpdatesInfo.Availability { get }

    /// Indicates whether the mobile map package must be reopened after applying the available updates.
    ///
    /// In some cases, applying updates may require files, such as mobile geodatabases, to be replaced
    /// with a new version. When a reopen will be required after updating, this property will be `true` - see
    /// ``OfflineMapSyncResult/mobileMapPackageReopenIsRequired``.
    ///
    /// If your offline map was created using
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures``, be aware that
    /// immediately following replacement, the new geodatabase will not contain the new features
    /// that have been synced up to the feature service. The uploaded features can be downloaded
    /// after the next scheduled update has executed and changes are available for download.
    final public var mobileMapPackageReopenIsRequired: Bool { get }

    /// The total size in bytes of update files to download for a scheduled updates workflow.
    ///
    /// The scheduled updates workflow allows read-only updates to be stored with the online map area
    /// and downloaded to your device at a later time. Updates can cover several sets of changes to the online geodatabase
    /// and can cover multiple geodatabases in an offline map. This property is the total download size of
    /// all files required to update your offline map.
    ///
    /// You can use this information to determine whether you want to download updates immediately - for example
    /// based on available disk space or network availability.
    ///
    /// If there are no updates available, or your offline map does not use a scheduled updates workflow, this property
    /// will be 0.
    final public var scheduledUpdatesDownloadSize: Int { get }

    /// Indicates whether there are local changes to upload.
    ///
    /// If your offline map contains local edits that can be uploaded to
    /// online feature services, this property will be ``Availability/available``.
    ///
    /// If there are no local changes, or your offline map does not support syncing with feature
    /// services, this property will be ``Availability/noneAvailable``.
    /// - Note: See Also: `Geodatabase.hasLocalEdits`
    final public var uploadAvailability: ArcGIS.OfflineMapUpdatesInfo.Availability { get }
}

extension OfflineMapUpdatesInfo.Availability : Equatable {
}

extension OfflineMapUpdatesInfo.Availability : Hashable {
}

/// Represents settings in an online web map which the author has configured for offline use.
///
/// Offline settings can be configured by a web map author to provide default
/// values which are appropriate for taking a map offline. Applications which take the map
/// offline can choose to ignore these offline settings when setting parameters for an
/// ``OfflineMapTask``.
///
/// Note: the following methods will use the offline settings to set default parameter values:
/// * `OfflineMapTask.makeDefaultDownloadPreplannedOfflineMapParameters(preplannedMapArea:)`
/// * `OfflineMapTask.makeDefaultGenerateOfflineMapParameters(areaOfInterest:minScale:maxScale:)`
/// * `OfflineMapTask.makeDefaultGenerateOfflineMapParameters(areaOfInterest:minScale:maxScale:)`
/// * `OfflineMapTask.makeGenerateOfflineMapParameterOverrides(parameters:)`
/// - Since: 200.1
final public class OfflineSettings {

    /// A setting configured by the web map author that provides guidance for how attachments should be synced when working offline.
    ///
    /// If this setting is ``AttachmentSyncDirection/noSync``, then attachments should never be
    /// uploaded or downloaded when performing a sync operation.
    ///
    /// If this setting is ``AttachmentSyncDirection/upload``, then attachments should be
    /// uploaded when performing sync.
    ///
    /// If this setting is ``AttachmentSyncDirection/bidirectional``, then attachments should
    /// be uploaded and downloaded when performing sync.
    ///
    /// This value can be used to set a default for ``GenerateOfflineMapParameters/attachmentSyncDirection``.
    /// Alternatively, using `OfflineMapTask.makeDefaultGenerateOfflineMapParameters(areaOfInterest:minScale:maxScale:)` will pre-populate the parameters using this property.
    final public var attachmentSyncDirection: ArcGIS.AttachmentSyncDirection { get }

    /// List of layers that the web map author determined will remain online when the map is taken offline.
    ///
    /// Layers may be selected to remain online because they do not support being taken offline or to provide live
    /// contextual information such as traffic or weather.
    final public var onlineLayers: [ArcGIS.Layer] { get }

    /// List of non-spatial tables that the web map author determined will remain online when the map is taken offline.
    ///
    /// Tables may be selected to remain online because they do not support being taken offline or to provide live
    /// contextual information such as traffic or weather.
    final public var onlineTables: [ArcGIS.ServiceFeatureTable] { get }

    /// The name of a local basemap file which can be used instead of downloading a basemap when taking this map offline.
    ///
    /// Supported basemap formats are:
    /// * .tpk
    /// * .tpkx
    /// * .vtpk
    ///
    /// The webmap author sets this property to denote an appropriate basemap file. Client code
    /// is responsible for ensuring that the basemap has been correctly side-loaded to the device.
    ///
    /// This property can be used to inform settings for:
    /// * ``DownloadPreplannedOfflineMapParameters/referenceBasemapFilename``
    /// * ``GenerateOfflineMapParameters/referenceBasemapFilename``
    final public var referenceBasemapFilename: String { get }

    /// A setting configured by the web map author that indicates which feature layers should include attachments when taken offline.
    ///
    /// Based on the value of this setting, attachments should be included with:
    /// * None of the layers when the value is ``ReturnLayerAttachmentOption/notIncluded``
    /// * All of the layers when the value is ``ReturnLayerAttachmentOption/allLayers``
    /// * Read only layers when the value is ``ReturnLayerAttachmentOption/readOnlyLayers``
    /// * Editable layers when the value is ``ReturnLayerAttachmentOption/editableLayers``
    ///
    /// This value can be used to set a default for ``GenerateOfflineMapParameters/returnLayerAttachmentOption``.
    /// Alternatively, using `OfflineMapTask.makeDefaultGenerateOfflineMapParameters(areaOfInterest:minScale:maxScale:)` will pre-populate the parameters using this property.
    final public var returnLayerAttachmentOption: ArcGIS.ReturnLayerAttachmentOption { get }

    /// A setting configured by the web map author that indicates whether or not feature layers taken offline should be schema only and contain no data.
    ///
    /// If `true`, this setting means that feature layers should be taken offline with no
    /// existing data in them.
    ///
    /// If `false`, this setting means that existing features should be included when taking
    /// data offline for an editing workflow.
    ///
    /// This value can be used to set a default for
    /// ``GenerateOfflineMapParameters/returnsSchemaOnlyForEditableLayers``.
    ///
    /// Alternatively, using `OfflineMapTask.makeDefaultGenerateOfflineMapParameters(areaOfInterest:minScale:maxScale:)`
    /// will pre-populate the parameters using this property.
    final public var returnsSchemaOnlyForEditableLayers: Bool { get }
}

/// A layer that requests images from OpenStreetMap servers.
///
/// OpenStreetMap (OSM) is a project to create a free, publicly editable map of the world. This
/// layer displays map content from
/// [OpenStreetMap tile servers](https://www.openstreetmap.org/).
///
/// An ``OpenStreetMapLayer`` is a preconfigured ``WebTiledLayer``. Unlike a web tiled layer,
/// it comes with predefined attribution and does not support identify, query, selection, or
/// time. Performance of OSM layers is similar to web tiled layer performance. Raster tiles
/// are read from the service as needed by the map.
///
/// Use of OpenStreetMap's tiles is subject to their tile usage policy. Consider the following
/// before using an OpenStreetMap layer in your app:
/// * Service availability is not guaranteed. Apps with high demand may be denied access at any
///   time.
/// * There are many organizations providing OpenStreetMap tiles. Consider using one of these
///   services (or hosting your own) if you anticipate high demand.
/// - Note: See Also: ``Layer``, ``WebTiledLayer``
/// - Since: 200.1
final public class OpenStreetMapLayer : ArcGIS.WebTiledLayer {

    /// Creates an OpenStreetMap layer object.
    ///
    /// Use this function to create a layer that pulls tiles from the default OpenStreetMap servers.
    public convenience init()
}

/// Support Orbital Camera navigation around a stationary or moving point ``GeoElement`` object.
///
/// Orbit camera controller provides orbital navigation around a point object.
/// - Note: See Also: ``OrbitLocationCameraController``, ``GlobeCameraController``
/// - Since: 200.1
final public class OrbitGeoElementCameraController : ArcGIS.CameraController {

    /// Determines if CameraHeadingOffset is updated with target's heading.
    ///
    /// If `true`, the camera will maintain its heading offset when the target's heading changes. Defaults to `true`.
    /// The graphic's heading can be controlled using an expression in the renderer class.
    /// - Note: See Also: ``RendererSceneProperties/headingExpression``
    final public var autoHeadingIsEnabled: Bool

    /// Determines if CameraPitchOffset is updated with target's pitch.
    ///
    /// If `true`, the camera will maintain its pitch offset when the target's pitch changes. Defaults to `true`.
    /// The graphic's pitch can be controlled using an expression in the renderer class.
    /// - Note: See Also: ``RendererSceneProperties/pitchExpression``
    final public var autoPitchIsEnabled: Bool

    /// Determines if CameraRollOffset is updated with target's roll.
    ///
    /// If `true`, the camera will maintain its roll offset when the target's roll changes. Defaults to `true`.
    /// The graphic's roll can be controlled using an expression in the renderer class
    /// - Note: See Also: ``RendererSceneProperties/rollExpression``
    final public var autoRollIsEnabled: Bool

    /// The distance from the target object to the camera.
    @ArcGIS.Streamed final public var cameraDistance: Double

    final public var $cameraDistance: AsyncStream<Double> { get }

    /// The interactive distance value indicating if user interactions are enabled supporting distance changes/zoom interactions.
    ///
    /// When enabled the user can interactively change the distance between the camera and the target object.
    final public var cameraDistanceIsInteractive: Bool

    /// The heading of the camera relative to the target object.
    @ArcGIS.Streamed final public var cameraHeadingOffset: Double

    final public var $cameraHeadingOffset: AsyncStream<Double> { get }

    /// The interactive heading value indicating if user interactions are enabled.
    ///
    /// When interactive heading is enabled the user is able to manually change the relative heading between
    /// the target focal point and the camera.
    final public var cameraHeadingOffsetIsInteractive: Bool

    /// The pitch of the camera relative to the target object.
    @ArcGIS.Streamed final public var cameraPitchOffset: Double

    final public var $cameraPitchOffset: AsyncStream<Double> { get }

    /// The interactive pitch value indicating if user interactions are enabled.
    ///
    /// When interactive pitch is enabled the user is able to manually change the relative pitch between
    /// the target focal point and the camera.
    final public var cameraPitchOffsetIsInteractive: Bool

    /// The maximum distance from the camera to the target.
    ///
    /// No limit on maximum distance. Animations and
    /// interactions are bounded by this limit.
    final public var maxCameraDistance: Double

    /// The maximum camera heading.
    ///
    /// Any angle, positive or negative. Will be wrapped to a clockwise angle in [0, 360]. Animations and
    /// interactions are bounded by this limit.
    final public var maxCameraHeadingOffset: Double

    /// The maximum camera pitch.
    ///
    /// The maximum camera Pitch. Must be between (MinCameraPitchOffset, 90]. Defaults to 90. Animations
    /// and interactions are bounded by this limit.
    final public var maxCameraPitchOffset: Double

    /// The minimum distance from the camera to the target.
    ///
    /// Must be greater than 0. Defaults to 0. Animations
    /// and interactions are bounded by this limit.
    final public var minCameraDistance: Double

    /// The minimum camera heading.
    ///
    /// Any angle, positive or negative. Will be wrapped to a clockwise angle in [0, 360]. Animations and
    /// interactions are bounded by this limit.
    final public var minCameraHeadingOffset: Double

    /// The minimum camera pitch.
    ///
    /// The minimum camera Pitch. Must be between [-90, MaxCameraPitchOffset). Defaults to -90.
    /// Animations and interactions are bounded by this limit.
    final public var minCameraPitchOffset: Double

    /// The target geo element of the camera controller.
    ///
    /// The target ``GeoElement`` can represent either point ``Graphic``, a point ``Feature``, or a point ``DynamicEntity``.
    /// the target determines the focal point of the camera managed by the orbit camera controller
    final public var target: ArcGIS.GeoElement { get }

    /// The X Offset of the target focus point relative the target object in the X axis in the symbol coordinate system.
    ///
    /// Setting the offsets for the target allows the user to move the focal point from the target's geometry
    /// to any point on the symbol.
    final public var targetOffsetX: CGFloat

    /// The Y Offset of the target focus point relative the target object in the Y axis in the symbol coordinate system.
    ///
    /// Setting the offsets for the target allows the user to move the focal point from the graphic's geometry
    /// to any point on the symbol.
    final public var targetOffsetY: CGFloat

    /// The Z Offset of the target focus point relative the target object in the Z axis in the symbol coordinate system.
    ///
    /// Setting the offsets for the target allows the user to move the focal point from the graphic's geometry
    /// to any point on the symbol.
    final public var targetOffsetZ: CGFloat

    /// The target screen vertical factor of the orbit camera controller.
    ///
    /// The target screen vertical factor value indicates the position of the target object on the screen. The default values
    /// is 0.5 representing the vertical center of the screen.
    /// - Note: See Also: ``OrbitGeoElementCameraController``
    final public var targetVerticalScreenFactor: CGFloat

    /// Animate the camera target offsets of the camera.
    ///
    /// By default the camera focus's on the target's geometry center point.  Using the offsets you can move the focal
    /// point to a new position relative to that center point.
    /// - Parameters:
    ///   - x: The change x offset symbol center.
    ///   - y: The change y offset symbol center.
    ///   - z: The change z offset symbol center.
    ///   - duration: The duration of the animation in seconds.
    /// - Returns: A bool used to check the animation complete successfully or not.
    final public func setTargetOffsets(x: Double, y: Double, z: Double, duration: TimeInterval) async throws -> Bool
}

extension OrbitGeoElementCameraController {

    /// Creates an ``OrbitGeoElementCameraController`` using a distance to a specified
    /// ``Graphic``.
    ///
    /// An Orbit camera controller is used to associate camera navigation and movement with the``Graphic`` point object.
    /// When the controller is set on the Scene View using `SceneView.cameraController` the interaction mode will
    /// change for the active navigation model be to focused on the input ``Graphic`` allowing the user to rotate around and
    /// zoom in an out from the object.  For a moving ``Graphic`` the camera will move in synchronization with it.
    /// Adjust the position, heading, pitch and roll of the object by simply changing the object with no requirement to
    /// change the camera.
    /// - Parameters:
    ///   - target: The ``Graphic`` which will be the focus of the camera in the view.
    ///   - distance: The distance from the ``Graphic`` the camera will be placed.
    public convenience init(target: ArcGIS.Graphic, distance: Double)

    /// Creates an ``OrbitGeoElementCameraController`` using a distance to a specified
    /// ``Feature``.
    ///
    /// An Orbit camera controller is used to associate camera navigation and movement with the``Feature`` point object.
    /// When the controller is set on the Scene View using `SceneView.cameraController` the interaction mode will
    /// change for the active navigation model to be focused on the input ``Feature`` allowing the user to rotate around and
    /// zoom in an out from the object.  For a moving ``Feature`` the camera will move in synchronization with it.
    /// Adjust the position, heading, pitch and roll of the object by simply changing the object with no requirement to
    /// change the camera.
    /// - Parameters:
    ///   - target: The ``Feature`` which will be the focus of the camera in the view.
    ///   - distance: The distance from the ``Feature`` the camera will be placed.
    public convenience init(target: ArcGIS.Feature, distance: Double)

    /// Creates an ``OrbitGeoElementCameraController`` using a distance to a specified
    /// ``DynamicEntity``.
    ///
    /// An Orbit camera controller is used to associate camera navigation and movement with the``DynamicEntity`` point object.
    /// When the controller is set on the Scene View using `SceneView.cameraController` the interaction mode will
    /// change for the active navigation model to be focused on the input ``DynamicEntity`` allowing the user to rotate around and
    /// zoom in an out from the object.  For a moving ``DynamicEntity`` the camera will move in synchronization with it.
    /// Adjust the position, heading, pitch and roll of the object by simply changing the object with no requirement to
    /// change the camera.
    /// - Parameters:
    ///   - target: The ``DynamicEntity`` which will be the focus of the camera in the view.
    ///   - distance: The distance from the ``DynamicEntity`` the camera will be placed.
    public convenience init(target: ArcGIS.DynamicEntity, distance: Double)

    /// Animate the camera to the new position relative to the target.
    /// - Parameters:
    ///   - distanceDelta: The change in distance to apply in the animation.
    ///   - headingDelta: The change in heading to apply in the animation.
    ///   - pitchDelta: The change in pitch to apply in the animation.
    ///   - duration: The duration of the animation in seconds.
    /// - Returns: A Boolean value used to check the animation complete successfully or not.
    @discardableResult
    final public func moveCamera(distanceDelta: Double, headingDelta: Double, pitchDelta: Double, duration: TimeInterval) async -> Bool
}

/// Support Orbital Camera navigation around a stationary or moving point object.
///
/// Orbit camera controller provides orbital navigation around a point object.
/// - Note: See Also: ``OrbitGeoElementCameraController``, ``GlobeCameraController``
/// - Since: 200.1
final public class OrbitLocationCameraController : ArcGIS.CameraController {

    /// Create an orbit camera controller object with a target point and a camera point.
    ///
    /// Create an Orbit camera controller and calculate the distance of the camera from the target point.
    /// When the controller is set on the Scene View using `SceneView.cameraController` the interaction mode
    /// will change for the active navigation model to be focused on the input point allowing the user to rotate around and
    /// zoom in and out from the point.
    /// - Parameters:
    ///   - target: A ``Point`` which will be the focus of the camera in the view.
    ///   - cameraLocation: A ``Point`` which is where the camera is located.
    /// - Precondition: `!target.isEmpty`
    /// - Precondition: `!cameraLocation.isEmpty`
    public convenience init(target: ArcGIS.Point, cameraLocation: ArcGIS.Point)

    /// Create an orbit camera controller object with a target point and distance from that point.
    ///
    /// Create an Orbit camera controller and associate it with a point object and set the distance of the camera from this point object.
    /// When the controller is set on the Scene View using `SceneView.cameraController` the interaction mode for
    /// will change for the active navigation model be focused on the input point allowing the user to rotation around and
    /// zoom in an out from the point.
    /// - Parameters:
    ///   - target: A pointer to the ``Point`` which will be the focus of the camera in the view.
    ///   - distance: The distance from the point the camera will be placed.
    /// - Precondition: `!target.isEmpty`
    public convenience init(target: ArcGIS.Point, distance: Double)

    /// The distance from the target object to the camera.
    @ArcGIS.Streamed final public var cameraDistance: Double

    final public var $cameraDistance: AsyncStream<Double> { get }

    /// The interactive distance value indicating if user interactions are enabled supporting distance changes/zoom interactions.
    ///
    /// When enabled the user can interactively change the distance between the camera and the target object.
    final public var cameraDistanceIsInteractive: Bool

    /// The heading of the camera relative to the target object.
    @ArcGIS.Streamed final public var cameraHeadingOffset: Double

    final public var $cameraHeadingOffset: AsyncStream<Double> { get }

    /// The interactive heading value indicating if user interactions are enabled.
    ///
    /// When interactive heading is enabled the user is able to manually change the relative heading between
    /// the target focal point and the camera.
    final public var cameraHeadingOffsetIsInteractive: Bool

    /// The pitch of the camera relative to the target object.
    @ArcGIS.Streamed final public var cameraPitchOffset: Double

    final public var $cameraPitchOffset: AsyncStream<Double> { get }

    /// The interactive pitch value indicating if user interactions are enabled.
    ///
    /// When interactive pitch is enabled the user is able to manually change the relative pitch between
    /// the target focal point and the camera.
    final public var cameraPitchOffsetIsInteractive: Bool

    /// The maximum distance from the camera to the target.
    ///
    /// No limit on maximum distance. Animations and
    /// interactions are bounded by this limit.
    final public var maxCameraDistance: Double

    /// The maximum camera heading.
    ///
    /// Any angle, positive or negative. Will be wrapped to a clockwise angle in [0, 360]. Animations and
    /// interactions are bounded by this limit.
    final public var maxCameraHeadingOffset: Double

    /// The maximum camera pitch.
    ///
    /// Must be between (MinCameraPitch, 90]. Defaults to 90. Animations
    /// and interactions are bounded by this limit.
    final public var maxCameraPitchOffset: Double

    /// The minimum distance from the camera to the target.
    ///
    /// Must be greater than 0. Defaults to 0. Animations
    /// and interactions are bounded by this limit.
    final public var minCameraDistance: Double

    /// The minimum camera heading.
    ///
    /// Any angle, positive or negative. Will be wrapped to a clockwise angle in [0, 360]. Animations and
    /// interactions are bounded by this limit.
    final public var minCameraHeadingOffset: Double

    /// The minimum camera pitch.
    ///
    /// The minimum camera Pitch. Must be between [-90, maxCameraPitchOffset). Defaults to -90.
    /// Animations and interactions are bounded by this limit.
    final public var minCameraPitchOffset: Double

    /// The target point location of the orbit camera controller.
    ///
    /// The target determines the focal point of the camera managed by the orbit camera controller.
    final public var targetLocation: ArcGIS.Point? { get }
}

extension OrbitLocationCameraController {

    /// Animate the camera to the new position relative to the target.
    /// - Parameters:
    ///   - distanceDelta: The change in distance to apply in the animation.
    ///   - headingDelta: The change in heading to apply in the animation.
    ///   - pitchDelta: The change in pitch to apply in the animation.
    ///   - duration: The duration of the animation in seconds.
    /// - Returns: A Boolean value used to check the animation complete successfully or not.
    @discardableResult
    final public func moveCamera(distanceDelta: Double, headingDelta: Double, pitchDelta: Double, duration: TimeInterval) async -> Bool
}

/// An object that represents an ordering in a query's order by clause.
/// - Since: 200.1
final public class OrderBy {

    /// The various ways a query result can be ordered by.
    public enum SortOrder {

        /// Sort the query results in an ascending order.
        case ascending

        /// Sort the query results in a descending order.
        case descending

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.OrderBy.SortOrder, b: ArcGIS.OrderBy.SortOrder) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new order by object.
    public convenience init()

    /// Creates a new order by object.
    /// - Parameters:
    ///   - fieldName: Name of the field.
    ///   - sortOrder: The order.
    public convenience init(fieldName: String, sortOrder: ArcGIS.OrderBy.SortOrder)

    /// The field name of the field being ordered by.
    final public var fieldName: String

    /// The order that should be applied.
    final public var sortOrder: ArcGIS.OrderBy.SortOrder
}

extension OrderBy.SortOrder : Equatable {
}

extension OrderBy.SortOrder : Hashable {
}

/// An error denoting a value was out of the expected range.
/// - Since: 200.1
public struct OutOfRangeError : Error {

    /// The error details.
    public let details: String
}

extension OutOfRangeError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.OutOfRangeError, b: ArcGIS.OutOfRangeError) -> Bool
}

/// An object that defines ownership-based access control settings of a service.
/// - Since: 200.1
final public class OwnershipBasedAccessControlInfo {

    /// `true` if anonymous users are allowed to delete features.
    final public var allowsAnonymousToDelete: Bool { get }

    /// `true` if anonymous users are allowed to update features.
    final public var allowsAnonymousToUpdate: Bool { get }

    /// `true` if others are allowed to delete features.
    final public var allowsOthersToDelete: Bool { get }

    /// `true` if others are allowed to query for features.
    final public var allowsOthersToQuery: Bool { get }

    /// `true` if others are allowed to update features.
    final public var allowsOthersToUpdate: Bool { get }
}

/// Represents a single part of a multipart geometry (polygon or polyline).
///
/// A collection of ``Segment`` objects that together represent a part in a ``Multipart`` geometry. You
/// can also access the ``Point`` objects that represent the vertices of the geometry (that is, the ends of each
/// segment), using point-based helpers such as `Part.point(pointIndex:)`.
///
/// Prior to v100.12, the only supported segment type was ``LineSegment``. If the underlying geometry contained
/// curve segments (``Geometry/hasCurves`` is `true`) then the curve information was lost when iterating through
/// the segments in that part.
///
/// From v100.12, curve segments may be returned from `Part.segment(segmentIndex:)`. A part may contain
/// a mix of linear and curve segments.
/// - Since: 200.1
final public class Part {

    /// The end point of the last segment in the part.
    /// Returns `nil` if the collection is empty.
    final public var endPoint: ArcGIS.Point? { get }

    /// Indicates if the part contains any curve segments.
    ///
    /// Prior to v100.12, if this property returned `true`, there was no way to access the curve segment information
    /// contained by the part. Retrieving the ``Segment`` instances of the part would return only ``LineSegment``
    /// instances.
    ///
    /// From v100.12, when this property returns `true`, curve segments may be returned from
    /// `Part.segment(segmentIndex:)`. A part may contain a mix of linear and curve segments.
    /// - Note: See Also: ``Geometry/hasCurves``
    final public var hasCurves: Bool { get }

    /// Indicates if the part contains no segments.
    final public var isEmpty: Bool { get }

    /// The spatial reference for the immutable part.
    ///
    /// If the collection does not have a spatial reference `nil` is returned.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The start point of the first segment in the part.
    /// Returns `nil` if the collection is empty.
    final public var startPoint: ArcGIS.Point? { get }
}

extension Part : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Part, rhs: ArcGIS.Part) -> Bool
}

extension Part {

    /// A view into an part as points.
    public struct PointView {
    }

    /// The points of the part, as a view into the part.
    final public var points: ArcGIS.Part.PointView { get }
}

extension Part {

    /// A view into a part as segments.
    public struct SegmentView {
    }

    /// The segments of the part, as a view into the part.
    final public var segments: ArcGIS.Part.SegmentView { get }
}

extension Part {

    /// Returns the index of the end point of the segment at the given index.
    /// - Parameter index: The index of a segment.
    /// - Returns: An index of a point or `nil` if `index` is not a valid index
    /// of a segment.
    final public func indexOfEndPointForSegment(at index: ArcGIS.Part.SegmentView.Index) -> ArcGIS.Part.PointView.Index?

    /// Returns the index of the segment whose end point is the point at the
    /// given index.
    /// - Parameter index: The index of a point.
    /// - Returns: An index of a segment or `nil` if `index` is not a valid
    /// index of a point.
    final public func indexOfSegmentWithEndPoint(at index: ArcGIS.Part.PointView.Index) -> ArcGIS.Part.SegmentView.Index?

    /// Returns the index of the segment whose start point is the point at the
    /// given index.
    /// - Parameter index: The index of a point.
    /// - Returns: An index of a segment or `nil` if `index` is not a valid
    /// index of a segment.
    final public func indexOfSegmentWithStartPoint(at index: ArcGIS.Part.PointView.Index) -> ArcGIS.Part.SegmentView.Index?

    /// Returns the index of the start point of the segment at the given index.
    /// - Parameter index: The index of a segment.
    /// - Returns: An index of a point or `nil` if `index` is not a valid index
    /// of a segment.
    final public func indexOfStartPointForSegment(at index: ArcGIS.Part.SegmentView.Index) -> ArcGIS.Part.PointView.Index?
}

extension Part.PointView : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> ArcGIS.Point { get }

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Point

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.Part.PointView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.Part.PointView>
}

extension Part.SegmentView : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> ArcGIS.Segment { get }

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Segment

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.Part.SegmentView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.Part.SegmentView>
}

/// Represents immutable collection of parts for a polygon or polyline geometry. Each part is a collection of segments.
///
/// Polygons and polyline can have multiple disjoint parts.
/// Each part is represented by a ``Part``.
/// A part is composed of segments representing the edge of the polygon or polyline.
/// - Since: 200.1
final public class PartCollection {

    /// The spatial reference for the immutable part collection.
    ///
    /// If the collection does not have a spatial reference `nil` is returned.
    final public var spatialReference: ArcGIS.SpatialReference? { get }
}

extension PartCollection : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable final public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    final public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    final public subscript(position: Int) -> ArcGIS.Part { get }

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Part

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.PartCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.PartCollection>
}

/// A credential that uses a username and password for authentication.
/// - Since: 200.1
public struct PasswordCredential : Codable, Hashable {

    /// The username of the credential.
    public let username: String

    /// The password of the credential.
    public let password: String

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PasswordCredential, b: ArcGIS.PasswordCredential) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

/// The percent clip stretch parameters object.
/// - Since: 200.1
final public class PercentClipStretchParameters : ArcGIS.StretchParameters {

    /// Creates a percent clip stretch parameters object with the specified min and max value.
    /// - Parameters:
    ///   - min: The min value.
    ///   - max: The max value.
    public convenience init(min: Double, max: Double)

    /// Max value from a percent clip stretch parameters object.
    final public var max: Double { get }

    /// Min value from a percent clip stretch parameters object.
    final public var min: Double { get }
}

/// Uses an image to symbolize the fill for a polygon geoelement.
///
/// Supported image formats are BMP, GIF, ICO, JPEG, and PNG. Animated GIF is not supported.
/// - Note: See Also: ``FillSymbol``, ``Symbol``
/// - Since: 200.1
final public class PictureFillSymbol : ArcGIS.FillSymbol, ArcGIS.Loadable {

    /// Creates a picture fill symbol object.
    public convenience init()

    /// Creates a picture fill symbol.
    ///
    /// Supported image formats are BMP, GIF, ICO, JPEG, and PNG. Animated GIF is not supported.
    /// - Parameter image: The image.
    public convenience init(image: UIImage)

    /// Creates a picture fill symbol.
    ///
    /// Supported image formats are BMP, GIF, ICO, JPEG, and PNG. Animated GIF is not supported.
    /// - Parameter url: URL of the image.
    public convenience init(url: URL)

    /// The angle of the picture fill symbol.
    final public var angle: Double

    /// The height of the picture fill symbol.
    final public var height: CGFloat

    /// The image of the picture fill symbol.
    final public var image: UIImage? { get }

    /// The x offset of the picture fill symbol.
    final public var offsetX: CGFloat

    /// The y offset of the picture fill symbol.
    final public var offsetY: CGFloat

    /// The opacity for the symbol.
    final public var opacity: Float

    /// The x scale of the picture fill symbol.
    final public var scaleX: Double

    /// The y scale of the picture fill symbol.
    final public var scaleY: Double

    /// The URL of the picture fill symbol.
    final public var url: URL? { get }

    /// The width of the picture fill symbol.
    final public var width: CGFloat

    /// Get Multilayer polygon symbol generated from picture fill symbol.
    ///
    /// Given a picture fill symbol, this method will return a MultilayerPolygonSymbol with a PictureFillSymbolLayer.
    /// - Returns: A ``MultilayerPolygonSymbol`` object.
    final public func toMultilayerSymbol() -> ArcGIS.MultilayerPolygonSymbol

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A symbol layer that fills polygon geometry with an image.
///
/// The specified image fills the layer's polygon if it's the only symbol layer in a ``MultilayerPolygonSymbol``.
/// If a single image doesn't completely fill the geometry, it is tiled to complete the fill.
///
/// This layer can also represent the Web Scene specification's Icon3DSymbolLayers.
/// ``PictureFillSymbolLayer`` represents IconSymbol3DLayers that contain pictures and
/// ``VectorMarkerSymbolLayer`` represents Icon3DSymbolLayers that are primitives or vector paths.
/// - Since: 200.1
final public class PictureFillSymbolLayer : ArcGIS.FillSymbolLayer, ArcGIS.Loadable {

    /// Creates a picture fill symbol layer from an `UIImage`.
    ///
    /// Create a ``PictureFillSymbolLayer`` with image data. The image, if valid, is set
    /// as the image used to fill the containing polygon. The function throws if the image is
    /// `nil` or empty. If the image is valid, the load status of the ``PictureFillSymbolLayer``
    /// is set to `LoadStatus.loaded`.
    /// - Parameter image: the `UIImage` indicating the desired image
    public convenience init(image: UIImage)

    /// Creates a picture fill symbol layer from a URI.
    ///
    /// Create a ``PictureFillSymbolLayer`` with an image URI. The given URI is used to retrieve the
    /// image data to use as the picture. The URI may be a URL or a file location.
    /// - Parameter url: the const char* indicating the URI location of the image to use in the symbol layer
    public convenience init(url: URL)

    /// The image held by a picture fill symbol layer.
    ///
    /// The `UIImage` held by the given ``PictureFillSymbolLayer``.
    /// Setting the image visually changes the image that makes up the fill pattern. If the image is valid
    /// and non-empty, this function sets the image and sets the symbol layer's load status to
    /// `LoadStatus.loaded`. You cannot set an image on a ``PictureFillSymbolLayer`` that has already loaded.
    final public var image: UIImage? { get }

    /// The tint color of a picture fill symbol layer.
    ///
    /// The tint color is applied to the entire image by multiplying each RGB color channel in the image by the
    /// corresponding color channel of the tint color. The default tint color is white with 100% opacity, i.e.
    /// RGBA(255, 255, 255, 255), which leaves the image with its native colors. A white tint color with opacity
    /// less than 100% tints the image white, with the reduced opacity respected.
    ///
    /// When getting the tint color from a symbol, the consensus value is reported. If there is no consensus
    /// (one or more layers have different colors), a `nil` value is reported for the color. Likewise,
    /// setting a value for tint color on a symbol will apply that tint color to all layers the symbol contains.
    final public var tintColor: UIColor

    /// The URI of a picture fill symbol layer.
    ///
    /// The URI of the ``PictureFillSymbolLayer``. If there is no URI set, the method returns an empty string.
    final public var url: URL? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// Uses an image to symbolize geoelements that have point or multipoint geometry.
///
/// Supported image formats are BMP, GIF, ICO, JPEG, and PNG. Animated GIF is not supported.
/// - Note: See Also: ``MarkerSymbol``, ``Symbol``
/// - Since: 200.1
final public class PictureMarkerSymbol : ArcGIS.MarkerSymbol, ArcGIS.Loadable {

    /// Creates a picture marker symbol object.
    public convenience init()

    /// Creates a picture marker symbol.
    ///
    /// Supported image formats are BMP, GIF, ICO, JPEG, and PNG. Animated GIF is not supported.
    /// - Parameter image: The image.
    public convenience init(image: UIImage)

    /// Creates a picture marker symbol.
    ///
    /// Supported image formats are BMP, GIF, ICO, JPEG, and PNG. Animated GIF is not supported.
    /// - Parameter url: URL of the image.
    public convenience init(url: URL)

    /// The height of the picture marker symbol.
    final public var height: CGFloat

    /// The image of the picture marker symbol.
    final public var image: UIImage? { get }

    /// The opacity for the symbol.
    final public var opacity: Float

    /// The URL of the picture marker symbol.
    final public var url: URL? { get }

    /// The width of the picture marker symbol.
    final public var width: CGFloat

    /// Get Multilayer point symbol generated from picture marker symbol.
    ///
    /// Given a picture marker symbol, this method will return a MultilayerPointSymbol with a PictureMarkerSymbolLayer.
    /// - Returns: A ``MultilayerPointSymbol`` object.
    final public func toMultilayerSymbol() -> ArcGIS.MultilayerPointSymbol

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A struct that implements picture marker symbol layers.
///
/// A ``PictureMarkerSymbolLayer`` represents a symbol layer used to place a
/// picture marker on a point geometry.
///
/// This symbol layer, in a ``MultilayerPointSymbol``, places a picture marker at
/// the location of the point feature. The class supports changing dimensions of the marker,
/// specifying the image (or URI linking to the image) to use as the marker, as well as the
/// general marker options provided by the ``MarkerSymbolLayer`` base class.
///
/// This symbol layer is similar to the Web Scene specification's IconSymbol3DLayer, when the
/// IconSymbol3DLayer references an image. ``PictureMarkerSymbolLayer`` is also similar to the
/// Web Map specification's ``PictureMarkerSymbol``. As a symbol layer, ``PictureMarkerSymbolLayer``
/// can be combined with other symbol layers in a ``MultilayerSymbol``, whereas ``PictureMarkerSymbol``
/// cannot.
/// - Since: 200.1
final public class PictureMarkerSymbolLayer : ArcGIS.MarkerSymbolLayer, ArcGIS.Loadable {

    /// Creates a picture marker symbol layer from an `UIImage`.
    ///
    /// This function sets up the following default properties:
    /// Anchor at (0, 0), offset of (0, 0), size of 13.33 DIPs (10 points), an angle of 0 degrees, width
    /// and height of (0, 0), and an empty URI. If the image is valid, the function sets the image on the symbol layer,
    /// and sets the load status of the ``PictureMarkerSymbolLayer`` to `LoadStatus.loaded`.
    /// - Parameter image: The `UIImage` indicating the desired image.
    public convenience init(image: UIImage)

    /// Creates a picture marker symbol layer from a URI.
    ///
    /// This function sets up the following default properties:
    /// Anchor at (0, 0), offset of (0, 0), size of 13.33 DIPs (10 points), an angle of 0 degrees,
    /// width and height of (0, 0), and a `nil` image. The function sets the URI to the string provided.
    /// After creating, call ``load()`` to load the image from the URI.
    /// - Parameter url: The const char* indicating the URI location of the image to use in the symbol layer.
    public convenience init(url: URL)

    /// The image of a picture marker symbol layer.
    ///
    /// Setting the image of a ``PictureMarkerSymbolLayer`` modifies the picture used for rendering the marker.
    final public var image: UIImage? { get }

    /// The tint color of a picture marker symbol layer.
    ///
    /// The tint color is applied to the entire image by multiplying each RGB color channel in the image by the
    /// corresponding color channel of the tint color. The default tint color is white with 100% opacity, i.e.
    /// RGBA(255, 255, 255, 255), which leaves the image with its native colors. A white tint color with opacity
    /// less than 100% tints the image white, with the reduced opacity respected.
    ///
    /// When getting the tint color from a symbol, the consensus value is reported. If there is no consensus
    /// (one or more layers have different tint colors), a `nil` value is reported for the tint color. Likewise,
    /// setting a value for tint color on a symbol will apply that tint color to all layers the symbol contains.
    final public var tintColor: UIColor

    /// The URI of the image to be loaded in a picture marker symbol layer.
    ///
    /// Setting the URI changes the URI property of ``Loadable``, from which ``PictureMarkerSymbolLayer``
    /// inherits. The URI is an empty string by default. The URI cannot be set after attempting to load. To load the
    /// image at the specified URI, call ``load()``.
    final public var url: URL? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A location defined by x and y (and optionally z) coordinates.
///
/// ``Point`` geometries represent discrete locations or entities, such as a geocoded house
/// address, the location of a water meter in a water utility network, or a moving vehicle.
/// Larger geographic entities (such as cities) are often represented as points on small-scale
/// maps. Points can be used as the geometry of features and graphics and are often used to
/// construct more complex geometries. They are also used in a ``Viewpoint`` to define the
/// center of the display.
///
/// Points store a single set of x,y coordinates that define a location (longitude and latitude,
/// for example), and a ``SpatialReference``. Points can optionally have a z-value (commonly
/// used to describe elevation or altitude) and an m-value (commonly used for measurement
/// relative to the geometry).
///
/// For points defined with a geographic spatial reference, the x-coordinate is the longitude (east
/// or west), and the y-coordinate is the latitude (north or south). When geographic coordinates
/// are represented in strings, points are generally written using the form "(latitude, longitude)",
/// where the y-coordinate comes before the x-coordinate. Latitude values south of the equator
/// and longitude values west of the prime meridian are expressed as negative numbers.
///
/// Use ``CoordinateFormatter`` to convert a latitude and longitude formatted string directly
/// to a ``Point``. The coordinate formatter can also return a latitude and longitude formatted
/// string from an existing ``Point``. Other coordinate notations, such as Military Grid Reference
/// System (MGRS) and United States National Grid (USNG) are also supported.
///
/// Points are based upon the parent ``Geometry`` class. The geometry class is
/// immutable which means that you can not change its shape once it is created. If you need to
/// modify a point once it has been created, use the ``PointBuilder`` class
/// instead. The `GeometryBuilder.toGeometry()` method provides you with the
/// point object.
/// - Note: See Also: ``Geometry``
/// - Since: 200.1
final public class Point : ArcGIS.Geometry {

    /// The x-coordinate for the point.
    final public var x: Double { get }

    /// The y-coordinate for the point.
    final public var y: Double { get }
}

extension Point {

    /// The z coordinate for the point.
    /// - Remark: Geometries can have z-values, indicating values along the
    /// z-axis, which is perpendicular to both the x-axis and y-axis. Z-values
    /// indicate height above or depth below a surface, or an absolute
    /// elevation. For example, z-values are used to draw the locations of
    /// geometries in a ``SceneView``. Note that geometries are not considered
    /// `true` 3D shapes and are draped onto surfaces in the view, or in some
    /// cases, drawn in a single plane by using z-values. Z-values are stored on
    /// ``Point`` and ``Envelope``. Since ``Multipoint``, ``Polyline``, and
    /// ``Polygon`` are created from a collection of ``Point`` values, all types
    /// of geometry can have z-values.
    ///
    /// Whether or not a geometry has z-values is determined when the geometry
    /// is created; if you use an initializer that has a z-value parameter, the
    /// new geometry will have z-values (``Geometry/hasZ`` will be `true`). If
    /// you create a geometry using an initializer that takes a z-value
    /// parameter, or if you pass into the initializer points or segments that
    /// have z-values, then the new geometry will have z-values. A ``Geometry``
    /// with z-values is sometimes known as a z-aware geometry.
    ///
    /// It may be that not all vertices in your geometry have a z-value defined.
    /// `nan` is a valid z-value used to indicate an unknown z-value. A value
    /// of `nil` indicates that the geometry does not have a z-value.
    final public var z: Double? { get }

    /// An optional coordinate to define a measure value for the point.
    /// - Remark: M-values are used in linear referencing scenarios and may
    /// represent things like mile markers along a highway. Like z-values, every
    /// geometry can optionally store m-values with the point coordinates that
    /// comprise it. If an m-value is specified when a geometry is created, the
    /// new geometry will have m-values (``Geometry/hasM`` will be `true`). A
    /// value of `nil` indicates that the geometry does not have an m-value.
    final public var m: Double? { get }

    /// Creates a point with an x, y, z, m and spatial reference.
    /// - Parameters:
    ///   - x: The x coordinate for the point.
    ///   - y: The y coordinate for the point.
    ///   - z: The z coordinate for the point. The minimum is -6,356,752 meters,
    ///   which is the approximate radius of the earth (the WGS 84 datum
    ///   semi-minor axis). The maximum z-value is 55,000,000 meters. The
    ///   default is `nil`.
    ///   - m: The m value for the point. The default is `nil`.
    ///   - spatialReference: The spatial reference for the point. The default
    ///   is `nil`.
    public convenience init(x: Double, y: Double, z: Double? = nil, m: Double? = nil, spatialReference: ArcGIS.SpatialReference? = nil)

    /// Creates a point with a latitude, longitude, and WGS84 spatial reference.
    /// - Parameters:
    ///   - latitude: The latitude coordinate for the point.
    ///   - longitude: The longitude coordinate for the point.
    public convenience init(latitude: Double, longitude: Double)
}

extension Point : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    final public var description: String { get }
}

/// A point barrier object is used to restrict route solving.
///
/// A class that represents a point location to be avoided (or penalized) by a route.
/// A point barrier may represent a restricted location to be avoided by a route (e.g., a car accident) or
/// a location at which some additional delay occurs if visited along a route (e.g., a railroad crossing).
///
/// The point barrier class is derived from the graphic class.
/// - Since: 200.1
final public class PointBarrier {

    /// Creates a point barrier instance.
    ///
    /// Creates a point barrier.
    /// - Parameter point: A point.
    /// - Note: See Also: ``Point``
    public convenience init(point: ArcGIS.Point)

    /// Point barrier ID.
    ///
    /// This is a caller supplied foreign key that can be used to associate output point barriers with input point barriers.
    /// - Note: See Also: `RouteParameters.setPointBarriers(fromFeaturesIn:queryParameters:)`, ``RouteResult/pointBarriers``,
    /// `ClosestFacilityParameters.setPointBarriers(fromFeaturesIn:queryParameters:)`, ``ClosestFacilityResult/pointBarriers``,
    /// `ServiceAreaParameters.setPointBarriers(fromFeaturesIn:queryParameters:)`, ``ServiceAreaResult/pointBarriers``
    final public var barrierID: Int

    /// Point barrier's curb approach.
    ///
    /// The curb approach.
    /// - Note: See Also: ``CurbApproach``
    final public var curbApproach: ArcGIS.CurbApproach?

    /// The geometry of a point barrier.
    ///
    /// The point geometry of Point barrier.
    /// - Note: See Also: ``Point``
    final public var geometry: ArcGIS.Point?

    /// Location status.
    ///
    /// A location status of the point barrier.
    /// - Note: See Also: ``LocationStatus``
    final public var locationStatus: ArcGIS.LocationStatus { get }

    /// The name of a point barrier.
    /// - Note: See Also: `String`
    final public var name: String

    /// Point barrier's type.
    ///
    /// The type of point barrier.
    /// - Note: See Also: ``BarrierType``
    final public var type: ArcGIS.BarrierType

    /// Gets added cost.
    ///
    /// Get the amount of additional cost that has been added for a particular attribute on this Stop. If no cost has been
    /// added, or an incorrect name is specified, a value of zero will be returned.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: A value of added cost.
    final public func addedCost(forAttributeNamed attributeName: String) -> Double

    /// Clones the ``PointBarrier``.
    /// - Returns: A new ``PointBarrier`` with the same values as the current ``PointBarrier``.
    final public func clone() -> Self

    /// Sets added cost.
    ///
    /// Set the amount of additional cost for an attribute by name. Any additional cost, e.g. Minutes, TravelTime,
    /// Kilometers, can be modified with this method.
    /// - Parameters:
    ///   - addedCost: The added cost.
    ///   - attributeName: The name of attribute.
    final public func setAddedCost(_ addedCost: Double, forAttributeNamed attributeName: String)
}

/// The point builder object is used to create a point.
/// - Since: 200.1
final public class PointBuilder : ArcGIS.GeometryBuilder<ArcGIS.Point> {

    /// Creates a point builder from a point.
    /// - Parameter point: The point object.
    /// - Note: See Also: ``Point``
    public convenience init(point: ArcGIS.Point)

    /// Creates a point builder.
    /// - Parameter spatialReference: The builder's spatial reference.
    public convenience init(spatialReference: ArcGIS.SpatialReference? = nil)

    /// The m-value for the point.
    final public var m: Double

    /// The x-coordinate for the point.
    final public var x: Double

    /// The y-coordinate for the point.
    final public var y: Double

    /// The z-coordinate for the point.
    ///
    /// The minimum z-coordinate is -6,356,752 meters, which is the approximate radius of the earth (the WGS 84 datum semi-minor axis).
    /// The maximum z-coordinate is 55,000,000 meters.
    final public var z: Double

    /// Offsets the envelope by the given offsets for the x and y dimension.
    /// - Parameters:
    ///   - x: The number of units to move the envelope on the x axis.
    ///   - y: The number of units to move the envelope on the y axis.
    final public func offsetBy(x: Double, y: Double)

    /// Sets the x,y coordinates of a point.
    /// - Parameters:
    ///   - x: The new x-coordinate value for the point.
    ///   - y: The new y-coordinate value for the point.
    final public func setXY(x: Double, y: Double)
}

/// An instance of this class represents a layer that can visualize a point cloud layer.
/// Point cloud layers provide fast display of large volumes of symbolized and filtered point cloud data.
/// They are optimized for the display and sharing of many kinds of sensor data, including lidar.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class PointCloudLayer : ArcGIS.Layer {

    /// Creates a Point Cloud layer object with a portal item.
    /// - Parameter item: The point cloud layer item (only ``PortalItem`` are supported).
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// Creates a Point Cloud layer object.
    ///
    /// If the specified URI is a portal item URL (see ``PortalItem/init(url:)`` for the supported URL formats), the underlying ``PortalItem`` will be created and accessible through ``Layer/item``.
    /// - Parameter url: The URI to a service, scene layer package, or portal item.
    /// - Note: See Also: `CoreRequestRequestRequiredEvent`, `CoreRequest.handleResponse(data:etag:mediaType:httpStatusCode:platformAPIError:response:)`, ``PortalItem``, ``PortalItem/init(url:)``, ``Layer/item``
    public convenience init(url: URL)

    /// The layer altitude offset.
    final public var altitudeOffset: Double

    /// The URI of the Point Cloud layer.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:)``
    final public var url: URL?
}

/// Represents an immutable collection of points.
///
/// This collection is used to represent the content of a ``Multipoint`` geometry.
/// - Since: 200.1
final public class PointCollection {

    /// The spatial reference for the immutable point collection.
    ///
    /// If the collection does not have a spatial reference `nil` is returned.
    final public var spatialReference: ArcGIS.SpatialReference? { get }
}

extension PointCollection : RandomAccessCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @inlinable final public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    final public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    final public subscript(position: Int) -> ArcGIS.Point { get }

    /// A type representing the sequence's elements.
    public typealias Element = ArcGIS.Point

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArcGIS.PointCollection>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    public typealias SubSequence = Slice<ArcGIS.PointCollection>
}

/// A multipart shape used to represent an area.
///
/// Polygon geometries represent the shape and location of areas, for example, a country, island,
/// or a lake. A polygon can be used as the geometry of features and graphics, or as input or
/// output of tasks or geoprocessing operations, such as the output of a drive-time analysis or a
/// `GeometryEngine.buffer(around:distance:)` operation.
///
/// Each part of a multipart polygon is a series of connected ``Segment`` objects forming a
/// closed ring. Each part must not cross any other part, but may lie completely inside or
/// outside another part. For example, a polygon representing the state of Hawaii would comprise
/// eight disjoint parts, one representing each island. A polygon representing the country of
/// South Africa, which completely surrounds the enclave of Lesotho, would comprise two parts,
/// one contained inside the other.
///
/// Like polyline, the polygon class is a ``Multipart``, which provides members for iterating the
/// segments and points of each part in a polygon. Unlike parts in a polyline, however, each
/// part of a polygon defines a closed area, so the end point of the last segment in the part is
/// always in the same location as the start point of the first segment, forming a closed
/// boundary.
///
/// When defining a polygon part, there is no need to explicitly close it by repeating the start
/// point as the last point. Polygons parts are always interpreted as enclosed areas by the ArcGIS
/// Maps API.
///
/// Interior rings to make donut polygons should be counter-clockwise in direction to have the
/// correct topology.
///
/// If there is ever a doubt about the topological correctness of a polygon, call the
/// `GeometryEngine.simplify(_:)` method to correct any issues. This is especially `true`
/// if you pass a polygon to ArcGIS Server for a geoprocessing task to avoid any ArcGIS Server
/// errors being thrown or to rectify polygons that may be self-intersecting, have rings which
/// are partially contained in each other, or contain incorrect ring orientations.
///
/// Polygons are based upon the parent ``Geometry`` class. The geometry object is
/// immutable which means that you can not change its shape once it is created. If you need to
/// create a new polygon or modify it once it has been created, use the ``PolygonBuilder`` class.
///
/// A polygon can be used as the geometry of a ``Feature`` or ``Graphic``. To obtain the
/// geometry on these objects, use ``GeoElement/geometry``.
/// - Note: See Also: ``Geometry``
/// - Since: 200.1
final public class Polygon : ArcGIS.Geometry, ArcGIS.Multipart {

    /// Creates a polyline containing paths for all the rings in this polygon.
    ///
    /// Creates a polyline object that matches the geometry of this polygon.
    /// - Returns: A polyline.
    final public func toPolyline() -> ArcGIS.Polyline
}

extension Polygon {

    /// Creates a polygon with the given parts.
    ///
    /// The spatial reference of the polygon will be either the spatial
    /// reference of the first part or `nil` if there are no parts.
    /// - Parameter parts: The parts with which to create the polygon. All
    /// parts must have the same spatial reference.
    public convenience init<S>(parts: S) where S : Sequence, S.Element == ArcGIS.MutablePart
}

/// A polygon barrier object is used to restrict route solving.
///
/// A class that represents a polygon feature to be avoided (or penalized) by a route.
/// A polygon barrier may represent a regional area of interest within the network to be avoided
/// (i.e., not entered) by a route (e.g., a flood zone) or to penalize/delay a route within any
/// portions of the area traversed by the route (e.g., a busy downtown area or a bad neighborhood).
///
/// The polygon barrier class is derived from the graphic class.
/// - Since: 200.1
final public class PolygonBarrier {

    /// Creates a polygon barrier instance.
    /// - Parameter polygon: A polygon.
    /// - Note: See Also: ``Polygon``
    public convenience init(polygon: ArcGIS.Polygon)

    /// Polygon barrier ID.
    ///
    /// This is a caller supplied foreign key that can be used to associate output polygon barriers with input polygon barriers.
    /// - Note: See Also: `RouteParameters.setPolygonBarriers(fromFeaturesIn:queryParameters:)`, ``RouteResult/polygonBarriers``,
    /// `ClosestFacilityParameters.setPolygonBarriers(fromFeaturesIn:queryParameters:)`, ``ClosestFacilityResult/polygonBarriers``,
    /// `ServiceAreaParameters.setPolygonBarriers(fromFeaturesIn:queryParameters:)`, ``ServiceAreaResult/polygonBarriers``
    final public var barrierID: Int

    /// Polygon barrier's geometry.
    ///
    /// The polygon geometry of a Polygon barrier.
    /// - Note: See Also: ``Polygon``
    final public var geometry: ArcGIS.Polygon?

    /// The name of a polygon barrier.
    /// - Note: See Also: `String`
    final public var name: String

    /// Polygon barrier's type.
    /// - Note: See Also: ``BarrierType``
    final public var type: ArcGIS.BarrierType

    /// Clones the ``PolygonBarrier``.
    /// - Returns: A new ``PolygonBarrier`` with the same values as the current ``PolygonBarrier``.
    final public func clone() -> Self

    /// Gets scale factor for cost.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: A value of scale factor for cost.
    final public func scaleFactor(forCostAttributeNamed attributeName: String) -> Double

    /// Sets scale factor for cost.
    /// - Parameters:
    ///   - scaleFactor: The scale factor for cost.
    ///   - attributeName: The name of attribute.
    final public func setScaleFactor(_ scaleFactor: Double, forCostAttributeNamed attributeName: String)
}

/// The polygon builder object is used to create a polygon.
/// - Since: 200.1
final public class PolygonBuilder : ArcGIS.GeometryBuilder<ArcGIS.Polygon> {

    /// Creates a polygon builder from a polygon.
    ///
    /// Prior to v100.12, only polygons without curves could be used; passing in a polygon where
    /// ``Geometry/hasCurves`` is `true` would throw an exception.
    ///
    /// From v100.12, polygons with curves are supported.
    /// - Parameter polygon: A polygon object.
    /// - Note: See Also: ``GeometryBuilder/hasCurves``
    public convenience init(polygon: ArcGIS.Polygon)

    /// Creates a polygon builder.
    /// - Parameter spatialReference: The builder's spatial reference.
    public convenience init(spatialReference: ArcGIS.SpatialReference? = nil)

    /// Creates a polyline with the values in the polygon builder.
    ///
    /// Creates the polyline object described by this builder.
    /// - Returns: A polyline.
    final public func toPolyline() -> ArcGIS.Polyline
}

extension PolygonBuilder : ArcGIS.MultipartBuilder {

    /// The type of geometry buildable by this builder.
    public typealias Buildable = ArcGIS.Polygon
}

/// A multipart linear shape.
///
/// Polyline geometries represent the shape and location of linear features, such as a street
/// in a road network, a contour line representing an elevation value, or a hiking trail. A
/// polyline can be used to define geometry for features and graphics, or as input or output
/// for tasks or geoprocessing operations, such as the output of a network trace.
///
/// A polyline can be used as the geometry of a ``Feature`` or ``Graphic``. To obtain the
/// geometry on these objects, use ``GeoElement/geometry``.
///
/// A polyline is composed of a series of connected segments, where each ``Segment`` defines a
/// continuous line between a start and an end point. You can define a new polyline from a
/// collection of ``Point`` objects to create a series of straight ``LineSegment`` objects
/// connecting the points you specified. You can use ``PolylineBuilder`` to build a polyline
/// one point at a time, or to modify an existing polyline.
///
/// A polyline can have multiple parts. Each part is a series of connected segments, but the
/// parts can be disjoint, for example, a polyline representing a street that ends, and starts
/// again a block later. Parts can also intersect at one or more points (or vertices), for
/// example, a polyline representing a river and its tributaries.
///
/// Polylines inherit from ``Multipart``, which provides members for iterating the segments and
/// points of each part in a polyline.
///
/// Polylines are based upon the parent ``Geometry`` class which is immutable, meaning you can
/// not change its shape once it is created. If you need to modify a polyline once it has been
/// created, use the ``PolylineBuilder`` class.
/// - Note: See Also: ``Geometry``
/// - Since: 200.1
final public class Polyline : ArcGIS.Geometry, ArcGIS.Multipart {
}

extension Polyline {

    /// Creates a polyline with the given parts.
    ///
    /// The spatial reference of the polyline will be either the spatial
    /// reference of the first part or `nil` if there are no parts.
    /// - Parameter parts: The parts with which to create the polyline. All
    /// parts must have the same spatial reference.
    public convenience init<S>(parts: S) where S : Sequence, S.Element == ArcGIS.MutablePart
}

/// A polyline barrier is used to restrict route solving.
///
/// A class that represents a linear feature to be avoided (or penalized) by a route.
/// A polyline barrier may represent a linear feature (e.g., a subpath in the network) to be avoided
/// (i.e., not crossed or followed) by a route or to penalize/delay a route along any portions
/// of the feature traversed by the route (e.g., a stretch of interstate with temporarily
/// reduced speed limits due to local construction along an adjacent lane).
///
/// The polyline barrier class is derived from the graphic class.
/// - Since: 200.1
final public class PolylineBarrier {

    /// Creates a polyline barrier instance.
    ///
    /// Creates a polyline barrier.
    /// - Parameter polyline: A polyline.
    /// - Note: See Also: ``Polyline``
    public convenience init(polyline: ArcGIS.Polyline)

    /// Polyline barrier ID.
    ///
    /// This is a caller supplied foreign key that can be used to associate output polyline barriers with input polyline barriers.
    /// - Note: See Also: `RouteParameters.setPolylineBarriers(fromFeaturesIn:queryParameters:)`, ``RouteResult/polylineBarriers``,
    /// `ClosestFacilityParameters.setPolylineBarriers(fromFeaturesIn:queryParameters:)`, ``ClosestFacilityResult/polylineBarriers``,
    /// `ServiceAreaParameters.setPolylineBarriers(fromFeaturesIn:queryParameters:)`, ``ServiceAreaResult/polylineBarriers``
    final public var barrierID: Int

    /// The geometry of a polyline barrier.
    ///
    /// The polyline geometry of a Polyline barrier.
    /// - Note: See Also: ``Polyline``
    final public var geometry: ArcGIS.Polyline?

    /// The name of a polyline barrier.
    /// - Note: See Also: ``Polyline``
    final public var name: String

    /// Polyline barrier's type.
    ///
    /// A type of polyline barrier.
    /// - Note: See Also: ``BarrierType``
    final public var type: ArcGIS.BarrierType

    /// Clones the ``PolylineBarrier``.
    /// - Returns: A new ``PolylineBarrier`` with the same values as the current ``PolylineBarrier``.
    final public func clone() -> Self

    /// Gets scale factor for cost.
    ///
    /// Returns scale factor for cost.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: A value of scale factor for cost.
    final public func scaleFactor(forCostAttributeNamed attributeName: String) -> Double

    /// Sets scale factor for cost.
    /// - Parameters:
    ///   - scaleFactor: The scale factor for cost.
    ///   - attributeName: The name of attribute.
    final public func setScaleFactor(_ scaleFactor: Double, forCostAttributeNamed attributeName: String)
}

/// The polyline builder object is used to create a polyline.
/// - Since: 200.1
final public class PolylineBuilder : ArcGIS.GeometryBuilder<ArcGIS.Polyline> {

    /// Creates a polyline builder from a polyline.
    ///
    /// Prior to v100.12, only polylines without curves could be used; passing in a polygon where
    /// ``Geometry/hasCurves`` is `true` would throw an exception.
    ///
    /// From v100.12, polylines with curves are supported.
    /// - Parameter polyline: A polyline object.
    /// - Note: See Also: ``GeometryBuilder/hasCurves``
    public convenience init(polyline: ArcGIS.Polyline)

    /// Creates a polyline builder.
    /// - Parameter spatialReference: The builder's spatial reference.
    public convenience init(spatialReference: ArcGIS.SpatialReference? = nil)
}

extension PolylineBuilder : ArcGIS.MultipartBuilder {

    /// The type of geometry buildable by this builder.
    public typealias Buildable = ArcGIS.Polyline
}

/// Represents a pop-up which is basically a pair (GeoElement, PopupDefinition).
/// - Since: 200.1
final public class Popup {

    /// The popup definition associated with the popup.
    final public var definition: ArcGIS.PopupDefinition { get }

    /// An `Array` of ``PopupElement`` objects evaluated asynchronously by `Popup.evaluateExpressions()`.
    /// During the evaluation, each ``ExpressionPopupElement`` is replaced by the ``PopupElement`` returned by the Arcade expression and each placeholder is replaced by its value.
    /// If the Arcade expression returns a list of attributes to be used by the popup element, these attributes will be used by `Popup.formattedValue(for:)`.
    ///
    /// The array is empty while `Popup.evaluateExpressions()` has not been executed, and is cleared if `Popup.evaluateExpressions()` is executed more than once.
    /// After evaluation, the order of the popup elements in the `Array` matches the order elements present in
    /// ``PopupDefinition/elements`` and shown in the pop-up window.
    /// If an ``ExpressionPopupElement`` fails to be evaluated, then it will be skipped in the `Array`. Use the array of
    /// ``PopupExpressionEvaluation`` returned from `Popup.evaluateExpressions()` to learn the cause of the error.
    /// - Note: See Also: ``PopupDefinition/elements``, `Popup.evaluateExpressions()`
    final public var evaluatedElements: [ArcGIS.PopupElement] { get }

    /// The ``GeoElement`` of the pop-up.
    final public var geoElement: ArcGIS.GeoElement { get }

    /// The popup symbol.
    final public var symbol: ArcGIS.Symbol? { get }

    /// The popup title.
    final public var title: String { get }

    /// Asynchronously evaluates all expressions available at ``PopupDefinition/expressions`` or at ``ExpressionPopupElement/popupExpression``.
    /// The expression can include Arcade FeatureSet functions, which need to be evaluated asynchronously.
    ///
    /// Also populates the ``evaluatedElements`` from the ``PopupDefinition/elements``.
    /// During the evaluation, each ``ExpressionPopupElement`` is replaced by the ``PopupElement`` returned by the Arcade expression and each placeholder is replaced by its value.
    ///
    /// This method must be called before displaying the popup information in a UI so you can use synchronous methods
    /// `Popup.formattedValue(for:)` and `Popup.substitute(templatedString:)` to get the formatted `String` representation.
    /// If there are no ``PopupDefinition/expressions`` and no popup elements of type ``ExpressionPopupElement`` then the result array will be empty.
    ///
    /// The ``PopupExpression`` may be used in the ``PopupDefinition/fields``, ``PopupDefinition/media``, ``PopupDefinition/title``
    /// and ``PopupDefinition/description``.
    /// - Returns: An array of ``PopupExpressionEvaluation``.
    final public func evaluateExpressions() async throws -> [ArcGIS.PopupExpressionEvaluation]

    /// Gets the formatted value of the popup field.
    ///
    /// Dates and times are returned in the local timezone.
    /// If ``PopupDefinition/expressions`` is not empty then the ``PopupField``
    /// may be using expressions with Arcade FeatureSet functions. Use `Popup.evaluateExpressions()` to
    /// evaluate the Arcade expressions before trying to get the formatted `String` representation
    /// of the popup field's value, otherwise it may return an empty string.
    ///
    /// If the field is part of a ``CodedValueDomain``, the ``CodedValue/name`` is returned.
    /// - Parameter popupField: The popup field object.
    /// - Returns: A `String`.
    final public func formattedValue(for popupField: ArcGIS.PopupField) -> String
}

extension Popup {

    /// Creates a new popup from a feature and a popup definition.
    ///
    /// If the popup definition is `nil`, a default one will be created from the geo element.
    /// - Parameters:
    ///   - geoElement: The ``Feature`` for the popup.
    ///   - definition: A ``PopupDefinition``.
    /// - Note: See Also: ``GeoViewProxy/identifyLayers(screenPoint:tolerance:returnPopupsOnly:maximumResultsPerLayer:)``
    public convenience init(geoElement: ArcGIS.Feature, definition: ArcGIS.PopupDefinition? = nil)

    /// Creates a new popup from a graphic and a popup definition.
    ///
    /// If the popup definition is `nil`, a default one will be created from the graphic.
    /// - Parameters:
    ///   - geoElement: The ``Graphic`` for the popup.
    ///   - definition: A ``PopupDefinition``.
    /// - Note: See Also: ``GeoViewProxy/identifyLayers(screenPoint:tolerance:returnPopupsOnly:maximumResultsPerLayer:)``
    public convenience init(geoElement: ArcGIS.Graphic, definition: ArcGIS.PopupDefinition? = nil)
}

/// Represents an attachment belonging to a popup. Wraps the Attachment object and add additional properties
/// and method to support displaying attachments in a popup.
/// - Since: 200.1
final public class PopupAttachment : ArcGIS.Loadable {

    /// The type of attachments in a PopupAttachmentManager
    public enum Kind {

        /// An image.
        case image

        /// A video.
        case video

        /// A document.
        case document

        /// An attachment of another type.
        case other

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PopupAttachment.Kind, b: ArcGIS.PopupAttachment.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The underlying ``Attachment``.
    final public var attachment: ArcGIS.Attachment? { get }

    /// The MIME content type of the ``PopupAttachment``.
    final public var contentType: String { get }

    /// The local temporary filepath where we store the attachment once it is loaded.
    final public var fileURL: URL { get }

    /// A value indicating whether "loading" (fetching the data) can be accomplished without using the network.
    ///
    /// This is `true` if it just needs to pull the data from a database,
    /// `false` if the loading will cause a network request.
    final public var isLocal: Bool { get }

    /// The type of the ``PopupAttachment``.
    final public var kind: ArcGIS.PopupAttachment.Kind { get }

    /// The name of the ``PopupAttachment``.
    final public var name: String { get }

    /// The size of the ``PopupAttachment`` in bytes.
    final public var size: Int { get }

    /// Creates asynchronously the full image for displaying the attachment in full screen or some UI larger than a thumbnail.
    ///
    /// This is only supported if the ``kind-swift.property`` is ``Kind-swift.enum/image``.
    /// - Returns: A task that represents the asynchronous operation. The task result contains the full image as an `UIImage`.
    final public func makeFullImage() async throws -> UIImage

    /// Creates asynchronously a thumbnail image with the specified width and height.
    ///
    /// This is only supported if the ``kind-swift.property`` is ``Kind-swift.enum/image``.
    /// - Parameters:
    ///   - width: Width of the thumbnail.
    ///   - height: Height of the thumbnail.
    /// - Returns: A task that represents the asynchronous operation. The task result contains the thumbnail as an `UIImage`.
    final public func makeThumbnail(width: Int, height: Int) async throws -> UIImage

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension PopupAttachment.Kind : Equatable {
}

extension PopupAttachment.Kind : Hashable {
}

/// Represents the look and feel of pop-ups.
/// - Since: 200.1
final public class PopupDefinition {

    /// Creates a new popup definition.
    ///
    /// Use this object to define the look and feel of pop-up windows when users click or query a feature.
    public convenience init()

    /// A flag indicating whether the popup should allow the associated GeoElement to be deleted.
    final public var allowsDelete: Bool

    /// A flag indicating whether the popup should allow the associated GeoElement to be edited.
    final public var allowsEdit: Bool

    /// A flag indicating whether the popup should allow the geometry of the associated GeoElement to be edited.
    final public var allowsEditGeometry: Bool

    /// A string that appears in the body of the pop-up window as a description.
    ///
    /// The description can contain a literal value, or a placeholder for value from the geo element's attribute.
    /// The placeholder needs to be of the form {field_name} where <i>field_name</i> is a key in the geo element's attributes
    final public var description: String

    /// An `Array` of ``PopupElement`` objects that represent an ordered list of pop-up elements.
    ///
    /// The order of the `Array` is the order that elements are shown in the pop-up window.
    ///
    /// For backward compatibility with a webmap or webscene created by clients that don't support the popup elements,
    /// a few popup elements are created to match the legacy popup style when reading a popup definition without popup elements:
    ///   - a ``TextPopupElement`` if ``description`` is not empty
    ///   - a ``FieldsPopupElement`` if ``description`` is empty
    ///   - a ``MediaPopupElement`` if ``media`` is not empty
    ///   - an ``AttachmentsPopupElement`` if ``showsAttachments`` is `true`
    ///
    ///   Vice versa, if the user updates the popup elements, the legacy popup style is updated during the ``PopupDefinition`` serialization,
    ///   in order to match as much as possible the popup elements, so that older clients can display a popup that looks similar.
    final public var elements: [ArcGIS.PopupElement] { get }

    /// Adds a sequence of `PopupElement` values to the end of the `elements` property.
    /// - Parameter newElements: The new `PopupElement` values to append.
    final public func addElements<S>(_ newElements: S) where S : Sequence, S.Element == ArcGIS.PopupElement

    /// Adds a `PopupElement` value to the end of the `elements` property.
    /// - Parameter newElement: The new `PopupElement` value to append.
    final public func addElement(_ newElement: ArcGIS.PopupElement)

    /// Inserts a collection of `PopupElement` values into the `elements` property at the specified position.
    /// - Parameters:
    ///   - newElements: The new `PopupElement` values to insert.
    ///   - index: The position at which to insert the new `PopupElement` values.
    final public func insertElements<C>(_ newElements: C, at index: Int) where C : Collection, C.Element == ArcGIS.PopupElement

    /// Inserts a `PopupElement` value into the `elements` property at the specified position.
    /// - Parameters:
    ///   - newElement: The new `PopupElement` value to insert.
    ///   - index: The position at which to insert the new `PopupElement` value.
    final public func insertElement(_ newElement: ArcGIS.PopupElement, at index: Int)

    /// Removes all values from the `elements` property.
    final public func removeAllElements()

    /// Removes a sequence of `PopupElement` values from the `elements` property.
    /// - Parameter elements: The `PopupElement` values to remove.
    final public func removeElements<S>(_ elements: S) where S : Sequence, S.Element == ArcGIS.PopupElement

    /// Removes a `PopupElement` value from the `elements` property.
    /// - Parameter element: The `PopupElement` value to remove.
    final public func removeElement(_ element: ArcGIS.PopupElement)

    /// An `Array` of ``PopupExpression`` objects defining the various arcade expressions on the popup.
    final public var expressions: [ArcGIS.PopupExpression] { get }

    /// Adds a sequence of `PopupExpression` values to the end of the `expressions` property.
    /// - Parameter newExpressions: The new `PopupExpression` values to append.
    final public func addExpressions<S>(_ newExpressions: S) where S : Sequence, S.Element == ArcGIS.PopupExpression

    /// Adds a `PopupExpression` value to the end of the `expressions` property.
    /// - Parameter newExpression: The new `PopupExpression` value to append.
    final public func addExpression(_ newExpression: ArcGIS.PopupExpression)

    /// Inserts a collection of `PopupExpression` values into the `expressions` property at the specified position.
    /// - Parameters:
    ///   - newExpressions: The new `PopupExpression` values to insert.
    ///   - index: The position at which to insert the new `PopupExpression` values.
    final public func insertExpressions<C>(_ newExpressions: C, at index: Int) where C : Collection, C.Element == ArcGIS.PopupExpression

    /// Inserts a `PopupExpression` value into the `expressions` property at the specified position.
    /// - Parameters:
    ///   - newExpression: The new `PopupExpression` value to insert.
    ///   - index: The position at which to insert the new `PopupExpression` value.
    final public func insertExpression(_ newExpression: ArcGIS.PopupExpression, at index: Int)

    /// Removes all values from the `expressions` property.
    final public func removeAllExpressions()

    /// Removes a sequence of `PopupExpression` values from the `expressions` property.
    /// - Parameter expressions: The `PopupExpression` values to remove.
    final public func removeExpressions<S>(_ expressions: S) where S : Sequence, S.Element == ArcGIS.PopupExpression

    /// Removes a `PopupExpression` value from the `expressions` property.
    /// - Parameter expression: The `PopupExpression` value to remove.
    final public func removeExpression(_ expression: ArcGIS.PopupExpression)

    /// An `Array` of ``PopupField`` objects defining how each field participates in the pop-up window.
    ///
    /// The order of the `Array` is the order that fields are shown in the pop-up window.
    final public var fields: [ArcGIS.PopupField] { get }

    /// Adds a sequence of `PopupField` values to the end of the `fields` property.
    /// - Parameter newFields: The new `PopupField` values to append.
    final public func addFields<S>(_ newFields: S) where S : Sequence, S.Element == ArcGIS.PopupField

    /// Adds a `PopupField` value to the end of the `fields` property.
    /// - Parameter newField: The new `PopupField` value to append.
    final public func addField(_ newField: ArcGIS.PopupField)

    /// Inserts a collection of `PopupField` values into the `fields` property at the specified position.
    /// - Parameters:
    ///   - newFields: The new `PopupField` values to insert.
    ///   - index: The position at which to insert the new `PopupField` values.
    final public func insertFields<C>(_ newFields: C, at index: Int) where C : Collection, C.Element == ArcGIS.PopupField

    /// Inserts a `PopupField` value into the `fields` property at the specified position.
    /// - Parameters:
    ///   - newField: The new `PopupField` value to insert.
    ///   - index: The position at which to insert the new `PopupField` value.
    final public func insertField(_ newField: ArcGIS.PopupField, at index: Int)

    /// Removes all values from the `fields` property.
    final public func removeAllFields()

    /// Removes a sequence of `PopupField` values from the `fields` property.
    /// - Parameter fields: The `PopupField` values to remove.
    final public func removeFields<S>(_ fields: S) where S : Sequence, S.Element == ArcGIS.PopupField

    /// Removes a `PopupField` value from the `fields` property.
    /// - Parameter field: The `PopupField` value to remove.
    final public func removeField(_ field: ArcGIS.PopupField)

    /// An `Array` of ``PopupMedia`` objects that define images and charts displayed in the pop-up window.
    ///
    /// The order of the `Array` is the order that medias are shown in the pop-up window.
    final public var media: [ArcGIS.PopupMedia] { get }

    /// Adds a sequence of `PopupMedia` values to the end of the `media` property.
    /// - Parameter newMedia: The new `PopupMedia` values to append.
    final public func addMedia<S>(_ newMedia: S) where S : Sequence, S.Element == ArcGIS.PopupMedia

    /// Adds a `PopupMedia` value to the end of the `media` property.
    /// - Parameter newMedia: The new `PopupMedia` value to append.
    final public func addMedia(_ newMedia: ArcGIS.PopupMedia)

    /// Inserts a collection of `PopupMedia` values into the `media` property at the specified position.
    /// - Parameters:
    ///   - newMedia: The new `PopupMedia` values to insert.
    ///   - index: The position at which to insert the new `PopupMedia` values.
    final public func insertMedia<C>(_ newMedia: C, at index: Int) where C : Collection, C.Element == ArcGIS.PopupMedia

    /// Inserts a `PopupMedia` value into the `media` property at the specified position.
    /// - Parameters:
    ///   - newMedia: The new `PopupMedia` value to insert.
    ///   - index: The position at which to insert the new `PopupMedia` value.
    final public func insertMedia(_ newMedia: ArcGIS.PopupMedia, at index: Int)

    /// Removes all values from the `media` property.
    final public func removeAllMedia()

    /// Removes a sequence of `PopupMedia` values from the `media` property.
    /// - Parameter media: The `PopupMedia` values to remove.
    final public func removeMedia<S>(_ media: S) where S : Sequence, S.Element == ArcGIS.PopupMedia

    /// Removes a `PopupMedia` value from the `media` property.
    /// - Parameter media: The `PopupMedia` value to remove.
    final public func removeMedia(_ media: ArcGIS.PopupMedia)

    /// The related features definition.
    ///
    /// A definition that dictates whether related features should be displayed in the popup and how they should be sorted.
    final public var relatedFeaturesDefinition: ArcGIS.PopupRelatedFeaturesDefinition?

    /// A flag determining whether attachments will be loaded for feature layers that have attachments.
    final public var showsAttachments: Bool

    /// A flag indicating whether the popup should display the edit summary of the associated GeoElement.
    final public var showsEditSummary: Bool

    /// A string that appears at the top of the pop-up window as a title.
    ///
    /// The title can contain a literal value, or a placeholder for value from the geo element's attribute.
    /// The placeholder needs to be of the form {field_name} where <i>field_name</i> is a key in the geo element's attributes.
    final public var title: String
}

extension PopupDefinition {

    /// Creates a new popup definition from a ``GeoElement``.
    /// - Remark: This creates a new popup definition with default properties and default popup elements based on the geoelement fields.
    /// Use this object to define the look and feel of pop-up windows when users click or query a feature.
    /// - Parameter geoElement: The geoelement for the popup definition, such as a ``Feature`` or ``Graphic``.
    public convenience init(geoElement: ArcGIS.GeoElement)

    /// Creates a new popup definition from a popup source.
    /// - Remark: This creates a new popup definition with default properties and default popup elements based on the popup source fields.
    /// Use this object to define the look and feel of pop-up windows when users click or query a feature.
    /// - Parameter popupSource: The popup source for the popup definition, such as a ``FeatureLayer`` or ``GraphicsOverlay``.
    public convenience init(popupSource: ArcGIS.PopupSource)
}

/// Represents an element that is displayed in a pop-up for a geoelement.
/// - Note: See Also: `PopupElement.Type`, ``PopupDefinition/elements``, ``Popup/evaluatedElements``
/// - Since: 200.1
public class PopupElement : ArcGIS.JSONSerializable {

    /// A value indicating whether the popup element is contained in the ``Popup/evaluatedElements``.
    public var isEvaluated: Bool { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

/// Defines an Arcade expression within a pop-up.
/// - Since: 200.1
final public class PopupExpression {

    /// The type of the result returned by an Arcade expression.
    public enum ReturnType {

        /// A string value is returned.
        case string

        /// A numeric value is returned.
        case number

        /// The return type is expected to be a dictionary of key/value pairs that must follow the Web Map Specification for a popupElement.
        ///
        /// Refer to [Popup Element](https://developers.arcgis.com/arcade/profiles/popup-element/) for more details.
        case dictionary

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PopupExpression.ReturnType, b: ArcGIS.PopupExpression.ReturnType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a popup expression.
    ///
    /// Use a pop-up expression object to define an Arcade expression within a pop-up.
    public convenience init()

    /// The Arcade expression defined in this expression.
    final public var expression: String

    /// The name of this expression.
    final public var name: String

    /// The return type of this expression.
    final public var returnType: ArcGIS.PopupExpression.ReturnType

    /// The title of this expression.
    final public var title: String
}

extension PopupExpression : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.PopupExpression, rhs: ArcGIS.PopupExpression) -> Bool
}

extension PopupExpression : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

extension PopupExpression.ReturnType : Equatable {
}

extension PopupExpression.ReturnType : Hashable {
}

/// The result of an attempt to evaluate a popup expression.
///
/// The popup expression can come from the ``PopupDefinition/expressions`` or from the ``ExpressionPopupElement/popupExpression``
/// - Since: 200.1
public struct PopupExpressionEvaluation {
}

extension PopupExpressionEvaluation {

    /// An error information about the evaluation of ``popupExpression``.
    public var error: Error? { get }

    /// One of the Arcade expressions defined on popup at ``PopupDefinition/expressions`` or at ``ExpressionPopupElement/popupExpression``.
    public var popupExpression: ArcGIS.PopupExpression { get }

    /// The result of an evaluation of ``popupExpression``. The type of result object
    /// is a String, a Number, or a Dictionary based on the ``PopupExpression/returnType-swift.property``.
    ///
    /// Dictionary return type is only supported for popup expressions coming from an ``ExpressionPopupElement``.
    /// In this case, the dictionary must follow the Web Map Specification for a popupElement.
    /// Refer to [Popup Element](https://developers.arcgis.com/arcade/profiles/popup-element/) for more details.
    public var result: Any? { get }
}

/// Represents how a geoelement's attribute (field) should be displayed in a pop-up.
/// - Since: 200.1
final public class PopupField {

    /// Type of input box editors see when editing the field in a pop-up.
    ///
    /// Controls the type of input box editors inside a pop-up.
    public enum StringFieldOption {

        /// A single-line input box.
        case singleLine

        /// A multi-line input box.
        case multiLine

        /// A rich text editor allowing for bold text, highlighting, and so forth.
        case richText

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PopupField.StringFieldOption, b: ArcGIS.PopupField.StringFieldOption) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Create a new popup field object.
    ///
    /// Use a popup field object to define how a field in the dataset participates (or does not participate) in a pop-up window.
    public convenience init()

    /// The field name.
    final public var fieldName: String

    /// The format used to display the field.
    ///
    /// The format is used with numerical or date fields to provide more detail about how the value should be displayed in a pop-up window.
    final public var format: ArcGIS.PopupFieldFormat?

    /// A flag indicating whether users can edit the field.
    final public var isEditable: Bool

    /// A flag indicating whether the field is visible in the pop-up.
    final public var isVisible: Bool

    /// The field label.
    ///
    /// The field label (alias) can be overridden by the web map author.
    final public var label: String

    /// The type of input box editors see when editing the field. Applies only to string fields.
    final public var stringFieldOption: ArcGIS.PopupField.StringFieldOption?

    /// A string providing an editing hints for editors of the field.
    ///
    /// This string can provide a short description of the field and how editors should format or supply its value.
    final public var tooltip: String
}

extension PopupField.StringFieldOption : Equatable {
}

extension PopupField.StringFieldOption : Hashable {
}

/// Represents the formatting of a field when used in the application.
/// Applies only to fields of type date or number (float, double, integer).
/// - Since: 200.1
final public class PopupFieldFormat {

    /// Format of a date field in a pop-up.
    ///
    /// Controls how a date field is displayed a pop-up.
    public enum DateFormat {

        /// Example: 30 Dec 1997.
        case dayShortMonthYear

        /// Example: Tuesday, December 30, 1997.
        case longDate

        /// Example: December 30, 1997.
        case longMonthDayYear

        /// Example: December 1997.
        case longMonthYear

        /// Example: 12/30/1997.
        case shortDate

        /// Example: 30/12/1997.
        case shortDateLE

        /// Example: 30/12/1997 5:59:59 PM.
        case shortDateLELongTime

        /// Example: 30/12/1997 17:59:59.
        case shortDateLELongTime24

        /// Example: 30/12/1997 6:00 PM.
        case shortDateLEShortTime

        /// Example: 30/12/1997 18:00.
        case shortDateLEShortTime24

        /// Example: 12/30/1997 5:59:59 PM.
        case shortDateLongTime

        /// Example: 12/30/1997 17:59:59.
        case shortDateLongTime24

        /// Example: 12/30/1997 6:00 PM.
        case shortDateShortTime

        /// Example: 12/30/1997 18:00.
        case shortDateShortTime24

        /// Example: Dec 1997.
        case shortMonthYear

        /// Example: 1997.
        case year

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PopupFieldFormat.DateFormat, b: ArcGIS.PopupFieldFormat.DateFormat) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Create a new popup field format.
    ///
    /// Use this object with numerical or date fields to provide more detail about how values should be displayed in web map pop-up windows.
    public convenience init()

    /// The format used to display a date field in a pop-up.
    final public var dateFormat: ArcGIS.PopupFieldFormat.DateFormat?

    /// The number of supported decimal places that should appear for displaying a numerical field in a pop-up. Any places beyond this value are rounded.
    final public var decimalPlaces: Int

    /// A flag indicating whether a numerical field may use the thousands (or digit) separator when the field is displayed in a pop-up.
    ///
    /// Depending on the locale, the thousands separator is a decimal point, a comma or a blank.
    final public var usesThousandsSeparator: Bool
}

extension PopupFieldFormat.DateFormat : Equatable {
}

extension PopupFieldFormat.DateFormat : Hashable {
}

/// Represents the media that is displayed in a pop-up for a geo-element.
/// - Note: See Also: ``Kind-swift.enum``
/// - Since: 200.1
final public class PopupMedia {

    /// Type of media in a pop-up.
    ///
    /// Controls the type of media inside a pop-up.
    public enum Kind {

        /// Image.
        case image

        /// Bar chart.
        case barChart

        /// Column chart.
        case columnChart

        /// Line chart.
        case lineChart

        /// Pie chart.
        case pieChart

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PopupMedia.Kind, b: ArcGIS.PopupMedia.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Create a new popup media.
    ///
    /// Use this object to define an image or a chart to be displayed in a pop-up window.
    public convenience init()

    /// The caption that is displayed for the media.
    ///
    /// This can contain a literal value, or a placeholder for value from the geoelement's attribute for which the pop-up is displayed.
    /// The placeholder needs to be of the form {field_name} where field_name is a key in the geoelement's attributes.
    final public var caption: String

    /// The image refresh interval. This property is useful only for a pop-up media of type ``Kind-swift.enum/image``.
    ///
    /// A refresh interval of `nil` means never refresh. The default value is `nil`.
    final public var imageRefreshInterval: TimeInterval?

    /// The type of media.
    final public var kind: ArcGIS.PopupMedia.Kind?

    /// The title that is displayed for the media.
    ///
    /// This can contain a literal value, or a placeholder for value from the geoelement's attribute for which the pop-up is displayed.
    /// The placeholder needs to be of the form {field_name} where field_name is a key in the geoelement's attributes.
    final public var title: String

    /// The optional popup media value that are depending on the type of media.
    final public var value: ArcGIS.PopupMediaValue?
}

extension PopupMedia.Kind : Equatable {
}

extension PopupMedia.Kind : Hashable {
}

/// Represents the popup media values that are depending on the type of media.
/// - Note: See Also: ``PopupMedia/Kind-swift.enum``
/// - Since: 200.1
final public class PopupMediaValue {

    /// Create a new popup media value object.
    ///
    /// This value object contains information about how the image should be retrieved or how the chart should be constructed.
    public convenience init()

    /// The attribute values for the pop-up media's fields defined in ``fieldNames``.
    /// This property is populated when `Popup.evaluateExpressions()` is called.
    ///
    /// For PopupMediaValue objects used with an image or if ``PopupElement/isEvaluated`` is `false`, this will be an empty collection.
    /// The data will be normalized if ``normalizeFieldName`` is not empty.
    final public var data: [Any] { get }

    /// The field names of the fields to display in the chart.
    /// - Note: See Also: `Array`, `String`
    final public var fieldNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `fieldNames` property.
    /// - Parameter newFieldNames: The new `String` values to append.
    final public func addFieldNames<S>(_ newFieldNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `fieldNames` property.
    /// - Parameter newFieldName: The new `String` value to append.
    final public func addFieldName(_ newFieldName: String)

    /// Inserts a collection of `String` values into the `fieldNames` property at the specified position.
    /// - Parameters:
    ///   - newFieldNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertFieldNames<C>(_ newFieldNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `fieldNames` property at the specified position.
    /// - Parameters:
    ///   - newFieldName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertFieldName(_ newFieldName: String, at index: Int)

    /// Removes all values from the `fieldNames` property.
    final public func removeAllFieldNames()

    /// Removes a sequence of `String` values from the `fieldNames` property.
    /// - Parameter fieldNames: The `String` values to remove.
    final public func removeFieldNames<S>(_ fieldNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `fieldNames` property.
    /// - Parameter fieldName: The `String` value to remove.
    final public func removeFieldName(_ fieldName: String)

    /// The user-friendly display names for the pop-up media's fields defined in ``fieldNames``.
    /// This property is populated when `Popup.evaluateExpressions()` is called.
    ///
    /// For PopupMediaValue objects used with an image or if ``PopupElement/isEvaluated`` is `false`, this will be an empty collection.
    /// - Note: See Also: `String`
    final public var labels: [String] { get }

    /// Gets the link URL for an image media.
    ///
    /// For PopupMediaValue objects used with a chart, this will be `nil`.
    final public var linkURL: URL?

    /// The optional field used to normalize the chart.
    final public var normalizeFieldName: String

    /// The source URL for an image media.
    ///
    /// For PopupMediaValue objects used with a chart, this will be `nil`.
    final public var sourceURL: URL?

    /// The tooltip field name.
    final public var tooltipFieldName: String
}

/// Contains information about displaying related features in a popup.
/// - Since: 200.1
final public class PopupRelatedFeaturesDefinition {

    /// Create a new popup related features definition.
    public convenience init()

    /// A flag indicating whether the popup should show features that are related to this popup's feature.
    final public var showsRelatedFeatures: Bool

    /// An array of objects which dictate the order in which the relationships and related features in each relationship should be displayed in a popup.
    final public var sortOrder: [ArcGIS.PopupRelatedFeaturesSortOrder] { get }

    /// Adds a sequence of `PopupRelatedFeaturesSortOrder` values to the end of the `sortOrder` property.
    /// - Parameter newSortOrder: The new `PopupRelatedFeaturesSortOrder` values to append.
    final public func addSortOrder<S>(_ newSortOrder: S) where S : Sequence, S.Element == ArcGIS.PopupRelatedFeaturesSortOrder

    /// Adds a `PopupRelatedFeaturesSortOrder` value to the end of the `sortOrder` property.
    /// - Parameter newSortOrder: The new `PopupRelatedFeaturesSortOrder` value to append.
    final public func addSortOrder(_ newSortOrder: ArcGIS.PopupRelatedFeaturesSortOrder)

    /// Inserts a collection of `PopupRelatedFeaturesSortOrder` values into the `sortOrder` property at the specified position.
    /// - Parameters:
    ///   - newSortOrder: The new `PopupRelatedFeaturesSortOrder` values to insert.
    ///   - index: The position at which to insert the new `PopupRelatedFeaturesSortOrder` values.
    final public func insertSortOrder<C>(_ newSortOrder: C, at index: Int) where C : Collection, C.Element == ArcGIS.PopupRelatedFeaturesSortOrder

    /// Inserts a `PopupRelatedFeaturesSortOrder` value into the `sortOrder` property at the specified position.
    /// - Parameters:
    ///   - newSortOrder: The new `PopupRelatedFeaturesSortOrder` value to insert.
    ///   - index: The position at which to insert the new `PopupRelatedFeaturesSortOrder` value.
    final public func insertSortOrder(_ newSortOrder: ArcGIS.PopupRelatedFeaturesSortOrder, at index: Int)

    /// Removes all values from the `sortOrder` property.
    final public func removeAllSortOrder()

    /// Removes a sequence of `PopupRelatedFeaturesSortOrder` values from the `sortOrder` property.
    /// - Parameter sortOrder: The `PopupRelatedFeaturesSortOrder` values to remove.
    final public func removeSortOrder<S>(_ sortOrder: S) where S : Sequence, S.Element == ArcGIS.PopupRelatedFeaturesSortOrder

    /// Removes a `PopupRelatedFeaturesSortOrder` value from the `sortOrder` property.
    /// - Parameter sortOrder: The `PopupRelatedFeaturesSortOrder` value to remove.
    final public func removeSortOrder(_ sortOrder: ArcGIS.PopupRelatedFeaturesSortOrder)
}

/// Defines the order in which related features of a particular relationship are sorted for displaying in a popup.
/// - Since: 200.1
final public class PopupRelatedFeaturesSortOrder {

    /// Create a new popup related features sort order.
    public convenience init()

    /// The field in the related table by which the related features should be sorted for displaying in a popup.
    final public var orderByField: ArcGIS.OrderBy?

    /// The id of the relationship for which related features should be sorted for displaying in a popup.
    final public var relationshipID: Int
}

/// An interface to type any classes such as ``ArcGISSublayer`` and ``FeatureLayer`` that support popup and have PopupDefinition.
///
/// This interface is implemented by ``FeatureLayer``, ``RasterLayer``, ``ArcGISSublayer`` and ``GraphicsOverlay``.
/// - Since: 200.1
public protocol PopupSource {

    /// The pop-up definition.
    ///
    /// The ``PopupDefinition`` associated with the popup source.
    var popupDefinition: ArcGIS.PopupDefinition? { get set }

    /// A flag indicating whether the ``PopupDefinition`` defined on the ``PopupSource`` is enable / disable.
    var popupsAreEnabled: Bool { get set }
}

/// An object that represents a portal.
///
/// A portal is an object that represents a view for a user (anonymous or not) into a
/// portal. For example, https://www.arcgis.com is an example of a portal. A portal may support subscriptions
/// which provides organizations a sandboxed area on the portal.
///
/// `Portal` is the main class and the entry point into the API to work with portals and organization subscriptions.
/// It implements all the operations to interface with the backend
/// [ArcGIS Portal REST API](https://developers.arcgis.com/rest/).
/// - Note: See Also: ``PortalItem/portal``
/// - Since: 200.1
final public class Portal {

    /// The connection type used while loading the portal.
    public enum Connection {

        /// The portal will be loaded anonymously.
        case anonymous

        /// The portal will be loaded using a credential.
        case authenticated

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Portal.Connection, b: ArcGIS.Portal.Connection) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a portal object.
    ///
    /// The supported URL formats are:
    /// - The URL of the portal (Example: https://www.arcgis.com)
    /// - The URL of the portal rest end point (Example: https://www.arcgis.com/sharing/rest)
    /// - The URL of the deprecated portal rest end point (Example: https://www.arcgis.com/sharing)
    ///
    /// If the portal permits anonymous access and you want to connect anonymously, set `connection`
    /// to `anonymous`. If you want to connect to the portal using an identity, you should set
    /// `connection` to `authenticated` and an authentication challenge will be issued to first
    /// request a credential.
    /// - Parameters:
    ///   - url: The URL to the portal.
    ///   - connection: The connection type used while loading the portal.
    public convenience init(url: URL, connection: ArcGIS.Portal.Connection = .anonymous)

    /// An array of ``Basemap`` objects within the basemap gallery group.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/basemapGalleryGroupQuery``
    final public var basemaps: [ArcGIS.Basemap] { get async throws }

    /// An array of ``Basemap`` objects within the developer basemap gallery group.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/developerBasemapGalleryGroupQuery``
    final public var developerBasemaps: [ArcGIS.Basemap] { get async throws }

    /// The featured groups of the portal.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/featuredGroupsQueries``
    final public var featuredGroups: [ArcGIS.PortalGroup] { get async throws }

    /// The featured items of the portal.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/featuredItemsGroupQuery``
    final public var featuredItems: [ArcGIS.PortalItem] { get async throws }

    /// The home page featured content of the portal.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/homePageFeaturedContentGroupQuery``
    final public var homePageFeaturedContent: [ArcGIS.PortalItem] { get async throws }

    /// The current user's license information, including the entitlements and extensions.
    final public var licenseInfo: ArcGIS.LicenseInfo { get async throws }

    /// An array of ``PortalItem`` objects within the styles group.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/stylesGroupQuery``
    final public var styles: [ArcGIS.PortalItem] { get async throws }

    /// An array of ``PortalItem`` objects within the symbol sets group.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/symbolSetsGroupQuery``
    final public var symbolSets: [ArcGIS.PortalItem] { get async throws }

    /// An array of ``Basemap`` objects within the vector basemap gallery group.
    /// - Remark: Accessing this property sends out network requests.
    /// - Note: See Also: ``PortalInfo/vectorBasemapGalleryGroupQuery``
    final public var vectorBasemaps: [ArcGIS.Basemap] { get async throws }

    /// A code that specifies the culture-specific formatting to use when accessing ``Portal`` content.
    ///
    /// The culture code provides localized content when viewing featured groups or items, adding or updating
    /// an item, adding a comment or rating to an item, and so on. If not explicitly set, the culture used by
    /// the device/machine is used. If the culture is not supported by the portal or set to `nil`, the culture specified in the
    /// portal/organization settings is used.
    /// - Remark: The format for culture code is based on a language code and a country code
    /// separated by a dash. Example: "en-US".
    final public var locale: Locale?

    /// The connection type used while loading the portal. The default is `anonymous`.
    /// - Note: See Also: ``Portal/init(url:connection:)``, ``Portal/arcGISOnline(connection:)``
    final public var connection: ArcGIS.Portal.Connection { get }

    /// Information about this portal.
    /// - Remark: This property will be `nil` until the portal is loaded.
    final public var info: ArcGIS.PortalInfo? { get }

    /// The registered user of this portal.
    /// - Remark: Will be `nil` if this portal is either not loaded or accessed anonymously.
    final public var user: ArcGIS.PortalUser? { get }

    /// The URL of this portal.
    final public var url: URL { get }

    /// Creates a portal instance pointing to https://www.arcgis.com.
    ///
    /// The portal should be loaded using ``Portal/load()`` before using it.
    /// ArcGIS Online permits anonymous access. If you want to connect to the portal anonymously,
    /// you should set `connection` to `anonymous`. If you want to connect to the portal using an
    /// identity, you should set `connection` to `authenticated` and an authentication challenge
    /// will be issued to first request a credential.
    /// - Parameter connection: The connection type used while loading the portal.
    final public class func arcGISOnline(connection: ArcGIS.Portal.Connection) -> Self

    /// Finds portal groups that match the given query parameters.
    /// - Parameter queryParameters: The query parameters to find portal groups.
    /// - Returns: A `PortalQueryResultSet` containing the portal groups that were found.
    /// - Remark: The returned `PortalGroup` objects have already been loaded.
    final public func findGroups(queryParameters: ArcGIS.PortalQueryParameters) async throws -> ArcGIS.PortalQueryResultSet<ArcGIS.PortalGroup>

    /// Finds portal items that match the given query parameters.
    ///
    /// If you are considering using this method to find items that belong to a group, see
    /// ``PortalGroup/findItems(searchParameters:)`` for a description of how that method, which uses a group content search
    /// operation that's designed specifically for finding items that belong to a group, differs from this method,
    /// which uses a general-purpose search operation.
    /// - Parameter queryParameters: The query parameters to find the portal items.
    /// - Returns: A `PortalQueryResultSet` containing the portal items that were found.
    final public func findItems(queryParameters: ArcGIS.PortalQueryParameters) async throws -> ArcGIS.PortalQueryResultSet<ArcGIS.PortalItem>

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad() async
}

extension Portal : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Portal, rhs: ArcGIS.Portal) -> Bool
}

extension Portal {

    /// An error thrown by objects not having a valid portal instance.
    public enum Error : Error {

        /// There is no associated portal object.
        case noAssociatedPortal

        /// The portal is not authenticated.
        case notAuthenticated

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Portal.Error, b: ArcGIS.Portal.Error) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension Portal : ArcGIS.Loadable {
}

extension Portal.Connection : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

extension Portal.Connection : Equatable {
}

extension Portal.Connection : Hashable {
}

extension Portal.Error : Equatable {
}

extension Portal.Error : Hashable {
}

/// Indicates the level of access to this portal object: private, shared, organization, or public.
/// - Since: 200.1
public enum PortalAccess {

    /// Organization level of access.
    case organization

    /// Private access.
    case `private`

    /// Public access.
    case `public`

    /// Shared access.
    case shared

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalAccess, b: ArcGIS.PortalAccess) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension PortalAccess : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension PortalAccess : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init?(_ description: String)
}

extension PortalAccess : Equatable {
}

extension PortalAccess : Hashable {
}

/// Represents a folder of content within the portal or organization.
/// A user's content in a portal can be organized into folders.
/// - Since: 200.1
public struct PortalFolder : Hashable, Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public struct ID : Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The ID of the folder.
    public let id: ArcGIS.PortalFolder.ID

    /// The title of the folder.
    public let title: String

    /// The date of creation of the folder.
    public let creationDate: Date

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalFolder, b: ArcGIS.PortalFolder) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension PortalFolder : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension PortalFolder.ID : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

/// Represents a group within a portal.
/// - Remark: Collections of fully populated ``PortalGroup`` objects can be
/// obtained by calling the ``Portal/findGroups(queryParameters:)``method, or
/// the ``Portal/featuredGroups``, ``PortalItem/groups-swift.property``, and
/// ``PortalUser/groups`` properties. The load status of such objects is
/// ``LoadStatus/loaded``.
///
/// Alternatively, a portal group object can be constructed using
/// ``PortalGroup/init(portal:id:)`` if the group ID is known. In this case the
/// load status is initially ``LoadStatus/notLoaded`` and the object needs to be
/// loaded to populate its properties.
///
/// The portal group owner is automatically an administrator and is returned in the list of admins.
/// The access property determines the visibility of the group to other users. If the group is
/// private, no one except the administrators and the members of the group can see it. If the group is
/// shared with an organization, then all members of the organization can see the group.
///
/// Administrators can invite, add to, and remove members from a group, and also update and delete
/// the group. The administrator for an organization may also reassign the group to another
/// member of the organization. Group members may leave the group. Authenticated users may
/// apply to join a group.
/// - Since: 200.1
final public class PortalGroup : Identifiable {

    /// Indicates the desired sorting criterion for group items.
    public enum SortField : String {

        /// Average rating.
        case averageRating

        /// Created date.
        case created

        /// Modified date.
        case modified

        /// Owner.
        case owner

        /// Title.
        case title

        /// Number of views.
        case viewCount

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public struct ID : Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The various users that belong to this group.
    public struct Users : Hashable {

        /// The usernames of the admins.
        public let admins: [String]

        /// The usernames of the members.
        public let members: [String]

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PortalGroup.Users, b: ArcGIS.PortalGroup.Users) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The identifier of the group.
    final public let id: ArcGIS.PortalGroup.ID

    /// The access level of the group's content.
    /// Remark: If `nil`, the access is unknown.
    final public var access: ArcGIS.PortalAccess? { get }

    /// The date on which the group was created.
    final public var creationDate: Date? { get }

    /// The description of the group.
    final public var description: String { get }

    /// A Boolean value indicating whether the group will not accept join
    /// requests. If `true`, only group owners and admins can invite users to
    /// the group. Otherwise, this group does not require an invitation to join.
    final public var isInvitationOnly: Bool { get }

    /// A Boolean value indicating whether the group is view only or not. Users
    /// cannot share items with view only groups.
    final public var isViewOnly: Bool { get }

    /// The date on which the group was modified.
    final public var modificationDate: Date? { get }

    /// The user who created the group.
    final public var owner: String { get }

    /// The contact information for the group.
    final public var phone: String { get }

    /// The portal to which the group belongs.
    weak final public var portal: ArcGIS.Portal? { get }

    /// Snippet or summary of the group with a character limit of 250 characters.
    final public var snippet: String { get }

    /// The users that belong to this group.
    /// - Remark: Accessing this property sends out a network request.
    final public var users: ArcGIS.PortalGroup.Users { get async throws }

    /// The sort field for the group's content.
    final public var sortField: ArcGIS.PortalGroup.SortField? { get }

    /// The sort order for the group's content.
    final public var sortOrder: ArcGIS.PortalQuerySortOrder { get }

    /// An array of words or short phrases that describe the group.
    final public var tags: [String] { get }

    /// The thumbnail image of the group. If it is `nil`, there is no group
    /// thumbnail. Otherwise, the image needs to be loaded asynchronously by
    /// using ``LoadableImage/load()``.
    final public var thumbnail: ArcGIS.LoadableImage? { get }

    /// The group title.
    final public var title: String { get }

    /// Creates a portal group object for a specified portal and a specified group ID.
    /// - Parameters:
    ///   - portal: The portal the group belongs to.
    ///   - id: The ID of the existing group in the portal.
    public convenience init(portal: ArcGIS.Portal, id: ArcGIS.PortalGroup.ID)

    /// Finds portal items that belong to this group and match the given search parameters.
    ///
    /// This method uses a group content search operation that's designed specifically for
    /// finding items that belong to a group. It differs from the ``Portal/findItems(queryParameters:)``
    /// method which uses a general-purpose search operation that's suitable for searching all
    /// items stored on a portal.
    ///
    /// The behavior of this method differs from the ``Portal/findItems(queryParameters:)`` method in the
    /// following ways:
    /// - If the ``PortalGroupContentSearchParameters/categories`` property is used, the
    ///   categories specified there will be matched with group categories that have been
    ///   specified by the group owner/administrator, as opposed to the organization-level
    ///   categories that the general-purpose search operation matches against.
    /// - An extra ``PortalGroupContentSearchParameters/sortField`` option is available ("added")
    ///   to sort the results on the time the items were added to the group.
    /// - Parameter searchParameters: The search parameters used to find the portal items.
    /// - Returns: A portal group content search result set containing the portal items that were found.
    final public func findItems(searchParameters: ArcGIS.PortalGroupContentSearchParameters) async throws -> ArcGIS.PortalGroupContentSearchResultSet

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad() async
}

extension PortalGroup : ArcGIS.Loadable {
}

extension PortalGroup.SortField : Equatable {
}

extension PortalGroup.SortField : Hashable {
}

extension PortalGroup.SortField : RawRepresentable {
}

extension PortalGroup.ID : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

/// Contains search parameters suitable for finding portal items that belong to a portal group.
///
/// A typical usage pattern is:
/// - Create a new ``PortalGroupContentSearchParameters`` instance
/// - Optionally set one or more of the properties
/// - Use the instance by passing it to ``PortalGroup/findItems(searchParameters:)``
/// - Optionally call ``PortalGroupContentSearchResultSet/nextSearchParameters`` to get a new
/// ``PortalGroupContentSearchParameters`` instance that can be used to find the next batch of results
/// - Remark: You can create an instance using one of the factory methods that are designed for
/// particular types of searches, or you can use one of the initializers and specify a custom
/// query string. A number of properties are also available to customize various aspects of the search.
/// - Note: See Also: ``PortalGroup/findItems(searchParameters:)``
/// - Since: 200.1
public struct PortalGroupContentSearchParameters {

    /// An envelope specifying the bounding box for a spatial search.
    ///
    /// Documents that have no extent (e.g., mxds, 3dds, lyr) will not be found when doing a bounding box search.
    /// Document extent is assumed to be in the WGS84 geographic coordinate system.
    /// - Remark: Spatial search is an overlaps/intersects function of the bounding box and the extent of the document.
    public var boundingBox: ArcGIS.Envelope?

    /// An array of content category specifications to use when searching for items.
    ///
    /// The full path of each category is required and an OR relationship is applied between the categories
    /// within a particular string.
    ///
    /// There can be up to 8 strings with an AND relationship being applied between the different strings.
    ///
    /// For example, to search for items belonging to either the water or forest categories, both within the US,
    /// specify 2 strings as follows: "/Categories/Water,/Categories/Forest" and "/Region/US".
    /// - Remark: Each entry in the array is a string containing a comma-separated list of up to 8 group content categories.
    public var categories: [String]

    /// The maximum number of results to be included in the result set response.
    ///
    /// Note that the actual number of returned results may be less than limit. This happens when the number of
    /// results remaining after the ``startIndex`` is less than limit.
    /// - Remark: Default is `10` and the maximum is `100`.
    public var limit: Int

    /// The query string to use.
    public var query: String { get }

    /// Indicates whether public items outside the organization may be included in the search results.
    /// - Remark: Default is `true`.
    public var searchPublic: Bool

    /// The field on which sorting should be done.
    /// - Remark: Sort field names are case-insensitive. Supported field names are "title", "created", "type", "owner", "modified",
    /// "avgrating", "numratings", "numcomments", and "numviews".
    public var sortField: String

    /// The order of sorting.
    /// - Remark: Default is ``PortalQuerySortOrder/ascending``.
    public var sortOrder: ArcGIS.PortalQuerySortOrder

    /// The index from which the results should be returned. The index number is 1-based. You should use
    /// this for paginating the search results.
    /// - Remark: Default is `1`.
    public var startIndex: Int

    /// Returns a group content search parameters instance that will find an item with a specified ID.
    /// - Parameter itemID: The ID of the item.
    public static func item(withID itemID: String) -> ArcGIS.PortalGroupContentSearchParameters

    /// Returns a group content search parameters instance that will find items that satisfy the specified criteria.
    /// - Parameters:
    ///   - kinds: The item kinds to search for.
    ///   - owner: The username of the owner of the items.
    ///   - searchText: The string specifying other criteria for the search.
    public static func items(ofKinds kinds: Set<ArcGIS.PortalItem.Kind> = [], withOwner owner: String = "", searchText: String = "") -> ArcGIS.PortalGroupContentSearchParameters

    /// Returns a group content search parameters instance with a custom query.
    ///
    /// See [ArcGIS REST APIs](https://developers.arcgis.com/rest/users-groups-and-items/search-reference.htm)
    /// for information on query syntax.
    /// - Parameter query: The custom query.
    public static func query(_ query: String) -> ArcGIS.PortalGroupContentSearchParameters
}

extension PortalGroupContentSearchParameters : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalGroupContentSearchParameters, b: ArcGIS.PortalGroupContentSearchParameters) -> Bool
}

/// Results of a Group Content Search operation performed on a PortalGroup.
/// - Note: See Also: `PortalGroup.findItems(searchParams:)`
/// - Since: 200.1
public struct PortalGroupContentSearchResultSet {

    /// Search parameters that can be used to fetch the next set of results.
    ///
    /// This is automatically generated if there are more results to be retrieved, or it will be `nil` if no more
    /// items are available. Pass it to a further call to `PortalGroup.findItems(searchParams:)` to fetch the next set of
    /// results.
    public let nextSearchParameters: ArcGIS.PortalGroupContentSearchParameters?

    /// The present results of the search.
    ///
    /// These are limited by the value of ``PortalGroupContentSearchParameters/limit`` in the parameters used to
    /// generate these results.
    public let results: [ArcGIS.PortalItem]

    /// The search parameters used to generate these results.
    public let searchParameters: ArcGIS.PortalGroupContentSearchParameters

    /// The total number of results irrespective of the paging.
    public let totalResults: Int
}

/// Services provided by an organization's portal.
/// - Since: 200.1
public struct PortalHelperServices : Hashable {

    /// Geoprocessing service that performs analyses.
    public let analysisServiceURL: URL?

    /// Geoprocessing service for asynchronous closest-facility analysis.
    public let asyncClosestFacilityServiceURL: URL?

    /// Geoprocessing service for asynchronous location-allocation network analysis.
    public let asyncLocationAllocationServiceURL: URL?

    /// Geoprocessing service for generating origin-destination cost matrices asynchronously.
    public let asyncODCostMatrixServiceURL: URL?

    /// Geoprocessing service for asynchronous service-area analysis.
    public let asyncServiceAreaServiceURL: URL?

    /// Geoprocessing service for solving asynchronous vehicle routing problems.
    public let asyncVRPServiceURL: URL?

    /// Network Analyst service for synchronous closest-facility analysis.
    public let closestFacilityServiceURL: URL?

    /// Information about Limited Error Raster Compression (LERC) elevation services used by ArcGIS Pro and the Web Scene Viewer.
    public let defaultElevationServices: [ArcGIS.ElevationServiceInfo]

    /// Geoprocessing service for elevation analysis.
    public let elevationServiceURL: URL?

    /// Geoprocessing service for elevation analysis.
    public let elevationSyncServiceURL: URL?

    /// Geocoding services to use for geocoding.
    public let geocodeServiceURLs: [URL]

    /// Geoenrichment services for getting facts about a location or area.
    public let geoenrichmentServiceURL: URL?

    /// Geometry service to use for geometry functions.
    public let geometryServiceURL: URL?

    /// Geoprocessing service for hydrologic analysis.
    public let hydrologyServiceURL: URL?

    /// The URL of the location tracking service.
    public let locationTrackingServiceURL: URL?

    /// Print Task service to use for printing functionality.
    public let printTaskURL: URL?

    /// Geoprocessing service for asynchronous route analysis.
    public let routeServiceURL: URL?

    /// Network Analyst service for service-area analysis.
    public let serviceAreaServiceURL: URL?

    /// Geoprocessing service for solving synchronous vehicle routing problems.
    public let syncVRPServiceURL: URL?

    /// Map service for displaying traffic speeds and traffic incidents.
    public let trafficServiceURL: URL?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalHelperServices, b: ArcGIS.PortalHelperServices) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Contains information about the related ``Portal``.
/// - Since: 200.1
final public class PortalInfo {

    /// Indicating whether the portal contains multiple organizations or not.
    public enum Mode : String {

        /// Multiple organizations.
        case multiTenant

        /// Only one organization.
        case singleTenant

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }

    /// Determines who can view the organization's content.
    final public let access: ArcGIS.PortalAccess

    /// Indicates if the organization is using HTTPS.
    ///
    /// If `true`, all calls made against resources that belong to the organization will require HTTPS.
    /// - Remark: The default is `false`.
    final public let requiresSSL: Bool

    /// The pre-defined query string for finding the collection of basemaps.
    final public let basemapGalleryGroupQuery: String

    /// The Bing App ID associated with the portal.
    final public let bingKey: ArcGIS.BingKey?

    /// Indicates whether the members of the organization can search content outside of the organization.
    final public let canSearchPublic: Bool

    /// Indicates whether the members of the organization can share Bing content outside of the organization.
    final public let canShareBingPublic: Bool

    /// Indicates whether the members of the organization can share content outside of the organization.
    final public let canSharePublic: Bool

    /// Indicates whether or not comments are enabled for the portal.
    final public let areCommentsEnabled: Bool

    /// The date the organization was created.
    final public let creationDate: Date?

    /// The organization's default locale (language and country) information.
    final public let locale: Locale?

    /// The portion of the URL's host component that identifies the portal.
    final public let customBaseDomain: String

    /// The default basemap of the portal/organization.
    final public let defaultBasemap: ArcGIS.Basemap?

    /// The default extent for the basemaps.
    final public let defaultExtent: ArcGIS.Envelope?

    /// The default vector basemap of the portal/organization.
    final public let defaultVectorBasemap: ArcGIS.Basemap?

    /// A query that identifies the group containing developer basemaps.
    ///
    /// Developer basemaps are accessible and metered via API keys.
    /// - Note: See Also: ``Portal/developerBasemaps``
    final public let developerBasemapGalleryGroupQuery: String

    /// An array of pre-defined query strings for finding featured groups.
    final public let featuredGroupsQueries: [String]

    /// A pre-defined query string for finding featured items group.
    final public let featuredItemsGroupQuery: String

    /// Various services provided by the organization.
    final public let helperServices: ArcGIS.PortalHelperServices?

    /// The number of featured items that can be displayed on the home page. The max is `100`.
    final public let homePageFeaturedContentCount: Int

    /// The pre-defined query string for finding homepage featured items group.
    final public let homePageFeaturedContentGroupQuery: String

    /// The country code of the calling IP.
    final public let ipCountryCode: String

    /// Indicates if the portal is on-premises.
    final public let isPortal: Bool

    /// Indicates if the portal is currently in read-only mode.
    /// - Note: See Also: `readOnlyMessage`
    final public let isReadOnly: Bool

    /// The query that identifies the group containing the Living Atlas layers.
    /// - Remark: This expression should be used as the query string parameter
    /// to find the group.
    /// - Note: See Also: ``Portal/findGroups(queryParameters:)``,
    /// ``PortalQueryParameters``
    final public let livingAtlasGroupQuery: String

    /// The date the organization was last modified.
    final public let modificationDate: Date?

    /// The banner image of the organization.
    ///
    /// If it is `nil`, there is no banner. Otherwise, the image needs to be
    /// loaded asynchronously by using ``LoadableImage/load()``.
    final public var organizationBanner: ArcGIS.LoadableImage? { get }

    /// The description of the organization.
    final public let organizationDescription: String

    /// The ID of the organization.
    final public let organizationID: String

    /// The name of the organization.
    final public let organizationName: String

    /// The portion of the URL's host component that identifies a specific organization subscription within a portal.
    final public let organizationSubdomain: String

    /// The portal that is being referred to.
    weak final public var portal: ArcGIS.Portal? { get }

    /// Indicates whether the portal is single or multi tenant.
    final public let portalMode: ArcGIS.PortalInfo.Mode

    /// The name of the portal.
    final public let portalName: String

    /// The thumbnail image of the portal.
    ///
    /// If it is `nil`, there is no thumbnail. Otherwise, the image needs to be
    /// loaded asynchronously by calling ``LoadableImage/load()``.
    final public var portalThumbnail: ArcGIS.LoadableImage? { get }

    /// If the portal is currently in read-only mode, this is an explanatory message that can be displayed to the user.
    /// - Remark: This will be empty if ``isReadOnly`` is `false`.
    final public let readOnlyMessage: String

    /// Indicates if the description of your organization displays on the home page.
    final public let showsHomePageDescription: Bool

    /// A query that identifies a group of styles. Each style contains
    /// references to symbols that can be used in the ArcGIS platform.
    /// - Remark: This expression can be used as the query string parameter to
    /// find the styles group. Instead of providing your own query, you can use
    /// the property ``Portal/styles`` to fetch the items in the styles group.
    /// - Note: See Also: ``Portal/findGroups(queryParameters:)``,
    /// ``PortalQueryParameters``
    final public let stylesGroupQuery: String

    /// Information about the portal user's subscription.
    /// - Remark: If `nil`, the portal is accessed anonymously.
    final public let subscriptionInfo: ArcGIS.SubscriptionInfo?

    /// Indicates whether or not this portal supports OAuth authentication.
    final public let supportsOAuth: Bool

    /// A query that identifies the symbol sets group.
    /// - Remark: This expression can be used as the query string parameter to
    /// find the symbol sets group. Instead of providing your own query, you can
    /// use the helper method ``Portal/symbolSets`` to fetch the items in the
    /// symbol sets group.
    /// - Note: See Also: ``Portal/findGroups(queryParameters:)``,
    /// ``PortalQueryParameters``
    final public let symbolSetsGroupQuery: String

    /// The organization's thumbnail image.
    ///
    /// If it is `nil`, there is no thumbnail. Otherwise, the image needs to be
    /// loaded asynchronously by using ``LoadableImage/load()``.
    final public var thumbnail: ArcGIS.LoadableImage? { get }

    /// Indicates whether the organization uses the Esri vector basemaps.
    final public let usesVectorBasemaps: Bool

    /// The query that can be used to find the group containing web maps for display in a gallery of vector basemaps.
    /// - Remark: This query is intended for use when ``usesVectorBasemaps`` is `true`.
    final public let vectorBasemapGalleryGroupQuery: String

    /// The portal's current version number.
    final public let version: ArcGIS.Version

    /// The portal's hostname.
    final public let hostname: String

    /// A Boolean value indicating whether the organization allows ArcGIS Online to collect usage information from
    /// its members to improve the user experience.
    final public let isEUEIEnabled: Bool
}

extension PortalInfo.Mode : Equatable {
}

extension PortalInfo.Mode : Hashable {
}

extension PortalInfo.Mode : RawRepresentable {
}

/// An object that represents a portal item.
/// - Note: See Also: ``Layer/item``, ``GeoModel/item``, ``Basemap/item``
/// - Since: 200.1
final public class PortalItem : ArcGIS.Item, ArcGIS.Loadable {

    /// An enumeration of various types of portal items.
    public enum Kind : CaseIterable {

        /// Pro Add In (esriaddinx).
        case arcGISProAddIn

        /// ArcPad Package (zip).
        case arcPadPackage

        /// A Computer-Aided Design drawing comprised of a single file.
        case cadDrawing

        /// A text file of data values separated by commas or other delimiters.
        /// Can be published as a feature service using the Portal API Publish call.
        case csv

        /// A city engine web scene.
        case cityEngineWebScene

        /// The sample code associated with an application whose purpose is code sample.
        case codeAttachment

        /// A code sample.
        case codeSample

        /// A color set.
        case colorSet

        /// ArcGIS Add-In (esriaddin).
        case desktopAddIn

        /// Desktop Application (zip).
        case desktopApplication

        /// The Desktop Application Template (zip) includes either a desktop add in or a toolbar.exe.
        case desktopApplicationTemplate

        /// ArcGIS Pro Style file (stylx).
        case desktopStyle

        /// Link to a web resource.
        case documentLink

        /// ArcGIS Explorer Layer (eaz).
        case explorerAddIn

        /// ArcGIS Explorer Layer (nmc).
        case explorerLayer

        /// ArcGIS Explorer Document (nmf).
        case explorerMap

        /// A feature collection is a saved web map feature layer with layer definition (types, symbols, fields, and so on) and a feature set (the actual features).
        case featureCollection

        /// A feature collection that includes the layer definition component.
        case featureCollectionTemplate

        /// A feature service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        /// Optional JSON data contains overridden service properties.
        case featureService

        /// File Geodatabase.
        case fileGeodatabase

        /// Form authored using Survey123.
        case form

        /// ArcGIS Server Geocoding Service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case geocodingService

        /// ArcGIS Server Geodata Service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case geodataService

        /// ArcGIS Server Geometry Service
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case geometryService

        /// ArcGIS Geoprocessing Package (gpk).
        case geoprocessingPackage

        /// ArcGIS Pro Geoprocessing Package (gpkx).
        case geoprocessingPackageProVersion

        /// Geoprocessing Sample.
        case geoprocessingSample

        /// ArcGIS Server Geoprocessing Service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case geoprocessingService

        /// ArcGlobe Document (3dd).
        case globeDocument

        /// ArcGIS Server Globe Service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case globeService

        /// Image Types (.jpg, .jpeg, .tif, .tiff, .png).
        case image

        /// A portable file that contains one or more images that can be published as an image service for imagery visualization and analysis.
        case imageCollection

        /// An image service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        /// Optional JSON data contains overridden service properties.
        case imageService

        /// Insights model records analysis steps on an insights pages, including adding and joining datasets, spatial analysis, data analytics and styling.
        case insightsModel

        /// Insights Page resides in Insights Workbook, used to connect the data and analyze related content and themes with interactive visualization.
        case insightsPage

        /// Insights Workbook collects or associates all data and analytical activity for a project,
        /// capturing and maintaining relationships such as data locations and storing result layers, models, pages and cards.
        case insightsWorkbook

        /// iWork Keynote file (.key).
        case iWorkKeynote

        /// iWork Numbers file (.numbers).
        case iWorkNumbers

        /// iWork Pages file (.pages).
        case iWorkPages

        /// KML Network Link or KML file.
        /// If a file, then the data resource retrieves the file and can be used as a network link.
        /// If a network link, then the serviceURL property of the item (see ``PortalItem/serviceURL``) contains the URL for the network link.
        case kml

        /// A zip file containing a collection of KML/KMZ files.
        case kmlCollection

        /// Layer File (lyr) or ArcGIS Pro layer file (lyrx).
        case layer

        /// Layer Package (lpk).
        case layerPackage

        /// ArcGIS Pro Layout File (pagx).
        case layout

        /// ArcGIS Locator Package (gcpk).
        case locatorPackage

        /// ArcMap Document (mxd).
        case mapDocument

        /// ArcGIS Map Package (mpk).
        case mapPackage

        /// A map service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        /// Optional JSON data contains overridden service properties.
        case mapService

        /// The Map Template (.zip) contains documentation, a map, and GDB folder.
        case mapTemplate

        /// Microsoft Excel Document (.xls, .xlsx).
        case microsoftExcel

        /// Microsoft Powerpoint (.ppt, .pptx).
        case microsoftPowerpoint

        /// Microsoft Word Document (.doc, .docx).
        case microsoftWord

        /// A mobile application.
        /// The URL to the application in the app store is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case mobileApplication

        /// ArcGIS Mobile Basemap Package (.bpk).
        case mobileBasemapPackage

        /// ArcGIS Mobile Map Package (mmpk).
        case mobileMapPackage

        /// Native Application for ArcGIS AppStudio.
        case nativeApplication

        /// Native Application Installer for ArcGIS AppStudio.
        case nativeApplicationInstaller

        /// Native Application Template for ArcGIS AppStudio.
        case nativeApplicationTemplate

        /// Self-describing, portable and scalable file format for storing multidimensional scientific data usable by GeoAnalytics tools.
        case netCDF

        /// ArcGIS Server Network Analyst Service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case networkAnalysisService

        /// An operation view.
        ///
        /// This item type was retired in ArcGIS Online deployments and ArcGIS Enterprise deployments starting at version 10.7.
        case operationView

        /// ArcGIS Operations Dashboard Add In (opdashboardaddin).
        ///
        /// This item type was retired in ArcGIS Online deployments and ArcGIS Enterprise deployments starting at version 10.7.
        case operationsDashboardAddIn

        /// ArcGIS Operations Dashboard Extension.
        ///
        /// This item type was retired in ArcGIS Online deployments and ArcGIS Enterprise deployments starting at version 10.7.
        case operationsDashboardExtension

        /// Portable Document Format (.pdf).
        case pdf

        /// ArcGIS Project Package (ppkx).
        case projectPackage

        /// ArcGIS Project Template (aptx).
        case projectTemplate

        /// ArcGIS Pro map file (mapx).
        case proMap

        /// ArcReader Document (pmf).
        case publishedMap

        /// ArcGIS Pro raster function template.
        case rasterFunctionTemplate

        /// ArcGIS server relational catalog service. Item represents a connection to a database for the purpose of viewing, querying and analyzing its contents.
        case relationalDatabaseConnection

        /// Report template used by the geoenrichment service and Business Analyst applications to generate custom reports.
        case reportTemplate

        /// ArcGIS Rule Package (lpk).
        case rulePackage

        /// ArcScene Document (sxd).
        case sceneDocument

        /// Scene Layer Package (spk or slpk).
        case scenePackage

        /// Cached web layers that are optimized for displaying a large amount of 2D or 3D features.
        case sceneService

        /// A Service Definition that can be published to create a geo spatial web service using the Portal API Publish call.
        case serviceDefinition

        /// A shape file.
        case shapeFile

        /// Data collection used by the geoenrichment service and Business Analyst applications to perform data aggregation with statistical feature data.
        case statisticalDataCollection

        /// A symbol set.
        case symbolSet

        /// ArcGIS Task File (esriTasks).
        case taskFile

        /// Tile Package (tpk).
        case tilePackage

        /// Vector Tile Package (.vtpk).
        case vectorTilePackage

        /// A Vector Tile Service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case vectorTileService

        /// Visio Document (.vsd).
        case visioDocument

        /// A 360-degrees virtual reality experience that lets you explore a set of connected geo-located panoramic 3D visualizations or photos.
        case vr360Experience

        /// OGC Web Feature Service. The URL of the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case wfs

        /// OGC Web Map Service.
        /// The URL to the service is stored in the serviceURL property of the item (see ``PortalItem/serviceURL``).
        case wms

        /// A WMTS Service.
        case wmts

        /// A Web map.
        case webMap

        /// A web mapping application.
        case webMappingApplication

        /// Web scene.
        case webScene

        /// A windows mobile package.
        case windowsMobilePackage

        /// Workflow Manager Package (wpk)
        case workflowManagerPackage

        /// ArcGIS Server Workflow Manager Service.
        case workflowManagerService

        /// Workforce Project.
        case workforceProject

        /// A runtime sqlite geodatabase.
        case sqliteGeodatabase

        /// An offline map area defining a map created ahead-of-time.
        case mapArea

        /// Initiatives organize data and tools with an organization goal.
        case hubInitiative

        /// A customizable website that provides a focused view of an organization's items.
        case hubSiteApplication

        /// Hub pages provide web site pages to market Hub Initiatives and provide chart and app content.
        case hubPage

        /// AppBuilder Extension for ArcGIS Web AppBuilder.
        /// URL that references custom widgets for use in Web AppBuilder apps within Portal.
        case appBuilderExtension

        /// AppBuilder Widget Package for ArcGIS Web AppBuilder.
        /// Custom widget in a zip file that can be downloaded for use in Web AppBuilder Developer Edition or ArcGIS Enterprise 10.5.1 or above.
        case appBuilderWidgetPackage

        /// Dashboards integrate maps, lists, charts, and gauges that help monitoring and managing daily operations.
        case dashboard

        /// A customization of Pro to include a custom splash screen and startup page as well as tools, dock panes, and menus.
        case arcGISProConfiguration

        /// Content category set is used as templates for creating the category set for an organization or a group.
        case contentCategorySet

        /// Insights Theme is a collection of properties set on cards and pages in an Insights Workbook.
        case insightsTheme

        /// Mobile Scene Package (mspk)
        case mobileScenePackage

        /// A collection of images stored as a catalog where data is added with specific parameters and auxiliary information
        /// to allow exploring non-nadir imagery on map and see the camera's field of view dynamically.
        case orientedImageryCatalog

        /// Ortho mapping project.
        case orthoMappingProject

        /// Ortho mapping template.
        case orthoMappingTemplate

        /// A solution is comprised of one or more related items and groups that work together as part of a workflow.
        /// It can be deployed to create a new copy of all the items and groups that make up the solution.
        case solution

        /// Building scene layers allow users to visualize and query building information.
        case buildingSceneLayer

        /// A tile package allows you to create a set of tiles (images) from a map, Raster or mosaic dataset, then
        /// use the set of tiles as a basemap in ArcGIS applications. (tpkx).
        case compactTilePackage

        /// For a given geodatabase or file share datastore, the datastore will be registered with Enterprise and will
        /// control who can see the datastore itself, enumerate datasets in it, and publish feature layers from it.
        case dataStore

        /// Deep Learning model package (dlpk).
        case deepLearningPackage

        /// A collection of portal items that provides a focused user experience when working with imagery
        /// to accomplish an image-based workflows as handled by the ArcGIS Excalibur web app.
        case excaliburImageryProject

        /// A GeoPackage is SQLite based containing both vector geospatial features and/or tile matrix sets.
        case geoPackage

        /// A collection of portal items that provides a focused user experience when working in this new
        /// product offering for mission focused, situational awareness.
        case mission

        /// The ArcGIS Enterprise Sites application creates this item. When viewed, users are able to interact with
        /// an Enterprise Site.
        case siteApplication

        /// The ArcGIS Enterprise Sites application creates this item. When viewed, users are able to interact with a page.
        case sitePage

        /// A component used by the ArcGIS Analytics for IoT application for processing high volumes of data.
        case bigDataAnalytic

        /// A component used by the ArcGIS Analytics for IoT application for bringing in a real-time data feed.
        /// Behaves like a stream layer when added to a map.
        case feed

        /// A component used by the ArcGIS Analytics for IoT application for processing real-time data.
        /// Includes references to data feeds, analytic operations, and destinations (outputs) where the results should be sent.
        case realTimeAnalytic

        /// ArcGIS Pro Report File (rptx).
        case proReport

        /// A project created by the QuickCapture Designer tool for use by the QuickCapture mobile app.
        case quickCaptureProject

        /// Survey123 Add-Ins are created and published via Survey123 Connect and are downloaded and used by the Survey123 field app.
        case survey123AddIn

        /// Contains all information needed to start up an Urban App including links to the Urban database services.
        case urbanModel

        /// An experience item created from Experience Builder for ArcGIS.
        case webExperience

        /// A template for a web experience, created from Experience Builder for ArcGIS.
        case webExperienceTemplate

        /// The next generation of StoryMap applications.
        case storyMap

        /// A collection of information (jobs, workflows, and configuration elements) supporting the ArcGIS Workflow Manager Server.
        case workflow

        /// An Insights Script is JSON that allows parameterized code created in the Insights console to be shared as an
        /// item and consumed in Insights in order for the user to run the script using different Insights data sets
        /// and fields as input parameters.
        case insightsScript

        /// A Kernel Gateway Connection is JSON that creates a connection string from Insights in order for the Insights
        /// console to connect and execute code against a Jupyter Kernel Gateway.
        case kernelGatewayConnection

        /// A Knowledge Graph enables you to connect, open, and access graph data so that it can be used in Link Charts and Maps.
        case knowledgeGraph

        /// A Link Chart enables you to visualize and perform link analysis using entities and relationships from a
        /// Knowledge Graph so that you may better understand their connectivity.
        case linkChart

        /// A webstyle item.
        case style

        /// An administrative report in CSV format that outlines various organization usage activities. This cannot be shared to the public.
        case administrativeReport

        /// A package that allows administrators or group owners to export a group, and its content, into a downloadable package (.epk file).
        case exportPackage

        /// An open standard geospatial data interchange format that represents simple geographic features and their nonspatial attributes.
        /// Based on JavaScript Object Notation (JSON), GeoJSON is a format for encoding a variety of geographic data structures.
        case geoJSON

        /// Geography Markup Language (GML) file (.zip).
        /// An XML grammar defined by the OGC for expressing geographical features, serving as both a modeling language and an interchange format.
        case gml

        /// A central premium capability within ArcGIS Hub Premium, empowering customers and their trusted community members to create, edit, and manage in-person/online events.
        case hubEvent

        /// A package of multiple solutions related to a specific project or goal.
        case hubInitiativeTemplate

        /// A set of fonts, colors, block styles, and other design elements that define the appearance of a StoryMap.
        case storyMapTheme

        /// A custom widget (available via marketplace) is a configurable and shareable functional unit for use in ArcGIS Web AppBuilder.
        /// It will allow administrators to enable the use of a custom widget in Web AppBuilder UI so an organization can leverage the ArcGIS Online platform to host their applications.
        case webAppBuilderWidget

        /// An ArcGIS Earth configuration file is an exportable file containing all major settings in Earth.
        /// Earth users who have access to this file can customize the Earth settings by modifying this file.
        /// An Earth configuration file is saved as an .xml file. Users need to compress and zip the file before sharing.
        /// This zip file can be distributed and imported to Earth deployments.
        case earthConfiguration

        /// Support to publish OGC API Features service.
        case ogcFeatureServer

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PortalItem.Kind, b: ArcGIS.PortalItem.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.PortalItem.Kind]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.PortalItem.Kind] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a portal item object for a specified portal and a specified item ID.
    ///
    /// Use this constructor to instantiate a ``PortalItem`` from an existing item using its unique ID.
    ///
    /// The portal item ID can be determined from the URL of the item details web page or the map viewer and scene viewer web applications in your portal.
    /// The item details page has the following format https://www.arcgis.com/home/item.html?id=[item_id].
    /// The map viewer has the format https://www.arcgis.com/home/webmap/viewer.html?webmap=[item_id]
    /// or https://www.arcgis.com/apps/mapviewer/index.html?webmap=[item_id]
    /// depending on whether you use the classic map viewer or the new map viewer.
    /// The scene viewer has the following format https://www.arcgis.com/home/webscene/viewer.html?webscene=[item_id].
    /// In all cases, the [item_id] can be used as the ID to instantiate a portal item.
    /// - Parameters:
    ///   - portal: The portal.
    ///   - id: The item ID.
    /// - Note: See Also: ``portal``, `Item.id`
    public convenience init(portal: ArcGIS.Portal, id: ArcGIS.Item.ID)

    /// Creates a new portal item object with the specified type for a specified portal.
    ///
    /// This constructor is used if you wish to create a new item that you will add to a portal.
    /// - Parameters:
    ///   - portal: The portal.
    ///   - kind: The type of the new portal item.
    /// - Note: See Also: ``portal``, ``kind-swift.property``
    public convenience init(portal: ArcGIS.Portal, kind: ArcGIS.PortalItem.Kind?)

    /// Creates a portal item object from a JSON string and a portal.
    /// - Parameters:
    ///   - json: The JSON representation of the portal item.
    ///   - portal: The portal.
    /// - Note: See Also: ``portal``, ``toJSON()``
    public convenience init?(json: String, portal: ArcGIS.Portal)

    /// Creates a portal item object.
    ///
    /// Use this object to create a portal item from a URL. The supported URL formats are:
    /// * The REST Sharing API URL of the portal item (with or without the query parameter f=json). Example:
    ///   https://www.arcgis.com/sharing/rest/content/items/c6a2c53ead68432586cc9ac9ec366055?f=json
    /// * The REST Sharing API URL of the portal item data. Example:
    ///   https://www.arcgis.com/sharing/rest/content/items/c6a2c53ead68432586cc9ac9ec366055/data
    /// * The URL of the portal item details web page. Example:
    ///   https://www.arcgis.com/home/item.html?id=c6a2c53ead68432586cc9ac9ec366055
    /// * The URL of a webmap opened in the portal's map viewer web application (classic or new). Example:
    ///   https://www.arcgis.com/home/webmap/viewer.html?webmap=8bf7167d20924cbf8e25e7b11c7c502c or
    ///   https://www.arcgis.com/apps/mapviewer/index.html?webmap=8bf7167d20924cbf8e25e7b11c7c502c
    /// * The URL of a webscene opened in the portal's scene viewer web application. Example:
    ///   https://www.arcgis.com/home/webscene/viewer.html?webscene=74ec7d6ca482442ba24f80b708aec67e
    /// - Parameter url: The URL to the portal item.
    public convenience init?(url: URL)

    /// The portal item access.
    ///
    /// For internal use only.
    final public var access: ArcGIS.PortalAccess? { get }

    /// The average rating of the portal item.
    ///
    /// For internal use only. When the user updates their rating of an item, the average rating changes and we need to update that.
    final public var averageRating: Float { get }

    /// The number of comments on the portal item.
    ///
    /// For internal use only. When the user adds a comment, the number of comments needs to be incremented.
    final public var commentCount: Int { get }

    /// A flag indicating whether the comments are allowed on the portal item.
    final public var commentsAreEnabled: Bool { get }

    /// The culture of the portal item.
    ///
    /// The culture (language and country) of the portal item.
    final public var culture: String { get }

    /// The GIS content type of this portal item.
    ///
    /// A portal item's type cannot be changed once it has an item ID.
    final public var kind: ArcGIS.PortalItem.Kind?

    /// The username of the user who owns this portal item.
    final public var owner: String { get }

    /// The portal of the specified portal item.
    ///
    /// Will Throw `CoreErrorCode.commonIllegalState` if the portal item is loaded or loading.
    final public var portal: ArcGIS.Portal { get }

    /// The number of ratings on the portal item.
    ///
    /// For internal use only. When the user adds their item rating, the number of ratings needs to be incremented.
    final public var ratingCount: Int { get }

    /// The size of the portal item.
    final public var size: Int { get }

    /// The type name of this portal item.
    ///
    /// Most generally the type name is the string representation of the enum ``Kind-swift.enum`` returned by ``kind-swift.property``.
    /// However if the type is `nil`, the type name is set with the type found in the portal item JSON.
    /// This allows API to deal with new portal item types added since the latest API release.
    /// - Note: See Also: ``kind-swift.property``
    final public var typeName: String { get }

    /// The URL of the specified portal.
    ///
    /// Will Throw `CoreErrorCode.commonIllegalState` if the portal item is loaded or loading.
    final public var url: URL? { get }

    /// The number of views of the portal item.
    final public var viewCount: Int { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension PortalItem {

    /// Shares the item based on the given parameters.
    ///
    /// If the first or both parameters are `true` the item will be shared with everyone (``PortalAccess/public``).
    /// If both parameters are `false` the item will be private (``PortalAccess/private``), unless the
    /// item has been shared with one or more groups. In that case, the item will be shared (``PortalAccess/shared``).
    /// - Parameters:
    ///   - accessibleToEveryone: A Boolean value indicating whether the items should be shared with everyone  (``PortalAccess/public``).
    ///   - accessibleToOrganization: A Boolean value indicating whether the items should be shared with the organization  (``PortalAccess/organization``).
    final public func share(accessibleToEveryone: Bool, accessibleToOrganization: Bool = false) async throws

    /// Shares this item with the given groups.
    /// - Parameter groups: The portal groups that this item should be shared with.
    /// - Returns: The portal groups that this item could not be shared with.
    @discardableResult
    final public func share(with groups: [ArcGIS.PortalGroup]) async throws -> [ArcGIS.PortalGroup]
}

extension PortalItem {

    /// Unshares this item with everyone which will make the item private (``PortalAccess/private``).
    /// - Remark: This method will also unshare the item with any groups that it is shared with.
    final public func unshare() async throws

    /// Unshares this item with the given groups.
    /// - Parameter groups: The portal groups to unshare with.
    /// - Returns: The portal groups that the item could not be unshared with.
    @discardableResult
    final public func unshare(with groups: [ArcGIS.PortalGroup]) async throws -> [ArcGIS.PortalGroup]
}

extension PortalItem {

    /// Kicks off an operation to update the item based on the given parameters.
    /// - Parameter parameters: The portal item content parameters instance with which to update
    /// the portal item.
    final public func updateContent(parameters: ArcGIS.PortalItemContentParameters) async throws
}

extension PortalItem {

    /// Unknown data from the source JSON.
    /// - Remark: Unknown JSON is a dictionary of values that was in the source JSON but was unparsed by this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    final public var _unknownJSON: [String : Any] { get }

    /// Unsupported data from the source JSON.
    /// - Remark: Unsupported JSON is a dictionary of values that are supported by webmaps, but not exposed by this API.
    /// - Important: Do not use this property. It is not for public consumption and will be changed or removed in the future.
    final public var _unsupportedJSON: [String : Any] { get }

    /// Convert an object to JSON string.
    /// - Returns: A string containing a JSON representation of the portal item.
    final public func toJSON() -> String
}

extension PortalItem {

    /// Groups that this item belongs to.
    public struct Groups {

        /// Groups that this item belongs to, of which the current portal user is an administrator.
        public let admins: [ArcGIS.PortalGroup]

        /// Groups that this item belongs to, of which the current portal user is a member.
        public let members: [ArcGIS.PortalGroup]

        /// Groups that this item belongs to that are public or shared to the user's organization, but that
        /// the current portal user is not a member of.
        public let others: [ArcGIS.PortalGroup]
    }
}

extension PortalItem {

    /// The comments under this portal item.
    /// - Remark: Accessing this property sends a network request.
    final public var comments: [ArcGIS.PortalItemComment] { get async throws }

    /// The groups this portal item belongs to.
    ///
    /// Only those groups that are visible to the current portal user will be returned.
    /// - Remark: Accessing this property sends a network request.
    final public var groups: ArcGIS.PortalItem.Groups { get async throws }

    /// The user rating of the item.
    ///
    /// The updated user rating will be fetched each time this property is accessed. The rating is `nil` if the
    /// user has not rated the item or if the item ID is invalid.
    /// - Remark: Accessing this property sends a network request.
    final public var userRating: Double? { get async throws }

    /// The ID of the folder this item belongs to.
    /// - Remark: A `nil` folder ID means that the folder ID is unknown.
    /// An empty folder ID means that the item is stored at the root folder of the user directory.
    final public var folderID: ArcGIS.PortalFolder.ID? { get }

    /// The URL of the service that the portal item represents.
    ///
    /// Applies only to items that represent web-accessible resources such as map services.
    /// - Remark: The URL of the service that the portal item represents.
    /// Will return an empty string if the item doesn't represent a web-accessible resource.
    final public var serviceURL: URL? { get }

    /// Fetches all related portal items with any of the specified relationships to this portal item.
    /// - Parameters:
    ///   - relationships: An array of relationships.
    ///   - direction: The direction of the relationships.
    /// - Returns: An array of portal items that match the specified relationships.
    final public func relatedItems(by relationships: [ArcGIS.PortalItem.Relationship], direction: ArcGIS.PortalItem.RelationshipDirection) async throws -> [ArcGIS.PortalItem]

    /// Adds a rating to an item that the current ``Portal/user`` has access to.
    ///
    /// Upon success, the ``averageRating`` and ``ratingCount`` properties will be updated.
    /// Only one rating can be given to an item per user. If this call is made on an already rated item,
    /// the new rating will overwrite the current one. A user cannot rate their own item. This method is
    /// only available to authenticated users.
    /// - Parameter rating: The rating to add to the portal item. This value must be
    /// between `1.0` and `5.0`.
    final public func addRating(_ rating: Double) async throws

    /// Adds a comment to an item.
    ///
    /// Available only to authenticated users who have access to the item.
    /// - Parameter text: The text of the new comment.
    /// - Returns: The comment that was added to the portal item.
    final public func addComment(text: String) async throws -> ArcGIS.PortalItemComment
}

extension PortalItem {

    /// Errors thrown by portal item operations.
    public enum Error : Error {

        /// Rating is not between 1 and 5.
        case invalidRating

        /// Comment text cannot be empty.
        case emptyCommentText

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PortalItem.Error, b: ArcGIS.PortalItem.Error) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension PortalItem {

    /// An enumeration of ``PortalItem`` relationship types.
    public enum Relationship : String {

        /// Relates a map with a service.
        case mapToService

        /// Relates a web mapping application with a code attachment.
        /// - Remark: All related items are treated as one item when shared or deleted,
        /// and the destination item inherits all sharing permissions of the
        /// origin item.
        case wmaToCode

        /// Relates a map with a feature collection.
        case mapToFeatureCollection

        /// Relates a mobile application with a code attachment.
        /// - Remark: All related items are treated as one item when shared or deleted,
        /// and the destination item inherits all sharing permissions of the
        /// origin item.
        case mobileAppToCode

        /// Relates a derived service and its source data.
        ///
        /// The creator of the relationship must own all related items.
        /// - Remark: The derived service is the origin of the relationship,
        /// and the source data is the destination of the relationship.
        /// The source data can be a service. This relationship can be queried in both directions.
        case serviceToData

        /// Relates a source service and a derived service.
        ///
        /// The creator of the relationship must own all related items.
        /// - Remark: The source service is the origin of the relationship, and
        /// the derived service is the destination of the relationship.
        /// This relationship can be queried in both directions.
        case serviceToService

        /// Relates a Web Map to an Application Configuration.
        /// - Remark: The creator of the relationship must own all related items,
        /// all related items are treated as one item when shared or deleted,
        /// and the destination item inherits all sharing permissions of the
        /// origin item.
        case mapToAppConfig

        /// Relates an item to an attachment.
        /// - Remark: The creator of the relationship must own all related items,
        /// and all related items are treated as one item when shared or deleted.
        case itemToAttachment

        /// Relates an item to a report.
        case itemToReport

        /// Relates a listed item to a provisioned item.
        ///
        /// Additionally, the creator of the relationship must own all related items,
        /// and the all related items are treated as one item when deleted.
        /// - Remark: Both the source (parent) and destination (child) items must be listed:
        /// the parent publicly and the child privately.
        case listedToProvisioned

        /// Relates a vector tile service to a style.
        /// - Remark: The creator of the relationship must own the destination item.
        case styleToStyle

        /// Relates a vector tile service or style to a vector tile service or style.
        /// - Remark: The creator of the relationship must own the destination item.
        case serviceToStyle

        /// Relates a survey to a feature service.
        /// - Remark: The creator of the relationship must own the origin item.
        case surveyToService

        /// Relates a survey to its data.
        /// - Remark: The creator of the relationship must own the origin item.
        case surveyToData

        /// Relates a feature service containing all the routes and the route layer representing each route.
        /// - Remark: The creator of the relationship must own all related items,
        /// and all related items are treated as one item when deleted.
        case serviceToRoute

        /// Relates a map area to a map package, tile package, SQLite geodatabase,
        /// or vector tile package.
        /// - Remark: The creator of the relationship must own all related items,
        /// and all related items are treated as one item when shared or deleted.
        case areaToPackage

        /// Relates a web map to a map area.
        /// - Remark: The creator of the relationship must own all related items.
        case mapToArea

        /// Relates a feature service to a feature layer.
        /// - Remark: The creator of the relationship must own all related items,
        /// and all related items are treated as one item when shared or deleted.
        case serviceToLayer

        /// Relates a map area to a custom map package, tile package, SQLite geodatabase,
        /// or vector tile package.
        /// - Remark: The creator of the relationship must own all related items.
        case areaToCustomPackage

        /// Relates a track view with a web map that was created in the Tracker web app.
        case trackViewToMap

        /// Relates a Survey123 add in to data related to the add in.
        /// - Remark: The creator of the relationship must own the origin item.
        case surveyAddInToData

        /// Relates a web map to a Workforce feature service.
        ///
        /// This relationship is only applicable to ArcGIS Online organizations.
        /// - Remark: The creator of the relationship must own all related items.
        case workforceMapToFeatureService

        /// Relates a StoryMap theme to the StoryMaps that use the theme.
        ///
        /// This relationship can be queried in either direction, and is only applicable
        /// to ArcGIS Online organizations.
        /// - Remark: A theme can be used by many stories, but a story uses only one theme.
        case themeToStory

        /// Relates a web style to the desktop style that is used to publish the web style.
        ///
        /// This relationship is only applicable to ArcGIS Online organizations.
        /// - Remark: The creator of the relationship must own all related items.
        case webStyleToDesktopStyle

        /// Relates a solution to items created as part of the solution.
        ///
        /// This relationship is only applicable to ArcGIS Online organizations.
        case solutionToItem

        /// Relates an API key to an item on the ArcGIS for Developers item pages.
        ///
        /// This relationship is only applicable to ArcGIS Online organizations.
        /// - Remark: The creator of the relationship must own all related items.
        case apiKeyToItem

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }

    /// An enumeration of ``PortalItem`` relationship directions.
    public enum RelationshipDirection : String {

        /// The relationship goes from origin to destination.
        case forward

        /// The relationship goes from destination to origin.
        case reverse

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }
}

extension PortalItem.Kind : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension PortalItem.Kind : Equatable {
}

extension PortalItem.Kind : Hashable {
}

extension PortalItem.Error : Equatable {
}

extension PortalItem.Error : Hashable {
}

extension PortalItem.Relationship : Equatable {
}

extension PortalItem.Relationship : Hashable {
}

extension PortalItem.Relationship : RawRepresentable {
}

extension PortalItem.RelationshipDirection : Equatable {
}

extension PortalItem.RelationshipDirection : Hashable {
}

extension PortalItem.RelationshipDirection : RawRepresentable {
}

/// A comment for a portal's item.
/// - Since: 200.1
public struct PortalItemComment : Hashable, Identifiable {

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public struct ID : Hashable, RawRepresentable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The ID of the comment.
    public let id: ArcGIS.PortalItemComment.ID

    /// The text of the comment.
    public let text: String

    /// The date of creation of the comment.
    public let creationDate: Date

    /// The owner of the comment. This property will default to an empty string if the owner's account was deleted.
    public let owner: String

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalItemComment, b: ArcGIS.PortalItemComment) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension PortalItemComment.ID : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

/// Content for a new ``PortalItem``.
///
/// `PortalItemContentParameters` represents content for a new portal item created
/// by ``PortalUser/add(_:with:to:)``.
/// - Since: 200.1
public struct PortalItemContentParameters : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalItemContentParameters, b: ArcGIS.PortalItemContentParameters) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension PortalItemContentParameters {

    /// Returns a portal item content parameters instance with json.
    /// - Parameter json: The JSON representing the content (like a web map) for the portal item.
    /// - Returns: The portal item content parameters instance.
    public static func json(_ json: String) -> ArcGIS.PortalItemContentParameters

    /// Returns a portal item content parameters instance with data.
    /// - Parameters:
    ///   - data: The data representing the file or JSON content to be added or
    ///   updated on a ``PortalItem``.
    ///   - filename: The file name (including the extension) being used for the
    ///   file being uploaded for this content item.
    /// - Returns: The portal item content parameters instance.
    public static func data(_ data: Data, filename: String = "") -> ArcGIS.PortalItemContentParameters

    /// Returns a portal item content parameters instance with a URL.
    /// - Parameter url: The URL used for the ``PortalItem``.
    /// - Returns: The portal item content parameters instance.
    public static func url(_ url: URL) -> ArcGIS.PortalItemContentParameters
}

/// Privileges of a portal user.
///
/// Instances represent a privilege possessed by a portal user. This privilege permits the user to perform specific operations on the portal.
/// - Since: 200.1
public struct PortalPrivilege : Hashable {

    /// The type of an operation a portal privilege can permit.
    public struct Kind : RawRepresentable, Hashable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// Supported portal privilege realm.
    public struct Realm : RawRepresentable, Hashable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// Supported portal privilege role.
    public struct Role : RawRepresentable, Hashable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// Supported portal privilege subkind.
    public struct Subkind : RawRepresentable, Hashable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: String

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String
    }

    /// The realm the privilege belongs to. Helps to organize privileges into categories for aspects relating to a portal.
    public let realm: ArcGIS.PortalPrivilege.Realm

    /// The role the privilege applies to.
    public let role: ArcGIS.PortalPrivilege.Role

    /// The operation permitted by the privilege.
    public let kind: ArcGIS.PortalPrivilege.Kind

    /// The fine-grained operation subkind this privilege permits.
    ///
    /// Subkinds control access to a few fine-grained operations. The subkind is `nil`
    /// unless this privilege relates to a fine-grained operation.
    public let subkind: ArcGIS.PortalPrivilege.Subkind?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalPrivilege, b: ArcGIS.PortalPrivilege) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension PortalPrivilege : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension PortalPrivilege : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init?(_ description: String)
}

extension PortalPrivilege.Kind {

    /// Grants the ability to edit features in editable layers, according to the edit options enabled on the layer.
    public static let edit: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to add, delete, and update features in a hosted feature layer regardless of the editing options enabled on the layer.
    public static let fullEdit: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to create listings, list items and manage subscriptions in ArcGIS Marketplace.
    public static let manage: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to request purchase information about apps and data in ArcGIS Marketplace.
    public static let purchase: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to start trial subscriptions in ArcGIS Marketplace.
    public static let startTrial: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to designate groups within the organization as being available for use in Open Data.
    public static let designateGroup: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage Open Data sites for the organization.
    public static let openDataAdmin: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to assign members to, and remove members from, groups within the organization.
    public static let assignToGroups: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to change the role a member is assigned within the organization.
    public static let changeUserRoles: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to delete groups within the organization.
    public static let deleteGroups: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to delete content within the organization.
    public static let deleteItems: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to delete member accounts within the organization.
    public static let deleteUsers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to enable and disable member accounts within the organization.
    public static let disableUsers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to invite members to the organization.
    public static let inviteUsers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to link group membership to an enterprise group.
    public static let manageEnterpriseGroups: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to assign licenses to members of the organization.
    public static let manageLicenses: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to reassign groups to other members within the organization.
    public static let reassignGroups: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to reassign content to other members within the organization.
    public static let reassignItems: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to assign all groups and content of a member to another within the organization.
    public static let reassignUsers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to update groups within the organization.
    public static let updateGroups: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to update and categorize content within the organization.
    public static let updateItems: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to update member account information within the organization.
    public static let updateUsers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to view all groups within the organization.
    public static let viewGroups: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to view all content within the organization.
    public static let viewItems: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to view full member account information within the organization.
    public static let viewUsers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish hosted feature layers from shapefiles, CSVs, etc.
    public static let publishFeatures: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish hosted scene layers.
    public static let publishScenes: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish hosted tile layers from tile packages, features, etc.
    public static let publishTiles: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability for a member to create, edit, and delete their own groups.
    public static let createGroup: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability for a member to create, edit, and delete their own content.
    public static let createItem: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to join groups within the organization.
    public static let joinGroup: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to join groups external to the organization.
    public static let joinNonOrgGroup: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to make groups discoverable by the organization.
    public static let shareGroupToOrg: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to make groups discoverable by all users of the portal.
    public static let shareGroupToPublic: ArcGIS.PortalPrivilege.Kind

    /// For a user, grants the ability to share content to groups.
    /// For an administrator, grants the ability to share other member's content to groups the user belongs to.
    public static let shareToGroup: ArcGIS.PortalPrivilege.Kind

    /// For a user, grants the ability to share content to the organization.
    /// For an administrator, grants the ability to share other member's content to the organization.
    public static let shareToOrg: ArcGIS.PortalPrivilege.Kind

    /// For a user, grants the ability to share content to all users of the portal.
    /// For an administrator, grants the ability to share other member's content to all users of the portal.
    public static let shareToPublic: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to make use of premium demographic data.
    public static let demographics: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to perform analytical tasks on elevation data.
    public static let elevation: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to perform large-volume geocoding tasks with the Esri World Geocoder such as publishing a CSV of addresses as a hosted feature layer.
    public static let geocode: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to geoenrich features.
    public static let geoenrichment: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to perform network analysis tasks such as routing and drive-time areas.
    public static let networkAnalysis: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to perform spatial analysis tasks.
    public static let spatialAnalysis: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to create and own groups with item update capabilities.
    public static let createUpdateCapableGroup: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to view groups shared with the organization.
    public static let viewOrgGroups: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to view content shared with the organization.
    public static let viewOrgItems: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to view members of the organization.
    public static let viewOrgUsers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to use big data geoanalytics.
    public static let geoanalytics: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to use raster analysis.
    public static let rasterAnalysis: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish non-hosted server geoprocessing services.
    public static let publishServerGPServices: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish non-hosted server services.
    public static let publishServerServices: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to configure the organization content category schema.
    public static let updateItemCategorySchema: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to generate feature reports.
    public static let featureReport: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage the organization's collaborations.
    public static let manageCollaborations: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage the organization's credit settings.
    public static let manageCredits: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage the organization's member roles.
    public static let manageRoles: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage the organization's security settings.
    public static let manageSecurity: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage the portal's server settings.
    public static let manageServers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage the organization's utility service settings.
    public static let manageUtilityServices: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage the organization's website settings.
    public static let manageWebsite: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage replications and utilize the collaborations API.
    public static let manageReplications: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to create and edit interactive notebook documents.
    public static let createNotebooks: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish a notebook as a geoprocessing service.
    public static let createAdvancedNotebooks: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish web layers from a registered data store.
    public static let bulkPublishFromDataStores: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to get the list of datasets from a registered data store.
    public static let enumerateDataStores: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to register data stores to the portal.
    public static let registerDataStores: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to categorize items in groups.
    public static let categorizeItems: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to view members' location tracks via shared track views when location tracking is enabled.
    public static let viewTracks: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to create groups that allow external members, as well as invite external members to groups.
    public static let addExternalMembersToGroup: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage members in partnered collaboration groups.
    public static let manageCollaborationGroupMembers: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to manage version locks and view, alter, delete, edit, reconcile, and post to all branch
    /// versions accessed through ArcGIS Server feature layers.
    public static let manageVersions: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish hosted dynamic imagery layers from a single image or collection of images.
    public static let publishDynamicImagery: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to publish hosted tiled imagery layers from a single image or collection of images.
    public static let publishTiledImagery: ArcGIS.PortalPrivilege.Kind

    /// Grants the ability to schedule future automated runs of a notebook.
    public static let scheduleNotebooks: ArcGIS.PortalPrivilege.Kind
}

extension PortalPrivilege.Realm {

    /// A privilege that is specific to the portal.
    public static let portal: ArcGIS.PortalPrivilege.Realm

    /// A privilege that is specific to editing features.
    public static let features: ArcGIS.PortalPrivilege.Realm

    /// A privilege that is specific to ArcGIS Open Data.
    public static let openData: ArcGIS.PortalPrivilege.Realm

    /// A privilege that is specific to premium content.
    public static let premium: ArcGIS.PortalPrivilege.Realm

    /// A privilege that is specific to ArcGIS Online.
    public static let marketplace: ArcGIS.PortalPrivilege.Realm
}

extension PortalPrivilege.Role {

    /// An administrative privilege.
    public static let administrator: ArcGIS.PortalPrivilege.Role

    /// A publisher privilege.
    public static let publisher: ArcGIS.PortalPrivilege.Role

    /// A user privilege.
    public static let user: ArcGIS.PortalPrivilege.Role
}

extension PortalPrivilege.Subkind {

    /// Grants the ability to perform geocode operations and store the results, in a database for instance.
    public static let stored: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform geocode operations in which the results are not stored.
    public static let temporary: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform closest facility tasks.
    public static let closestFacility: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform location-allocation tasks.
    public static let locationAllocation: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform optimized routing tasks.
    public static let optimizedRouting: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform origin-destination cost matrix tasks.
    public static let originDestinationCostMatrix: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform simple routing tasks.
    public static let routing: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform service area tasks.
    public static let serviceArea: ArcGIS.PortalPrivilege.Subkind

    /// Grants the ability to perform vehicle routing tasks.
    public static let vehicleRouting: ArcGIS.PortalPrivilege.Subkind
}

/// Defines a query on a portal.
///
/// To query a portal for items or groups, the
/// ``Portal/findItems(queryParameters:)`` and ``Portal/findGroups(queryParameters:)``
/// methods must use the query parameters specified by the portal query
/// parameters. You can choose any of pre-defined query strings, supplied by the
/// static methods under this struct, or you can create a custom query string as
/// per the specification in the Portal API. The default number of results
/// returned is `10`. Adjust this limit to return more results and use with the
/// ``startIndex`` property, if you wish to paginate the results.
/// - Since: 200.1
public struct PortalQueryParameters {

    /// The bounding box for a spatial search, which is an overlaps/intersects
    /// function of the query bounding box and the extent of the document.
    /// Documents that have no extent (e.g., mxds, 3dds, lyr) will not be found
    /// when doing a bounding box search.
    public var boundingBox: ArcGIS.Envelope?

    /// An array of content category specifications to use when searching for
    /// items using ``Portal/findItems(queryParameters:)``.
    ///
    /// Each entry in the array is a string containing a comma-separated list of
    /// up to 8 organization-level content categories. The full path of each
    /// category is required and an OR relationship is applied between the
    /// categories within a particular string.
    ///
    /// There can be up to 8 strings with an AND relationship being applied
    /// between the different strings.
    ///
    /// For example, to search for items belonging to either the water or forest
    /// categories, both within the US, specify 2 strings as follows:
    /// "/Categories/Water,/Categories/Forest" and "/Region/US".
    ///
    /// The categories property is ignored if the portal query parameters is
    /// used to search for groups using ``Portal/findGroups(queryParameters:)``.
    public var categories: [String]

    /// The number of results to be returned. This along with the ``startIndex``
    /// property can help you paginate the search results.
    /// - Remark: Default is `10` and the maximum is `100`.
    public var limit: Int

    /// The query string specified for the search.
    ///
    /// See [ArcGIS REST APIs](https://developers.arcgis.com/rest/users-groups-and-items/search-reference.htm)
    /// for information on query syntax.
    public var query: String

    /// A Boolean value indicating whether public items outside the organization may be included in the search results.
    /// - Remark: Default is `true`.
    public var searchPublic: Bool

    /// The field on which sorting should be done.
    /// - Remark: Sort field names are case-insensitive. Supported field names are "title", "created", "type", "owner", "modified",
    /// "avgrating", "numratings", "numcomments", and "numviews".
    public var sortField: String

    /// The order of sorting.
    /// - Remark: Default is ``PortalQuerySortOrder/ascending``.
    public var sortOrder: ArcGIS.PortalQuerySortOrder

    /// The index from which the results should be returned. The index number is 1-based. You should use
    /// this for paginating the search results.
    /// - Remark: Default is `1`.
    public var startIndex: Int

    /// Returns a query parameters instance that will find groups with a specified owner and title.
    /// - Parameters:
    ///   - owner: The owner of the group.
    ///   - title: The title of the group.
    /// - Returns: The query parameters.
    public static func groups(withOwner owner: String, title: String) -> ArcGIS.PortalQueryParameters

    /// Returns a query parameters instance that will find items that satisfy the specified criteria.
    /// - Parameters:
    ///   - kinds: The portal item kinds.
    ///   - owner: The owner of the portal items.
    ///   - groupID: The ID of the group.
    ///   - searchText: The search text that can be used to specify other criteria for the search.
    /// - Returns: The query parameters.
    public static func items(ofKinds kinds: Set<ArcGIS.PortalItem.Kind> = [], withOwner owner: String = "", inGroup groupID: ArcGIS.PortalGroup.ID? = nil, searchText: String = "") -> ArcGIS.PortalQueryParameters

    /// Returns a query parameters instance that will find an item with a specified ID.
    /// - Parameter itemID: The ID of the item.
    /// - Returns: The query parameters.
    public static func item(withID itemID: String) -> ArcGIS.PortalQueryParameters
}

extension PortalQueryParameters {

    /// Creates a portal query parameters instance.
    /// - Parameters:
    ///   - query: The query string specified for the search.
    ///   - limit: The number of results to be returned.
    public init(query: String, limit: Int = 10)
}

extension PortalQueryParameters : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.PortalQueryParameters, b: ArcGIS.PortalQueryParameters) -> Bool
}

/// Results of a query on a portal.
/// - Since: 200.1
public struct PortalQueryResultSet<T> {

    /// The query parameters that was used to make the search.
    public let queryParameters: ArcGIS.PortalQueryParameters

    /// The query parameters for the next set of results based on the next start index.
    ///
    /// This is automatically generated if there are any more results left to be retrieved. This property is `nil`
    /// if there are no more results for the next page.
    public let nextQueryParameters: ArcGIS.PortalQueryParameters?

    /// The results of the query.
    public let results: [T]

    /// The total number of results irrespective of the paging.
    public let totalResults: Int
}

/// The order of results of a portal query.
/// - Since: 200.1
public enum PortalQuerySortOrder : String {

    /// The query results are in ascending order.
    case ascending

    /// The query results are in descending order.
    case descending

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = String

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: String { get }
}

extension PortalQuerySortOrder : Equatable {
}

extension PortalQuerySortOrder : Hashable {
}

extension PortalQuerySortOrder : RawRepresentable {
}

/// A registered user of the portal or organization.
///
/// A portal may have users who are unaffiliated with an organization or users
/// who are part of an organization. Users sign in to the portal and create and
/// share content which is organized into items (``PortalItem``). Users can
/// create and join groups (``PortalGroup``) and share items with groups. This
/// makes the items visible and accessible to other members of the group. Users
/// could be in different roles including administrators, publishers and
/// information workers. Administrators can add users to their organizations and
/// have access to all content within the organization. All users can create web
/// maps based on combining services that they have access to and can register
/// services running on external servers. Publishers within an organization can
/// in addition to user privileges create hosted services based on data files
/// that they upload.
/// - Since: 200.1
final public class PortalUser {

    /// Indicates the role of the portal user within an organization.
    public enum Role : String {

        /// A publisher that includes user privileges plus the ability to publish content.
        case publisher

        /// An administrator that includes publisher privileges plus privileges to manage
        /// the organization and other users.
        case admin

        /// An information worker that includes data editor privileges plus the ability to
        /// create groups and content.
        case user

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional("PaperSize.Legal")"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }

    /// Represents the content of a portal user.
    public struct Content {

        /// The user's folders.
        public let folders: [ArcGIS.PortalFolder]

        /// The user's portal items.
        public let items: [ArcGIS.PortalItem]
    }

    /// The ID of the organization if the user belongs to an organization.
    final public var organizationID: String { get }

    /// Determines if other users can search for this user's name to find
    /// content and groups owned by this user and to invite this user to join
    /// their groups.
    /// - ``PortalAccess/private`` implies the user is hidden and others cannot
    /// search for the user or view their information.
    /// - ``PortalAccess/organization`` implies only members of the organization
    /// can search for or view the user's information.
    /// - ``PortalAccess/public`` implies anyone can search for or access the
    /// user's information.
    /// - Remark: If `nil`, the access is unknown.
    final public var access: ArcGIS.PortalAccess? { get }

    /// The date on which the user account was created.
    final public var creationDate: Date? { get }

    /// The email address of the user.
    final public var email: String { get }

    /// The ID of the group that contains the users favorites.
    ///
    /// This property is `nil` if the portal group ID is invalid.
    final public var favoritesGroupID: ArcGIS.PortalGroup.ID? { get }

    /// The full name of the user.
    final public var fullName: String { get }

    /// An array of the groups to which the user belongs.
    /// - Remark: The ``PortalGroup`` objects are fully populated and have a
    /// load status of ``LoadStatus/loaded``.
    final public var groups: [ArcGIS.PortalGroup] { get }

    /// The date on which the user account was modified.
    final public var modificationDate: Date? { get }

    /// The portal to which the user belongs.
    weak final public var portal: ArcGIS.Portal? { get }

    /// An array of ``PortalPrivilege`` instances defining the fine-grained
    /// privileges possessed by this user.
    final public var privileges: [ArcGIS.PortalPrivilege] { get }

    /// The role of the user within the organization.
    final public var role: ArcGIS.PortalUser.Role? { get }

    /// An array of words or short phrases that describe the user.
    final public var tags: [String] { get }

    /// The thumbnail image of the user.
    /// If it is `nil`, there is no group thumbnail. Otherwise, the image needs
    /// to be loaded asynchronously using ``LoadableImage/load()``.
    final public var thumbnail: ArcGIS.LoadableImage? { get }

    /// The units preference of the user.
    final public var units: ArcGIS.UnitSystem? { get }

    /// The description of the user.
    final public var description: String { get }

    /// The user's content at the root level (not under any sub-folder).
    /// - Remark: Accessing this property sends out a network request.
    final public var content: ArcGIS.PortalUser.Content { get async throws }

    /// The username of the user.
    final public let username: String

    /// Creates a portal user object for a specified portal and a specified username.
    /// - Parameters:
    ///   - portal: The portal the user belongs to.
    ///   - username: The username of the user.
    ///  - Remark: The initializer will fail if passed an invalid user name, ie. if the user name is empty.
    public convenience init?(portal: ArcGIS.Portal, username: String)

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad() async
}

extension PortalUser {

    /// Adds the given item to this user's favorites group.
    /// - Parameter item: The item to be added.
    final public func add(toFavorites item: ArcGIS.PortalItem) async throws

    /// Removes the given item from this user's favorites group.
    /// - Parameter item: The item to be removed.
    final public func remove(fromFavorites item: ArcGIS.PortalItem) async throws
}

extension PortalUser {

    /// Creates a new folder with the given title in the user's root folder.
    /// - Parameter title: The title of the new folder.
    /// - Returns: The folder that was created.
    /// - Remark: Nested folders are not supported and two folders that belong to the same user
    /// cannot have the same title.
    final public func createFolder(title: String) async throws -> ArcGIS.PortalFolder

    /// Deletes the specified folder.
    ///
    /// Deleting a folder deletes all the items that it contains.
    /// - Remark: You cannot delete a user's root folder.
    /// - Parameter folder: The folder that should be deleted.
    final public func delete(_ folder: ArcGIS.PortalFolder) async throws
}

extension PortalUser {

    /// Adds the specified item to the portal in the given folder.
    /// - Parameters:
    ///   - item: The new item to be added to the portal.
    ///   - contentParameters: The content parameters for the item to be added.
    ///   - folder: The folder in which to create the item. If `nil`, the item
    ///   will be added to the user's root folder.
    /// - Precondition: `portalItem.loadStatus == .notLoaded`
    final public func add(_ item: ArcGIS.PortalItem, with contentParameters: ArcGIS.PortalItemContentParameters, to folder: ArcGIS.PortalFolder? = nil) async throws

    /// Moves the specified item to the specified folder.
    /// - Parameters:
    ///   - item: The item to move.
    ///   - folder: The folder to which to move the item. If `nil`, the item
    ///   will be moved to this user's root folder.
    final public func move(_ item: ArcGIS.PortalItem, to folder: ArcGIS.PortalFolder? = nil) async throws

    /// The error that is thrown when one or more items fails to move.
    public struct MoveItemsError : Error {
    }

    /// Moves the specified items to the specified folder.
    /// - Parameters:
    ///   - items: The items to move.
    ///   - folder: The folder to which to move the items. If `nil`, the items
    ///   will be moved to this user's root folder.
    /// - Throws: ``MoveItemsError`` when one or more items fails to move.
    final public func move(_ items: [ArcGIS.PortalItem], to folder: ArcGIS.PortalFolder? = nil) async throws

    /// Deletes the specified item from the portal.
    /// - Parameter item: The item to be deleted.
    final public func delete(_ item: ArcGIS.PortalItem) async throws
}

extension PortalUser {

    /// Errors thrown by portal user operations.
    public enum Error : Error {

        /// A folder title cannot be empty.
        case emptyFolderTitle

        /// The user does not have a favorites group.
        case noFavoritesGroup

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PortalUser.Error, b: ArcGIS.PortalUser.Error) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension PortalUser {

    /// Returns the items within the folder of this user for the given folder identifier.
    /// - Parameter folderID: The identifier of the folder to fetch the items from.
    /// - Returns: The items in the folder.
    final public func itemsInFolder(withID folderID: ArcGIS.PortalFolder.ID) async throws -> [ArcGIS.PortalItem]

    /// Returns a Boolean value indicating whether the given item is in the user's favorites group.
    /// - Parameter portalItem: The item to check.
    /// - Returns: `true` if the item is in this user's favorites group, otherwise `false`.
    /// - Note: See Also: ``PortalUser/favoritesGroupID``
    final public func isFavorite(_ portalItem: ArcGIS.PortalItem) async throws -> Bool
}

extension PortalUser : ArcGIS.Loadable {
}

extension PortalUser.Role : Equatable {
}

extension PortalUser.Role : Hashable {
}

extension PortalUser.Role : RawRepresentable {
}

extension PortalUser.Error : Equatable {
}

extension PortalUser.Error : Hashable {
}

/// A credential used to access token-secured ArcGIS resources using a token that is generated outside of your application.
/// - Since: 200.1
final public class PregeneratedTokenCredential : ArcGIS.ArcGISCredential {

    /// Creates an instance of a ``PregeneratedTokenCredential``.
    /// - Parameters:
    ///   - url: The URL of the token-secured resource.
    ///   - tokenInfo: The ``TokenInfo`` used to access secured resources.
    ///   - referer: The referer that was used to generate the ``TokenInfo``
    public convenience init(url: URL, tokenInfo: ArcGIS.TokenInfo, referer: String = "")

    /// Gets the ``TokenInfo`` used to create the credential.
    final public var tokenInfo: ArcGIS.TokenInfo { get }
}

/// Represents a single preplanned offline map area.
///
/// Offline map areas are specific work areas or major incident areas that are defined by an
/// online map author ahead of time. Each online map can contain a number of offline map areas.
/// These can be provided in a list by the `OfflineMapTask.preplannedMapAreas` method.
/// Each preplanned map area uses map content that is stored online. Download this map
/// content by running a ``DownloadPreplannedOfflineMapJob``. Create this job by passing the
/// preplanned map area to the `OfflineMapTask.makeDownloadPreplannedOfflineMapJob(parameters:downloadDirectory:)` method on the
/// ``OfflineMapTask``.
///
/// To successfully load a ``PreplannedMapArea`` the ``packagingStatus-swift.property`` must
/// be ``PackagingStatus-swift.enum/complete``.
/// - Since: 200.1
final public class PreplannedMapArea : ArcGIS.Loadable {

    /// Enumerates the different packaging states that an online ``PreplannedMapArea`` can be in.
    ///
    /// A ``PreplannedMapArea`` is made up of a set of data packages for each of the layers in the
    /// map. When a web map author first creates a map area these packages must be prepared by the
    /// relevant online services before the area is ready to be downloaded as an offline map.
    ///
    /// ``PreplannedMapArea/PackagingStatus-swift.enum`` lists the possible packaging states for an online map area. The
    /// area cannot be downloaded until the value is ``complete``.
    public enum PackagingStatus {

        /// Indicates that the ``PreplannedMapArea`` is not yet ready for download.
        ///
        /// This is the initial status for a ``PreplannedMapArea`` that has been created on the web
        /// map, but is not yet ready for download.
        case processing

        /// Indicates that a failure occurred when creating the packages for the ``PreplannedMapArea``.
        ///
        /// This status means that the ``PreplannedMapArea`` cannot be downloaded. Failures
        /// encountered while creating packages need to be addressed by the web map author.
        case failed

        /// Indicates that packaging is complete and the ``PreplannedMapArea`` is ready to be downloaded.
        ///
        /// This status means that all packages required to download the ``PreplannedMapArea`` have
        /// been successfully prepared.
        case complete

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.PreplannedMapArea.PackagingStatus, b: ArcGIS.PreplannedMapArea.PackagingStatus) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Create an offline map area instance with a portal item that is of type map area.
    /// - Parameter portalItem: ``PortalItem`` that represents a preplanned offline map area.
    public convenience init(portalItem: ArcGIS.PortalItem)

    /// The area of interest bounding the offline map area.
    ///
    /// The area of interest is returned as a ``Geometry``, which can be either an ``Envelope``
    /// or a ``Polygon`` depending on how the online map area was created.
    final public var areaOfInterest: ArcGIS.Geometry? { get }

    /// Portal items for packages related to this preplanned map area.
    ///
    /// When the offline map area has successfully loaded, this collection
    /// contains the portal items for the packages (tile packages or geodatabases)
    /// holding the offline data for the map area.
    @ArcGIS.Streamed final public var packageItems: [ArcGIS.PortalItem] { get }

    final public var $packageItems: AsyncStream<[ArcGIS.PortalItem]> { get }

    /// Describes the packaging status of the online map area.
    ///
    /// This property allows you to check whether an online ``PreplannedMapArea`` is in a
    /// ``PackagingStatus-swift.enum/complete`` state and ready to be downloaded.
    ///
    /// If you attempt to load a ``PreplannedMapArea`` that is not
    /// ``PackagingStatus-swift.enum/complete`` the ``PreplannedMapArea`` will fail to load with
    /// an error of `CoreErrorCode.commonIllegalState`.
    ///
    /// There are four possible values:
    /// * ``PackagingStatus-swift.enum/complete`` indicates the map area is ready for download
    ///   and the data has been packaged
    /// * ``PackagingStatus-swift.enum/processing`` indicates that the online map area is not
    ///   yet ready to be downloaded. The packages required for the map area have not been
    ///   packaged yet. This status will be available after the ``PreplannedMapArea`` fails to
    ///   load.
    /// * ``PackagingStatus-swift.enum/failed`` indicates that an error was encountered while
    ///   preparing the online map area or its packages. In this scenario, the map area cannot
    ///   be downloaded until the web map author has resolved the errors. This status will be
    ///   available after the ``PreplannedMapArea`` fails to load.
    /// * `nil` indicates that the metadata for the map area
    ///   has not been fetched. This will be the value when the map area is
    ///   `LoadStatus.notLoaded`.
    ///
    /// If the packaging status is ``PackagingStatus-swift.enum/processing`` you can check it
    /// again following these steps:
    /// 1. Create a new ``PortalItem`` instance using the ``PortalItem/url`` in the
    ///    ``portalItem``.
    /// 2. Create a new ``PreplannedMapArea`` using the portal item
    ///    ``init(portalItem:)``.
    /// 3. Load the ``PreplannedMapArea`` and check ``packagingStatus-swift.property``.
    final public var packagingStatus: ArcGIS.PreplannedMapArea.PackagingStatus? { get }

    /// The portal item that this offline map area was created from.
    final public var portalItem: ArcGIS.PortalItem { get }

    /// Describes the methods for obtaining updates that are supported for this offline map area.
    ///
    /// There are two approaches for updating the features in a preplanned offline map area:
    ///
    /// * Syncing directly with feature services.
    /// * Downloading scheduled updates (or update packages) from the online map area.
    ///
    /// Choose the approach that best suits your workflow, then select the appropriate
    /// ``DownloadPreplannedOfflineMapParameters/updateMode-swift.property``. For more details on how to update
    /// an offline map, see the ``OfflineMapSyncTask``.
    ///
    /// If ``OfflineMapUpdateCapabilities/supportsSyncWithFeatureServices`` is `true`, you can
    /// sync directly with feature services. This mode gives you full control over when you
    /// upload and download changes. However, performing a download sync places significant load
    /// on the backing feature service, so this approach does not scale well for very large
    /// deployments. Set the ``DownloadPreplannedOfflineMapParameters/updateMode-swift.property`` to
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/syncWithFeatureServices`` to use this approach.
    ///
    /// If ``OfflineMapUpdateCapabilities/supportsScheduledUpdatesForFeatures`` is `true`, you can
    /// download read-only update packages from the online map area. Updates are prepared on a
    /// regular schedule and cached for download by all users of the offline map area. Sharing a
    /// single set of cached updates, rather than performing individual sync operations, reduces
    /// the load on the back-end services. This approach is scalable for large deployments but
    /// does not support offline editing. Set the
    /// ``DownloadPreplannedOfflineMapParameters/updateMode-swift.property`` to
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdates`` to use this approach.
    ///
    /// Note that scheduled updates is an optimization that must be enabled by the web map
    /// author when the map area is created.
    ///
    /// If both of the above ``OfflineMapUpdateCapabilities`` are `true`, and the feature services
    /// in your online map support creating new features, you can adopt a hybrid update model
    /// where you download read-only update packages while uploading new features directly to
    /// the feature service. This approach combines the scalability of downloading scheduled
    /// updates with the ability to collect data in the field. However, note that this approach
    /// is strictly add only, meaning that you cannot delete or edit features once they have
    /// been uploaded to the feature service. Set the
    /// ``DownloadPreplannedOfflineMapParameters/updateMode-swift.property`` to
    /// ``DownloadPreplannedOfflineMapParameters/UpdateMode-swift.enum/downloadScheduledUpdatesAndUploadNewFeatures`` to use this
    /// approach.
    ///
    /// This property will return `nil` until the preplanned map area is loaded.
    final public var updateCapabilities: ArcGIS.OfflineMapUpdateCapabilities? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension PreplannedMapArea.PackagingStatus : Equatable {
}

extension PreplannedMapArea.PackagingStatus : Hashable {
}

/// The result of a proximity operation.
/// - Note: See Also: ``GeometryEngine/nearestCoordinate(in:to:)``,
/// ``GeometryEngine/nearestVertex(in:to:)``
/// - Since: 200.1
public struct ProximityResult : Hashable {

    /// The point found.
    public let coordinate: ArcGIS.Point

    /// The result distance.
    public let distance: Double

    /// The index of the part in which the point was found.
    public let partIndex: Int?

    /// The index of the point that was found within it's part.
    public let pointIndex: Int?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ProximityResult, b: ArcGIS.ProximityResult) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// An object that identifies the supported formats in which query results can be returned from a feature service.
/// - Since: 200.1
final public class QueryFormats {

    /// `true` if AMF is supported.
    final public var supportsAMF: Bool { get }

    /// `true` if the JSON is supported.
    final public var supportsJSON: Bool { get }

    /// `true` if the Protocolbuffers Binary Format is supported.
    final public var supportsPBF: Bool { get }
}

/// Parameters to perform a query on a dataset.
///
/// These parameters provide attribute, spatial, and temporal criteria that you can use to filter features.
/// You can define attribute criteria using a standard SQL expression based on the available attribute
/// fields, spatial criteria using a geometry and a spatial relationship (such as within, contains,
/// intersect), or temporal filters using a single date/time, or a range. You can also control how the
/// results are sorted and whether to return geometry.
///
/// In addition to querying features in a table, you can also use these parameters to count specific features,
/// calculate the extent of features, select features in layers, and populate service-based tables. If the query
/// method produces a set of features, they are returned in a ``FeatureQueryResult``.
///
/// Different query parameter objects are available to query data sources such as related features
/// (``RelatedQueryParameters``), statistical information (``StatisticsQueryParameters``), and portals
/// (``PortalQueryParameters``). Specialized query parameters also exist for working with utility networks and routing.
/// - Note: See Also: `FeatureTable.queryFeatures(using:)`, `FeatureTable.queryFeatureCount(using:)`, `FeatureTable.queryExtent(using:)`, `FeatureLayer.selectFeatures(using:mode:)`, `ServiceFeatureTable.populateFromService(using:clearCache:outFields:)`
/// - Since: 200.1
final public class QueryParameters {

    /// Creates a new query parameters object.
    public convenience init()

    /// The geometry used to filter the results.
    ///
    /// The geometry that (along with the ``spatialRelationship``) defines features to be included in the query.
    final public var geometry: ArcGIS.Geometry?

    /// The maximum allowable offset.
    final public var maxAllowableOffset: Double

    /// The maximum number of features the query should return.
    ///
    /// For consistent ordering of results when using pagination, provide a value for
    /// ``orderByFields``. Note that if you provide a maximum features value to support paging of
    /// results, you must also set a ``resultOffset`` value. Otherwise, the result may contain local
    /// features in place of server features if they satisfy the query. To ensure strict paging of server features,
    /// specify both maximum features and ``resultOffset``.
    final public var maxFeatures: Int

    /// The object ids of the features to query for.
    final public var objectIDs: [Int] { get }

    /// Adds a sequence of `Int` values to the end of the `objectIDs` property.
    /// - Parameter newObjectIDs: The new `Int` values to append.
    final public func addObjectIDs<S>(_ newObjectIDs: S) where S : Sequence, S.Element == Int

    /// Adds an `Int` value to the end of the `objectIDs` property.
    /// - Parameter newObjectID: The new `Int` value to append.
    final public func addObjectID(_ newObjectID: Int)

    /// Inserts a collection of `Int` values into the `objectIDs` property at the specified position.
    /// - Parameters:
    ///   - newObjectIDs: The new `Int` values to insert.
    ///   - index: The position at which to insert the new `Int` values.
    final public func insertObjectIDs<C>(_ newObjectIDs: C, at index: Int) where C : Collection, C.Element == Int

    /// Inserts an `Int` value into the `objectIDs` property at the specified position.
    /// - Parameters:
    ///   - newObjectID: The new `Int` value to insert.
    ///   - index: The position at which to insert the new `Int` value.
    final public func insertObjectID(_ newObjectID: Int, at index: Int)

    /// Removes all values from the `objectIDs` property.
    final public func removeAllObjectIDs()

    /// Removes a sequence of `Int` values from the `objectIDs` property.
    /// - Parameter objectIDs: The `Int` values to remove.
    final public func removeObjectIDs<S>(_ objectIDs: S) where S : Sequence, S.Element == Int

    /// Removes an `Int` value from the `objectIDs` property.
    /// - Parameter objectID: The `Int` value to remove.
    final public func removeObjectID(_ objectID: Int)

    /// The fields by which query results will be ordered.
    ///
    /// Results can be sorted by one or more fields. Each ``OrderBy`` instance includes a field name and whether to
    /// sort by that field in ascending or descending order. If a service-based table is being queried it must
    /// support advanced queries.
    final public var orderByFields: [ArcGIS.OrderBy] { get }

    /// Adds a sequence of `OrderBy` values to the end of the `orderByFields` property.
    /// - Parameter newOrderByFields: The new `OrderBy` values to append.
    final public func addOrderByFields<S>(_ newOrderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Adds an `OrderBy` value to the end of the `orderByFields` property.
    /// - Parameter newOrderByField: The new `OrderBy` value to append.
    final public func addOrderByField(_ newOrderByField: ArcGIS.OrderBy)

    /// Inserts a collection of `OrderBy` values into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByFields: The new `OrderBy` values to insert.
    ///   - index: The position at which to insert the new `OrderBy` values.
    final public func insertOrderByFields<C>(_ newOrderByFields: C, at index: Int) where C : Collection, C.Element == ArcGIS.OrderBy

    /// Inserts an `OrderBy` value into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByField: The new `OrderBy` value to insert.
    ///   - index: The position at which to insert the new `OrderBy` value.
    final public func insertOrderByField(_ newOrderByField: ArcGIS.OrderBy, at index: Int)

    /// Removes all values from the `orderByFields` property.
    final public func removeAllOrderByFields()

    /// Removes a sequence of `OrderBy` values from the `orderByFields` property.
    /// - Parameter orderByFields: The `OrderBy` values to remove.
    final public func removeOrderByFields<S>(_ orderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Removes an `OrderBy` value from the `orderByFields` property.
    /// - Parameter orderByField: The `OrderBy` value to remove.
    final public func removeOrderByField(_ orderByField: ArcGIS.OrderBy)

    /// The spatial reference of the feature results' geometry.
    ///
    /// If not specified, geometries are returned in the spatial reference of the service.
    final public var outSpatialReference: ArcGIS.SpatialReference?

    /// The starting offset of results to fetch. This is useful for paging through results.
    ///
    /// For consistent ordering of results when using pagination, you should also provide a value for the
    /// ``orderByFields``. Note that if you provide a result offset to support paging of
    /// results, you must also set a ``maxFeatures`` value. Otherwise, the result offset
    /// is ignored.
    final public var resultOffset: Int

    /// `true` if geometry values are returned in the results, otherwise `false`.
    ///
    /// This is needed when you want to display the features on a map or a scene. When querying
    /// non-spatial data, results do not include geometry.
    final public var returnsGeometry: Bool

    /// The spatial relationship that (along with the ``geometry``) defines features to be included in the query.
    ///
    /// The default spatial relationship is ``SpatialRelationship/intersects``.
    final public var spatialRelationship: ArcGIS.SpatialRelationship

    /// A span of time used to query features in a time-aware feature layer.
    ///
    /// You can apply a temporal filter on any ``FeatureLayer`` that supports time filtering
    /// (``FeatureLayer/supportsTimeFiltering``). Set the ``TimeExtent/startDate`` and
    /// ``TimeExtent/endDate`` to query features across a span of time. A single point in time can be
    /// queried by setting them to the same time value.
    ///
    /// By default, this value is `nil` and no time criteria is applied by the query.
    final public var timeExtent: ArcGIS.TimeExtent?

    /// The attribute expression that defines features to be included in the query.
    ///
    /// The where clause should follow standard SQL syntax similar to that discussed in the document
    /// [SQL reference for query expressions used in ArcGIS](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm#GUID-940733A1-D6D1-4200-B290-24CA2E1056D4)
    ///
    /// If the where clause includes dates, they must be correctly formatted based on the geodatabase datasource
    /// used in the service. Refer to [Dates and time](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm#GUID-85C03D85-F4A5-48FC-8E8C-3F79919430DB)
    /// for date formats expected by different data sources.
    ///
    /// ``ArcGISFeatureTable`` objects expect that any ``FieldType/globalID`` or ``FieldType/guid`` parameters in the
    /// where clause are formatted as: '{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}'. All characters are uppercase, wrapped
    /// in curly braces and surrounded by single quotes.
    ///
    /// If the where clause is used to populate an ``OGCFeatureCollectionTable``, you can use a CQL2-TEXT or
    /// CQL2-JSON string as defined in the document
    /// [OGC API - Features - Part3](https://docs.opengeospatial.org/DRAFTS/19-079r1.html).
    final public var whereClause: String
}

/// A RGB renderer object which is derived from a base stretch renderer object.
/// - Note: See Also: ``RasterRenderer``, ``BaseStretchRenderer``
/// - Since: 200.1
final public class RGBRenderer : ArcGIS.BaseStretchRenderer {

    /// The list of raster pansharpen types.
    ///
    /// This is used to determine the raster pansharpen types.
    public enum PansharpenType {

        /// IHS (intensity/hue/saturation) pansharpen type.
        case ihs

        /// Brovey pansharpen type.
        case brovey

        /// Mean pansharpen type.
        case mean

        /// Esri pansharpen type.
        case esri

        /// Gram-Schmidt pansharpen type.
        case gramSchmidt

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.RGBRenderer.PansharpenType, b: ArcGIS.RGBRenderer.PansharpenType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a RGB renderer.
    /// - Parameters:
    ///   - stretchParameters: The stretch parameters object.
    ///   - bandIndexes: The band indexes in which the raster is displayed.
    ///   - gammas: Gamma adjustment. An `Array` of double. Can be `nil`.
    ///   - estimatesStatistics: Estimates statistics
    ///   - pansharpenType: ``PansharpenType-swift.enum``
    ///   - panchromaticRaster: Panchromatic raster, ``Raster``.
    ///   - weights: Band weights value for pansharpening. An `Array` of double.
    public convenience init(stretchParameters: ArcGIS.StretchParameters?, bandIndexes: [Int], gammas: [Double], estimatesStatistics: Bool, pansharpenType: ArcGIS.RGBRenderer.PansharpenType? = nil, panchromaticRaster: ArcGIS.Raster? = nil, weights: [Double] = [])

    /// Band index array.
    final public var bandIndexes: [Int] { get }

    /// Panchromatic raster.
    final public var panchromaticRaster: ArcGIS.Raster? { get }

    /// Pansharpen type.
    final public var pansharpenType: ArcGIS.RGBRenderer.PansharpenType? { get }

    /// Pansharpen weight array.
    final public var weights: [Double] { get }
}

extension RGBRenderer.PansharpenType : Equatable {
}

extension RGBRenderer.PansharpenType : Hashable {
}

/// An object that specifies a range of valid values for a ``Field``.
/// - Since: 200.1
final public class RangeDomain : ArcGIS.Domain {

    /// The range domain's maximum value.
    final public var maxValue: Any? { get }

    /// The range domain's minimum value.
    final public var minValue: Any? { get }
}

/// An object that describes a ``RangeDomain`` to be created.
///
/// Creation of domains is currently only supported on mobile geodatabases,
/// either created in ArcGIS Pro or via `Geodatabase.createEmpty(fileURL:)`.
/// - Since: 200.1
final public class RangeDomainDescription : ArcGIS.DomainDescription {

    /// The range domain's maximum value.
    ///
    /// For fields that utilize a range domain, the field type must match the type
    /// of the min and max values.
    final public var maxValue: Any { get }

    /// The range domain's minimum value.
    ///
    /// For fields that utilize a range domain, the field type must match the type
    /// of the minimum and maximum values.
    final public var minValue: Any { get }
}

extension RangeDomainDescription {

    /// Creates a new range domain description object with the specified name and range.
    /// - Parameters:
    ///   - name: The range domain's name.
    ///   - range: The range of the domain.
    public convenience init(name: String, range: ClosedRange<Date>)

    /// Creates a new range domain description object with the specified name and range.
    /// - Parameters:
    ///   - name: The range domain's name.
    ///   - range: The range of the domain.
    public convenience init(name: String, range: ClosedRange<Double>)

    /// Creates a new range domain description object with the specified name and range.
    /// - Parameters:
    ///   - name: The range domain's name.
    ///   - range: The range of the domain.
    public convenience init(name: String, range: ClosedRange<Float>)

    /// Creates a new range domain description object with the specified name and range.
    /// - Parameters:
    ///   - name: The range domain's name.
    ///   - range: The range of the domain.
    public convenience init(name: String, range: ClosedRange<Int16>)

    /// Creates a new range domain description object with the specified name and range.
    /// - Parameters:
    ///   - name: The range domain's name.
    ///   - range: The range of the domain.
    public convenience init(name: String, range: ClosedRange<Int32>)

    /// Creates a new range domain description object with the specified name and range.
    /// - Parameters:
    ///   - name: The range domain's name.
    ///   - range: The range of the domain.
    public convenience init(name: String, range: ClosedRange<Int64>)
}

/// The raster object.
///
/// This is the raster data source object.
/// - Since: 200.1
public class Raster : ArcGIS.Loadable {

    /// Creates a raster with path.
    ///
    /// The object created is a raster data source object.
    /// - Parameter fileURL: Path of raster data source, can be local path or network path.
    public convenience init(fileURL: URL)

    /// Creates a raster object from raster function.
    ///
    /// The object created is a raster data source object.
    /// - Parameter rasterFunction: The raster function object.
    public convenience init(rasterFunction: ArcGIS.RasterFunction)

    /// The path in a raster object.
    public var fileURL: URL? { get }

    /// Raster function in a raster object.
    public var function: ArcGIS.RasterFunction? { get }

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

/// A raster cell
///
/// A RasterCell is a specific type of ``GeoElement`` used to represent the
/// values of a specific pixel in a ``RasterLayer``.
/// - Note: See Also: ``RasterLayer``
/// - Since: 200.1
final public class RasterCell : ArcGIS.GeoElement {

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    final public var attributes: [String : Any] { get }

    /// The geometry defines the shape and location of the ``GeoElement``.
    final public var geometry: ArcGIS.Geometry? { get }
}

/// An instance of this class represents an elevation source that can visualize raster elevation files.
/// - Since: 200.1
final public class RasterElevationSource : ArcGIS.ElevationSource {

    /// Creates a raster elevation source using an `Array` of type `String` with file paths of raster elevation files.
    ///
    /// A raster elevation source is added to a ``Surface`` and provides elevation data on which layers may be
    /// draped or offset from. The ArcGIS tiled elevation source uses a list of raster files to provide the elevation data.
    /// - Parameter fileURLs: The list of file paths of raster elevation sources.
    public convenience init(fileURLs: [URL] = [])

    /// The list of raster files that will be used for the elevation source.
    ///
    /// The `Array` of type `String` with raster files that will be used for the elevation source.
    /// This method can only be called if file paths have not already been set else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(fileURLs:)``
    final public var fileURLs: [URL] { get }

    /// Adds a sequence of `URL` values to the end of the `fileURLs` property.
    /// - Parameter newFileURLs: The new `URL` values to append.
    final public func addFileURLs<S>(_ newFileURLs: S) where S : Sequence, S.Element == URL

    /// Adds an `URL` value to the end of the `fileURLs` property.
    /// - Parameter newFileURL: The new `URL` value to append.
    final public func addFileURL(_ newFileURL: URL)

    /// Inserts a collection of `URL` values into the `fileURLs` property at the specified position.
    /// - Parameters:
    ///   - newFileURLs: The new `URL` values to insert.
    ///   - index: The position at which to insert the new `URL` values.
    final public func insertFileURLs<C>(_ newFileURLs: C, at index: Int) where C : Collection, C.Element == URL

    /// Inserts an `URL` value into the `fileURLs` property at the specified position.
    /// - Parameters:
    ///   - newFileURL: The new `URL` value to insert.
    ///   - index: The position at which to insert the new `URL` value.
    final public func insertFileURL(_ newFileURL: URL, at index: Int)

    /// Removes all values from the `fileURLs` property.
    final public func removeAllFileURLs()

    /// Removes a sequence of `URL` values from the `fileURLs` property.
    /// - Parameter fileURLs: The `URL` values to remove.
    final public func removeFileURLs<S>(_ fileURLs: S) where S : Sequence, S.Element == URL

    /// Removes an `URL` value from the `fileURLs` property.
    /// - Parameter fileURL: The `URL` value to remove.
    final public func removeFileURL(_ fileURL: URL)

    /// The extent of the elevation source.
    final public var fullExtent: ArcGIS.Envelope? { get }
}

/// The raster function object.
/// - Since: 200.1
final public class RasterFunction {

    /// Creates a raster function object from JSON file.
    ///
    /// Creates a raster function object from JSON.
    /// - Parameter fileURL: Path of a JSON file that represents a raster function chain.
    public convenience init(fileURL: URL)

    /// Function arguments from a raster function.
    ///
    /// Arguments defined in the raster function.
    final public var arguments: ArcGIS.RasterFunctionArguments? { get }

    /// Creates a raster function object from JSON string.
    ///
    /// Creates a raster function object from JSON.
    /// - Parameter json: A JSON string that represents a raster function chain.
    /// - Returns: A new raster function object.
    final public class func fromJSON(_ json: String) throws -> Self
}

/// The raster function arguments object.
/// - Since: 200.1
final public class RasterFunctionArguments {

    /// Creates a raster function arguments object to be used in a raster function.
    public convenience init()

    /// Argument variable names in the raster function arguments.
    ///
    /// Use `RasterFunctionArguments.setValue(_:forArgumentNamed:)` to set value for argument variable.
    final public var argumentNames: [String] { get }

    /// Raster variable names in the raster function arguments.
    ///
    /// Use `RasterFunctionArguments.setRaster(_:forArgumentNamed:)` to set value for raster variable.
    final public var rasterNames: [String] { get }

    /// Sets raster value for the specified raster variable.
    /// - Parameters:
    ///   - raster: Raster object.
    ///   - argumentName: Argument name.
    final public func setRaster(_ raster: ArcGIS.Raster, forArgumentNamed argumentName: String)

    /// Sets argument value for the specified argument variable.
    /// - Parameters:
    ///   - value: Argument value.
    ///   - argumentName: Argument name.
    final public func setValue(_ value: String, forArgumentNamed argumentName: String)
}

/// Displays raster data in a map or scene.
///
/// In its simplest form, raster data consists of a matrix of cells (or pixels) organized into
/// rows and columns (or a grid) where each cell contains a value representing information.
/// Raster layer can support these main types of raster data sources:
/// * Raster files - path to a file on the device
/// * Remote ArcGIS Image services, see ``ImageServiceRaster``
/// * Raster files within GeoPackages, see ``GeoPackageRaster``
/// * Mosaic datasets, see ``MosaicDatasetRaster``
///
/// You can change how a raster layer is visualized by creating a ``RasterRenderer`` and
/// applying it to the layer. Each raster layer supports identify on its individual cells when
/// it is displayed in a `MapView` or `SceneView`. The raster layer adopts the loadable
/// pattern; many of its properties are initialized asynchronously. See ``Loadable`` for more
/// information.
///
/// If a raster dataset has just one value associated with each cell it is called a single-band
/// raster. For example, in a digital elevation model (DEM) each cell contains one value
/// representing the elevation at that location.
///
/// A satellite image, however, commonly has multiple bands representing different wavelengths
/// of the electromagnetic spectrum. Landsat imagery, for example, contains seven bands that
/// represent data from the visible and infrared parts of the spectrum. Rasters are
/// particularly useful for remote sensing tasks, such as monitoring vegetation and seeing
/// through smoke to analyze an active fire.
///
/// Raster datasets can be quite large. The size of the dataset depends on the following:
/// * The geographic extent of the data
/// * The size of the cells used (resolution)
/// * The number of bands
///
/// As with any data consumed locally, file size can be an issue for storage as well as for
/// transferring datasets over the network.
/// - Note: See Also: ``Layer``, ``ImageAdjustmentLayer``, ``Raster``, ``ImageServiceRaster``, ``GeoPackageRaster``, ``MosaicDatasetRaster``,
/// - Since: 200.1
final public class RasterLayer : ArcGIS.ImageAdjustmentLayer, ArcGIS.PopupSource, ArcGIS.TimeAware {

    /// Creates a new raster layer object from a image service portal item.
    /// - Parameter item: A image service ``PortalItem``.
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// Creates a raster layer object.
    ///
    /// Use this function to create a raster layer from the input raster data source.
    /// - Parameter raster: Raster data source object.
    public convenience init(raster: ArcGIS.Raster)

    /// The raster source on this layer.
    final public var raster: ArcGIS.Raster? { get }

    /// The raster renderer for this layer
    final public var renderer: ArcGIS.RasterRenderer?

    /// The pop-up definition.
    ///
    /// The ``PopupDefinition`` associated with the popup source.
    final public var popupDefinition: ArcGIS.PopupDefinition?

    /// A flag indicating whether the ``PopupDefinition`` defined on the ``PopupSource`` is enable / disable.
    final public var popupsAreEnabled: Bool

    /// The full time extent of the object.
    @ArcGIS.Streamed final public var fullTimeExtent: ArcGIS.TimeExtent? { get }

    final public var $fullTimeExtent: AsyncStream<ArcGIS.TimeExtent?> { get }

    /// A flag indicating whether the object supports filtering its contents by time values with the extent set on the owning `GeoView`.
    final public var supportsTimeFiltering: Bool { get }

    /// A flag indicating whether the object must use the time extent defined on the owning `GeoView` to filter its data.
    final public var timeFilteringIsEnabled: Bool

    /// The suggested time slider step size for this time aware object.
    ///
    /// Can be `nil` if no time interval is suggested for this time aware object.
    final public var timeInterval: ArcGIS.TimeValue? { get }

    /// The time offset applied to this object.
    /// The offset is subtracted from the time extent set on the owning `GeoView`.
    /// This allows for data from different periods of time to be compared.
    final public var timeOffset: ArcGIS.TimeValue?
}

/// A raster renderer object.
///
/// This is the top level raster renderer object.
/// - Since: 200.1
public class RasterRenderer {
}

/// Raster sublayer source is a file-based raster that resides in a registered raster workspace.
/// - Note: See Also: ``TableSublayerSource``, ``TableJoinSublayerSource``, ``TableQuerySublayerSource``, ``MapSublayerSource``, `RasterSublayerSource.Type`
/// - Since: 200.1
final public class RasterSublayerSource : ArcGIS.SublayerSource {

    /// Create a raster sublayer source from a workspace ID and a data source name.
    /// - Parameters:
    ///   - workspaceID: The workspace id.
    ///   - dataSourceName: The data source name.
    /// - Note: See Also: ``SublayerSource``, ``ArcGISMapImageSublayer/source``
    public convenience init(workspaceID: String, dataSourceName: String)

    /// The data source name.
    final public var dataSourceName: String { get }

    /// The workspace id.
    final public var workspaceID: String { get }
}

/// Contains the features that have been returned from a related tables query.
///
/// Instances of this class represents the result of related queries. A
/// prerequisite for querying related features is that all the participating
/// tables must be part of a map, as either feature layers or non-spatial
/// tables. An array of instances are returned, one per related table containing
/// features related to the queried feature. This class has methods that can be
/// used to iterate over the collection of related features.
/// - Since: 200.1
final public class RelatedFeatureQueryResult : ArcGIS.FeatureSet {

    /// The feature for which related features were queried.
    final public var feature: ArcGIS.ArcGISFeature? { get }

    /// The related table for this query result.
    ///
    /// There can be more than one instance of the same table or layer on the map
    /// with different scale level visibility, definition expression, and so on.
    /// All such instances share the same RelationshipInfo with the table the
    /// query operation is called on. In such cases, results from all such instances
    /// are returned, and the relatedTable property is used to distinguish between them.
    final public var relatedTable: ArcGIS.ArcGISFeatureTable? { get }

    /// Relationship info
    ///
    /// If more than one related table were queried, multiple results are returned,
    /// each with its RelationshipInfo.
    final public var relationshipInfo: ArcGIS.RelationshipInfo? { get }

    /// `true` if the query resulted in a larger number of features than what the transfer limit supports.
    ///
    /// Many ArcGIS services only return up to 1000 features even if the query matched more features.
    /// When that happens for the query that produces this result, this property is `true`.
    final public var transferLimitWasExceeded: Bool { get }

    /// The fields of the feature set.
    /// - Note: See Also: `Array`, ``Field``
    final public var fields: [ArcGIS.Field] { get }

    /// The geometry type stored in this feature set.
    final public var geometryType: ArcGIS.Geometry.Type? { get }

    /// The spatial reference of the feature set.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// Returns the feature iterator.
    /// - Returns: An `AnySequence` that returns ``Feature`` types.
    final public func features() -> AnySequence<ArcGIS.Feature>
}

/// Parameters to perform a related query on an ``ArcGISFeatureTable``.
///
/// When querying related features, all participating tables must be included in the same ``Map`` or
/// ``Scene``, as either feature layers or non-spatial tables. The query that uses these parameters will
/// load these related tables.
///
/// ``RelatedQueryParameters`` lets you specify:
/// * Details about the relationship to be queried.
/// * A where clause used to filter features from the related table.
/// * How to sort the results.
/// * Whether to return geometry within the results.
/// - Note: See Also: `ArcGISFeatureTable.queryRelatedFeatures(to:using:)`, `ServiceFeatureTable.queryRelatedFeatures(to:using:queryFeatureFields:)`.
/// - Since: 200.1
final public class RelatedQueryParameters {

    /// Creates related query parameters with the specified relationship information.
    /// - Parameter relationshipInfo: The relationship information between related tables.
    public convenience init(relationshipInfo: ArcGIS.RelationshipInfo)

    /// The maximum number of features the query should return.
    ///
    /// For consistent ordering of results when using pagination, provide a value for
    /// ``orderByFields``. Note that if you provide a maximum features value to
    /// support paging of results, you must also set a ``QueryParameters/resultOffset`` value. Otherwise,
    /// the result may contain local features in place of server features if they satisfy the query. To
    /// ensure strict paging of server features, specify both maximum features and
    /// ``resultOffset``.
    final public var maxFeatures: Int

    /// The collection of order by objects that indicates how to sort the results.
    ///
    /// Results can be sorted by one or more fields. Each order by instance includes a field name and whether to
    /// sort by that field in ascending or descending order. If a service-based table is being queried it must
    /// support advanced queries.
    final public var orderByFields: [ArcGIS.OrderBy] { get }

    /// Adds a sequence of `OrderBy` values to the end of the `orderByFields` property.
    /// - Parameter newOrderByFields: The new `OrderBy` values to append.
    final public func addOrderByFields<S>(_ newOrderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Adds an `OrderBy` value to the end of the `orderByFields` property.
    /// - Parameter newOrderByField: The new `OrderBy` value to append.
    final public func addOrderByField(_ newOrderByField: ArcGIS.OrderBy)

    /// Inserts a collection of `OrderBy` values into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByFields: The new `OrderBy` values to insert.
    ///   - index: The position at which to insert the new `OrderBy` values.
    final public func insertOrderByFields<C>(_ newOrderByFields: C, at index: Int) where C : Collection, C.Element == ArcGIS.OrderBy

    /// Inserts an `OrderBy` value into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByField: The new `OrderBy` value to insert.
    ///   - index: The position at which to insert the new `OrderBy` value.
    final public func insertOrderByField(_ newOrderByField: ArcGIS.OrderBy, at index: Int)

    /// Removes all values from the `orderByFields` property.
    final public func removeAllOrderByFields()

    /// Removes a sequence of `OrderBy` values from the `orderByFields` property.
    /// - Parameter orderByFields: The `OrderBy` values to remove.
    final public func removeOrderByFields<S>(_ orderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Removes an `OrderBy` value from the `orderByFields` property.
    /// - Parameter orderByField: The `OrderBy` value to remove.
    final public func removeOrderByField(_ orderByField: ArcGIS.OrderBy)

    /// The relationship information used to define the tables to use for this query.
    final public var relationshipInfo: ArcGIS.RelationshipInfo

    /// The starting offset of results to fetch. This is useful for paging through results.
    ///
    /// For consistent ordering of results when using pagination, you should also provide a value for the
    /// ``orderByFields``. Note that if you provide a result offset to support paging of
    /// results, you must also set a ``maxFeatures`` value. Otherwise, the result offset
    /// is ignored.
    final public var resultOffset: Int

    /// `true` if geometry values are returned in the results, otherwise `false`.
    ///
    /// This is needed when you want to display the features on a map or a scene. When querying non-spatial data, results do not include geometry.
    final public var returnsGeometry: Bool

    /// The where clause to apply to the destination table.
    ///
    /// The where clause should follow standard SQL syntax similar to that discussed in the document
    /// [SQL reference for query expressions used in ArcGIS](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm#GUID-940733A1-D6D1-4200-B290-24CA2E1056D4).
    ///
    /// If the where clause includes dates, they must be correctly formatted based on the geodatabase datasource
    /// used in the service. Refer to [Dates and time](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm#GUID-85C03D85-F4A5-48FC-8E8C-3F79919430DB)
    /// for date formats expected by different data sources.
    ///
    /// ``ArcGISFeatureTable`` objects expect that any ``FieldType/globalID`` or ``FieldType/guid`` parameters in the
    /// where clause are formatted as: '{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}'. All characters are uppercase, wrapped
    /// in curly braces and surrounded by single quotes.
    final public var whereClause: String
}

/// The various constraint violations that may occur when relating two features.
/// - Since: 200.1
public enum RelationshipConstraintViolationType {

    /// There are no constraint violations.
    case noViolations

    /// Cardinality of the given feature is violated.
    case cardinality

    /// The given feature is an orphaned destination feature in a composite relationship. Note: Orphaned destination feature in a simple relationship is not considered a violation.
    case orphaned

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.RelationshipConstraintViolationType, b: ArcGIS.RelationshipConstraintViolationType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension RelationshipConstraintViolationType : Equatable {
}

extension RelationshipConstraintViolationType : Hashable {
}

/// An object that defines information about the relationship between tables.
///
/// A relationship consists of two and only two tables, each having one of these
/// roles in the relationship:
///  - Origin table, sometimes referred to as the source table or original table.
///  - Destination table.
///
/// One table must have one of these roles and the other table must have the
/// other role. A table can participate in more than one relationship. Further, a
/// table may be an origin table in one relationship and also a destination table
/// in another relationship.
/// The relationship's cardinality describes whether features in a table are
/// related to only one feature in the other table, or whether a feature may be
/// related to multiple features.
/// In a simple relationship, the features in the participating tables can exist
/// without the other. For example, a transformer and an electric pole may be
/// related but one's existence does not depend on the other. Deleting the origin
/// features will simply disassociate the destination features from the origin
/// features.
/// In a composite relationship, the destination features cannot exist without
/// the origin features. When the origin feature is deleted, the related
/// destination feature is deleted as well. This is called a cascade delete. This
/// dependency also means that each destination feature must be linked to a
/// counterpart origin feature.
/// - Since: 200.1
final public class RelationshipInfo {

    /// An enumeration of the different cardinalities of feature table relationships.
    public enum Cardinality {

        /// Features in both tables may be related to any number of features in the other table..
        case manyToMany

        /// An origin feature can be related to any number of features in the destination table.
        case oneToMany

        /// An origin feature can be related to at most one feature in the destination table.
        case oneToOne

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.RelationshipInfo.Cardinality, b: ArcGIS.RelationshipInfo.Cardinality) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An enumeration of the different roles of feature table relationships.
    public enum Role {

        /// Represents the destination table in a relationship.
        case destination

        /// Represents the origin table in a relationship.
        case origin

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.RelationshipInfo.Role, b: ArcGIS.RelationshipInfo.Role) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The cardinality of this relationship.
    final public var cardinality: ArcGIS.RelationshipInfo.Cardinality { get }

    /// The ID of this relationship.
    ///
    /// The relationship ID is shared between the origin and destination tables.
    final public var id: Int { get }

    /// Whether this is a composite relationship.
    ///
    /// In a composite relationship, a feature in the destination table must
    /// always be associated with an origin feature. Orphan features in
    /// the destination tables are not permitted. Therefore, destination table
    /// features will be deleted when their associated origin table features are
    /// deleted (this is called a cascade delete).
    final public var isComposite: Bool { get }

    /// The key field, the field that links the origin and destination tables of this relationship.
    final public var keyField: String { get }

    /// The key field in the relationship table.
    ///
    /// Used in many-to-many and attributed relationships.
    /// Values in this field will match values stored in the ``keyField`` of features participating in the relationship.
    final public var keyFieldInRelationshipTable: String { get }

    /// The name of the relationship.
    final public var name: String { get }

    /// The ID of the related table.
    final public var relatedTableID: Int { get }

    /// The role that this table has in this relationship.
    final public var role: ArcGIS.RelationshipInfo.Role { get }
}

extension RelationshipInfo {

    /// The ID of the relationship table. A value of `nil` indicates that no table exists.
    /// - Remark: The relationship table is used in many-to-many and attributed relationships.
    final public var relationshipTableID: Int? { get }
}

extension RelationshipInfo.Cardinality : Equatable {
}

extension RelationshipInfo.Cardinality : Hashable {
}

extension RelationshipInfo.Role : Equatable {
}

extension RelationshipInfo.Role : Hashable {
}

/// Represents a pop-up element of type relationship that is displayed in a pop-up for a geoelement.
///
/// A typical UI implementation displays a preview of ``displayCount`` related records
/// with a possibility to show more records and more detailed info by record.
/// - Note: See Also: `PopupElement.Type`, ``PopupElement``
/// - Since: 200.1
final public class RelationshipPopupElement : ArcGIS.PopupElement {

    /// Creates a new relationship pop-up element with the given relationship ID.
    /// - Parameter relationshipID: The id of the relationship as defined in the feature layer definition.
    public convenience init(relationshipID: Int)

    /// A string value describing the element in detail. Can be an empty string.
    final public var description: String

    /// The maximum number of records to display.
    ///
    /// The default value is 3.
    ///
    /// If this maximum number is 0, no records will be displayed in the preview.
    final public var displayCount: Int

    /// An `Array` of ``OrderBy`` objects indicating the display order for the related records and whether they should be sorted in ascending or descending order.
    ///
    /// If this collection is empty, the related records are displayed in whatever order the server decides.
    /// - Note: See Also: ``OrderBy/SortOrder-swift.enum``
    final public var orderByFields: [ArcGIS.OrderBy] { get }

    /// Adds a sequence of `OrderBy` values to the end of the `orderByFields` property.
    /// - Parameter newOrderByFields: The new `OrderBy` values to append.
    final public func addOrderByFields<S>(_ newOrderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Adds an `OrderBy` value to the end of the `orderByFields` property.
    /// - Parameter newOrderByField: The new `OrderBy` value to append.
    final public func addOrderByField(_ newOrderByField: ArcGIS.OrderBy)

    /// Inserts a collection of `OrderBy` values into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByFields: The new `OrderBy` values to insert.
    ///   - index: The position at which to insert the new `OrderBy` values.
    final public func insertOrderByFields<C>(_ newOrderByFields: C, at index: Int) where C : Collection, C.Element == ArcGIS.OrderBy

    /// Inserts an `OrderBy` value into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByField: The new `OrderBy` value to insert.
    ///   - index: The position at which to insert the new `OrderBy` value.
    final public func insertOrderByField(_ newOrderByField: ArcGIS.OrderBy, at index: Int)

    /// Removes all values from the `orderByFields` property.
    final public func removeAllOrderByFields()

    /// Removes a sequence of `OrderBy` values from the `orderByFields` property.
    /// - Parameter orderByFields: The `OrderBy` values to remove.
    final public func removeOrderByFields<S>(_ orderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Removes an `OrderBy` value from the `orderByFields` property.
    /// - Parameter orderByField: The `OrderBy` value to remove.
    final public func removeOrderByField(_ orderByField: ArcGIS.OrderBy)

    /// The id of the relationship as defined in the feature layer definition.
    final public var relationshipID: Int { get }

    /// A string value indicating what the element represents. Can be an empty string.
    final public var title: String
}

/// A Renderer object.
/// - Since: 200.1
public class Renderer : ArcGIS.JSONSerializable {

    /// The renderer's rotation expression.
    public var rotationExpression: String

    /// The renderer's rotation type.
    public var rotationType: ArcGIS.RotationType

    /// The scene view properties for the renderer.
    public var sceneProperties: ArcGIS.RendererSceneProperties

    /// Clones the ``Renderer``.
    /// - Returns: A new ``Renderer`` with the same values as the current ``Renderer``.
    public func clone() -> Self

    /// Returns the symbol that should be used to visualize the given dynamic entity with override attributes from the renderer.
    ///
    /// If applyAttributeOverrides is set to `true`, this method will get the symbol from the renderer and override the symbol properties with the
    /// overrides available on the renderer. These include visual variable size, color, opacity and rotation.
    /// If the override expression or attributes contain any information not known to either the renderer or dynamic entity (such as "scale"), that override will not be applied.
    /// If the override attributes are applied successfully a multilayer symbol will be returned else the original symbol will be returned.
    /// - Parameters:
    ///   - dynamicEntity: The dynamic entity.
    ///   - applyAttributeOverrides: If set to `true`, this applies the override attributes from the renderer to the symbol.
    /// - Returns: A ``Symbol``.
    public func symbol(for dynamicEntity: ArcGIS.DynamicEntity, applyAttributeOverrides: Bool = false) -> ArcGIS.Symbol?

    /// Returns the symbol that should be used to visualize the given dynamic entity observation with override attributes from the renderer.
    ///
    /// If applyAttributeOverrides is set to `true`, this method will get the symbol from the renderer and override the symbol properties with the
    /// overrides available on the renderer. These include visual variable size, color, opacity and rotation.
    /// If the override expression or attributes contain any information not known to either the renderer or observation (such as "scale"), that override will not be applied.
    /// If the override attributes are applied successfully a multilayer symbol will be returned else the original symbol will be returned.
    /// - Parameters:
    ///   - dynamicEntityObservation: The dynamic entity observation.
    ///   - applyAttributeOverrides: If set to `true`, this applies the override attributes from the renderer to the symbol.
    /// - Returns: A ``Symbol``.
    public func symbol(for dynamicEntityObservation: ArcGIS.DynamicEntityObservation, applyAttributeOverrides: Bool = false) -> ArcGIS.Symbol?

    /// Returns the symbol that should be used to visualize the given feature with override attributes from renderer.
    ///
    /// If applyAttributeOverrides is set to `true` this method will get the symbol from renderer and override the symbol properties with the
    /// overrides available on renderer. Like visual variable size, color, opacity and rotation.
    /// If the override expression or attributes contain any information not known to the renderer or feature that will not be
    /// evaluated e.g. "scale" and that override will not be applied.
    /// If the override attributes are applied successfully it will return a multilayer symbol else original symbol will be returned.
    /// - Parameters:
    ///   - feature: The feature.
    ///   - applyAttributeOverrides: boolean value if set to `true` applies the override attributes from renderer.
    /// - Returns: A ``Symbol``.
    public func symbol(for feature: ArcGIS.Feature, applyAttributeOverrides: Bool = false) -> ArcGIS.Symbol?

    /// Returns the symbol that should be used to visualize the given graphic with override attributes from renderer.
    ///
    /// If applyAttributeOverrides is set to `true` this method will get the symbol from renderer and override the symbol properties with the
    /// overrides available on renderer. Like visual variable size, color, opacity and rotation.
    /// If the override expression or attributes contain any information not known to the renderer or graphic that will not be
    /// evaluated e.g. "scale" and that override will not be applied.
    /// If the override attributes are applied successfully it will return a multilayer symbol else original symbol will be returned.
    /// - Parameters:
    ///   - graphic: The graphic.
    ///   - applyAttributeOverrides: Boolean value if set to `true` applies the override attributes from renderer.
    /// - Returns: A ``Symbol``.
    public func symbol(for graphic: ArcGIS.Graphic, applyAttributeOverrides: Bool = false) -> ArcGIS.Symbol?

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension Renderer : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Renderer, rhs: ArcGIS.Renderer) -> Bool
}

extension Renderer : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Provides access to scene specific properties.
///
/// Scene properties can be retrieved from the ``Renderer``
/// and used to set scene specific properties defining the behavior in 3D
/// - Since: 200.1
final public class RendererSceneProperties {

    /// The options for handling extrusion values.
    public enum ExtrusionMode : CaseIterable {

        /// Set there to be no extrusion.
        case off

        /// Flat top, offset from minimum geometries vertex height.
        case minimum

        /// Flat top, offset from maximum geometries vertex height.
        case maximum

        /// Flat top, extrude to the specific height.
        case absoluteHeight

        /// Non-flat top.
        case baseHeight

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.RendererSceneProperties.ExtrusionMode, b: ArcGIS.RendererSceneProperties.ExtrusionMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.RendererSceneProperties.ExtrusionMode]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.RendererSceneProperties.ExtrusionMode] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new scene view properties object.
    public convenience init()

    /// Creates a new scene view properties object with extrusion properties.
    /// - Parameters:
    ///   - extrusionExpression: Extrusion expression to be used.
    ///   - extrusionMode: Extrusion mode to apply to the scene view properties ``ExtrusionMode-swift.enum``.
    public convenience init(extrusionExpression: String, extrusionMode: ArcGIS.RendererSceneProperties.ExtrusionMode)

    /// Creates a new scene view properties object with rotation properties
    /// - Parameters:
    ///   - headingExpression: Heading expression to be used.
    ///   - pitchExpression: A `String` to the pitch expression to be used.
    ///   - rollExpression: A `String` to the roll expression to be used.
    public convenience init(headingExpression: String, pitchExpression: String, rollExpression: String)

    /// The Extrusion expression in the Scene Properties.
    final public var extrusionExpression: String

    /// The Extrusion mode from the Scene Properties.
    final public var extrusionMode: ArcGIS.RendererSceneProperties.ExtrusionMode

    /// The Heading expression in the Scene Properties.
    final public var headingExpression: String

    /// The Pitch expression in the Scene Properties.
    final public var pitchExpression: String

    /// The Roll expression in the Scene Properties.
    final public var rollExpression: String
}

extension RendererSceneProperties.ExtrusionMode : Equatable {
}

extension RendererSceneProperties.ExtrusionMode : Hashable {
}

/// An instance of this class represents the rule for how the requested image should be rendered or processed.
///
/// A rendering rule defines the processing that is to be done to the ArcGIS image service.
/// An instance of this class can be created from a ``RenderingRuleInfo`` or a JSON
/// string that specifies a service-defined or client-defined rendering rule. See the following
/// document for a list of functions and the syntax for rendering rules:
/// [raster function objects](https://developers.arcgis.com/documentation/common-data-types/raster-function-objects.htm).
/// - Since: 200.1
final public class RenderingRule {

    /// Creates a rendering rule object with rendering rule info.
    /// - Parameter info: The rendering rule info object
    public convenience init(info: ArcGIS.RenderingRuleInfo)

    /// Creates a rendering rule object with server side JSON.
    /// - Parameter json: The JSON that could either be a raster function object used in the image service REST API or a predefined service rendering rule.
    public convenience init(json: String)

    /// Rendering rule info from rendering rule object.
    final public var info: ArcGIS.RenderingRuleInfo? { get }

    /// JSON property from rendering rule object.
    final public var json: String { get }
}

/// An object that represents information about a rendering rule that is predefined on an ArcGIS Image Service.
///
/// It can be used to construct a ``RenderingRule``. You can get this object from ``ArcGISImageServiceInfo/renderingRuleInfos``.
/// You can also create an instance of this class simply with the name of a service-defined rendering rule.
/// - Since: 200.1
final public class RenderingRuleInfo {

    /// Creates a rendering rule info object with the name of a predefined service rendering rule.
    /// - Parameter name: The predefined service rendering rule name.
    public convenience init(name: String)

    /// The description of a predefined service rendering rule.
    final public var description: String { get }

    /// The help of a predefined service rendering rule.
    final public var help: String { get }

    /// The name of a predefined service rendering rule.
    final public var name: String { get }
}

/// Specifies behavior of request interception.
/// - Since: 200.1
public enum RequestInterceptionDisposition<Output, Failure> where Failure : Error {

    /// The original unmodified request should be performed.
    case performOriginalRequest

    /// The original request should be ignored and different request should be performed.
    case performModifiedRequest(URLRequest)

    /// Do not perform the request, but send the specified result straight away.
    case sendResult(Result<Output, Failure>)
}

/// Represents the parameters that are used to perform automatic re-routing if off-route while navigating along a route.
///
/// This class defines how automatic re-routing calculations will be performed if off-route is detected while navigating
/// along a route.  To enable re-routing, call the `RouteTracker.enableRerouting(using:)` method
/// passing in this class as the argument.
///
/// Note that re-routing only occurs when the current location is off-route, but on or near the transportation network edges.
/// For example if an off-route state is detected but the tracked location is in a parking lot, away from any transportation
/// network edges, re-routing will not occur, and will occur only once a subsequent tracked location is on or near the
/// transportation network edges.
/// - Since: 200.1
final public class ReroutingParameters {

    /// Creates a Rerouting parameters.
    ///
    /// An exception is thrown if the ``RouteTask`` or ``RouteParameters`` are `nil`.
    /// - Parameters:
    ///   - routeTask: A ``RouteTask`` capable of solving routes on the same network used by the original route.
    ///   - routeParameters: Creates a re-routing parameters object based on a ``RouteTask`` and ``RouteParameters``.
    /// - Note: See Also: ``RouteResult``
    public convenience init?(routeTask: ArcGIS.RouteTask, routeParameters: ArcGIS.RouteParameters)

    /// A ``FeatureTable`` containing the ``Polyline`` geometries that the ``RouteTask``'s network is based on.
    /// During the re-routing the geometries are used to determine if the current location is on or near the
    /// navigation network. The re-routing calculation will be skipped if the current location is off the
    /// network. The geometry type of the feature table must Polyline.
    ///
    /// Setting this property is only needed when the ``RouteTask`` for the navigation is based on a service. When
    /// the ``RouteTask`` is based on local data on the device, access to the ``Polyline`` geometries is already
    /// available to the re-routing algorithm.
    ///
    /// The ``FeatureTable`` can be the original network source data or one created specifically for checking if
    /// located on an edge.
    ///
    /// If there are multiple sources the geometries should be merged into a single table.
    ///
    /// Only the geometries are needed in the ``FeatureTable``, not the attributes.
    ///
    /// Online feature service should support pagination, otherwise `RouteTracker.enableRerouting(using:)`
    /// will throw an exception. To improve performance online feature service should have a
    /// maxRecordCount >= 2000 (this decreases the count of online queries).
    final public var networkEdgeGeometries: ArcGIS.ArcGISFeatureTable?

    /// A ``RouteParameters`` object that defines parameters for the rerouting ``RouteTask``.
    ///
    /// The following ``RouteParameters`` properties will be ignored:
    /// `RouteParameters.setStops(fromFeaturesIn:queryParameters:)`, ``RouteParameters/findsBestSequence``,
    /// ``RouteParameters/outputSpatialReference``, ``RouteParameters/preservesFirstStop``,
    /// ``RouteParameters/startDate``, ``RouteParameters/returnsDirections``,
    /// ``RouteParameters/returnsStops``, and  ``RouteParameters/returnsRoutes``
    final public var routeParameters: ArcGIS.RouteParameters { get }

    /// A ``RouteTask`` capable of solving routes on the same network that created the original route.
    ///
    /// This is usually the same ``RouteTask`` that was used to create the route being tracked. The ``RouteTask``
    /// will be used for rerouting in background thread.
    final public var routeTask: ArcGIS.RouteTask { get }

    /// A rerouting strategy that determines how new routes are created (to the next waypoint by default).
    final public var strategy: ArcGIS.RouteTracker.ReroutingStrategy

    /// Whether the first stop must be visited when rerouted (`false` by default).
    final public var visitsFirstStopOnStart: Bool
}

/// A structure that describes a transportation network restriction attribute.
/// - Since: 200.1
final public class RestrictionAttribute {

    /// Parameter values.
    ///
    /// Restriction attribute's parameter values.
    /// - Note: See Also: `Array`
    final public var parameterValues: [String : Any] { get }

    /// Restriction usage parameter name.
    /// - Note: See Also: `String`
    final public var restrictionUsageParameterName: String { get }
}

/// Specifies the behavior of result interception.
/// - Since: 200.1
public enum ResultInterceptionDisposition<Output, Failure> where Failure : Error {

    /// The original unmodified result should be used.
    case sendOriginalResult

    /// A modified result should be used.
    case sendModifiedResult(Result<Output, Failure>)
}

/// Indicate the type of layers we wish to include attachments with when taking feature layers
/// offline.
/// - Since: 200.1
public enum ReturnLayerAttachmentOption {

    /// Don't include attachments when taking feature layers offline.
    case notIncluded

    /// Include attachments with all feature layers when taking offline.
    case allLayers

    /// Only include attachments with read-only feature layers when taking offline.
    case readOnlyLayers

    /// Only include attachments with editable feature layers when taking offline.
    ///
    /// For offline maps, a feature layer is considered to be editable if the feature service has capabilities that
    /// include any of create, update or delete.
    /// A read-only layer is one that supports sync, but does not have any of create, update or delete capability.
    /// Service capabilities are accessible from service infos see ``ArcGISFeatureServiceInfo/featureServiceCapabilities`` or ``ArcGISFeatureLayerInfo/capabilities``.
    case editableLayers

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ReturnLayerAttachmentOption, b: ArcGIS.ReturnLayerAttachmentOption) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ReturnLayerAttachmentOption : Equatable {
}

extension ReturnLayerAttachmentOption : Hashable {
}

/// A class that describes a reverse geocode method parameters.
///
/// Structure holding the parameters to support the reverse geocode operation for a geocoding service or local locator.
/// - Since: 200.1
final public class ReverseGeocodeParameters {

    /// Creates a new reverse geocode parameters object.
    public convenience init()

    /// Feature types.
    ///
    /// Determines what feature types of address which should be returned.
    /// - Note: See Also: `Array`
    final public var featureTypes: [String] { get }

    /// Adds a sequence of `String` values to the end of the `featureTypes` property.
    /// - Parameter newFeatureTypes: The new `String` values to append.
    final public func addFeatureTypes<S>(_ newFeatureTypes: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `featureTypes` property.
    /// - Parameter newFeatureType: The new `String` value to append.
    final public func addFeatureType(_ newFeatureType: String)

    /// Inserts a collection of `String` values into the `featureTypes` property at the specified position.
    /// - Parameters:
    ///   - newFeatureTypes: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertFeatureTypes<C>(_ newFeatureTypes: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `featureTypes` property at the specified position.
    /// - Parameters:
    ///   - newFeatureType: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertFeatureType(_ newFeatureType: String, at index: Int)

    /// Removes all values from the `featureTypes` property.
    final public func removeAllFeatureTypes()

    /// Removes a sequence of `String` values from the `featureTypes` property.
    /// - Parameter featureTypes: The `String` values to remove.
    final public func removeFeatureTypes<S>(_ featureTypes: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `featureTypes` property.
    /// - Parameter featureType: The `String` value to remove.
    final public func removeFeatureType(_ featureType: String)

    /// For storage property.
    ///
    /// Specifies whether the results of the operation will be persisted.
    /// The default value is `false`, which indicates the results of the operation can't be stored.
    /// If you store the results, in a database for example, you need to set this parameter to `true`.
    final public var isForStorage: Bool

    /// Distance specifying with location the area where candidates will be searched in meters. If `nil`, there is no maximum.
    ///
    /// Distance specifying with location the area where candidates will be searched [meters].
    /// Supported value in a range between 1000 and 50000 meters, 1000 meters by default.
    final public var maxDistance: Double?

    /// Max locations.
    ///
    /// Determines the maximum count of candidates which should be returned. By default should be returned all found candidates.
    final public var maxResults: Int

    /// Output language code.
    ///
    /// Determines addresses with which the language should be returned.
    /// - Note: See Also: `String`
    final public var outputLanguageCode: String

    /// Output spatial reference.
    ///
    /// The spatial reference for candidate geometries.
    /// - Note: See Also: ``SpatialReference``
    final public var outputSpatialReference: ArcGIS.SpatialReference?

    /// Array of geocode result attribute names indicating which attributes should be returned for every result.
    ///
    /// For empty array return only default attributes, "*" means all attributes will be returned.
    /// - Note: See Also: `Array`
    final public var resultAttributeNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `resultAttributeNames` property.
    /// - Parameter newResultAttributeNames: The new `String` values to append.
    final public func addResultAttributeNames<S>(_ newResultAttributeNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `resultAttributeNames` property.
    /// - Parameter newResultAttributeName: The new `String` value to append.
    final public func addResultAttributeName(_ newResultAttributeName: String)

    /// Inserts a collection of `String` values into the `resultAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newResultAttributeNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertResultAttributeNames<C>(_ newResultAttributeNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `resultAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newResultAttributeName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertResultAttributeName(_ newResultAttributeName: String, at index: Int)

    /// Removes all values from the `resultAttributeNames` property.
    final public func removeAllResultAttributeNames()

    /// Removes a sequence of `String` values from the `resultAttributeNames` property.
    /// - Parameter resultAttributeNames: The `String` values to remove.
    final public func removeResultAttributeNames<S>(_ resultAttributeNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `resultAttributeNames` property.
    /// - Parameter resultAttributeName: The `String` value to remove.
    final public func removeResultAttributeName(_ resultAttributeName: String)
}

/// The list of possible rotation types.
///
/// Controls the origin and direction of rotation of a symbol on a feature.
/// - Since: 200.1
public enum RotationType {

    /// The symbol is rotated from East in a counterclockwise direction where East is the 0 degrees axis.
    case arithmetic

    /// The symbol is rotated from North in a clockwise direction where North is the 0 degrees axis.
    case geographic

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.RotationType, b: ArcGIS.RotationType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension RotationType : Equatable {
}

extension RotationType : Hashable {
}

/// A route object contains information about single route.
///
/// A class that contains the output from a route task for a single route.
/// The route contains all necessary output from a successfully-
/// completed route task solve. This includes the cost, shape, and
/// additional metadata specific to the resulting route solution (e.g.,
/// route directions, local start/end time, etc.).
/// - Since: 200.1
final public class Route {

    /// Direction maneuver.
    ///
    /// The list of turn-by-turn directions for this route.
    /// - Note: See Also: `Array`, ``DirectionManeuver``
    final public var directionManeuvers: [ArcGIS.DirectionManeuver] { get }

    /// End time.
    ///
    /// Value of the end time.
    /// - Note: See Also: `Date`
    final public var endDate: Date? { get }

    /// The time zone shift for the end date.
    ///
    /// Value of time zone shift for end time, in minutes.
    final public var endDateShift: TimeInterval { get }

    /// Route's geometry.
    ///
    /// The geometry for the full route (polyline).
    /// - Note: See Also: ``Polyline``
    final public var geometry: ArcGIS.Polyline? { get }

    /// Route's name.
    ///
    /// The name of the route.
    /// - Note: See Also: `String`
    final public var name: String { get }

    /// Start time.
    ///
    /// Value of the start time.
    /// - Note: See Also: `Date`
    final public var startDate: Date? { get }

    /// The time zone shift for the start date.
    ///
    /// Value of time zone shift for start time, in minutes.
    final public var startDateShift: TimeInterval { get }

    /// Stops.
    ///
    /// Collection of output stops.
    /// - Note: See Also: `Array`, ``Stop``
    final public var stops: [ArcGIS.Stop] { get }

    /// Total length in meters.
    ///
    /// The total length of the route (meters).
    final public var totalLength: Measurement<UnitLength> { get }

    /// The total time for the route.
    ///
    /// This includes any travel time, time spent waiting at stops (arriving before the start of a time window), and service time at stops.
    final public var totalTime: TimeInterval { get }

    /// The travel time for the route.
    ///
    /// This includes only time of the travel.
    final public var travelTime: TimeInterval { get }

    /// The violation time for the route.
    ///
    /// The total amount of additional time incurred due to time window violations.
    final public var violationTime: TimeInterval { get }

    /// The wait time for the route.
    ///
    /// The total amount of additional time incurred due to waiting at time windows.
    final public var waitTime: TimeInterval { get }

    /// Gets cost.
    ///
    /// Returns the associated cost for this attribute name.
    /// - Parameter attributeName: The name of the attribute name e.g. "Minutes" or "TravelTime".
    /// - Returns: A value of cost.
    final public func cost(forAttributeNamed attributeName: String) -> Double
}

/// A route parameters object contains parameters for route calculation.
///
/// A class that contains settings that are used when solving a Route_task.
/// The Route_parameters class contains all inputs for the Route_task, as well as settings such as
/// the impedance attribute, accumulate and restriction attributes, backtrack (u-turn) policy, etc.
/// - Note: See Also: ``RouteTask``
/// - Since: 200.1
final public class RouteParameters {

    /// Creates a route parameters.
    ///
    /// Creates a route parameters object.
    public convenience init()

    /// Accumulate attribute names.
    final public var accumulateAttributeNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `accumulateAttributeNames` property.
    /// - Parameter newAccumulateAttributeNames: The new `String` values to append.
    final public func addAccumulateAttributeNames<S>(_ newAccumulateAttributeNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `accumulateAttributeNames` property.
    /// - Parameter newAccumulateAttributeName: The new `String` value to append.
    final public func addAccumulateAttributeName(_ newAccumulateAttributeName: String)

    /// Inserts a collection of `String` values into the `accumulateAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newAccumulateAttributeNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertAccumulateAttributeNames<C>(_ newAccumulateAttributeNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `accumulateAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newAccumulateAttributeName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertAccumulateAttributeName(_ newAccumulateAttributeName: String, at index: Int)

    /// Removes all values from the `accumulateAttributeNames` property.
    final public func removeAllAccumulateAttributeNames()

    /// Removes a sequence of `String` values from the `accumulateAttributeNames` property.
    /// - Parameter accumulateAttributeNames: The `String` values to remove.
    final public func removeAccumulateAttributeNames<S>(_ accumulateAttributeNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `accumulateAttributeNames` property.
    /// - Parameter accumulateAttributeName: The `String` value to remove.
    final public func removeAccumulateAttributeName(_ accumulateAttributeName: String)

    /// Directions distance text units.
    ///
    /// A directions distance text units. Describes the unit of measurement for the length of directions.
    /// - Note: See Also: ``UnitSystem``
    final public var directionsDistanceUnits: ArcGIS.UnitSystem

    /// Directions language.
    /// - Note: See Also: `String`
    final public var directionsLanguage: String

    /// Directions style.
    ///
    /// A directions style. The directions setting to generate directions designed for different kind of applications.
    /// - Note: See Also: ``DirectionsStyle``
    final public var directionsStyle: ArcGIS.DirectionsStyle

    /// Find best sequence.
    final public var findsBestSequence: Bool

    /// Output spatial reference.
    /// - Note: See Also: ``SpatialReference``
    final public var outputSpatialReference: ArcGIS.SpatialReference?

    /// Preserve first stop.
    final public var preservesFirstStop: Bool

    /// Preserve last stop.
    final public var preservesLastStop: Bool

    /// Return directions status.
    final public var returnsDirections: Bool

    /// Return point barriers.
    final public var returnsPointBarriers: Bool

    /// Return polygon barriers.
    final public var returnsPolygonBarriers: Bool

    /// Return polyline barriers.
    final public var returnsPolylineBarriers: Bool

    /// Return routes.
    final public var returnsRoutes: Bool

    /// Return stops.
    final public var returnsStops: Bool

    /// Route shape type.
    /// - Note: See Also: ``RouteShapeType``
    final public var routeShapeType: ArcGIS.RouteShapeType?

    /// Start time.
    /// - Note: See Also: `Date`
    final public var startDate: Date?

    /// Travel mode.
    ///
    /// Travel mode instance for route parameters.
    /// - Note: See Also: ``TravelMode``
    final public var travelMode: ArcGIS.TravelMode?

    /// Clears point barriers.
    final public func clearPointBarriers()

    /// Clears polygon barriers.
    final public func clearPolygonBarriers()

    /// Clears polyline barriers.
    final public func clearPolylineBarriers()

    /// Clears stops.
    final public func clearStops()

    /// Clones the ``RouteParameters``.
    /// - Returns: A new ``RouteParameters`` with the same values as the current ``RouteParameters``.
    final public func clone() -> Self

    /// Gets the search where clause from the specified network dataset's source feature class.
    /// - Parameter sourceName: The name of the network dataset's source feature class to retrieve the where clause from.
    /// - Returns: A `String`.
    final public func searchWhereClause(fromSourceNamed sourceName: String) -> String

    /// Sets point barriers.
    /// - Parameter pointBarriers: An `Array` of ``PointBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PointBarrier``
    final public func setPointBarriers<S>(_ pointBarriers: S) where S : Sequence, S.Element == ArcGIS.PointBarrier

    /// Sets the point barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type point.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPointBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets polygon barriers.
    /// - Parameter polygonBarriers: An `Array` of ``PolygonBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PolygonBarrier``
    final public func setPolygonBarriers<S>(_ polygonBarriers: S) where S : Sequence, S.Element == ArcGIS.PolygonBarrier

    /// Sets the polygon barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type polygon.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPolygonBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets polyline barriers.
    /// - Parameter lineBarriers: An `Array` of ``PolylineBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PolylineBarrier``
    final public func setPolylineBarriers<S>(_ lineBarriers: S) where S : Sequence, S.Element == ArcGIS.PolylineBarrier

    /// Sets the polyline barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type polyline.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPolylineBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets a search where clause on the specified network dataset's source feature class.  Only features satisfying the
    /// where clause for the specified feature class will be used to locate stops on the network during the solve
    /// operation.  If a where clause is not set all network features are used.
    /// - Parameters:
    ///   - searchWhereClause: The search where clause.
    ///   - sourceName: The name of the network dataset's source feature class the where clause will be applied to.
    final public func setSearchWhereClause(_ searchWhereClause: String, forSourceNamed sourceName: String)

    /// Sets stops.
    /// - Parameter stops: An `Array` of ``Stop`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``Stop``
    final public func setStops<S>(_ stops: S) where S : Sequence, S.Element == ArcGIS.Stop

    /// Sets the stops from the features in specified feature table.  The feature table can be either local or online.
    /// The feature table must be of geometry type point.  Attributes from the feature table are mapped to the properties
    /// on the stops objects generated from the specified feature table.  The where clause set in the query parameters
    /// will be applied to the feature table.  If an online feature table is specified the features will not be queried
    /// until Solve is called.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setStops(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)
}

/// A route result object contains output of route task's solve.
///
/// A class that contains the output results from a route task.
/// The route result contains all necessary output from a successfully-
/// completed route task solve. This includes collection of routes,
/// barriers and messages.
/// - Since: 200.1
final public class RouteResult {

    /// Directions language.
    ///
    /// Language of directions.
    /// - Note: See Also: `String`
    final public var directionsLanguage: String { get }

    /// Messages.
    ///
    /// Messages received when solve is completed. If a route cannot be solved, the message
    /// returned by the server identifies the route that could not be solved.
    /// - Note: See Also: `Array`, `String`
    final public var messages: [String] { get }

    /// Point barriers.
    ///
    /// Barriers are only returned if ``RouteParameters/returnsPointBarriers`` is `true`.
    /// - Note: See Also: `Array`, ``PointBarrier``
    final public var pointBarriers: [ArcGIS.PointBarrier] { get }

    /// Polygon barriers.
    ///
    /// Barriers are only returned if ``RouteParameters/returnsPolygonBarriers`` is `true`.
    /// - Note: See Also: `Array`, ``PolygonBarrier``
    final public var polygonBarriers: [ArcGIS.PolygonBarrier] { get }

    /// Polyline barriers.
    ///
    /// Barriers are only returned if ``RouteParameters/returnsPolylineBarriers`` is `true`.
    /// - Note: See Also: `Array`, ``PolylineBarrier``
    final public var polylineBarriers: [ArcGIS.PolylineBarrier] { get }

    /// Routes.
    ///
    /// Each object represents a separate route with independent driving directions
    /// - Note: See Also: `Array`, ``Route``
    final public var routes: [ArcGIS.Route] { get }
}

/// The type of shape output for a route.
/// - Since: 200.1
public enum RouteShapeType {

    /// A straight line shape type.
    case straightLine

    /// A `true` shape type with measures.
    case trueShapeWithMeasures

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.RouteShapeType, b: ArcGIS.RouteShapeType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension RouteShapeType : Equatable {
}

extension RouteShapeType : Hashable {
}

/// A route task object is used for calculation route by specified parameters.
///
/// A class that implements the route task.
/// The route task class uses a transportation network to create a route
/// between multiple stops. The route generated and the results returned honor
/// the settings provided by a route settings object.
/// - Note: See Also: ``Loadable``
/// - Since: 200.1
final public class RouteTask : ArcGIS.APIKeyResource, ArcGIS.Loadable {

    /// Creates a route task with path to geodatabase.
    ///
    /// Creates a route task.
    /// - Parameter dataset: A transportation network dataset.
    /// - Note: See Also: ``TransportationNetworkDataset``
    public convenience init(dataset: ArcGIS.TransportationNetworkDataset)

    /// Creates a route task with path to geodatabase.
    ///
    /// Creates a route task.
    /// - Parameters:
    ///   - pathToDatabaseURL: A path to geodatabase.
    ///   - networkName: A network name.
    public convenience init(pathToDatabaseURL: URL, networkName: String)

    /// Creates a route task with URL.
    ///
    /// Creates a route task with specified service URL.
    /// - Parameter url: An URL to online routing services.
    public convenience init(url: URL)

    /// Gets route task info.
    ///
    /// Generates default parameters.
    /// - Note: See Also: ``RouteTaskInfo``
    final public var info: ArcGIS.RouteTaskInfo { get }

    /// Transportation network dataset of local route task.
    /// - Note: See Also: ``TransportationNetworkDataset``
    final public var transportationNetworkDataset: ArcGIS.TransportationNetworkDataset? { get }

    /// The URL of online service.
    /// - Note: See Also: `String`
    final public var url: URL? { get }

    /// Creates default parameters.
    ///
    /// Generates default parameters.
    /// - Returns: A ``RouteParameters``.
    /// - Note: See Also: ``RouteParameters``
    final public func makeDefaultParameters() async throws -> ArcGIS.RouteParameters

    /// Imports route parameters from feature collection and then adjusts imported parameters to current Route task.
    ///
    /// Travel mode would be `nil` if it could not be created from the route layer settings for the route task's network.
    /// In case if travel mode is `nil` then client can override it by another travel mode (for example obtained from ``RouteTaskInfo``).
    /// Accumulate attributes from Route Info table going to be applied only if they exist in transportation network restriction and cost attributes.
    /// - Parameter collection: The feature collection object that contains stops, route info, and barriers tables. Stops table is required.
    /// - Returns: A ``RouteParameters``.
    final public func makeParameters(collection: ArcGIS.FeatureCollection) async throws -> ArcGIS.RouteParameters

    /// Imports route parameters from portal item and then adjusts imported parameters to current Route task.
    ///
    /// Travel mode would be `nil` if it could not be created from the route layer settings for the route task's network.
    /// In case if travel mode is `nil` then client can override it by another travel mode (for example obtained from ``RouteTaskInfo``).
    /// Accumulate attributes from Route Info table going to be applied only if they exist in transportation network restriction and cost attributes.
    /// - Parameter portalItem: The portal item object with feature collection that contains stops, route info, and barriers tables. Stops table is required.
    /// - Returns: A ``RouteParameters``.
    final public func makeParameters(portalItem: ArcGIS.PortalItem) async throws -> ArcGIS.RouteParameters

    /// Imports route result from feature collection.
    /// - Parameter collection: The feature collection that contains directions, stops, route info, and barriers tables.
    /// - Returns: A ``RouteResult``.
    final public class func makeRouteResult(collection: ArcGIS.FeatureCollection) async throws -> ArcGIS.RouteResult

    /// Imports route result from portal item.
    /// - Parameter portalItem: The portal item with feature collection that contains directions, stops, route info, and barriers tables.
    /// - Returns: A ``RouteResult``.
    final public class func makeRouteResult(portalItem: ArcGIS.PortalItem) async throws -> ArcGIS.RouteResult

    /// Solves a route passing in a parameters object.
    /// - Parameter parameters: The route parameters.
    /// - Returns: A ``RouteResult`` type.
    /// - Note: See Also: ``RouteParameters``
    final public func solveRoute(using parameters: ArcGIS.RouteParameters) async throws -> ArcGIS.RouteResult

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A description of the transportation network to which a route task is bound.
/// - Since: 200.1
public struct RouteTaskInfo {
}

extension RouteTaskInfo {

    /// Accumulate attribute names.
    /// - Note: See Also: `Array`, `String`
    public var accumulateAttributeNames: [String] { get }

    /// Cost attributes.
    /// - Note: See Also: `Dictionary`
    public var costAttributes: [String : ArcGIS.CostAttribute] { get }

    /// Default travel mode's name.
    /// - Note: See Also: `String`
    public var defaultTravelModeName: String { get }

    /// Directions distance text units.
    /// - Note: See Also: ``UnitSystem``
    public var directionsDistanceUnits: ArcGIS.UnitSystem { get }

    /// Directions language.
    /// - Note: See Also: `String`
    public var directionsLanguage: String { get }

    /// Directions style.
    ///
    /// A directions style. The directions setting to generate directions designed for different kind of applications.
    /// - Note: See Also: ``DirectionsStyle``
    public var directionsStyle: ArcGIS.DirectionsStyle { get }

    /// Whether the underlying network dataset supports the returning of directions.
    ///
    /// For services prior to ArcGIS 10.8, this value will be `nil`.
    /// - Note: See Also: ``NetworkDirectionsSupport``
    public var directionsSupport: ArcGIS.NetworkDirectionsSupport? { get }

    /// Find best sequence.
    public var findsBestSequence: Bool { get }

    /// Maximum locating distance is the furthest distance in meters that Network Analyst searches when locating or relocating a point onto the network.
    ///
    /// The search looks for suitable edges or junctions and snaps the point to the nearest one.
    /// If a suitable location isn't found within the maximum locating distance, the object is marked as unlocated.
    public var maxLocatingDistance: Measurement<UnitLength> { get }

    /// Network name.
    /// - Note: See Also: `String`
    public var networkName: String { get }

    /// Output spatial reference.
    /// - Note: See Also: ``SpatialReference``
    public var outputSpatialReference: ArcGIS.SpatialReference? { get }

    /// Preserve first stop.
    public var preservesFirstStop: Bool { get }

    /// Preserve last stop.
    public var preservesLastStop: Bool { get }

    /// Restriction attributes.
    /// - Note: See Also: `Dictionary`
    public var restrictionAttributes: [String : ArcGIS.RestrictionAttribute] { get }

    /// Route shape type.
    /// - Note: See Also: ``RouteShapeType``
    public var routeShapeType: ArcGIS.RouteShapeType? { get }

    /// Start time.
    /// - Note: See Also: `Date`
    public var startDate: Date? { get }

    /// Array of supported languages.
    /// - Note: See Also: `Array`, `String`
    public var supportedLanguages: [String] { get }

    /// Array of supported restriction usage parameter values.
    /// - Note: See Also: `Array`, `String`
    public var supportedRestrictionUsageParameterValues: [String] { get }

    /// Value of service property "Supports Rerouting"
    ///
    /// If property doesn't exist on service value will be `false`. For local data value will be `true`.
    public var supportsRerouting: Bool { get }

    /// Array of travel modes.
    /// - Note: See Also: `Array`, ``TravelMode``
    public var travelModes: [ArcGIS.TravelMode] { get }
}

/// Uses a location to provide status and progress updates as a route is traversed (by a moving vehicle, for example).
///
/// RouteTracker can give the time or distance to the next maneuver, notify if the location is off-route, and regenerate a new route if
/// necessary.
/// Basic workflow:
/// 1. Create a new RouteTracker instance.
/// 2. Enable rerouting with `RouteTracker.enableRerouting(using:)` (if supported by the underlying route service).
/// 3. Use `RouteTracker.track(_:)` to track the location of the device.
/// 4. Subscribe to ``trackingStatus`` to get the ``TrackingStatus`` as the location changes.
/// 5. Subscribe to ``voiceGuidances`` to get the ``VoiceGuidance`` whenever new instructions are available.
/// 6. If there are multiple stops, call `RouteTracker.switchToNextDestination()` each time ``TrackingStatus/DestinationStatus-swift.enum/reached`` status is returned.
///    Before calling `RouteTracker.switchToNextDestination()` make sure that ``TrackingStatus/remainingDestinationCount`` > 1,
///    a value of 1 means the last destination is being approached.
/// - Since: 200.1
final public class RouteTracker {

    /// The route tracker's rerouting strategy.
    ///
    /// Strategies determine which locations will be used during rerouting
    /// and/or if new route is optimized.
    public enum ReroutingStrategy {

        /// Reroute to next unvisited waypoint, rest break, or stop.
        case toNextWaypoint

        /// Reroute to next unvisited stop.
        case toNextStop

        /// Re-sequence (optimize) all remaining stops, which will drop all waypoints and rest breaks.
        case resequenceStopsOnly

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.RouteTracker.ReroutingStrategy, b: ArcGIS.RouteTracker.ReroutingStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a Route Tracker using a specific route from a route result with an option to specify treating coincident stops as a single destination.
    ///
    /// An exception is thrown if the ``Route`` is not found or if it lacks ``Route/stops`` and ``Route/directionManeuvers``.
    /// - Parameters:
    ///   - routeResult: A ``RouteResult`` generated from route task solve.
    ///   - routeIndex: The integer value for which route to use in the array of ``RouteResult/routes``. The array is zero-based.
    ///   - skipsCoincidentStops: Determines if coincident stops (multiple stops in a row at the same location) should be treated as a single destination.
    /// - Note: See Also: ``RouteResult``
    public convenience init?(routeResult: ArcGIS.RouteResult, routeIndex: Int, skipsCoincidentStops: Bool)

    /// Sets reroute completed callback.
    final public var rerouteCompleted: ((ArcGIS.TrackingStatus, Error?) -> Void)?

    /// Sets reroute started callback.
    final public var rerouteStarted: (() -> Void)?

    /// Reports if routes are automatically regenerated when tracking status is off-route. `true` if rerouting is enabled, otherwise `false`.
    /// - Note: See Also: `RouteTracker.enableRerouting(using:)`, `RouteTracker.disableRerouting()`
    final public var reroutingIsEnabled: Bool { get }

    /// Indicates if multiple stops in a row at the same location should treated as one stop.
    ///
    /// When `true`, if there are multiple stops, in a row, at the same network location the new voice guidance event will
    /// fire a single time and calling `RouteTracker.switchToNextDestination()` will skip over the other coincident
    /// stops, setting the state to the next relevant direction maneuver. If the value is `false` each stop will be treated
    /// as a unique destination.  The default value for this property is `true`. If your route does not have coincident
    /// stops the value of this property will have no effect.
    final public var skipsCoincidentStops: Bool { get }

    /// Status for the current location on the route.
    /// - Note: See Also: ``TrackingStatus``
    @ArcGIS.Streamed final public var trackingStatus: ArcGIS.TrackingStatus? { get }

    final public var $trackingStatus: AsyncStream<ArcGIS.TrackingStatus?> { get }

    /// The unit system used in voice guidance commands.
    ///
    /// Default value is ``UnitSystem/metric``. Supported values are ``UnitSystem/metric`` and ``UnitSystem/imperial``.
    final public var voiceGuidanceUnitSystem: ArcGIS.UnitSystem

    /// The new voice guidances from the route tracker.
    final public var voiceGuidances: AsyncStream<ArcGIS.VoiceGuidance> { get }

    /// Cancels a running reroute task.
    ///
    /// If rerouting is in progress, this method will interrupt the background route task process.
    final public func cancelRerouting()

    /// Disables automatic rerouting.
    ///
    /// When disabled, the tracker will not automatically recalculate a route when the tracking status is off-route.
    /// - Note: See Also: `RouteTracker.enableRerouting(using:)`
    final public func disableRerouting()

    /// Enables automatic rerouting when the tracker detects an off-route status.
    ///
    /// Re-routing only occurs when the current location is off-route, but on or near the transportation network edges.
    /// For example if an off-route state is detected but the tracked location is in a parking lot, away from any transportation
    /// network edges, re-routing will not occur, and will occur only once a subsequent tracked location is on or near the
    /// transportation network edges.
    /// - Parameter parameters: A ``ReroutingParameters`` allow customizing background rerouting.
    final public func enableRerouting(using parameters: ArcGIS.ReroutingParameters) async throws

    /// Gets the current ``VoiceGuidance`` object.
    ///
    /// The most recent voice guidance based on the last ``Location`` used by `RouteTracker.track(_:)`.
    /// It can be used to repeat last/latest voice guidance.
    /// - Returns: Voice guidance.
    /// - Note: See Also: ``TrackingStatus``
    final public func generateVoiceGuidance() -> ArcGIS.VoiceGuidance?

    /// Starts tracking progress to the next destination in the ``Route``.
    ///
    /// Use `RouteTracker.switchToNextDestination()` when the tracker reports a ``TrackingStatus/DestinationStatus-swift.enum/reached`` status.
    /// Before calling `RouteTracker.switchToNextDestination()` make sure that ``TrackingStatus/remainingDestinationCount`` > 1
    /// (a value of 1 means navigation is proceeding to last destination). This method can also be called after
    /// ``TrackingStatus/DestinationStatus-swift.enum/approaching`` is raised in cases where the location cannot get near enough to the destination point
    /// for ``TrackingStatus/DestinationStatus-swift.enum/reached`` to be raised (such as the center of a park or shopping center, for example).
    /// `RouteTracker.track(_:)` needs to be called at least once before calling this method otherwise an error will be thrown.
    /// `RouteTracker.track(_:)` is needed for getting ``TrackingStatus`` and for handling visitFirstStopOnStart.
    final public func switchToNextDestination() async throws

    /// Provides route tracking status relative to the provided location.
    ///
    /// The location generally comes from a GPS but may also be a simulated or manually entered location.
    /// It must have valid values for X and Y coordinates, speed (in meters per second), course (in degrees),
    /// and a timestamp.
    /// Events fired for ``RouteTracker`` when completed.
    /// - Parameter location: A location used to evaluate status and progress along the route.
    /// - Note: See Also: ``Location``
    final public func track(_ location: ArcGIS.Location) async throws
}

extension RouteTracker {

    /// Sets the speech engine (text to speech) ready callback.
    ///
    /// The return value of this callback is a Boolean value that should indicate if the speech engine is ready or not.
    final public var isSpeechEngineReady: (() -> Bool)?
}

extension RouteTracker.ReroutingStrategy : Equatable {
}

extension RouteTracker.ReroutingStrategy : Hashable {
}

/// A location data source that uses a route tracker and a generic location data source to output locations snapped to a route.
///
/// Setting the RouteTrackerLocationDataSource is optional when desiring to have the location
/// display symbol navigate along a route. Using this object provides the benefit of having the
/// current location snapped to the route polyline during navigation. If the
/// RouteTrackerLocationDataSource is not used, you may notice that the actual GPS location
/// tends to wander off the route polyline due to the accuracy provided by the GPS unit.
///
/// No distance tolerance needs to be specified to enable the snapping effect of having the
/// location display symbol follow along the  route polyline. An internal algorithm is used by
/// the RouteTrackerLocationDataSource to determine if location is 'on route' or 'off route'. If
/// the location is seen as 'on route' then snapping will occur, otherwise the output location
/// will be the original input GPS location. If it is determined that the tracking along the
/// route is no longer needed the RouteTrackerLocationDataSource's stop method can be called or
/// the ``LocationDisplay`` can be reset to a different data source.
///
/// To provide some insight on how the RouteTrackerLocationDataSource works, the data
/// source will pass the locations from the ``LocationDataSource/locations`` event
/// to the `RouteTracker.track(_:)`. The ``TrackingStatus/displayLocation``
/// will then be returned in this data source's locationChanged event.
///
/// To control the orientation of the location display symbol as it navigates along a route
/// refer to the `MapView.locationDisplay` class.
/// - Since: 200.1
final public class RouteTrackerLocationDataSource : ArcGIS.LocationDataSource {
}

extension RouteTrackerLocationDataSource {

    /// Creates a `RouteTrackerLocationDataSource` object.
    /// - Parameters:
    ///   - routeTracker: A ``RouteTracker`` object.
    ///   - locationDataSource: A ``LocationDataSource`` object. The default value is `SystemLocationDataSource()`.
    public convenience init(routeTracker: ArcGIS.RouteTracker, locationDataSource: ArcGIS.LocationDataSource = SystemLocationDataSource())
}

/// Filter features from the display based on the current map scale.
///
/// This is useful when there is so much feature density at small scales making the display difficult to
/// interpret or slow to draw.
/// - Note: See Also: ``ManualDisplayFilterDefinition``
/// - Since: 200.1
final public class ScaleDisplayFilterDefinition : ArcGIS.DisplayFilterDefinition {

    /// Creates a new ``ScaleDisplayFilterDefinition`` with the specified scale range display filters.
    /// - Parameter filters: The collection of scale range display filters.
    public convenience init(filters: [ArcGIS.ScaleRangeDisplayFilter])

    /// The collection of scale range display filters.
    ///
    /// To enable display filter on a layer, every ``ScaleRangeDisplayFilter`` in this collection must provide a
    /// ``ScaleRangeDisplayFilter/minScale`` or ``ScaleRangeDisplayFilter/maxScale`` within the map's current scale.
    ///
    /// If more than one ``ScaleRangeDisplayFilter`` is applicable at a given scale, the first ``ScaleRangeDisplayFilter``
    /// within the current map scale is applied.
    ///
    /// If the features displayed are not expected, check the layer's ``LayerViewState`` for a ``LayerViewState/Status-swift.struct/warning``
    /// as there might be a ``LayerViewState/error`` indicating there is a scale overlap between multiple
    /// ``ScaleRangeDisplayFilter`` objects.
    /// - Note: See Also: ``ScaleRangeDisplayFilter``
    final public var filters: [ArcGIS.ScaleRangeDisplayFilter] { get }

    /// Adds a sequence of `ScaleRangeDisplayFilter` values to the end of the `filters` property.
    /// - Parameter newFilters: The new `ScaleRangeDisplayFilter` values to append.
    final public func addFilters<S>(_ newFilters: S) where S : Sequence, S.Element == ArcGIS.ScaleRangeDisplayFilter

    /// Adds a `ScaleRangeDisplayFilter` value to the end of the `filters` property.
    /// - Parameter newFilter: The new `ScaleRangeDisplayFilter` value to append.
    final public func addFilter(_ newFilter: ArcGIS.ScaleRangeDisplayFilter)

    /// Inserts a collection of `ScaleRangeDisplayFilter` values into the `filters` property at the specified position.
    /// - Parameters:
    ///   - newFilters: The new `ScaleRangeDisplayFilter` values to insert.
    ///   - index: The position at which to insert the new `ScaleRangeDisplayFilter` values.
    final public func insertFilters<C>(_ newFilters: C, at index: Int) where C : Collection, C.Element == ArcGIS.ScaleRangeDisplayFilter

    /// Inserts a `ScaleRangeDisplayFilter` value into the `filters` property at the specified position.
    /// - Parameters:
    ///   - newFilter: The new `ScaleRangeDisplayFilter` value to insert.
    ///   - index: The position at which to insert the new `ScaleRangeDisplayFilter` value.
    final public func insertFilter(_ newFilter: ArcGIS.ScaleRangeDisplayFilter, at index: Int)

    /// Removes all values from the `filters` property.
    final public func removeAllFilters()

    /// Removes a sequence of `ScaleRangeDisplayFilter` values from the `filters` property.
    /// - Parameter filters: The `ScaleRangeDisplayFilter` values to remove.
    final public func removeFilters<S>(_ filters: S) where S : Sequence, S.Element == ArcGIS.ScaleRangeDisplayFilter

    /// Removes a `ScaleRangeDisplayFilter` value from the `filters` property.
    /// - Parameter filter: The `ScaleRangeDisplayFilter` value to remove.
    final public func removeFilter(_ filter: ArcGIS.ScaleRangeDisplayFilter)
}

/// A ``DisplayFilter`` that is applied on the layer based on the provided scale range.
/// - Note: See Also: ``ScaleDisplayFilterDefinition/filters``
/// - Since: 200.1
final public class ScaleRangeDisplayFilter : ArcGIS.DisplayFilter {

    /// Creates a new ``ScaleRangeDisplayFilter`` with the specified name, where clause, and scale range.
    /// - Parameters:
    ///   - name: A descriptive name for this display filter.
    ///   - whereClause: A SQL expression that defines which features are rendered.
    ///   - minScale: The minimum scale at which this display filter is applied.
    ///   - maxScale: The maximum scale at which this display filter is applied.
    /// - Precondition: If `minScale` and `maxScale` are specified, the `minScale` must be greater than or equal to the `maxScale`.
    public convenience init(name: String, whereClause: String, minScale: Double? = nil, maxScale: Double? = nil)

    /// The maximum scale at which this display filter is applied. If `nil`, there is no maximum.
    ///
    /// This display filter is only applied when zoomed further out than the maximum scale.
    /// Set this property to allow current scale of the map to determine when this display filter is applied.
    /// If `MapView.scale` or ``Viewpoint/targetScale`` is greater than or equal this value,
    /// the ``DisplayFilter`` will be applied.
    /// This value should be less than ``minScale``.
    /// A value of 0 indicates this display filter is applied without an upper limit.
    /// The default value is 0.
    final public var maxScale: Double?

    /// The minimum scale at which this display filter is applied. If `nil`, there is no minimum.
    ///
    /// This display filter is only applied when zoomed further in than the minimum scale.
    /// Set this property to allow current scale of the map to determine when this display filter is applied.
    /// If `MapView.scale` or ``Viewpoint/targetScale`` is less than or equal this value,
    /// the ``DisplayFilter`` will be applied.
    /// This value should be greater than ``maxScale``.
    /// A value of 0 indicates this display filter is applied without a lower limit.
    /// The default value is 0.
    final public var minScale: Double?
}

/// A scene is a container for layers. You use a scene together with a `SceneView` to display layers of geographic data in 3D.
///
/// ``Scene`` contains layers of mapping data and information such as elevation data, renderers, and labels which
/// define the scene's capabilities. You can access ``Scene`` content directly or, more commonly, visualize
/// the scene in a `SceneView`.
///
/// In an MVC architecture, ``Scene`` represents the model and `SceneView` represents the 3D view. ``Scene``
/// specifies how the geographic data is organized, and `SceneView` renders the data on the screen and
/// allows users to interact with it.
///
/// A scene can contain a base surface, a basemap, and one or more operational layers:
///
/// * A base surface is the default surface on which layers are draped or from which relative layers are offset. The ground height is provided by ``ElevationSource`` objects that are combined to make the ``Surface``.
/// * A basemap is a layer that helps orient the user of the scene. It is composed of a collection of base layers, such as imagery or hillshade, that are draped on the surface, and/or reference layers such as street labels that are displayed on top of operational layers. This content is relatively static.
/// * An operational layer provides content that is of unique interest to the app and the task at hand, such as data about earthquakes, traffic, or weather. This content can change frequently.
///
/// You can create a scene from an existing web scene using its URL or ``PortalItem``. Alternatively, you can get a scene
/// directly from a ``MobileScenePackage/scenes`` collection. ``Scene`` properties are hydrated when the scene is loaded.
///
/// If you create a new scene, the spatial reference of the first layer you add, which is typically
/// the first layer in the ``Basemap``, defines the spatial reference of the entire scene.
///
/// See [Scenes 3D](https://developers.arcgis.com/documentation/mapping-apis-and-services/maps/scenes-3d/) for more information about scenes.
/// - Since: 200.1
final public class Scene : ArcGIS.GeoModel {

    /// The options for setting the Scene tiling scheme.
    public enum SceneViewTilingScheme {

        /// Use a geographic tiling scheme for tiled layers.
        case geographic

        /// Use a web Mercator tiling scheme for tiled layers.
        case webMercator

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Scene.SceneViewTilingScheme, b: ArcGIS.Scene.SceneViewTilingScheme) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a scene.
    /// - Note: See Also: ``GeoModel/load()``
    public convenience init()

    /// Creates a scene with a ``Basemap``.
    /// - Parameter basemap: A basemap object.
    public convenience init(basemap: ArcGIS.Basemap)

    /// Creates a scene with a ``Basemap/Style``.
    /// - Parameter basemapStyle: The basemap style.
    /// - Note: See Also: ``Basemap/Style``
    public convenience init(basemapStyle: ArcGIS.Basemap.Style)

    /// Creates a scene with a portal item of type ``PortalItem/Kind-swift.enum/webScene``.
    ///
    /// The ``PortalItem`` automatically loads when the ``Scene`` loads. If the loaded ``Item`` is not
    /// a portal item of type ``PortalItem/Kind-swift.enum/webScene``, the scene fails to load.
    /// - Parameter item: The web scene ``PortalItem``.
    public convenience init(item: ArcGIS.Item)

    /// Creates a scene with a specific tiling scheme.
    ///
    /// The tiling scheme determines which cached tiled services can render in the scene.
    /// - Parameter tilingScheme: The tiling scheme to use for tiled layers.
    public convenience init(tilingScheme: ArcGIS.Scene.SceneViewTilingScheme)

    /// Creates a scene with the URL to a web scene.
    ///
    /// If the specified URL is a portal item URL, the underlying ``PortalItem`` is created and can be
    /// accessed through ``GeoModel/item``. The URL may be a direct URL to web scene JSON content or the URL of a
    /// portal item.
    ///
    /// Examples of supported URL formats:
    /// * The web scene viewer page, for example:
    ///   https://www.arcgis.com/home/webscene/viewer.html?webscene=579f97b2f3b94d4a8e48a5f140a6639b
    /// * The web scene item details page, for example:
    ///   https://www.arcgis.com/home/item.html?id=579f97b2f3b94d4a8e48a5f140a6639b
    /// * The REST sharing API data, for example:
    ///   https://www.arcgis.com/sharing/rest/content/items/579f97b2f3b94d4a8e48a5f140a6639b/data
    /// * The REST sharing API page (with or without the query parameter f=json), for example:
    ///   https://www.arcgis.com/sharing/rest/content/items/579f97b2f3b94d4a8e48a5f140a6639b?f=json
    /// - Parameter url: URI of the web scene on ArcGIS Online or ArcGIS Enterprise portal.
    /// - Note: See Also: ``PortalItem``, ``PortalItem/init(url:)``, ``GeoModel/item``
    public convenience init?(url: URL)

    /// The base surface of the scene.
    ///
    /// The base surface is the default surface on which layers are draped or from which
    /// relative layers are offset.
    /// - Note: See Also: ``Surface``
    final public var baseSurface: ArcGIS.Surface

    /// The tiling scheme defines how tile based data is rendered.
    ///
    /// The tiling scheme property is used by the `SceneView` to determine how to render tiled data.
    ///
    /// This property is determined during ``GeoModel/load()``. The ``SpatialReference`` of the first tiled elevation source
    /// (``ArcGISTiledElevationSource``) or tiled layer in the basemap or operational layer (see ``ArcGISTiledLayer``)
    /// determines whether the value is ``SceneViewTilingScheme/geographic`` or ``SceneViewTilingScheme/webMercator``.
    ///
    /// If you create a new scene, you can set this value before adding the base surface, basemap or operational layers. The
    /// ``SceneViewTilingScheme`` must correspond to the ``SpatialReference`` of the layers to ensure they render correctly.
    ///
    /// The default value is ``SceneViewTilingScheme/webMercator``.
    final public var tilingScheme: ArcGIS.Scene.SceneViewTilingScheme { get }

    /// Creates a scene from JSON.
    /// - Parameter json: The JSON string for the scene.
    /// - Returns: A new scene object.
    final public class func fromJSON(_ json: String) throws -> Self
}

extension Scene.SceneViewTilingScheme : Equatable {
}

extension Scene.SceneViewTilingScheme : Hashable {
}

/// A view that displays 3D geographic content from a `Scene`.
/// - Since: 200.1
@MainActor public struct SceneView : View {

    /// Creates a scene view.
    /// - Parameters:
    ///   - scene: The scene to be displayed by the scene view.
    ///   - viewpoint: A viewpoint that corresponds to the area of the scene to
    ///   display.
    ///   - timeExtent: A binding to a time extent that corresponds to the time extent of
    ///   the scene to display.
    ///   - graphicsOverlays: The graphics overlays to display on top of the
    ///   scene view's content.
    ///   - analysisOverlays: The analyses overlays to display on top of the
    ///   scene view's content.
    ///   - imageOverlays: The image overlays to display on top of the scene
    ///   view's content.
    @MainActor public init(scene: ArcGIS.Scene, viewpoint: ArcGIS.Viewpoint? = nil, timeExtent: Binding<ArcGIS.TimeExtent?>? = nil, graphicsOverlays: [ArcGIS.GraphicsOverlay] = [], analysisOverlays: [ArcGIS.AnalysisOverlay] = [], imageOverlays: [ArcGIS.ImageOverlay] = [])

    /// Creates a scene view.
    /// - Parameters:
    ///   - scene: The scene to be displayed by the scene view.
    ///   - camera: A binding to a camera that corresponds to the area of the scene to display.
    ///   - timeExtent: A binding to a time extent that corresponds to the time extent of
    ///   the scene to display.
    ///   - graphicsOverlays: The graphics overlays to display on top of the
    ///   scene view's content.
    ///   - analysisOverlays: The analyses overlays to display on top of the
    ///   scene view's content.
    ///   - imageOverlays: The image overlays to display on top of the scene
    ///   view's content.
    @MainActor public init(scene: ArcGIS.Scene, camera: Binding<ArcGIS.Camera?>, timeExtent: Binding<ArcGIS.TimeExtent?>? = nil, graphicsOverlays: [ArcGIS.GraphicsOverlay] = [], analysisOverlays: [ArcGIS.AnalysisOverlay] = [], imageOverlays: [ArcGIS.ImageOverlay] = [])

    /// Creates a scene view.
    /// - Parameters:
    ///   - scene: The scene to be displayed by the scene view.
    ///   - cameraController: The camera interaction and navigation model.
    ///   - timeExtent: A binding to a time extent that corresponds to the time extent of
    ///   the scene to display.
    ///   - graphicsOverlays: The graphics overlays to display on top of the
    ///   scene view's content.
    ///   - analysisOverlays: The analyses overlays to display on top of the
    ///   scene view's content.
    ///   - imageOverlays: The image overlays to display on top of the scene
    ///   view's content.
    @MainActor public init(scene: ArcGIS.Scene, cameraController: ArcGIS.CameraController, timeExtent: Binding<ArcGIS.TimeExtent?>? = nil, graphicsOverlays: [ArcGIS.GraphicsOverlay] = [], analysisOverlays: [ArcGIS.AnalysisOverlay] = [], imageOverlays: [ArcGIS.ImageOverlay] = [])

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    public typealias Body = some View
}

extension SceneView : ArcGIS.GeoView {

    /// Sets the visibility of this geo view's attribution bar.
    /// - Parameter hidden: A Boolean value that indicates whether to hide the
    /// attribution bar.
    @MainActor public func attributionBarHidden(_ hidden: Bool) -> ArcGIS.SceneView

    /// Displays a callout when the specified placement is a non-`nil` value.
    /// - Parameters:
    ///   - placement: Binding to the placement for which to display a callout.
    ///   When the wrapped value of the binding is not `nil`, then the callout
    ///   is displayed.
    ///   - content: The content to be displayed within the callout.
    @MainActor public func callout(placement: Binding<ArcGIS.CalloutPlacement?>, @ViewBuilder content: @escaping (ArcGIS.CalloutPlacement) -> some View) -> ArcGIS.SceneView

    /// Sets whether to disable flicking for this geo view.
    /// - Parameter disabled: A Boolean value that indicates whether flicking is
    ///   disabled.
    @MainActor public func flickingDisabled(_ disabled: Bool) -> ArcGIS.SceneView

    /// Sets a closure to perform when this geo view's attribution text changes.
    /// - Parameter action: The closure to perform when the attribution text has
    ///   changed.
    @MainActor public func onAttributionTextChanged(perform action: @escaping (String) -> Void) -> ArcGIS.SceneView

    /// Sets a closure to perform when the camera of this scene view changes.
    ///
    /// This modifier is not necessary when the scene view has been initialized
    /// with a binding to a camera.
    /// - Parameter action: The closure to perform when the camera has changed.
    @MainActor public func onCameraChanged(perform action: @escaping (_ newCamera: ArcGIS.Camera) -> Void) -> ArcGIS.SceneView

    /// Sets a closure to perform when this geo view's draw status changes.
    /// - Parameter action: The closure to perform when the draw status has
    /// changed.
    @MainActor public func onDrawStatusChanged(perform action: @escaping (ArcGIS.DrawStatus) -> Void) -> ArcGIS.SceneView

    /// Sets a closure to perform when the view state of a layer of this geo
    /// view changes.
    /// - Parameter action: The closure to perform when a layer's view state has
    ///   changed.
    @MainActor public func onLayerViewStateChanged(perform action: @escaping (ArcGIS.Layer, ArcGIS.LayerViewState) -> Void) -> ArcGIS.SceneView

    /// Sets a closure to perform when this geo view's navigation status
    /// changes.
    ///
    /// The navigation status indicates whether the viewpoint is changing, due
    /// to either user interaction (panning and/or zooming) or a viewpoint
    /// animation.
    /// - Parameter action: The closure to perform when the navigation status
    /// has changed.
    @MainActor public func onNavigatingChanged(perform action: @escaping (Bool) -> Void) -> ArcGIS.SceneView

    /// Sets a closure to perform when this geo view's spatial reference
    /// changes.
    /// - Parameter action: The closure to perform when the spatial reference
    /// has changed.
    @MainActor public func onSpatialReferenceChanged(perform action: @escaping (ArcGIS.SpatialReference?) -> Void) -> ArcGIS.SceneView

    /// Sets a closure to perform when the viewpoint of this geo view changes.
    ///
    /// Viewpoints received by the `action` closure will not have a camera.
    /// - Parameters:
    ///   - kind: The kind of viewpoint passed to the `action` closure.
    ///   - action: The closure to perform when the viewpoint has changed.
    @MainActor public func onViewpointChanged(kind: ArcGIS.Viewpoint.Kind, perform action: @escaping (ArcGIS.Viewpoint) -> Void) -> ArcGIS.SceneView

    /// Sets the selection color for all graphic overlays and selectable layers
    /// of this geo view.
    ///
    /// The default selection color is cyan.
    /// - Parameter color: The selection color to use for this geo view.
    @MainActor public func selectionColor(_ color: Color) -> ArcGIS.SceneView

    /// Sets the zoom factor for this geo view.
    /// - Parameter zoomFactor: The zoom factor for animated zooming in and out
    ///   in this geo view.
    @MainActor public func zoomFactor(_ zoomFactor: Double) -> ArcGIS.SceneView
}

extension SceneView {

    /// Sets whether to hide labels and if label animations should be active for this scene view.
    /// - Parameters:
    ///   - hidden: A Boolean value that indicates whether labels are hidden. The default is `false`.
    ///   - animated: A Boolean value that indicates whether labeling animations are active.
    @MainActor public func sceneLabels(hidden: Bool, animated: Bool = false) -> ArcGIS.SceneView
}

extension SceneView {

    /// Visual effect options for a scene view's atmosphere.
    public enum AtmosphereEffect : CaseIterable {

        /// No atmosphere effect.
        case off

        /// Applies the atmosphere effect at the horizon of the scene view. It
        /// is not applied to the surface.
        case horizonOnly

        /// Applies the atmosphere effect throughout the surface of the scene.
        case realistic

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SceneView.AtmosphereEffect, b: ArcGIS.SceneView.AtmosphereEffect) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.SceneView.AtmosphereEffect]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.SceneView.AtmosphereEffect] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Sets the atmosphere effect for this scene view.
    ///
    /// The default value is `horizonOnly`.
    /// - Parameter atmosphereEffect: The atmosphere effect to set on this scene
    /// view.
    @MainActor public func atmosphereEffect(_ atmosphereEffect: ArcGIS.SceneView.AtmosphereEffect) -> ArcGIS.SceneView
}

extension SceneView {

    /// Determines whether outer space is black with stars or transparent.
    public enum SpaceEffect : CaseIterable {

        /// Outer space is black with stars.
        case stars

        /// Outer space is transparent.
        case transparent

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SceneView.SpaceEffect, b: ArcGIS.SceneView.SpaceEffect) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.SceneView.SpaceEffect]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.SceneView.SpaceEffect] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Sets the space effect for this scene view.
    ///
    /// The default value is `stars`.
    /// - Parameter spaceEffect: The space effect to set on this scene view.
    @MainActor public func spaceEffect(_ spaceEffect: ArcGIS.SceneView.SpaceEffect) -> ArcGIS.SceneView
}

extension SceneView {

    /// Ambient lighting options for a scene view.
    public enum SunLighting : CaseIterable {

        /// No ambient light from the sun.
        case off

        /// Applies ambient light with no shadows cast from terrain and 3D models.
        case light

        /// Applies ambient light with shadows cast from terrain and 3D models.
        case lightAndShadows

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SceneView.SunLighting, b: ArcGIS.SceneView.SunLighting) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// A type that can represent a collection of all values of this type.
        public typealias AllCases = [ArcGIS.SceneView.SunLighting]

        /// A collection of all values of this type.
        public static var allCases: [ArcGIS.SceneView.SunLighting] { get }

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Sets the sun lighting for this scene view.
    ///
    /// The default value is `off` meaning there is no ambient sun light.
    /// - Parameter sunLighting: The sun lighting to set on this scene view.
    @MainActor public func sunLighting(_ sunLighting: ArcGIS.SceneView.SunLighting) -> ArcGIS.SceneView
}

extension SceneView {

    /// Sets the ambient light color for this scene view.
    ///
    /// The ambient light is visible if the `sunLighting` is set to `light` or `lightAndShadows`.
    /// - Parameter ambientLightColor: The ambient light color to set on this scene view.
    @MainActor public func ambientLightColor(_ ambientLightColor: Color) -> ArcGIS.SceneView

    /// Sets the sun date for this scene view.
    ///
    /// The default value is Fri Sep 22 2000 12:00:00 GMT+0000.
    /// - Parameter sunDate: The sun date to set on this scene view.
    @MainActor public func sunDate(_ sunDate: Date) -> ArcGIS.SceneView

    /// Sets a closure to perform when a single tap occurs on the scene view.
    /// - Parameters:
    ///   - action: The closure to perform upon single tap.
    ///   - screenPoint: The location of the tap in the scene view's coordinate
    ///   space.
    ///   - scenePoint: The location of the tap in the scene's coordinate space.
    ///   Will be `nil` if the tap location is off the globe or the scene view
    ///   does not have a spatial reference.
    @MainActor public func onSingleTapGesture(perform action: @escaping (_ screenPoint: CGPoint, _ scenePoint: ArcGIS.Point?) -> Void) -> ArcGIS.SceneView

    /// Sets an action to perform when the scene view recognizes a long press
    /// gesture.
    /// - Parameters:
    ///   - action: The action to perform when a long press is recognized.
    ///   - screenPoint: The location of the long press in the scene view's
    ///   coordinate space.
    ///   - scenePoint: The location of the long press in the scene's coordinate
    ///   space.
    @MainActor public func onLongPressGesture(perform action: @escaping (_ screenPoint: CGPoint, _ scenePoint: ArcGIS.Point?) -> Void) -> ArcGIS.SceneView
}

extension SceneView.AtmosphereEffect : Equatable {
}

extension SceneView.AtmosphereEffect : Hashable {
}

extension SceneView.SpaceEffect : Equatable {
}

extension SceneView.SpaceEffect : Hashable {
}

extension SceneView.SunLighting : Equatable {
}

extension SceneView.SunLighting : Hashable {
}

/// A proxy for access to the operations of the ``SceneView``.
///
/// This proxy can be obtained in the closure when creating an instance of ``SceneViewReader``.
/// - Note: See Also: ``setViewpoint(_:duration:)``, ``identify(on:screenPoint:tolerance:returnPopupsOnly:maximumResults:)-8kqyd``
/// - Since: 200.1
public struct SceneViewProxy {
}

extension SceneViewProxy {

    /// Converts a geographical coordinate within the scene view's spatial
    /// reference to a screen point in the view coordinate space of the scene
    /// view.
    /// - Remark: The result is a type that contains both the screen coordinate
    /// and information about the coordinate's visibility. A `nil` value will be
    ///  returned if the passed in location is not in the viewport.
    /// - Parameter location: A geographical location defined within the scene
    /// view's spatial reference.
    /// - Returns: A ``ScreenPointFromLocationResult`` instance that contains
    /// both the screen point corresponding to the passed in geographical
    /// location and information about the visibility of that screen point. The
    /// screen point in the result will be in the view coordinate space of the
    /// scene view.
    public func screenPoint(fromLocation location: ArcGIS.Point) -> ArcGIS.ScreenPointFromLocationResult?

    /// Converts a screen coordinate to a geographical location with the scene
    /// view's spatial reference.
    /// - Parameter screenPoint: A screen point in the view coordinate space of
    /// the scene view.
    /// - Returns: A geographical location on the base surface in the same
    /// spatial reference as the scene view, or `nil` if the scene view does
    /// not have a spatial reference or if the screen point is off the globe.
    public func baseSurfaceLocation(fromScreenPoint screenPoint: CGPoint) -> ArcGIS.Point?

    /// Converts a screen coordinate to a geographical location within the scene
    /// view's spatial reference.
    /// - Remark: The conversion will take into account the terrain and features
    /// of the scene, returning a location not necessarily on the base surface.
    /// The function will throw if the view does not have a spatial reference.
    /// - Parameter screenPoint: A screen point in the view coordinate space of
    /// the scene view.
    /// - Returns: A `Point` that represents the geographical location within the
    /// scene view's spatial reference.
    public func location(fromScreenPoint screenPoint: CGPoint) async throws -> ArcGIS.Point
}

extension SceneViewProxy : ArcGIS.GeoViewProxy {

    /// A Boolean value indicating whether the view's content wraps around the dateline.
    /// - Precondition: The geo view reader must contain a single geo view.
    public var wrapAroundIsEnabled: Bool { get }

    /// Provides an image depicting the view's current display.
    /// - Returns: An image of the view's current display.
    public func exportImage() async throws -> UIImage

    /// Performs an identify operation on the specified graphics overlay.
    /// - Parameters:
    ///   - graphicsOverlay: The overlay on which to perform the identify.
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify
    ///   a circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only overlays with popups will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/popups``. If
    ///   `false`, all overlays (with or without popups) will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/graphics``.
    ///   - maximumResults: The maximum number of graphics which can be
    ///   identified. A value of `1` means that only the top-most graphic will
    ///   be identified. A value of `nil` means that the number of results will
    ///   not be limited.
    /// - Returns: An ``IdentifyGraphicsOverlayResult`` value.
    public func identify(on graphicsOverlay: ArcGIS.GraphicsOverlay, screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResults: Int? = 1) async throws -> ArcGIS.IdentifyGraphicsOverlayResult

    /// Performs an identify operation on all graphics overlays.
    /// - Remark: Results are returned in top-to-bottom order.
    /// - Parameters:
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only overlays with popups will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/popups``. If
    ///   `false`, all overlays (with or without popups) will be identified and
    ///   the results will be in ``IdentifyGraphicsOverlayResult/graphics``.
    ///   - maximumResultsPerOverlay: The maximum number of graphics which can
    ///   be identified per overlay. A value of `1` means only the top-most
    ///   graphic per overlay will be identified. A value of `nil` means that
    ///   the number of results per layer will not be limited.
    /// - Returns: An array of ``IdentifyGraphicsOverlayResult`` values.
    public func identifyGraphicsOverlays(screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResultsPerOverlay: Int? = 1) async throws -> [ArcGIS.IdentifyGraphicsOverlayResult]

    /// Performs an identify operation on the specified layer.
    /// - Parameters:
    ///   - layer: The layer on which to perform the identify.
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only layers with popups will be identified and the
    ///   results will be in ``IdentifyLayerResult/popups``. If `false`, all
    ///   overlays (with or without popups) will be identified and the results
    ///   will be in ``IdentifyLayerResult/geoElements``.
    ///   - maximumResults: The maximum number of elements which can be
    ///   identified. A value of `1` indicates only the top-most element per
    ///   layer and sublayer will be identified. A value of `nil` means that
    ///   the number of results per layer will not be limited.
    /// - Returns: An ``IdentifyLayerResult`` value.
    public func identify(on layer: ArcGIS.Layer, screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResults: Int? = 1) async throws -> ArcGIS.IdentifyLayerResult

    /// Performs an identify operation on all layers in the geo view.
    /// - Parameters:
    ///   - screenPoint: The screen coordinate of the geo view at which to
    ///   identify.
    ///   - tolerance: Determines the extent of the region used during the
    ///   identify operation. A tolerance of `0` tests just the point at
    ///   `screenPoint`. Tolerance values above `0` are in points and specify a
    ///   circular region centered on `screenPoint`, with radius equal to
    ///   tolerance. The maximum allowed tolerance value is `100`, resulting in
    ///   an identify circle of diameter `200`.
    ///   - returnPopupsOnly: Specifies what the identify results should
    ///   contain. If `true`, only layers with popups will be identified and the
    ///   results will be in ``IdentifyLayerResult/popups``. If `false`, all
    ///   layers (with or without popups) will be identified.
    ///   - maximumResultsPerLayer: The maximum number of elements which can be
    ///   identified per layer or sublayer. A value of `1` means that only
    ///   the top-most element per layer and sublayer will be identified. A
    ///   value of `nil` means that the number of results per layer will not be
    ///   limited.
    /// - Returns: An array of ``IdentifyLayerResult`` values.
    public func identifyLayers(screenPoint: CGPoint, tolerance: Double, returnPopupsOnly: Bool = false, maximumResultsPerLayer: Int? = 1) async throws -> [ArcGIS.IdentifyLayerResult]

    /// Sets the viewpoint of the geo view to that of the provided bookmark.
    /// - Parameter bookmark: The bookmark whose viewpoint will be used.
    /// - Returns: A Boolean value indicating whether the operation continued
    /// until the end without any interruption.
    @discardableResult
    public func setBookmark(_ bookmark: ArcGIS.Bookmark) async throws -> Bool

    /// Retrieves the current view state for the specified layer.
    /// - Parameter layer: The layer to get the view state for.
    /// - Returns: A ``LayerViewState`` value.
    /// - Precondition: The geo view reader must contain a single geo view.
    public func viewState(for layer: ArcGIS.Layer) -> ArcGIS.LayerViewState?
}

extension SceneViewProxy {

    /// Pan or zoom the geo view using animation to the specified viewpoint. Animation
    /// takes place over the specified duration.
    /// - Parameters:
    ///   - viewpoint: The viewpoint.
    ///   - duration: The amount of time in seconds to move to the new viewpoint.
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Geo view reader must contain a geo view.
    @discardableResult
    public func setViewpoint(_ viewpoint: ArcGIS.Viewpoint, duration: TimeInterval? = nil) async -> Bool

    /// Sets the display to the viewpoint specified by the given camera.
    /// - Parameter camera: The new camera information for the scene view.
    /// - Precondition: Scene view reader must contain a scene view.
    public func setViewpointCamera(_ camera: ArcGIS.Camera)

    /// Sets the display to the viewpoint specified by the given camera using the specified
    /// duration to arrive.
    /// - Parameters:
    ///   - camera: The new camera information for the scene view.
    ///   - duration: The time for the transition animation to completed, in seconds.
    /// - Returns: `true` if the animation continued until the end
    /// without interruption, otherwise `false`.
    /// - Precondition: Scene view reader must contain a scene view.
    @discardableResult
    public func setViewpointCamera(_ camera: ArcGIS.Camera, duration: TimeInterval? = nil) async -> Bool
}

/// A view whose child is defined as a function of a ``SceneViewProxy``
/// targeting the scene view within the child.
/// - Since: 200.1
public struct SceneViewReader<Content> : View where Content : View {

    /// The view builder that creates the reader's content.
    public var content: (ArcGIS.SceneViewProxy) -> Content

    /// Creates an instance that can perform programmatic actions of its
    /// child scene view.
    /// - Parameter content: The reader's content, containing one scene view.
    /// This view builder receives a ``SceneViewProxy`` instance that you use to
    /// perform actions on the scene view.
    public init(@ViewBuilder content: @escaping (ArcGIS.SceneViewProxy) -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }

    /// The type of view representing the body of this view.
    ///
    /// When you create a custom view, Swift infers this type from your
    /// implementation of the required ``View/body-swift.property`` property.
    public typealias Body = some View
}

/// A value that contains the result of converting a geographical location to a
/// screen coordinate on a ``SceneView``.
/// - Since: 200.1
public struct ScreenPointFromLocationResult {

    /// The resulting screen point of the conversion from a geographical
    /// location.
    public var screenPoint: CGPoint

    /// The visibility of the geographic location that was passed to the
    /// conversion function on the ``SceneView``.
    public var visibility: ArcGIS.ScreenPointFromLocationResult.Visibility
}

/// An enumeration that defines the visibility of a geographic location.
extension ScreenPointFromLocationResult {

    public enum Visibility {

        /// Visible.
        case visible

        /// Blocked by base surface.
        case hiddenByBaseSurface

        /// Point is on other side of globe.
        case hiddenByEarth

        /// Elevation layer is blocking visibility.
        case hiddenByElevation

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ScreenPointFromLocationResult.Visibility, b: ArcGIS.ScreenPointFromLocationResult.Visibility) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension ScreenPointFromLocationResult.Visibility : Equatable {
}

extension ScreenPointFromLocationResult.Visibility : Hashable {
}

/// A segment represents an edge of a multipart geometry, connecting a start to an end point.
///
/// A segment describes a continuous line between a start location and an end location. ArcGIS software supports
/// both linear segments (represented by ``LineSegment``) and curve segments (represented by ``CubicBezierSegment``
/// and ``EllipticArcSegment``).
///
/// `GeometryEngine.densify(_:maxSegmentLength:)` can translate curve segments into multiple ``LineSegment``
/// instances to approximate the curve.
///
/// Every ``Part`` in a ``Multipart`` geometry is a collection of ``Segment`` instances, where the end of
/// one segment is at exactly the same location as the start of the following segment. ``Multipart`` geometries
/// can be composed from and decomposed into their constituent segments if required.
///
/// Because a single location is shared by adjacent segments, a single ``Point`` object is used to represent the
/// shared location when you iterate through the points in a part. As a result, when iterating through the points
/// in a part of a polyline or polygon, there is one more point than the number of segments in that same part.
///
/// Segments are immutable so you cannot change a segment's shape once it is created. For workflows that involve
/// geometry editing, create a new segment with the properties you require.
///
/// From v100.12, curve segments are supported in geometry editing workflows. You can add curve segments to a
/// ``MultipartBuilder``, and if a geometry has curves (``Geometry/hasCurves`` is `true`) then curve segments are
/// returned where applicable from the ``Part`` collections that comprise the multipart geometry. Curve
/// and linear segments can be mixed together in the same geometry.
/// - Note: See Also: ``CubicBezierSegment``, ``EllipticArcSegment``, ``LineSegment``
/// - Since: 200.1
public class Segment {

    /// The end point of the segment.
    public var endPoint: ArcGIS.Point { get }

    /// Indicates is a segment is closed, it has a matching start and end point.
    public var isClosed: Bool { get }

    /// `false` if the object is a ``LineSegment``; `true` otherwise.
    ///
    /// Prior to v100.12, only ``LineSegment`` instances were supported when creating new geometries using a
    /// ``MultipartBuilder`` or iterating the ``Segment`` instances in an existing ``Multipart`` geometry.
    ///
    /// From v100.12, you can add curve segments (``CubicBezierSegment``, ``EllipticArcSegment``) when using a
    /// ``MultipartBuilder``, and get them back from an existing ``Multipart`` geometry when
    /// ``Geometry/hasCurves`` is `true`.
    /// - Note: See Also: ``GeometryBuilder/hasCurves``, ``MutablePart/hasCurves``, ``CubicBezierSegment``, ``EllipticArcSegment``
    public var isCurve: Bool { get }

    /// The spatial reference for the segment.
    ///
    /// If the segment does not have a spatial reference `nil` is returned.
    public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The start point of the segment.
    public var startPoint: ArcGIS.Point { get }
}

extension Segment : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Segment, rhs: ArcGIS.Segment) -> Bool
}

extension Segment : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A class that describes service area facility.
///
/// Facilities represent locations from which service areas need to be calculated. For example, a fire station can
/// be set as a facility to find which areas it can serve within a 10 minute service area. A hospital can be set as
/// the facility to find what proportion of the population is within a 2 mile driving distance.
/// - Since: 200.1
final public class ServiceAreaFacility {

    /// Creates a service area facility instance with point.
    ///
    /// Creates a facility.
    /// - Parameter point: A point.
    /// - Note: See Also: ``Point``
    public convenience init(point: ArcGIS.Point)

    /// Curb approach.
    ///
    /// Default value ``CurbApproach/eitherSide`` will be returned on error.
    /// - Note: See Also: ``CurbApproach``
    final public var curbApproach: ArcGIS.CurbApproach?

    /// Current bearing in degrees.
    ///
    /// Current bearing in degrees, measured clockwise from `true` north. Typical values are 0 to 360 or `nan`,
    /// negative values will be subtracted from 360 (e.g. -15 => 345), values greater than 360 will be have 360
    /// subtracted from them (e.g. 385 => 25). For this property to be used the bearing tolerance also has to be set.
    final public var currentBearing: Double

    /// Current bearing tolerance in degrees. Valid values are 0 to 180 or `nan`.
    final public var currentBearingTolerance: Double

    /// Distance to network location in meters.
    ///
    /// The distance to network location in meters can be populated by service area task.
    final public var distanceToNetworkLocation: Measurement<UnitLength> { get }

    /// Service area facility ID.
    ///
    /// This is a caller supplied foreign key that can be used to associate output facilities with input facilities.
    /// - Note: See Also: `ServiceAreaParameters.setFacilities(fromFeaturesIn:queryParameters:)`, ``ServiceAreaResult/facilities``
    final public var facilityID: Int

    /// The geometry of a service area facility.
    ///
    /// Gets service area facility's location using geographical point.
    /// - Note: See Also: ``Point``
    final public var geometry: ArcGIS.Point? { get }

    /// The impedance cutoffs value.
    ///
    /// Cutoffs specify the quantity of the impedance to apply. They constrain the extent of the service area
    /// to be calculated. For example, if you apply breaks of 5, 10, and 15 when the impedance is set to Time,
    /// the service area will include those streets that can be reached within 5, 10, and 15 minutes.
    /// The value specified in the impedance cutoffs property overrides the Default Cutoffs analysis setting.
    /// If no value for the impedance cutoffs property is specified, service area are generated for the facility
    /// based on the Default Cutoffs setting.
    final public var impedanceCutoffs: [Double] { get }

    /// Adds a sequence of `Double` values to the end of the `impedanceCutoffs` property.
    /// - Parameter newImpedanceCutoffs: The new `Double` values to append.
    final public func addImpedanceCutoffs<S>(_ newImpedanceCutoffs: S) where S : Sequence, S.Element == Double

    /// Adds a `Double` value to the end of the `impedanceCutoffs` property.
    /// - Parameter newImpedanceCutoff: The new `Double` value to append.
    final public func addImpedanceCutoff(_ newImpedanceCutoff: Double)

    /// Inserts a collection of `Double` values into the `impedanceCutoffs` property at the specified position.
    /// - Parameters:
    ///   - newImpedanceCutoffs: The new `Double` values to insert.
    ///   - index: The position at which to insert the new `Double` values.
    final public func insertImpedanceCutoffs<C>(_ newImpedanceCutoffs: C, at index: Int) where C : Collection, C.Element == Double

    /// Inserts a `Double` value into the `impedanceCutoffs` property at the specified position.
    /// - Parameters:
    ///   - newImpedanceCutoff: The new `Double` value to insert.
    ///   - index: The position at which to insert the new `Double` value.
    final public func insertImpedanceCutoff(_ newImpedanceCutoff: Double, at index: Int)

    /// Removes all values from the `impedanceCutoffs` property.
    final public func removeAllImpedanceCutoffs()

    /// Removes a sequence of `Double` values from the `impedanceCutoffs` property.
    /// - Parameter impedanceCutoffs: The `Double` values to remove.
    final public func removeImpedanceCutoffs<S>(_ impedanceCutoffs: S) where S : Sequence, S.Element == Double

    /// Removes a `Double` value from the `impedanceCutoffs` property.
    /// - Parameter impedanceCutoff: The `Double` value to remove.
    final public func removeImpedanceCutoff(_ impedanceCutoff: Double)

    /// Location status.
    ///
    /// Facility location's status can be populated by service area task.
    /// Default value ``LocationStatus/notLocated`` will be returned on error.
    /// - Note: See Also: ``LocationStatus``
    final public var locationStatus: ArcGIS.LocationStatus { get }

    /// Service area facility's name.
    ///
    /// Service area facility's name to be reported.
    /// - Note: See Also: `String`
    final public var name: String

    /// Navigation latency in seconds.
    final public var navigationLatency: TimeInterval

    /// Navigation speed in meters per second.
    final public var navigationSpeed: Double

    /// Network location.
    ///
    /// The service area facility's location on the network that can be populated by service area task.
    /// Set to `nil` for resetting a network location.
    /// - Note: See Also: ``NetworkLocation``
    final public var networkLocation: ArcGIS.NetworkLocation?

    /// Gets added cost.
    ///
    /// Returns added cost value for given impedance or accumulate attribute.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: The value of added cost.
    final public func addedCost(forAttributeNamed attributeName: String) -> Double

    /// Clones the ``ServiceAreaFacility``.
    /// - Returns: A new ``ServiceAreaFacility`` with the same values as the current ``ServiceAreaFacility``.
    final public func clone() -> Self

    /// Sets added cost.
    ///
    /// Sets added cost value for given impedance or accumulate attribute.
    /// - Parameters:
    ///   - addedCost: The added cost.
    ///   - attributeName: The name of attribute.
    final public func setAddedCost(_ addedCost: Double, forAttributeNamed attributeName: String)
}

/// Service area overlap geometry.
///
/// Specifies the behavior of service-area output from multiple facilities in relation to one another.
/// - Since: 200.1
public enum ServiceAreaOverlapGeometry {

    /// Creates individual polygons or sets of lines for each facility.
    /// The polygons or lines can overlap each other.
    case overlap

    /// Joins the polygons of multiple facilities that have the same cutoff value into a single polygon.
    /// Lines will not overlap each other.
    case dissolve

    /// Area is assigned to the closest facility so polygons or lines do not overlap each other.
    case split

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ServiceAreaOverlapGeometry, b: ArcGIS.ServiceAreaOverlapGeometry) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ServiceAreaOverlapGeometry : Equatable {
}

extension ServiceAreaOverlapGeometry : Hashable {
}

/// A class that describes the service area parameters.
///
/// Class holding the parameters of a service area to be solved by ``ServiceAreaTask``.
/// The default parameters for a ``ServiceAreaTask`` can be retrieved by calling `ServiceAreaTask.makeDefaultParameters()` method.
/// - Note: See Also: ``ServiceAreaTask``
/// - Since: 200.1
final public class ServiceAreaParameters {

    /// Accumulate attribute names.
    ///
    /// The accumulate attribute names e.g. "Minutes", "Miles", etc.
    /// Accumulate attributes are useful when more information other than the default impedance attribute is required.
    /// - Note: See Also: `Array`
    final public var accumulateAttributeNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `accumulateAttributeNames` property.
    /// - Parameter newAccumulateAttributeNames: The new `String` values to append.
    final public func addAccumulateAttributeNames<S>(_ newAccumulateAttributeNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `accumulateAttributeNames` property.
    /// - Parameter newAccumulateAttributeName: The new `String` value to append.
    final public func addAccumulateAttributeName(_ newAccumulateAttributeName: String)

    /// Inserts a collection of `String` values into the `accumulateAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newAccumulateAttributeNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertAccumulateAttributeNames<C>(_ newAccumulateAttributeNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `accumulateAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newAccumulateAttributeName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertAccumulateAttributeName(_ newAccumulateAttributeName: String, at index: Int)

    /// Removes all values from the `accumulateAttributeNames` property.
    final public func removeAllAccumulateAttributeNames()

    /// Removes a sequence of `String` values from the `accumulateAttributeNames` property.
    /// - Parameter accumulateAttributeNames: The `String` values to remove.
    final public func removeAccumulateAttributeNames<S>(_ accumulateAttributeNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `accumulateAttributeNames` property.
    /// - Parameter accumulateAttributeName: The `String` value to remove.
    final public func removeAccumulateAttributeName(_ accumulateAttributeName: String)

    /// The default cutoffs value.
    ///
    /// Cutoffs specify the quantity of the impedance to apply. They constrain the extent of the service area
    /// to be calculated. For example, if you apply breaks of 5, 10, and 15 when the impedance is set to Time,
    /// the service area will include those streets that can be reached within 5, 10, and 15 minutes.
    /// The cutoffs you specify in the defaultBreaks property are applied to all facilities that don't contain
    /// their own cutoffs.
    final public var defaultImpedanceCutoffs: [Double] { get }

    /// Adds a sequence of `Double` values to the end of the `defaultImpedanceCutoffs` property.
    /// - Parameter newDefaultImpedanceCutoffs: The new `Double` values to append.
    final public func addDefaultImpedanceCutoffs<S>(_ newDefaultImpedanceCutoffs: S) where S : Sequence, S.Element == Double

    /// Adds a `Double` value to the end of the `defaultImpedanceCutoffs` property.
    /// - Parameter newDefaultImpedanceCutoff: The new `Double` value to append.
    final public func addDefaultImpedanceCutoff(_ newDefaultImpedanceCutoff: Double)

    /// Inserts a collection of `Double` values into the `defaultImpedanceCutoffs` property at the specified position.
    /// - Parameters:
    ///   - newDefaultImpedanceCutoffs: The new `Double` values to insert.
    ///   - index: The position at which to insert the new `Double` values.
    final public func insertDefaultImpedanceCutoffs<C>(_ newDefaultImpedanceCutoffs: C, at index: Int) where C : Collection, C.Element == Double

    /// Inserts a `Double` value into the `defaultImpedanceCutoffs` property at the specified position.
    /// - Parameters:
    ///   - newDefaultImpedanceCutoff: The new `Double` value to insert.
    ///   - index: The position at which to insert the new `Double` value.
    final public func insertDefaultImpedanceCutoff(_ newDefaultImpedanceCutoff: Double, at index: Int)

    /// Removes all values from the `defaultImpedanceCutoffs` property.
    final public func removeAllDefaultImpedanceCutoffs()

    /// Removes a sequence of `Double` values from the `defaultImpedanceCutoffs` property.
    /// - Parameter defaultImpedanceCutoffs: The `Double` values to remove.
    final public func removeDefaultImpedanceCutoffs<S>(_ defaultImpedanceCutoffs: S) where S : Sequence, S.Element == Double

    /// Removes a `Double` value from the `defaultImpedanceCutoffs` property.
    /// - Parameter defaultImpedanceCutoff: The `Double` value to remove.
    final public func removeDefaultImpedanceCutoff(_ defaultImpedanceCutoff: Double)

    /// Geometry at cutoff.
    ///
    /// Specifies the behavior of service area output for a single facility when multiple cutoff values are specified.
    /// This parameter does not apply to line output.
    /// Default value ``ServiceAreaPolygonCutoffGeometry/rings`` will be returned on error.
    /// - Note: See Also: ``ServiceAreaPolygonCutoffGeometry``
    final public var geometryAtCutoff: ArcGIS.ServiceAreaPolygonCutoffGeometry

    /// Geometry at overlap.
    ///
    /// Specifies the behavior of service-area output from multiple facilities in relation to one another.
    /// Default value ``ServiceAreaOverlapGeometry/overlap`` will be returned on error.
    /// - Note: See Also: ``ServiceAreaOverlapGeometry``
    final public var geometryAtOverlap: ArcGIS.ServiceAreaOverlapGeometry

    /// Output spatial reference.
    ///
    /// All route's geometries will be returned in this spatial reference in the even of a successful solve.
    /// - Note: See Also: ``SpatialReference``
    final public var outputSpatialReference: ArcGIS.SpatialReference?

    /// Polygon buffer distance.
    ///
    /// The polygon buffer refers to the distance from the road the service area polygon should extend when
    /// no other reachable roads are nearby, similar to a line buffer size. This is useful if the network is
    /// very sparse and you don't want the service area to cover large areas where there are no features.
    final public var polygonBufferDistance: Double

    /// Polygon detail.
    ///
    /// Specifies the level of detail of the output polygons.
    /// If your analysis covers an urban area with a grid-like street network, the difference between generalized and
    /// standard polygons will be minimal. However, for mountain and rural roads, the standard and detailed polygons may
    /// present significantly more accurate results than generalized polygons.
    /// Default value ``ServiceAreaPolygonDetail/standard`` will be returned on error.
    /// - Note: See Also: ``ServiceAreaPolygonDetail``
    final public var polygonDetail: ArcGIS.ServiceAreaPolygonDetail

    /// Whether or not to return the point barriers used in the service area task.
    final public var returnsPointBarriers: Bool

    /// Whether or not to return the polygon barriers used in the service area task.
    final public var returnsPolygonBarriers: Bool

    /// Whether or not return service area polygons are to be returned.
    ///
    /// Enabled by default. Can be returned in the ``ServiceAreaResult`` of a successful solve.
    final public var returnsPolygons: Bool

    /// Whether or not to return the polyline barriers used in the service area task.
    final public var returnsPolylineBarriers: Bool

    /// Whether or not return service area polylines are to be returned.
    ///
    /// Disabled by default. Can be returned in the ``ServiceAreaResult`` of a successful solve.
    final public var returnsPolylines: Bool

    /// Start time.
    ///
    /// Start time in the UTC time zone.
    /// Returns `nil` if start time was not specified.
    /// - Note: See Also: `Date`
    final public var startDate: Date?

    /// The travel direction for the service area computation (to or from facility).
    ///
    /// Default value ``TravelDirection/fromFacility`` will be returned on error.
    /// - Note: See Also: ``TravelDirection``
    final public var travelDirection: ArcGIS.TravelDirection

    /// Travel mode.
    ///
    /// Travel mode that will be used for service area's solving.
    /// List of supported travel modes can be obtained from ``ServiceAreaTaskInfo/travelModes`` method.
    /// - Note: See Also: ``TravelMode``
    final public var travelMode: ArcGIS.TravelMode?

    /// Clears facilities.
    ///
    /// Clears facilities that were set by `ServiceAreaParameters.setFacilities(fromFeaturesIn:queryParameters:)`.
    final public func clearFacilities()

    /// Clears point barriers.
    ///
    /// Clears point barriers that were set by `ServiceAreaParameters.setPointBarriers(_:)` or `ServiceAreaParameters.setPointBarriers(fromFeaturesIn:queryParameters:)`.
    final public func clearPointBarriers()

    /// Clears polygon barriers.
    ///
    /// Clears polygon barriers that were set by `ServiceAreaParameters.setPolygonBarriers(_:)` or `ServiceAreaParameters.setPolygonBarriers(fromFeaturesIn:queryParameters:)`.
    final public func clearPolygonBarriers()

    /// Clears polyline barriers.
    ///
    /// Clears polyline barriers that were set by `ServiceAreaParameters.setPolylineBarriers(_:)` or `ServiceAreaParameters.setPolylineBarriers(fromFeaturesIn:queryParameters:)`.
    final public func clearPolylineBarriers()

    /// Clones the ``ServiceAreaParameters``.
    /// - Returns: A new ``ServiceAreaParameters`` with the same values as the current ``ServiceAreaParameters``.
    final public func clone() -> Self

    /// Gets the search where clause from the specified network dataset's source feature class.
    /// - Parameter sourceName: The name of the network dataset's source feature class to retrieve the where clause from.
    /// - Returns: A `String`.
    final public func searchWhereClause(fromSourceNamed sourceName: String) -> String

    /// Sets facilities.
    ///
    /// The set of service area facilities loaded as network locations during analysis.
    /// You need to specify at least one facility to successfully `ServiceAreaTask.solveServiceArea(using:)`.
    /// - Parameter facilities: An `Array` of ``ServiceAreaFacility`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``ServiceAreaFacility``
    final public func setFacilities<S>(_ facilities: S) where S : Sequence, S.Element == ArcGIS.ServiceAreaFacility

    /// Sets the facilities from the features in specified feature table.  The feature table can be either local or online.
    /// The feature table must be of geometry type point.  Attributes from the feature table are mapped to the properties
    /// on the facilities objects generated from the specified feature table.  The where clause set in the query parameters
    /// will be applied to the feature table.  If an online feature table is specified the table will not be queried for
    /// features until Solve is called.
    ///
    /// Sets facilities by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setFacilities(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets point barriers.
    /// - Parameter pointBarriers: An `Array` of ``PointBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PointBarrier``
    final public func setPointBarriers<S>(_ pointBarriers: S) where S : Sequence, S.Element == ArcGIS.PointBarrier

    /// Sets the point barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type point.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    ///
    /// Sets point barriers by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPointBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets polygon barriers.
    /// - Parameter polygonBarriers: An `Array` of ``PolygonBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PolygonBarrier``
    final public func setPolygonBarriers<S>(_ polygonBarriers: S) where S : Sequence, S.Element == ArcGIS.PolygonBarrier

    /// Sets the polygon barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type polygon.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    ///
    /// Sets polygon barriers by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPolygonBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets polyline barriers.
    /// - Parameter lineBarriers: An `Array` of ``PolylineBarrier`` instances. Contents of the `Array` are copied.
    /// - Note: See Also: `Array`, ``PolylineBarrier``
    final public func setPolylineBarriers<S>(_ lineBarriers: S) where S : Sequence, S.Element == ArcGIS.PolylineBarrier

    /// Sets the polyline barriers from the features in specified feature table.  The feature table can be either local or
    /// online. The feature table must be of geometry type polyline.  Attributes from the feature table are mapped to the
    /// properties on the barrier objects generated from the specified feature table.  The where clause set in the query
    /// parameters will be applied to the feature table.  If an online feature table is specified the table will not be
    /// queried for features until Solve is called.
    ///
    /// Sets polyline barriers by importing them from local or remote table.
    /// - Parameters:
    ///   - featureTable: The feature table.
    ///   - queryParameters: The query parameters.
    /// - Note: See Also: ``FeatureTable``, ``QueryParameters``
    final public func setPolylineBarriers(fromFeaturesIn featureTable: ArcGIS.ArcGISFeatureTable, queryParameters: ArcGIS.QueryParameters)

    /// Sets a search where clause on the specified network dataset's source feature class.  Only features satisfying the
    /// where clause for the specified feature class will be used to locate facilities on the network during the solve
    /// operation.  If a where clause is not set all network features are used.
    /// - Parameters:
    ///   - searchWhereClause: The search where clause.
    ///   - sourceName: The name of the network dataset's source feature class the where clause will be applied to.
    final public func setSearchWhereClause(_ searchWhereClause: String, forSourceNamed sourceName: String)
}

/// A class that describes the single service area polygon.
///
/// The service area polygon stores the resultant service area polygon, which cover the area of the network that can
/// be reached within the given time, distance, or other travel-cost cutoff.
/// - Since: 200.1
final public class ServiceAreaPolygon {

    /// From impedance cutoff.
    ///
    /// A service area polygon's minimal impedance value.
    /// For example, an time impedance value of "5 10 15" specifies service areas of 5, 10, and 15 minutes intervals.
    /// You can get polygon which covers area from 5 to 10 minutes interval.
    final public var fromImpedanceCutoff: Double { get }

    /// Service area polygon's geometry.
    ///
    /// The geometry for the polygon in case if ``ServiceAreaParameters/returnsPolygons`` is `true`.
    /// - Note: See Also: ``Polygon``
    final public var geometry: ArcGIS.Polygon { get }

    /// To impedance cutoff.
    ///
    /// A service area polygon's maximal impedance value.
    /// For example, an time impedance value of "5 10 15" specifies service areas of 5, 10, and 15 minutes intervals.
    /// You can get polygon which covers area from 5 to 10 minutes interval.
    final public var toImpedanceCutoff: Double { get }
}

/// Service area polygon cutoff geometry.
///
/// Specifies the behavior of service area output for a single facility when multiple cutoff values are specified.
/// This parameter does not apply to line output.
/// - Since: 200.1
public enum ServiceAreaPolygonCutoffGeometry {

    /// Each polygon includes only the area between consecutive cutoff values.
    /// It does not include the area between the facility and any smaller cutoffs.
    /// For instance, If you create 5- and 10-minute service areas, then the 5-minute service area polygon will include
    /// the area reachable in 0-5 minutes, and the 10-minute service area polygon will include the area reachable between
    /// 5 and 10 minutes.
    case rings

    /// Each polygon includes the area reachable from the facility up to the cutoff value,
    /// including the area reachable within smaller cutoff values.
    /// For instance, If you create 5- and 10-minute service areas, then the 10-minute service area polygon will include
    /// the area under the 5-minute service area polygon.
    case disks

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ServiceAreaPolygonCutoffGeometry, b: ArcGIS.ServiceAreaPolygonCutoffGeometry) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ServiceAreaPolygonCutoffGeometry : Equatable {
}

extension ServiceAreaPolygonCutoffGeometry : Hashable {
}

/// Service area polygon detail.
///
/// Specifies the level of detail of the output polygons.
/// If your analysis covers an urban area with a grid-like street network, the difference between generalized and
/// standard polygons will be minimal. However, for mountain and rural roads, the standard and detailed polygons may
/// present significantly more accurate results than generalized polygons.
/// - Since: 200.1
public enum ServiceAreaPolygonDetail {

    /// Creates generalized polygons using the hierarchy present in the network data source in order to produce results quickly.
    case generalized

    /// Creates polygons with a standard level of detail. This is the default.
    case standard

    /// Creates polygons with a higher level of detail for applications in which very precise results are important.
    case high

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ServiceAreaPolygonDetail, b: ArcGIS.ServiceAreaPolygonDetail) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ServiceAreaPolygonDetail : Equatable {
}

extension ServiceAreaPolygonDetail : Hashable {
}

/// A class that describes the single service area polyline.
///
/// The service area polyline stores the resultant service area polyline, which the represents the network edges
/// that can be reached within the given impedance.
/// - Since: 200.1
final public class ServiceAreaPolyline {

    /// Network location where the polyline begins.
    ///
    /// The location on the network where the service area polyline begins.
    /// - Note: See Also: ``NetworkLocation``
    final public var fromNetworkLocation: ArcGIS.NetworkLocation? { get }

    /// Service area polyline's geometry.
    ///
    /// The geometry for the polyline in case if ``ServiceAreaParameters/returnsPolylines`` is `true`.
    /// - Note: See Also: ``Polyline``
    final public var geometry: ArcGIS.Polyline { get }

    /// Network location where the polyline ends.
    ///
    /// The location on the network where the service area polyline ends.
    /// - Note: See Also: ``NetworkLocation``
    final public var toNetworkLocation: ArcGIS.NetworkLocation? { get }

    /// Gets the cumulative cost for the beginning of polyline.
    ///
    /// Returns the cumulative cost value of the path from the facility to the beginning of this polyline.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: A value of cumulative cost.
    final public func fromCumulativeCost(forAttributeNamed attributeName: String) -> Double

    /// Gets the cumulative cost for the end of polyline.
    ///
    /// Returns the cumulative cost value of the path from the facility to the end of this polyline.
    /// - Parameter attributeName: The name of attribute.
    /// - Returns: A value of cumulative cost.
    final public func toCumulativeCost(forAttributeNamed attributeName: String) -> Double
}

/// A class that describes the service area result.
///
/// The result from `ServiceAreaTask.solveServiceArea(using:)` operation.
/// A Service area result object represents the results of the operation. It can contains the following (if you
/// enabled returning corresponding property on parameters):
/// An array of polygons and/or lines representing the service areas.
/// An array of graphics representing the facilities used in the analysis.
/// An arrays of barriers (point, polyline, polygon)
/// - Since: 200.1
final public class ServiceAreaResult {

    /// Array of the facilities used to calculate the service are.
    /// - Note: See Also: `Array`, ``ServiceAreaFacility``
    final public var facilities: [ArcGIS.ServiceAreaFacility] { get }

    /// Messages.
    ///
    /// Messages received when solve is completed. If a route cannot be solved, the message
    /// returned by the server identifies the route that could not be solved.
    /// - Note: See Also: `Array`, `String`
    final public var messages: [String] { get }

    /// Array of the point barriers.
    ///
    /// Barriers are only returned if the returnPointBarriers property of ``ServiceAreaParameters`` is `true`.
    /// - Note: See Also: `Array`, ``PointBarrier``, ``ServiceAreaParameters``
    final public var pointBarriers: [ArcGIS.PointBarrier] { get }

    /// Array of the polygon barriers.
    ///
    /// Barriers are only returned if the returnPolygonBarriers property of ``ServiceAreaParameters`` is `true`.
    /// - Note: See Also: `Array`, ``PolygonBarrier``, ``ServiceAreaParameters/returnsPolygonBarriers``
    final public var polygonBarriers: [ArcGIS.PolygonBarrier] { get }

    /// Array of the polyline barriers.
    ///
    /// Barriers are only returned if the returnPolylineBarriers property of ``ServiceAreaParameters`` is `true`.
    /// - Note: See Also: `Array`, ``PolylineBarrier``, ``ServiceAreaParameters/returnsPolylineBarriers``
    final public var polylineBarriers: [ArcGIS.PolylineBarrier] { get }

    /// Gets array of the result polygons.
    ///
    /// Result polygons are only returned if the returnPolygons property of ``ServiceAreaParameters`` is `true`.
    /// - Parameter facilityIndex: The index of facility.
    /// - Returns: An `Array` of ``ServiceAreaPolygon``
    /// - Note: See Also: `Array`, ``PolygonBarrier``, ``ServiceAreaParameters``
    final public func resultPolygons(forFacilityAtIndex facilityIndex: Int) -> [ArcGIS.ServiceAreaPolygon]

    /// Gets array of the result polylines.
    ///
    /// Result polylines are only returned if the returnPolylines property of ``ServiceAreaParameters`` is `true`.
    /// - Parameter facilityIndex: The index of facility.
    /// - Returns: An `Array` of ``ServiceAreaPolyline``
    /// - Note: See Also: `Array`, ``ServiceAreaPolyline``, ``ServiceAreaParameters``
    final public func resultPolylines(forFacilityAtIndex facilityIndex: Int) -> [ArcGIS.ServiceAreaPolyline]
}

/// Instances of this class represent tasks that can compute service areas.
///
/// A Service Area task allows you to calculate areas that can be serviced (reached) from a given location.
/// A service area is a region that encompasses all accessible streets, that is, streets that lie within a specified impedance.
/// For instance, the 10-minute service area for a facility includes all the streets that can be reached within 10 minutes from that facility.
/// - Since: 200.1
final public class ServiceAreaTask : ArcGIS.APIKeyResource, ArcGIS.Loadable {

    /// Creates a service area task with path to geodatabase.
    /// - Parameters:
    ///   - databaseURL: A path to geodatabase.
    ///   - networkName: A network name.
    public convenience init(databaseURL: URL, networkName: String)

    /// Creates a service area task with transportation network dataset.
    /// - Parameter dataset: A transportation network dataset.
    /// - Note: See Also: ``TransportationNetworkDataset``
    public convenience init(dataset: ArcGIS.TransportationNetworkDataset)

    /// Creates a service area task with URL.
    ///
    /// Creates a service area task.
    /// - Parameter url: An URL to online routing services.
    public convenience init(url: URL)

    /// Service area task info.
    ///
    /// Information about this service area task.
    /// For a service area task using an online service, this will involve a network call.
    /// - Note: See Also: ``ServiceAreaTaskInfo``
    final public var info: ArcGIS.ServiceAreaTaskInfo? { get }

    /// Transportation network dataset.
    /// - Note: See Also: ``TransportationNetworkDataset``
    final public var transportationNetworkDataset: ArcGIS.TransportationNetworkDataset? { get }

    /// The URL of online service.
    ///
    /// The URL that will be used when the service area task is loaded.
    /// - Note: See Also: `String`
    final public var url: URL? { get }

    /// Creates default parameters.
    ///
    /// Retrieves the default parameters as defined by the service.
    /// - Returns: A ``ServiceAreaParameters`` type.
    /// - Note: See Also: ``ServiceAreaParameters``
    final public func makeDefaultParameters() async throws -> ArcGIS.ServiceAreaParameters

    /// Solve a service area passing in a parameters object.
    ///
    /// Executes the ``ServiceAreaParameters`` defined for this ``ServiceAreaTask``
    /// and returns a ``ServiceAreaResult`` containing the results.
    /// - Parameter serviceAreaParameters: The service area parameters.
    /// - Returns: A ``ServiceAreaResult`` type.
    /// - Note: See Also: ``ServiceAreaParameters``
    final public func solveServiceArea(using serviceAreaParameters: ArcGIS.ServiceAreaParameters) async throws -> ArcGIS.ServiceAreaResult

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// A description of a service area task.
/// - Since: 200.1
public struct ServiceAreaTaskInfo {
}

extension ServiceAreaTaskInfo {

    /// Accumulate attribute names.
    /// - Note: See Also: `Array`, `String`
    public var accumulateAttributeNames: [String] { get }

    /// Cost attributes.
    ///
    /// Key in the result dictionary is name of cost attribute.
    /// - Note: See Also: `Dictionary`
    public var costAttributes: [String : ArcGIS.CostAttribute] { get }

    /// Default impedance cutoffs.
    ///
    /// Cutoffs specify the quantity of the impedance to apply. They constrain the extent of the service area
    /// to be calculated. For example, if you apply breaks of 5, 10, and 15 when the impedance is set to Time,
    /// the service area will include those streets that can be reached within 5, 10, and 15 minutes.
    /// - Note: See Also: `Array`
    public var defaultImpedanceCutoffs: [Double] { get }

    /// Default travel mode's name.
    /// - Note: See Also: `String`
    public var defaultTravelModeName: String { get }

    /// Geometry at cutoff.
    ///
    /// Specifies the behavior of service area output for a single facility when multiple cutoff values are specified.
    /// This parameter does not apply to line output.
    /// Default value ``ServiceAreaPolygonCutoffGeometry/rings`` will be returned on error.
    /// - Note: See Also: ``ServiceAreaPolygonCutoffGeometry``
    public var geometryAtCutoff: ArcGIS.ServiceAreaPolygonCutoffGeometry { get }

    /// Geometry at overlap.
    ///
    /// Specifies the behavior of service-area output from multiple facilities in relation to one another.
    /// Default value ``ServiceAreaOverlapGeometry/overlap`` will be returned on error.
    /// - Note: See Also: ``ServiceAreaOverlapGeometry``
    public var geometryAtOverlap: ArcGIS.ServiceAreaOverlapGeometry { get }

    /// Maximum locating distance is the furthest distance in meters that Network Analyst searches when locating or relocating a point onto the network.
    ///
    /// The search looks for suitable edges or junctions and snaps the point to the nearest one.
    /// If a suitable location isn't found within the maximum locating distance, the object is marked as unlocated.
    public var maxLocatingDistance: Measurement<UnitLength> { get }

    /// Network name.
    /// - Note: See Also: `String`
    public var networkName: String { get }

    /// Output spatial reference.
    ///
    /// The spatial reference that will be used for output geometry during service area solving.
    /// - Note: See Also: ``SpatialReference``
    public var outputSpatialReference: ArcGIS.SpatialReference? { get }

    /// Polygon buffer distance.
    ///
    /// The polygon buffer refers to the distance from the road the service area polygon should extend when
    /// no other reachable roads are nearby, similar to a line buffer size. This is useful if the network is
    /// very sparse and you don't want the service area to cover large areas where there are no features.
    public var polygonBufferDistance: Double { get }

    /// Polygon detail.
    ///
    /// Specifies the level of detail of the output polygons.
    /// If your analysis covers an urban area with a grid-like street network, the difference between generalized and
    /// standard polygons will be minimal. However, for mountain and rural roads, the standard and detailed polygons may
    /// present significantly more accurate results than generalized polygons.
    /// Default value ``ServiceAreaPolygonDetail/standard`` will be returned on error.
    /// - Note: See Also: ``ServiceAreaPolygonDetail``
    public var polygonDetail: ArcGIS.ServiceAreaPolygonDetail { get }

    /// Restriction attributes.
    ///
    /// The names of set restriction attributes e.g. "Oneway". Key in the result dictionary is name of restriction attribute.
    /// - Note: See Also: `Dictionary`
    public var restrictionAttributes: [String : ArcGIS.RestrictionAttribute] { get }

    /// Return polygons.
    ///
    /// Specifies the type of output to be generated.
    /// Service area output will contain polygon features encompassing reachable area(s).
    public var returnsPolygons: Bool { get }

    /// Return polylines.
    ///
    /// Specifies the type of output to be generated.
    /// Service area output will contain line features representing the roads reachable before the cutoffs are exceeded.
    public var returnsPolylines: Bool { get }

    /// Start time.
    ///
    /// A `nil` if a start time was not set.
    /// - Note: See Also: `Date`
    public var startDate: Date? { get }

    /// Array of supported restriction usage parameter values.
    ///
    /// Array of special string values for restriction usage, such as Avoid_High.
    /// - Note: See Also: `Array`, `String`
    public var supportedRestrictionUsageParameterValues: [String] { get }

    /// Travel direction.
    ///
    /// Default value ``TravelDirection/fromFacility`` will be returned on error.
    /// - Note: See Also: ``TravelDirection``
    public var travelDirection: ArcGIS.TravelDirection { get }

    /// Array of supported travel modes.
    /// - Note: See Also: `Array`, ``TravelMode``
    public var travelModes: [ArcGIS.TravelMode] { get }
}

/// How curve geometries are fetched from and sent to services that support curves.
///
/// By default, curve geometries are not fetched from services that support curves, meaning that densified
/// versions of any curve geometries are fetched from the service. By default, this API is not a `true`
/// curve-enabled client when sending updates to services that support curves. Use
/// ``ArcGISEnvironment/serviceCurveGeometryMode`` to change this default behavior.
///
/// For details of curve support in services, see [ArcGIS REST API documentation](https://developers.arcgis.com/rest/services-reference/enterprise/get-started-with-the-services-directory.htm).
/// - Note: See Also: ``ArcGISEnvironment/serviceCurveGeometryMode``, ``ArcGISFeatureServiceInfo/supportsTrueCurve``,
/// ``ArcGISFeatureServiceInfo/allowsTrueCurveUpdates``,
/// ``ArcGISFeatureServiceInfo/onlyAllowTrueCurveUpdatesByTrueCurveClients``
/// - Since: 200.1
public enum ServiceCurveGeometryMode {

    /// Densified versions of geometries with curves are fetched. This is the default.
    case densifyCurves

    /// Curve geometries are fetched, and this API acts as a `true` curve client when editing.
    case trueCurveClient

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ServiceCurveGeometryMode, b: ArcGIS.ServiceCurveGeometryMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ServiceCurveGeometryMode : Equatable {
}

extension ServiceCurveGeometryMode : Hashable {
}

/// Provides various information about the map service such as title, author, keywords and comments. It also includes
/// the text anti-aliasing mode.
/// - Note: See Also: ``ArcGISMapServiceInfo/documentInfo``, ``ArcGISFeatureServiceInfo/documentInfo``
/// - Since: 200.1
final public class ServiceDocumentInfo {

    /// An enumeration of various antialiasing modes.
    public enum AntialiasingMode {

        /// No antialiasing is performed.
        case off

        /// Minimal antialiasing is performed, optimized for speed.
        case fastest

        /// Some antialiasing is performed, optimized for speed with better quality than can be achieved with Fastest.
        case fast

        /// A good balance of speed and quality.
        case normal

        /// The best quality antialiasing.  This option takes the longest to render.
        case best

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ServiceDocumentInfo.AntialiasingMode, b: ArcGIS.ServiceDocumentInfo.AntialiasingMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An enumeration of the different text antialiasing modes.
    public enum TextAntialiasingMode {

        /// No text antialiasing is performed.
        case off

        /// Text antialiasing is performed as determined by the font.
        case normal

        /// Text is always drawn with antialiasing regardless of individual font parameters.
        case force

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ServiceDocumentInfo.TextAntialiasingMode, b: ArcGIS.ServiceDocumentInfo.TextAntialiasingMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The anti aliasing mode.
    final public var antialiasingMode: ArcGIS.ServiceDocumentInfo.AntialiasingMode { get }

    /// The document author.
    final public var author: String { get }

    /// The document category.
    final public var category: String { get }

    /// The document comments.
    final public var comments: String { get }

    /// The document keywords.
    /// - Note: See Also: `Array`, `String`
    final public var keywords: [String] { get }

    /// The document subject.
    final public var subject: String { get }

    /// The text anti aliasing mode.
    final public var textAntialiasingMode: ArcGIS.ServiceDocumentInfo.TextAntialiasingMode { get }

    /// The document title.
    final public var title: String { get }
}

extension ServiceDocumentInfo.AntialiasingMode : Equatable {
}

extension ServiceDocumentInfo.AntialiasingMode : Hashable {
}

extension ServiceDocumentInfo.TextAntialiasingMode : Equatable {
}

extension ServiceDocumentInfo.TextAntialiasingMode : Hashable {
}

/// A value that represents an error that occurred when connecting to a network
/// service.
/// - Since: 200.1
public struct ServiceError : Error {

    /// An error code. Typically this will be an HTTP status code.
    public let code: Int

    /// A basic description for the error.
    public let description: String

    /// Details beyond the basic message about the error.
    public let details: String

    /// Additional information about the error.
    public let info: [String : String]
}

extension ServiceError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ServiceError, b: ArcGIS.ServiceError) -> Bool
}

/// A table of features that typically represents real-world objects created from an ArcGIS feature service.
///
/// An instance of this class represents the dataset of an individual layer or table in an ArcGIS map or feature
/// service. The map or feature service may be hosted in the cloud on ArcGIS Online, or on-premises on an ArcGIS
/// Server. To access these services you may need to provide authentication in your application.
///
/// You can construct a ``ServiceFeatureTable`` directly from the feature service using its URI or ``PortalItem``.
/// Alternatively, you can obtain a ``ServiceFeatureTable`` from a ``FeatureLayer`` or a ``FeatureTable`` that is
/// part of a ``Map`` or ``Scene``. You can also obtain a ``ServiceFeatureTable`` directly from its service
/// geodatabase using `ServiceGeodatabase.table(withLayerID:)`.
///
/// The ``ServiceFeatureTable`` adopts the loadable pattern so many of its properties are initialized asynchronously
/// after connecting to the service. For more information, see ``Loadable``.
///
/// Display
///
/// If the ``FeatureTable/hasGeometry`` is `true`, you can display the features in a ``Map`` or ``Scene``. To
/// do this create a ``FeatureLayer`` from the feature table and add it to the map or scene's collection of
/// operational layers (``GeoModel/operationalLayers``). Spatial features are requested in the ``SpatialReference``
/// that matches the ``Map`` or ``Scene`` and are displayed using the ``Symbol`` information defined by the map or
/// feature service.
///
/// Query
///
/// You can query the data in the ServiceFeatureTable based on SQL expressions and/or spatial relationships. Use the
/// ``QueryParameters`` object to define your spatial or attribute query and pass it to the
/// `ServiceFeatureTable.queryFeatures(using:queryFeatureFields:)` method. If the service feature table is related to any other tables
/// that are part of the map or scene, use the `ServiceFeatureTable.queryRelatedFeatures(to:using:queryFeatureFields:)` method to query the
/// related tables. For more information see ``RelatedQueryParameters``.
///
/// Edit
///
/// A ``ServiceFeatureTable`` can have editable attribute fields, feature templates(``FeatureTemplate``), feature
/// types (``FeatureType``), and editing capabilities defined in ``ArcGISFeatureLayerInfo/capabilities``. You can
/// create, delete, and update data in the local cache depending upon whether the service allows those operations,
/// who owns the data, and what ownership-based access control policies are in place. Permission to edit the data
/// is managed by the author of the feature service. Explore ``FeatureTable/isEditable``,
/// `ServiceFeatureTable.canAddFeature()`, `ServiceFeatureTable.canUpdate(_:)`, and `ServiceFeatureTable.canDelete(_:)` for
/// information on what is permitted. If the service supports attachments (``ArcGISFeatureTable/hasAttachments``),
/// you can also view and potentially edit the attachments. If you want to apply your edits to the feature service,
/// you must call the `ServiceGeodatabase.applyEdits()` method on the
/// ``serviceGeodatabase``. This will ensure that the table and any tables involved in
/// geodatabase behavior are updated. Areas that have geodatabase behavior include:
///     * Composite relationships
///     * Annotation feature layers
///     * Utility network association deletion semantics
///     * Attribute rules
///
/// Contingent Values
///
/// The ``ServiceFeatureTable`` supports querying and editing contingent values. See
/// `ServiceFeatureTable.contingentValues(with:forFieldNamed:)` for more information.
///
/// Offline
///
/// If you wish to adopt an offline workflow, you can take areas of a ``ServiceFeatureTable`` offline using the
/// ``GeodatabaseSyncTask``. If you wish to take a ``Map`` offline use the ``OfflineMapTask``. See
/// [Build offline applications](https://developers.arcgis.com/documentation/mapping-apis-and-services/offline/) for more information.
///
/// Feature Request Mode
///
/// The ``FeatureRequestMode`` determines whether ServiceFeatureTable features are cached locally (for quicker
/// access by map and scene layers) and whether queries are performed on the local cache or on the server. Consider
/// which of these 3 modes is appropriate for your application:
///
/// * ``FeatureRequestMode/onInteractionCache`` - User interactions (pan or zoom) with the `MapView` or
/// `SceneView` request features from the server and cache them locally for the duration of the session.
/// Subsequent interactions with the `MapView` or `SceneView` will refresh this local cache. Queries are
/// executed on the local cache or (if requested features are not resident in the cache) on the server. If the
/// network connection is lost then the application can still operate with the local cache. This is the default
/// mode.
///
/// * ``FeatureRequestMode/onInteractionNoCache`` - Your application will display or query features directly from
/// the server. They are not cached locally. This mode ensures that you are working against the latest data, but it
/// has a high network bandwidth since it goes to the server for all interactions (pans, zooms, selects, or
/// queries).
///
/// * ``FeatureRequestMode/manualCache`` - Your application must explicitly call
/// `ServiceFeatureTable.populateFromService(using:clearCache:outFields:)` to query the
/// feature service and cache the resulting features in the ``ServiceFeatureTable``. All queries are made against
/// this local cache. You must adopt this mode for tables that contain non-spatial records
/// (see ``FeatureTable/hasGeometry``).
/// - Since: 200.1
final public class ServiceFeatureTable : ArcGIS.ArcGISFeatureTable, ArcGIS.APIKeyResource {

    /// Controls which attributes are included in the features returned by `ServiceFeatureTable.queryFeatures(using:queryFeatureFields:)` or `ServiceFeatureTable.queryRelatedFeatures(to:using:queryFeatureFields:)`.
    public enum QueryFeatureFields {

        /// Includes only the object id and global id in the ArcGISFeatures of the query result. The features are returned with no other attributes. The geometry returned by this request does not include m-values, even if they are defined in the feature service.
        case idsOnly

        /// Includes the minimum set of attributes in the ArcGISFeatures of the query result. The geometry returned by this request does not include m-values, even if they are defined in the feature service.
        case minimum

        /// Includes all available attributes in the ArcGISFeatures of the query result. This constant loads the features returned by the query, which makes all attributes available. The geometry returned by this request includes m-values if defined in the feature service.
        case loadAll

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ServiceFeatureTable.QueryFeatureFields, b: ArcGIS.ServiceFeatureTable.QueryFeatureFields) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new service feature table object from an ArcGIS feature service or feature layer portal item.
    ///
    /// If the portal item is a feature service, the ``ServiceFeatureTable`` will be created from the first
    /// layer on the service. If the portal item is a feature layer, the ``ServiceFeatureTable`` will be created
    /// from the feature layer.
    /// - Parameter item: An ArcGIS feature service or feature layer ``PortalItem``.
    /// - Note: See Also: ``item``
    public convenience init(item: ArcGIS.Item)

    /// Creates a new service feature table object from a feature service portal item.
    /// - Parameters:
    ///   - item: An ArcGIS feature service ``PortalItem``.
    ///   - layerID: The layer id of an individual layer in the ArcGIS feature service represented by the ``Item``.
    /// - Note: See Also: ``item``
    public convenience init(item: ArcGIS.Item, layerID: Int)

    /// Creates a new service feature table object from the specified table and relationship information.
    /// - Parameters:
    ///   - table: The table from which to create a new table.
    ///   - relationshipInfo: The relationship information specifying which table to create.
    public convenience init(table: ArcGIS.ServiceFeatureTable, relationshipInfo: ArcGIS.RelationshipInfo)

    /// Creates a new service feature table object from a given URI.
    /// - Parameter url: The URI of an individual layer or table in an ArcGIS map or feature service.
    public convenience init(url: URL)

    /// The factor used to calculate a buffered extent around the current visible area when requesting features from a service.
    ///
    /// New features are requested from the service if the visible area of the `MapView` exceeds the buffered
    /// extent. A change in the visible area can result from any user interaction with the `MapView`, such as a
    /// pan or zoom action. The buffer factor is applied when the ``FeatureRequestMode`` is in either
    /// ``FeatureRequestMode/onInteractionCache`` or ``FeatureRequestMode/onInteractionNoCache``.
    ///
    /// The default value is 2 (twice the current extent). The maximum value is 10. If it is set to 0 or 1, the
    /// buffered extent will equal the visible map area.
    final public var bufferFactor: Double

    /// An expression (SQL where clause) to filter features queried in this table.
    ///
    /// The definition expression string uses the SQL-92 where clause syntax (https://en.wikipedia.org/wiki/SQL-92).
    /// Be sure to escape special characters in the expression string as required for your platform. The DATE
    /// keyword expects the date format yyyy-mm-dd and the TIMESTAMP keyword expects the time stamp format
    /// yyyy-mm-dd hh:mm:ss. For more information see the ArcGIS Blog article ["Querying Feature Services Date-Time Queries"](https://www.esri.com/arcgis-blog/products/api-rest/data-management/querying-feature-services-date-time-queries/).
    final public var definitionExpression: String

    /// Defines when features and non-spatial records are requested from the feature service.
    ///
    /// The default mode is ``FeatureRequestMode/onInteractionCache``. For more information see ``FeatureRequestMode``.
    final public var featureRequestMode: ArcGIS.FeatureRequestMode

    /// The service geodatabase version name.
    ///
    /// This property is populated if the ``ServiceFeatureTable`` is provided by a layer or a table in a web map or
    /// if the ``ServiceFeatureTable`` is created using `ServiceGeodatabase.table(withLayerID:)`.
    ///
    /// The default geodatabase version has the string value "sde.DEFAULT".
    final public var geodatabaseVersion: String

    /// The ``Item`` that defines the service feature table.
    /// - Note: See Also: ``init(item:layerID:)``
    final public var item: ArcGIS.Item? { get }

    /// The service geodatabase this service feature table is part of.
    ///
    /// This property is populated if the ``ServiceFeatureTable`` is provided by a layer or a table in a web map or
    /// if the ``ServiceFeatureTable`` is created using `ServiceGeodatabase.table(withLayerID:)`.
    final public var serviceGeodatabase: ArcGIS.ServiceGeodatabase? { get }

    /// The URI of the service feature table.
    final public var url: URL? { get }

    /// Uploads any changes to the local table to the feature service.
    ///
    /// `ServiceFeatureTable.applyEdits()` is meant to be used for single table workflows or tables without
    /// geodatabase behavior (see below). If an edit on this table can cause an edit to another table due to geodatabase
    /// behavior, it is highly recommended to use `ServiceGeodatabase.applyEdits()` instead to prevent data
    /// inconsistency, so that dependent edits are all applied or none are (if an error occurs).
    ///
    /// For example, when tables have a composite relationship, applying the delete of a destination feature
    /// in a composite relationship deletion will only delete the destination feature on the server, therefore
    /// causing inconsistency in the data.
    ///
    /// Areas which have geodatabase behavior:
    /// * Composite relationships
    /// * Annotation feature layers
    /// * Utility network association deletion semantics
    /// * Attribute rules
    /// - Returns: An `Array` containing ``FeatureEditResult`` types.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func applyEdits() async throws -> [ArcGIS.FeatureEditResult]

    /// Clears cached data.
    /// - Parameter keepLocalEdits: `true` if you need to retain edits in the local cache.
    final public func clearCache(keepingLocalEdits keepLocalEdits: Bool)

    /// Queries the feature service and places the resulting features in the local table, which is cached for the duration of the session. The ``ServiceFeatureTable`` must have its ``featureRequestMode`` set to ``FeatureRequestMode/manualCache``.
    ///
    /// This method is useful for non-geographic data. It's also helpful when you want to avoid accessing the service
    /// for a feature whose geometry is in the current extent of the map or scene.
    ///
    /// Specifying `nil` or an empty `Array` for outfields results in the minimum set of fields being used
    /// to populate the local table. This is the same set of fields described for
    /// ``FeatureRequestMode/onInteractionCache`` or ``FeatureRequestMode/onInteractionNoCache``.
    /// - Parameters:
    ///   - parameters: Options for controlling the operation.
    ///   - clearCache: `true`, if you want to clear the local cache before populating the local table. `false`, if you want to append the features to the local table.
    ///   - outFields: An `Array` containing `String`. Each string is the name of a field to be used when populating the cache. If the array contains the single element "*", then all fields will be used. If the ObjectID field string name is not provided as part of the `Array`, no features will be returned for this method.
    /// - Returns: A ``FeatureQueryResult`` type.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func populateFromService(using parameters: ArcGIS.QueryParameters, clearCache: Bool, outFields: [String]) async throws -> ArcGIS.FeatureQueryResult

    /// Queries features from this table's cache and/or from the feature service used to create this table.
    ///
    /// If the request mode of the table is ``FeatureRequestMode/manualCache``, then the query is always performed
    /// on the local table.
    ///
    /// If the mode is ``FeatureRequestMode/onInteractionCache``, then the query is performed on the local cache,
    /// provided that the geometries of the features are within an extent that has been cached; otherwise, the
    /// query is performed on the server.
    ///
    /// If the mode is ``FeatureRequestMode/onInteractionNoCache``, the query is always performed on the server.
    ///
    /// ``QueryFeatureFields`` controls which fields will be included with the returned features. The options are:
    ///
    /// * If the service feature table ``FeatureRequestMode`` is onInteractionCache or onInteractionNoCache, the
    ///   table will initially contains features with a minimum set of attribute required for rendering. To access
    ///   all the feature's attributes you must load the features ``QueryFeatureFields/loadAll`` automatically
    ///   loads the returned features into the local table and makes all attributes available.
    ///
    /// * If the service feature table ``FeatureRequestMode`` is manualCache, the table will contain the fields
    ///   that you specified when calling `ServiceFeatureTable.populateFromService(using:clearCache:outFields:)`
    ///
    /// Note that you can query any attribute defined by the feature service's table. If the attribute is not in
    /// the set of attributes in your local table, the query will be performed on the server.
    /// - Parameters:
    ///   - parameters: Options for controlling the operation.
    ///   - queryFeatureFields: Options for controlling what fields are in the features of the query result.
    /// - Returns: A ``FeatureQueryResult`` type.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func queryFeatures(using parameters: ArcGIS.QueryParameters, queryFeatureFields: ArcGIS.ServiceFeatureTable.QueryFeatureFields) async throws -> ArcGIS.FeatureQueryResult

    /// Queries for related features in this service feature table using the provided parameters and query feature fields. See `ServiceFeatureTable.queryFeatures(using:queryFeatureFields:)` for more details.
    /// - Parameters:
    ///   - feature: The feature for which to query related features.
    ///   - parameters: The related query parameters.
    ///   - queryFeatureFields: Enumeration indicating which fields to return from the query.
    /// - Returns: An `Array` of objects of ``RelatedFeatureQueryResult`` type.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func queryRelatedFeatures(to feature: ArcGIS.ArcGISFeature, using parameters: ArcGIS.RelatedQueryParameters, queryFeatureFields: ArcGIS.ServiceFeatureTable.QueryFeatureFields) async throws -> [ArcGIS.RelatedFeatureQueryResult]

    /// Undoes all of the local edits since the last server acknowledgment.
    ///
    /// `ServiceFeatureTable.undoLocalEdits()` is meant to be used for single table workflows or tables without
    /// geodatabase behavior (see below). If the service which the table belongs to has geodatabase behavior (see below),
    /// it is highly recommended to use `ServiceGeodatabase.undoLocalEdits()`. Undoing edits in one table
    /// can cause data inconsistencies between the local cache and the service if
    /// `ServiceFeatureTable.undoLocalEdits()` is used.
    ///
    /// For example, when tables have a composite relationship, undoing only the origin feature would violate the
    /// composite relationship rule that an origin and destination feature must be either deleted together or not
    /// at all.
    ///
    /// Areas which have geodatabase behavior:
    /// * Composite relationships
    /// * Annotation feature layers
    /// * Utility network association deletion semantics
    /// * Attribute rules
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func undoLocalEdits() async throws

    /// The API key to access API key enabled services and resources in ArcGIS Online.
    ///
    /// An API key is a unique key used to authorize access to specific services and resources in ArcGIS Online.
    /// It is also used to monitor access to those services. An API key is created and managed in the ArcGIS developer
    /// dashboard and is tied to a specific ArcGIS account.
    ///
    /// In addition to setting an ``ArcGISEnvironment/apiKey`` at a global level for your application, you
    /// can set it on any class that implements ``APIKeyResource``. This overrides the
    /// ``ArcGISEnvironment/apiKey`` and enables more granular usage telemetry and management of ArcGIS
    /// location resources used by your app.
    ///
    /// Classes that expose an API key property by implementing ``APIKeyResource`` include:
    /// * ``Basemap``
    /// * ``ArcGISSceneLayer``
    /// * ``ArcGISTiledLayer``
    /// * ``ArcGISVectorTiledLayer``
    /// * ``ServiceFeatureTable``
    /// * ``ExportVectorTilesTask``
    /// * ``LocatorTask``
    /// * ``GeodatabaseSyncTask``
    /// * ``ClosestFacilityTask``
    /// * ``RouteTask``
    /// * ``ServiceAreaTask``
    /// * ``ExportTileCacheTask``
    final public var apiKey: ArcGIS.APIKey?
}

extension ServiceFeatureTable {

    /// Loads all attributes and geometries for features that have not been
    /// loaded and fetches attributes and geometries for previously loaded
    /// features.
    /// - Remark: Features returned from
    /// ``queryFeatures(using:queryFeatureFields:)`` or
    /// ``queryRelatedFeatures(to:using:queryFeatureFields:)``
    /// may be in the minimally loaded state (minimum attributes required for
    /// rendering and no m-values). To load all attributes, pass a sequence of
    /// features to this method.
    ///
    /// Any feature requested, but not returned, by the server will have its
    /// object id cleared (set to an invalid negative value) to indicate it is
    /// no longer associated with the service feature table.
    ///
    /// After calling this method, any non-applied edits on the table will be
    /// lost.
    ///
    /// This method will not refresh feature attachments. Use
    /// ``ArcGISFeature/attachments`` to retrieve attachments.
    ///
    /// All features loaded or refreshed by this method will have m-values if
    /// defined by the service. Note that an m-value may be `nan`.
    /// - Parameter features: The features to be loaded or refreshed.
    final public func loadOrRefresh<S>(_ features: S) async throws where S : Sequence, S.Element == ArcGIS.Feature
}

extension ServiceFeatureTable.QueryFeatureFields : Equatable {
}

extension ServiceFeatureTable.QueryFeatureFields : Hashable {
}

/// A container for a collection of ``ServiceFeatureTable`` connected to a feature service.
///
/// A ``ServiceGeodatabase`` connects to a feature service as a whole, grouping
/// together ``ServiceFeatureTable`` instances for related records queries,
/// connecting to a version in a branch-versioned service, and managing edits
/// for all tables.
/// - Since: 200.1
final public class ServiceGeodatabase : ArcGIS.Loadable {

    /// The collection of feature tables managed by the ``ServiceGeodatabase``.
    @ArcGIS.Streamed final public var connectedTables: [ArcGIS.ServiceFeatureTable] { get }

    final public var $connectedTables: AsyncStream<[ArcGIS.ServiceFeatureTable]> { get }

    /// The name of the default version
    final public var defaultVersionName: String { get }

    /// Determines if any of the tables in the ``ServiceGeodatabase`` have unapplied edits.
    final public var hasLocalEdits: Bool { get }

    /// The ``PortalItem`` which the ``ServiceGeodatabase`` was created from.
    /// - Note: See Also: ``init(portalItem:versionName:sessionType:)``
    final public var portalItem: ArcGIS.PortalItem? { get }

    /// The metadata of the service this object is connected to.
    final public var serviceInfo: ArcGIS.ArcGISFeatureServiceInfo? { get }

    /// The type of read and edit sessions to use when working with the service.
    ///
    /// The default value is ``FeatureServiceSessionType/transient``.
    ///
    /// If the feature service this ``ServiceGeodatabase`` references is not
    /// branch-versioned, only ``FeatureServiceSessionType/transient`` is supported.
    ///
    /// If using ``FeatureServiceSessionType/persistent``, it is important to call
    /// `ServiceGeodatabase.close()` before destruction.
    ///
    /// Cannot be set after the ``ServiceGeodatabase`` is loaded.  When the
    /// ``ServiceGeodatabase`` is created by loading a ``Map``, use ``LoadSettings``
    /// to control the session type.
    /// - Note: See Also: ``LoadSettings/featureServiceSessionType``
    final public var sessionType: ArcGIS.FeatureServiceSessionType

    /// Whether the service supports branch versioning.
    final public var supportsBranchVersioning: Bool { get }

    /// The URL of the feature service or the portal item to connect to.
    ///
    /// Use ``ArcGISFeatureServiceInfo/url`` to get the feature service URL.
    final public var url: URL? { get }

    /// The name of the version the ``ServiceGeodatabase`` is currently connected to.
    ///
    /// To change the version this ``ServiceGeodatabase`` is connected to,
    /// use the `ServiceGeodatabase.switchToVersion(named:)` method.
    final public var versionName: String { get }

    /// Gets a list of all versions on the service.
    ///
    /// If the service isn't branch versioned, a
    /// `CoreErrorCode.mappingBranchVersioningNotSupportedByService` is thrown.
    final public var versions: [ArcGIS.ServiceVersionInfo] { get async throws }

    /// Applies all local edits in all tables to the service.
    ///
    /// Edits in all tables are applied to the feature service in a call,
    /// which is more efficient than doing so one ``ServiceFeatureTable`` at
    /// a time.
    /// - Returns: An `Array` containing ``FeatureTableEditResult``.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func applyEdits() async throws -> [ArcGIS.FeatureTableEditResult]

    /// Closes this service geodatabase.
    ///
    /// A request to stop any active reading or editing sessions with the feature service is sent and once this asynchronous process is complete,
    /// this service geodatabase will be closed.
    ///
    /// Before calling this method, there should be no references to all related data. For example, terminate fetch versions,
    /// create version, switch, apply or undo edits, remove feature layers, and release tables from map.
    ///
    /// After calling this method, accessing this service geodatabase or any of its connected tables will fail
    /// with `CoreErrorCode.geodatabaseDatabaseClosed`.
    ///
    /// Closing this service geodatabase is not necessary if it has not been loaded.
    final public func close() async throws

    /// Creates a new version in the service based on the default version.
    ///
    /// Branch versioning requires that the default version always be the
    /// ancestor of all other versions.
    ///
    /// If the service isn't branch versioned, a
    /// `CoreErrorCode.mappingBranchVersioningNotSupportedByService` is thrown.
    ///
    /// If the version parameters do not include a name, an error is thrown.
    /// - Parameter parameters: The properties of the new version.
    /// - Returns: A Future which returns the full metadata for the new version.
    final public func makeVersion(parameters: ArcGIS.ServiceVersionParameters) async throws -> ArcGIS.ServiceVersionInfo

    /// Switches all connected feature tables to the new version.
    ///
    /// An error is thrown if:
    /// * The service isn't branch versioned
    /// * No version exists with the supplied name
    /// * Any of the ``connectedTables`` have unapplied edits
    ///
    /// Check the result of `ServiceGeodatabase.hasLocalEdits` before
    /// attempting to switch versions, to make sure all changes are saved to
    /// the service or discarded from the local cache.  Use the
    /// `ServiceGeodatabase.applyEdits()` or
    /// `ServiceGeodatabase.undoLocalEdits()` methods as appropriate
    /// to save or discard changes before switching versions.
    /// - Parameter versionName: The name of the version to connect to.
    final public func switchToVersion(named versionName: String) async throws

    /// Returns a service feature table object from the ID of a layer or table in the service.
    ///
    /// If a table instance for the layer already exists in
    /// ``connectedTables``, the existing object will be
    /// returned.  Otherwise, a new ``ServiceFeatureTable`` will be created.
    ///
    /// If no table or layer exists in the service with the given ID, a
    /// `CoreErrorCode.commonInvalidArgument` error is thrown.
    /// - Parameter layerID: The layer id for which to create the table.
    /// - Returns: A table instance for working with the table or layer in the feature service.
    final public func table(withLayerID layerID: Int) -> ArcGIS.ServiceFeatureTable?

    /// Undos all of the local edits in all the tables.
    /// - Note: See Also: ``FeatureServiceSessionType``
    final public func undoLocalEdits() async throws

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension ServiceGeodatabase {

    /// Creates an instance with a feature service portal item.
    ///
    /// If any of the following are true, the service geodatabase will
    /// fail to load:
    /// - A non-empty version name is specified and either the service is not
    /// branch versioned or the version does not exist.
    /// - Session type ``FeatureServiceSessionType/persistent`` is specified and
    /// the service is not branch versioned.
    ///
    /// If using ``FeatureServiceSessionType/persistent``, it is important to
    /// call ``close()`` before destruction.
    /// - Parameters:
    ///   - portalItem: A feature service portal item.
    ///   - versionName: The existing version to connect to when the service
    ///   geodatabase loads. Specify the empty string to connect to the default
    ///   version or if the service is not branch versioned. The default is the
    ///   empty string.
    ///   - sessionType: The type of read and edit sessions to use when working
    ///   with the service. The default session type is
    ///   ``FeatureServiceSessionType/transient``.
    public convenience init(portalItem: ArcGIS.PortalItem, versionName: String = "", sessionType: ArcGIS.FeatureServiceSessionType = .transient)

    /// Creates an instance with the feature service at the given URL.
    ///
    /// If any of the following are true, the service geodatabase will
    /// fail to load:
    /// - A non-empty version name is specified and either the service is not
    /// branch versioned or the version does not exist.
    /// - Session type ``FeatureServiceSessionType/persistent`` is specified and
    /// the service is not branch versioned.
    ///
    /// If using ``FeatureServiceSessionType/persistent``, it is important to
    /// call ``close()`` before destruction.
    /// - Parameters:
    ///   - url: The URL of the feature service or the portal item to connect
    ///   to.
    ///   - versionName: The existing version to connect to when the service
    ///   geodatabase loads. Specify the empty string to connect to the default
    ///   version or if the service is not branch versioned. The default is the
    ///   empty string.
    ///   - sessionType: The type of read and edit sessions to use when working
    ///   with the service. The default session type is
    ///   ``FeatureServiceSessionType/transient``.
    public convenience init(url: URL, versionName: String = "", sessionType: ArcGIS.FeatureServiceSessionType = .transient)
}

/// A super class for all image tiled layers that fetch map tiles from a remote service.
///
/// Allows you to have a custom service image tiled layer. For a given LOD, column and row your custom service image tiled layer will
/// be called to generate a request (`ServiceImageTiledLayer.generateRequest`).
/// Once you set the request information (`ServiceImageTiledLayer.setRequest(tileKey:url:parameters:)`) then the request will be sent over the network for you.
///
/// The service image tiled layer class is derived from the image tiled layer class.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
public class ServiceImageTiledLayer : ArcGIS.ImageTiledLayer {
}

/// Represents metadata about a service's support for querying features (see
/// `FeatureTable.queryFeatures(using:)`) and requesting map images for ``ArcGISMapImageLayer`` based on time.
///
/// It contains various time related information such as the map's time extent and the map's native time reference.
/// - Note: See Also: `FeatureTable.queryFeatures(using:)`, ``ArcGISMapImageLayer``
/// - Since: 200.1
final public class ServiceTimeInfo {

    /// Indicates how the start and end time of the time slider extent are processed.
    public enum TimeRelation {

        /// When start and end time of the time slider are included.
        case overlaps

        /// When start time is included and end time is excluded.
        case afterStartOverlapsEnd

        /// When start time is excluded and end time is included.
        case overlapsStartWithinEnd

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.ServiceTimeInfo.TimeRelation, b: ArcGIS.ServiceTimeInfo.TimeRelation) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The default time interval for the service. This can be used as a time slider's step size.
    final public var defaultInterval: ArcGIS.TimeValue? { get }

    /// Indicates if the service has live data.
    ///
    /// If `true`, export and identify operations will default the TimeExtent to startTime = (current server time - time interval),
    /// endTime = current server time.
    /// - Note: See Also: ``timeWindow``
    final public var hasLiveData: Bool { get }

    /// The time extent that includes all of the data in the layer.
    ///
    /// The time extent of the service.
    final public var timeExtent: ArcGIS.TimeExtent? { get }

    /// The time reference for the service.
    final public var timeReference: ArcGIS.TimeReference? { get }

    /// The time relation for the service.
    ///
    /// This can be used for determining how a time slider's start and end time are processed.
    final public var timeRelation: ArcGIS.ServiceTimeInfo.TimeRelation? { get }

    /// The default time window for the service to use for a time slider.
    ///
    /// If this value is `nil`, then the time slider should create and use a time extent for an instant in time (start time = end time),
    /// if it is greater than 0 this value should be used as the difference between the start time and end time.
    /// - Note: See Also: ``hasLiveData``
    final public var timeWindow: ArcGIS.TimeValue? { get }
}

extension ServiceTimeInfo : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.ServiceTimeInfo, rhs: ArcGIS.ServiceTimeInfo) -> Bool
}

extension ServiceTimeInfo : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

extension ServiceTimeInfo.TimeRelation : Equatable {
}

extension ServiceTimeInfo.TimeRelation : Hashable {
}

/// An enumeration of the different types of ArcGIS Server services.
/// - Since: 200.1
public enum ServiceType {

    /// A feature service.
    case featureService

    /// An image service.
    case imageService

    /// A map service.
    case mapService

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.ServiceType, b: ArcGIS.ServiceType) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension ServiceType : Equatable {
}

extension ServiceType : Hashable {
}

/// An object that represents version metadata for a version in a branch-versioned feature service.
///
/// All properties in this object are read-only, and represent the snapshot
/// in time when `ServiceGeodatabase.versions` was called.
/// To add a new version, use the `ServiceGeodatabase.makeVersion(parameters:)` function.
/// - Note: See Also: ``ServiceVersionParameters``, ``ServiceGeodatabase``
/// - Since: 200.1
final public class ServiceVersionInfo {

    /// The access level of the version.
    final public var access: ArcGIS.VersionAccess { get }

    /// The timestamp of when the version was last reconciled and posted to its ancestor.
    final public var commonAncestorDate: Date? { get }

    /// The timestamp of when the version was created.
    final public var creationDate: Date? { get }

    /// The description of the version.
    final public var description: String { get }

    /// The timestamp of when the topology of the version's data was last validated.
    final public var evaluationDate: Date? { get }

    /// Whether the current portal user is the owner of the version.
    final public var isOwner: Bool { get }

    /// The timestamp of when the data in the version was last modified.
    final public var modifiedDate: Date? { get }

    /// The name of the version.
    final public var name: String { get }

    /// The timestamp of when the version was last reconciled with its ancestor.
    final public var reconcileDate: Date? { get }

    /// The unique ID of the version.
    final public var versionID: UUID? { get }
}

/// The parameters used to create a new version in a branch-versioned feature service.
/// - Note: See Also: ``ServiceGeodatabase``
/// - Since: 200.1
final public class ServiceVersionParameters {

    /// Create a new ``ServiceVersionParameters`` object.
    ///
    /// The ``access`` will default to
    /// ``VersionAccess/public``.
    public convenience init()

    /// The access level of the version.
    final public var access: ArcGIS.VersionAccess

    /// The description of the version.
    final public var description: String

    /// The name of the version.
    ///
    /// The name should be short (less than 64 characters) and not contain
    /// any special characters.
    final public var name: String
}

/// An object that represents a shapefile table.
///
/// A shapefile dataset consists of at least three files (.shp, .shx, .dbf), and may include many others. Each of the component files of a shapefile must be smaller than 2 GB.
/// If the minimum required files are not present (or larger than 2 GB), the table will fail to load. If the file permissions are read-only, features cannot be edited.
/// On-the-fly projection of a shapefile is only supported if an associated .prj file is present. Otherwise, the features are assumed to have the same spatial reference as the map.
/// A default renderer is used to render a shapefile feature table in a feature layer. In most cases, the default
/// should be replaced with a custom renderer.
/// - Since: 200.1
final public class ShapefileFeatureTable : ArcGIS.FeatureTable {

    /// Create a shapefile feature table from a path to a local shapefile.
    ///
    /// A shapefile dataset consists of at least three files (.shp, .shx, .dbf), and may include many others. Each of the component files of a shapefile must be smaller than 2 GB.
    /// When creating a shapefile feature table, the path must point to the .shp file and the associated .shx and .dbf files must be present at the same location.
    /// - Parameter fileURL: Path to the .shp shape file.
    public convenience init(fileURL: URL)

    /// The path to the shapefile.
    ///
    /// A shapefile dataset consists of at least three files (.shp, .shx, .dbf), and may include many others. Each of the component files of a shapefile must be smaller than 2 GB.
    /// The path for a shapefile feature table points to the .shp file and the associated .shx and .dbf files must be available at the same location.
    /// The path can only be assigned when the shapefile is not loaded or has previously failed to load.
    final public var fileURL: URL { get }

    /// Shapefile info that contains metadata for the dataset.
    ///
    /// If the shapefile has an associated .xml file, a shapefile info object will be created and populated with metadata from the file.
    /// If an .xml file does not exist, this object will be `nil`.
    final public var info: ArcGIS.ShapefileInfo? { get }

    /// Whether or not the shapefile uses spatial indexes.
    ///
    /// ArcGIS for Desktop can be used to create spatial indexes for shapefiles, stored in .sbn and .sbx files.
    /// Having a current spatial index ensures that a high level of performance is maintained when drawing and working with the shapefile's features and that the shapefile's extent is accurate.
    final public var spatialIndexIsEnabled: Bool { get }

    /// Close a shapefile feature table.
    ///
    /// The use of all data it contains should cease before closing
    /// a shapefile feature table. For example: remove feature layer from maps and release
    /// feature tables. Attempts to access a shapefile feature table after it is
    /// closed will fail, resulting in an error. After closing a
    /// shapefile feature table, the underlying file it references can be deleted.
    final public func close()
}

/// An object that represents a shapefile info.
///
/// If a shapefile has an associated .xml file, shapefile info will be created and populated with metadata from the file.
/// If an .xml file does not exist, this object will be `nil`.
/// - Since: 200.1
final public class ShapefileInfo {

    /// The copyright text of the shapefile.
    ///
    /// Shapefile metadata values are read from the associated .xml file.
    final public var copyrightText: String { get }

    /// The credits of the shapefile.
    ///
    /// Shapefile metadata values are read from the associated .xml file.
    final public var credits: String { get }

    /// The description of the shapefile.
    ///
    /// Shapefile metadata values are read from the associated .xml file.
    final public var description: String { get }

    /// The summary of the shapefile.
    ///
    /// Shapefile metadata values are read from the associated .xml file.
    final public var summary: String { get }

    /// The tags of the shapefile.
    ///
    /// Shapefile metadata values are read from the associated .xml file.
    final public var tags: [String] { get }

    /// The thumbnail of the shapefile.
    ///
    /// Shapefile metadata values are read from the associated .xml file.
    final public var thumbnail: UIImage? { get }
}

/// Used to draw polygon features on a layer using simple patterns.
///
/// Fill symbols are used with graphics which are based on a polygon geometry.
/// The symbol can fill the interior of a polygon graphic with a solid color.
/// In addition, the symbol can have an optional outline which is defined by a line symbol.
/// - Note: See Also: ``FillSymbol``, ``Symbol``
/// - Since: 200.1
final public class SimpleFillSymbol : ArcGIS.FillSymbol {

    /// The list of possible simple fill symbol styles.
    ///
    /// This is used to determine the style of the simple fill symbol.
    public enum Style {

        /// Fills with backward diagonal lines.
        case backwardDiagonal

        /// Fills with horizontal and vertical lines.
        case cross

        /// Fills with forward and backward diagonal lines.
        case diagonalCross

        /// Fills with forward diagonal lines.
        case forwardDiagonal

        /// Fills with horizontal lines.
        case horizontal

        /// No fill.
        case noFill

        /// Solid fill.
        case solid

        /// Fills with vertical lines.
        case vertical

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SimpleFillSymbol.Style, b: ArcGIS.SimpleFillSymbol.Style) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a simple fill symbol object with some initial values.
    /// - Parameters:
    ///   - style: Indicates the type of simple fill symbol to create.
    ///   - color: The color of the simple fill symbol.
    ///   - outline: The outline of the simple fill symbol.
    public convenience init(style: ArcGIS.SimpleFillSymbol.Style = .solid, color: UIColor = .init(white: 211/255, alpha: 1), outline: ArcGIS.LineSymbol? = nil)

    /// The style of the simple fill symbol.
    final public var style: ArcGIS.SimpleFillSymbol.Style

    /// Get Multilayer polygon symbol generated from simple fill symbol.
    ///
    /// Multilayer symbol API allows users to create complex and custom symbols with multiple layers of different types of symbology.
    /// Simple fill symbol has a factory of predefined fill styles like cross, backward_diagonal etc. This helper method exports this symbol to ``MultilayerPolygonSymbol`` with
    /// ``HatchFillSymbolLayer`` defining the fill patterns.
    /// - Returns: A ``MultilayerPolygonSymbol`` object.
    final public func toMultilayerSymbol() -> ArcGIS.MultilayerPolygonSymbol
}

extension SimpleFillSymbol.Style : Equatable {
}

extension SimpleFillSymbol.Style : Hashable {
}

/// An expression script using the Simple REST language.
///
/// The label Simple expression expects to hold a legal, Simple script
/// and to be read and evaluated by a Simple expression interpreter.
/// An example expression that combines text with a field value is
///
/// "State: " CONCAT [State_Name]
///
/// Note that quotes are needed around the literal text.
/// See [Labeling objects](https://developers.arcgis.com/documentation/common-data-types/labeling-objects.htm)
/// for full documentation on the <b>labelExpression</b> syntax and functions.
/// Warning: If the expression attempts to use attributes which don't exist then no label will be produced.
/// This is distinct from the attribute existing but having a `nil` or empty value,
/// which can form part of the produced text label.
/// - Since: 200.1
final public class SimpleLabelExpression : ArcGIS.LabelExpression {

    /// Create a label Simple expression with a specific Simple script.
    ///
    /// The expression is expected to be a complete, self-contained Simple expression.
    /// - Parameter simpleExpression: The Simple expression script string.
    public convenience init(simpleExpression: String = "")
}

/// Used to draw linear features on a layer.
///
/// Simple line symbols display graphics using predefined line style patterns such as solid, dash, dot, etc.
/// - Note: See Also: ``LineSymbol``, ``Symbol``
/// - Since: 200.1
final public class SimpleLineSymbol : ArcGIS.LineSymbol {

    /// The list of possible marker placements on a simple line symbol.
    ///
    /// Controls the placement of markers on a simple line symbol, if any.
    public enum MarkerPlacement {

        /// A marker is placed at the beginning of the simple line symbol.
        case begin

        /// A marker is placed at the end of the simple line symbol.
        case end

        /// A marker is placed at both the beginning and end of the simple line symbol.
        case beginAndEnd

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SimpleLineSymbol.MarkerPlacement, b: ArcGIS.SimpleLineSymbol.MarkerPlacement) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of possible marker styles to place on a simple line symbol.
    ///
    /// Controls the style of marker placed at the end of a simple line symbol, if any.
    public enum MarkerStyle {

        /// No markers are placed at the end of the simple line symbol.
        case noMarkers

        /// Arrow marker(s) placed at the beginning, end, or beginning and end of the
        /// simple line symbol depending on the associated value of ``SimpleLineSymbol/MarkerPlacement-swift.enum``.
        case arrow

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SimpleLineSymbol.MarkerStyle, b: ArcGIS.SimpleLineSymbol.MarkerStyle) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of possible simple line symbol styles.
    ///
    /// This is used to determine the style of the simple line symbol.
    public enum Style {

        /// Dash line.
        case dash

        /// Dash dot line.
        case dashDot

        /// Dash dot dot line.
        case dashDotDot

        /// Dot line.
        case dot

        /// Invisible line.
        case noLine

        /// Solid line.
        case solid

        /// Dash line with long dash.
        case longDash

        /// Dash dot line with long dash.
        case longDashDot

        /// Dash line with short gaps.
        case shortDash

        /// Dash dot line with short gaps.
        case shortDashDot

        /// Dash dot dot line with short gaps.
        case shortDashDotDot

        /// Dot line with short gaps.
        case shortDot

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SimpleLineSymbol.Style, b: ArcGIS.SimpleLineSymbol.Style) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a simple line symbol object with some initial values.
    /// - Parameters:
    ///   - style: Indicates the type of simple line symbol to create.
    ///   - color: The color of the simple line symbol.
    ///   - width: The width of the simple line symbol.
    ///   - markerStyle: The style of simple line symbol end marker(s).
    ///   - markerPlacement: The placement of simple line symbol end marker(s).
    public convenience init(style: ArcGIS.SimpleLineSymbol.Style = .solid, color: UIColor = .init(white: 211/255, alpha: 1), width: CGFloat = 1, markerStyle: ArcGIS.SimpleLineSymbol.MarkerStyle = .noMarkers, markerPlacement: ArcGIS.SimpleLineSymbol.MarkerPlacement = .end)

    /// The simple line symbol end marker placement of the simple line symbol.
    final public var markerPlacement: ArcGIS.SimpleLineSymbol.MarkerPlacement

    /// The simple line symbol end marker style of the simple line symbol.
    final public var markerStyle: ArcGIS.SimpleLineSymbol.MarkerStyle

    /// The style of the simple line symbol.
    final public var style: ArcGIS.SimpleLineSymbol.Style

    /// Get Multilayer polyline symbol generated from simple line symbol.
    ///
    /// Multilayer symbol API allows users to create complex and custom symbols with multiple layers of different type of symbology.
    /// Simple line symbol offers a factory of styles like dash, dash_dot_dot etc. This helper method exports this symbol to ``MultilayerPolylineSymbol`` with
    /// ``SolidStrokeSymbolLayer`` and predefined collection of ``DashGeometricEffect``.
    /// - Returns: A ``MultilayerPolylineSymbol`` object.
    final public func toMultilayerSymbol() -> ArcGIS.MultilayerPolylineSymbol
}

extension SimpleLineSymbol.MarkerPlacement : Equatable {
}

extension SimpleLineSymbol.MarkerPlacement : Hashable {
}

extension SimpleLineSymbol.MarkerStyle : Equatable {
}

extension SimpleLineSymbol.MarkerStyle : Hashable {
}

extension SimpleLineSymbol.Style : Equatable {
}

extension SimpleLineSymbol.Style : Hashable {
}

/// Used to draw point or multipoint features on a layer using an 3D marker symbol.
///
/// simple marker scene symbols display graphics using a 3D symbol.
/// - Note: See Also: ``MarkerSceneSymbol``, ``Symbol``
/// - Since: 200.1
final public class SimpleMarkerSceneSymbol : ArcGIS.MarkerSceneSymbol {

    /// The list of possible simple marker scene symbol styles.
    ///
    /// This is used to determine the style of the simple scene marker symbol.
    public enum Style {

        /// The marker is a cone.
        case cone

        /// The marker is a 3D cube.
        case cube

        /// The marker is a cylinder.
        case cylinder

        /// The marker is a 3D diamond.
        case diamond

        /// The marker is a sphere.
        case sphere

        /// The marker is a tetrahedron.
        case tetrahedron

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SimpleMarkerSceneSymbol.Style, b: ArcGIS.SimpleMarkerSceneSymbol.Style) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a simple marker scene symbol.
    /// - Parameters:
    ///   - style: The style of the symbol ``Style-swift.enum``.
    ///   - color: The color of the symbol `UIColor`.
    ///   - height: The height in meters of the symbol.
    ///   - width: The width in meters of the symbol.
    ///   - depth: The depth in meters of the symbol.
    ///   - anchorPosition: The anchor_position of the symbol ``MarkerSceneSymbol/AnchorPosition-swift.enum``.
    /// - Precondition: `height > 0`
    /// - Precondition: `width > 0`
    /// - Precondition: `depth > 0`
    public convenience init(style: ArcGIS.SimpleMarkerSceneSymbol.Style = .sphere, color: UIColor = .init(white: 211/255, alpha: 1), height: Double = 100.0, width: Double = 100.0, depth: Double = 100.0, anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition = .bottom)

    /// The style of the simple marker scene symbol.
    ///
    /// The style of the simple scene marker symbol ``Style-swift.enum``.
    final public var style: ArcGIS.SimpleMarkerSceneSymbol.Style

    /// Creates a simple marker scene symbol with cone style.
    /// - Parameters:
    ///   - color: The color of the symbol.
    ///   - diameter: The diameter in meters of base of the cone symbol.
    ///   - height: The height in meters of the cone symbol.
    ///   - anchorPosition: The anchor position ``MarkerSceneSymbol/AnchorPosition-swift.enum`` of the cone symbol.
    /// - Returns: A ``SimpleMarkerSceneSymbol``.
    /// - Precondition: `diameter > 0`
    /// - Precondition: `height > 0`
    final public class func cone(color: UIColor, diameter: Double, height: Double, anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition = .bottom) -> ArcGIS.SimpleMarkerSceneSymbol

    /// Creates a simple marker scene symbol with cube style.
    /// - Parameters:
    ///   - color: The color of the symbol.
    ///   - size: The size in meters of base of the cube in each dimension symbol.
    ///   - anchorPosition: The anchor position ``MarkerSceneSymbol/AnchorPosition-swift.enum`` of the cube symbol.
    /// - Returns: A ``SimpleMarkerSceneSymbol``.
    /// - Precondition: `size > 0`
    final public class func cube(color: UIColor, size: Double, anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition = .bottom) -> ArcGIS.SimpleMarkerSceneSymbol

    /// Creates a simple marker scene symbol with cylinder style.
    /// - Parameters:
    ///   - color: The color of the symbol.
    ///   - diameter: The diameter in meters of base of the cylinder symbol.
    ///   - height: The height in meters of the cylinder symbol.
    ///   - anchorPosition: The anchor position ``MarkerSceneSymbol/AnchorPosition-swift.enum`` of the cube symbol.
    /// - Returns: A ``SimpleMarkerSceneSymbol``.
    /// - Precondition: `diameter > 0`
    /// - Precondition: `height > 0`
    final public class func cylinder(color: UIColor, diameter: Double, height: Double, anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition = .bottom) -> ArcGIS.SimpleMarkerSceneSymbol

    /// Creates a simple marker scene symbol with diamond style.
    /// - Parameters:
    ///   - color: The color of the symbol.
    ///   - size: The size in meters of width and depth of the diamond symbol.
    ///   - height: The height in meters of the diamond symbol.
    ///   - anchorPosition: The anchor position ``MarkerSceneSymbol/AnchorPosition-swift.enum`` of the cube symbol.
    /// - Returns: A ``SimpleMarkerSceneSymbol``.
    /// - Precondition: `size > 0`
    /// - Precondition: `height > 0`
    final public class func diamond(color: UIColor, size: Double, height: Double, anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition = .bottom) -> ArcGIS.SimpleMarkerSceneSymbol

    /// Creates a simple marker scene symbol with sphere style.
    /// - Parameters:
    ///   - color: The color of the symbol.
    ///   - diameter: The diameter in meters of sphere symbol.
    ///   - anchorPosition: The anchor position ``MarkerSceneSymbol/AnchorPosition-swift.enum`` of the cube symbol.
    /// - Returns: A ``SimpleMarkerSceneSymbol``.
    /// - Precondition: `diameter > 0`
    final public class func sphere(color: UIColor, diameter: Double, anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition = .bottom) -> ArcGIS.SimpleMarkerSceneSymbol

    /// Creates a simple marker scene symbol with tetrahedron style.
    /// - Parameters:
    ///   - color: The color of the symbol.
    ///   - size: The size in meters of width and depth of the tetrahedron symbol.
    ///   - height: The height in meters of the tetrahedron symbol.
    ///   - anchorPosition: The anchor position ``MarkerSceneSymbol/AnchorPosition-swift.enum`` of the cube symbol.
    /// - Returns: A ``SimpleMarkerSceneSymbol``.
    /// - Precondition: `size > 0`
    /// - Precondition: `height > 0`
    final public class func tetrahedron(color: UIColor, size: Double, height: Double, anchorPosition: ArcGIS.MarkerSceneSymbol.AnchorPosition = .bottom) -> ArcGIS.SimpleMarkerSceneSymbol
}

extension SimpleMarkerSceneSymbol.Style : Equatable {
}

extension SimpleMarkerSceneSymbol.Style : Hashable {
}

/// Used to draw point or multipoint features on a layer.
///
/// Simple marker symbols display graphics using simple, predefined markers such as circle, cross, etc.
/// In addition, the markers can have an optional outline, which is defined by a line symbol.
/// - Note: See Also: ``MarkerSymbol``, ``Symbol``
/// - Since: 200.1
final public class SimpleMarkerSymbol : ArcGIS.MarkerSymbol {

    /// The list of possible simple marker symbol styles.
    ///
    /// This is used to determine the style of the simple marker symbol.
    public enum Style {

        /// The marker is a circle.
        case circle

        /// The marker is a cross.
        case cross

        /// The marker is a diamond.
        case diamond

        /// The marker is a square.
        case square

        /// The marker is a triangle.
        case triangle

        /// The marker is a diagonal cross.
        case x

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SimpleMarkerSymbol.Style, b: ArcGIS.SimpleMarkerSymbol.Style) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a simple marker symbol object with some initial values.
    /// - Parameters:
    ///   - style: Indicates the type of simple marker symbol to create.
    ///   - color: The color of the simple marker symbol.
    ///   - size: The size of the simple marker symbol.
    public convenience init(style: ArcGIS.SimpleMarkerSymbol.Style = .circle, color: UIColor = .init(white: 211/255, alpha: 1), size: CGFloat = 8)

    /// The color for the simple marker symbol.
    final public var color: UIColor

    /// The outline of the simple marker symbol.
    final public var outline: ArcGIS.SimpleLineSymbol?

    /// The size of the simple marker symbol.
    final public var size: CGFloat

    /// The style of the simple marker symbol.
    final public var style: ArcGIS.SimpleMarkerSymbol.Style

    /// Get Multilayer point symbol generated from simple marker symbol.
    ///
    /// Multilayer symbol API allows users to create complex and custom symbols with multiple layers of different type of symbology.
    /// Simple fill symbol provides a factory of shapes like square, diamond, cross etc. This helper method allows users to generate a ``MultilayerPointSymbol``
    /// with ``VectorMarkerSymbolLayer`` containing polygon with defined geometry for different shapes.
    /// - Returns: A ``MultilayerPointSymbol`` object.
    final public func toMultilayerSymbol() -> ArcGIS.MultilayerPointSymbol
}

extension SimpleMarkerSymbol.Style : Equatable {
}

extension SimpleMarkerSymbol.Style : Hashable {
}

/// A Simple Renderer object.
/// - Since: 200.1
final public class SimpleRenderer : ArcGIS.Renderer {

    /// Creates a new simple renderer object with the given symbol.
    /// - Parameter symbol: The symbol.
    public convenience init(symbol: ArcGIS.Symbol? = nil)

    /// The description of this renderer.
    final public var description: String

    /// The renderer's label.
    final public var label: String

    /// The symbol of this renderer.
    final public var symbol: ArcGIS.Symbol?
}

/// A location data source that provides simulated device locations for testing.
///
/// Use this data source to simulate location updates for a device. It uses a collection of ``Location``
/// that are sequentially passed to `LocationDataSource.updateLocation(_:)`. The location collection can be
/// derived from vertices in a provided polyline, generated evenly along a polyline based on a travel velocity,
/// or assigned to the collection directly.
/// - Since: 200.1
final public class SimulatedLocationDataSource : ArcGIS.LocationDataSource {

    /// Creates a simulated location data source.
    public convenience init()

    /// The index of the item in the location collection that provides the current location.
    ///
    /// You can get this value to find which item in the ``simulatedLocations`` collection
    /// represents the current location. You can also provide a new index to skip to a different location
    /// in the collection.
    final public var currentLocationIndex: Int

    /// The rate over which the ``simulatedLocations`` collection is iterated.
    ///
    /// This controls the frequency of location updates for the simulated location data source. The default value is 1.0,
    /// resulting in calls to `LocationDataSource.updateLocation(_:)` every second. To increase the frequency, provide a
    /// higher value. A value of 2.0, for example, doubles the frequency of location updates. To slow down updates,
    /// provide a lower value. A value of 0.5, for example, decreases location updates by a factor of two.
    /// The iteration rate does not affect the `Location.timestamp` property of the items in the ``simulatedLocations``
    /// (they are always 1 second apart).
    final public var iterationRate: Double

    /// A collection of locations that are iterated sequentially.
    ///
    /// As the collection is iterated, the `LocationDataSource.updateLocation(_:)` is fired for each location. The
    /// frequency at which `LocationDataSource.updateLocation(_:)` is called is determined by ``iterationRate``.
    /// Populate the collection by calling `SimulatedLocationDataSource.setLocations(with:parameters:)` or by directly
    /// assigning a collection of ``Location`` to this property.
    final public var simulatedLocations: [ArcGIS.Location] { get }

    /// Adds a sequence of `Location` values to the end of the `simulatedLocations` property.
    /// - Parameter newSimulatedLocations: The new `Location` values to append.
    final public func addSimulatedLocations<S>(_ newSimulatedLocations: S) where S : Sequence, S.Element == ArcGIS.Location

    /// Adds a `Location` value to the end of the `simulatedLocations` property.
    /// - Parameter newSimulatedLocation: The new `Location` value to append.
    final public func addSimulatedLocation(_ newSimulatedLocation: ArcGIS.Location)

    /// Inserts a collection of `Location` values into the `simulatedLocations` property at the specified position.
    /// - Parameters:
    ///   - newSimulatedLocations: The new `Location` values to insert.
    ///   - index: The position at which to insert the new `Location` values.
    final public func insertSimulatedLocations<C>(_ newSimulatedLocations: C, at index: Int) where C : Collection, C.Element == ArcGIS.Location

    /// Inserts a `Location` value into the `simulatedLocations` property at the specified position.
    /// - Parameters:
    ///   - newSimulatedLocation: The new `Location` value to insert.
    ///   - index: The position at which to insert the new `Location` value.
    final public func insertSimulatedLocation(_ newSimulatedLocation: ArcGIS.Location, at index: Int)

    /// Removes all values from the `simulatedLocations` property.
    final public func removeAllSimulatedLocations()

    /// Removes a sequence of `Location` values from the `simulatedLocations` property.
    /// - Parameter simulatedLocations: The `Location` values to remove.
    final public func removeSimulatedLocations<S>(_ simulatedLocations: S) where S : Sequence, S.Element == ArcGIS.Location

    /// Removes a `Location` value from the `simulatedLocations` property.
    /// - Parameter simulatedLocation: The `Location` value to remove.
    final public func removeSimulatedLocation(_ simulatedLocation: ArcGIS.Location)
}

extension SimulatedLocationDataSource {

    /// Creates an instance with the specified locations.
    /// - Parameter simulatedLocations: The locations to be used by the data source for
    /// location simulation.
    public convenience init(simulatedLocations: [ArcGIS.Location])

    /// Creates an instance where the simulated locations are derived with a given polyline and
    /// optional simulation parameters.
    ///
    /// If the given simulation parameters are `nil`, then the generated simulated locations are
    /// based on vertices of the polyline. The course, time-stamp, position and velocity properties
    /// of the resulting locations are calculated based on the inputs. All other location properties
    /// will remain with default values.
    ///
    /// If the given simulation paramters are not `nil`, then the generated simulated locations are
    /// determined based on the vertices of the given polyline and the velocity of the simulation
    /// parameters. For example, if the specified velocity is 10 meters per second,
    /// the distance between locations will be 10 meters. The time stamp values will always be 1
    /// second apart. Other location properties will be specified based on the parameters. Refer
    /// to ``SimulationParameters`` for more details.
    /// - Parameters:
    ///   - polyline: A polyline that defines a simulated travel path.
    ///   - parameters: Parameters to control how locations are created.
    public convenience init(polyline: ArcGIS.Polyline, parameters: ArcGIS.SimulationParameters? = nil)

    /// Sets the simulated locations with a polyline and optional simulation parameters.
    ///
    /// If the given simulation parameters are `nil`, then the generated simulated locations are
    /// based on vertices of the polyline. The course, time-stamp, position and velocity properties
    /// of the resulting locations are calculated based on the inputs. All other location properties
    /// will remain with default values.
    ///
    /// If the given simulation paramters are not `nil`, then the generated simulated locations are
    /// determined based on the vertices of the given polyline and the velocity of the simulation
    /// parameters. For example, if the specified velocity is 10 meters per second,
    /// the distance between locations will be 10 meters. The time stamp values will always be 1
    /// second apart. Other location properties will be specified based on the parameters. Refer
    /// to ``SimulationParameters`` for more details.
    /// - Parameters:
    ///   - polyline: A polyline that defines a simulated travel path.
    ///   - parameters: Parameters to control how locations are created.
    final public func setSimulatedLocations(with polyline: ArcGIS.Polyline, parameters: ArcGIS.SimulationParameters? = nil)
}

/// Parameters to control how locations are created from a simulated route of travel (Polyline).
///
/// This can be provided as an input to the `SimulatedLocationDataSource.setLocations(with:parameters:)`
/// method to specify the start time for the first location, travel velocity (meters per second), and horizontal and
/// vertical accuracy of locations.
/// - Since: 200.1
public struct SimulationParameters : Hashable {

    /// Date and time of the first location. Each subsequent location will increment its timestamp by one second.
    public var startDate: Date

    /// Rate of travel, in meters per second
    ///
    /// The default value is 10.0. Note that very small values for velocity may greatly increase the
    /// number of locations created.
    public var speed: Double

    /// The horizontal accuracy to assign to generated locations.
    ///
    /// The default value is 0.0.
    public var horizontalAccuracy: Double

    /// The vertical accuracy to assign to generated locations.
    ///
    /// The default value is 0.0.
    public var verticalAccuracy: Double

    /// Creates a SimulationParameters
    /// - Parameters:
    ///   - startDate: Date and time of the first location. Each subsequent location will increment its timestamp by one second.
    ///   - speed: Rate of travel, in meters per second.
    ///   - horizontalAccuracy: The horizontal accuracy to assign to generated locations.
    ///   - verticalAccuracy: The vertical accuracy to assign to generated locations.
    public init(startDate: Date = Date(), speed: Double = 10, horizontalAccuracy: Double = .zero, verticalAccuracy: Double = .zero)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SimulationParameters, b: ArcGIS.SimulationParameters) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Defines the properties of the layer that contains sites for a floor-aware map or scene.
///
/// The layer contains the boundaries of managed sites. A site is the largest space designation
/// in the [ArcGIS Indoors Information Model](https://pro.arcgis.com/en/pro-app/latest/help/data/indoors/arcgis-indoors-information-model.htm) and is used to
/// represent an area such as a campus, a barrack, or an industrial site. A site can contain multiple facilities.
/// - Note: See Also: ``GeoModelFloorDefinition``
/// - Since: 200.1
final public class SiteLayerDefinition : ArcGIS.JSONSerializable {

    /// Creates a new ``SiteLayerDefinition`` object with the specified layer id, site name attribute field and site id attribute field.
    /// - Parameters:
    ///   - layerID: An ID that specifies a layer in the map or scene that contains site features.
    ///   - nameField: The name of the attribute field that contains each site feature's name.
    ///   - siteIDField: The name of the attribute field that contains each site feature's unique identifier.
    public convenience init(layerID: ArcGIS.Layer.ID, nameField: String, siteIDField: String)

    /// An ID that specifies a layer in the map or scene that contains site features.
    final public var layerID: ArcGIS.Layer.ID { get }

    /// The name of the attribute field that contains each site feature's name.
    final public var nameField: String { get }

    /// The name of the attribute field that contains each site feature's unique identifier.
    final public var siteIDField: String { get }

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

/// A struct that implements solid fill symbol layer.
///
/// A ``SolidFillSymbolLayer`` represents a symbol layer used to fill a polygon geometry with
/// a solid color. It can have transparency applied.
///
/// If a ``SolidFillSymbolLayer`` is the only symbol layer in a ``MultilayerPolygonSymbol``, it will
/// fill the geometry with the specified color.
///
/// The ``SolidFillSymbolLayer`` is similar to the Web Scene's FillSymbol3DLayer, and the Web Map's esriSFS.
///
/// ``SolidFillSymbolLayer`` is like ``SimpleFillSymbol`` with a solid style. Unlike
/// ``SimpleFillSymbol``, which includes hatch fill styles, ``SolidFillSymbolLayer`` is used
/// to symbolize a solid fill exclusively and therefore only exposes a color property.
/// - Since: 200.1
final public class SolidFillSymbolLayer : ArcGIS.FillSymbolLayer {

    /// Creates a solid fill symbol layer with a given color.
    /// - Parameter color: The color of the solid fill symbol layer.
    public convenience init(color: UIColor = .black)

    /// The color of a solid fill symbol layer.
    ///
    /// An `UIColor` representing the color used in the solid fill.
    /// If a color is not explicitly set, the default will be black, RGBA(0, 0, 0, 255).
    ///
    /// When getting the color from a symbol, the consensus value (for all layers) is
    /// reported. If there is no consensus (one or more layers have different colors), a `nil` value is
    /// reported for the color. Likewise, setting a value for color on a symbol will apply that color to
    /// all layers the symbol contains.
    ///
    /// If you don't want changes to the symbol color to propagate to some of the symbol layers it contains,
    /// you can lock the color for those layers. If a symbol layer is color-locked,
    /// changes to the parent symbol will not affect the symbol layer. This also means that the layer will
    /// not be considered when determining a consensus color for the symbol as a whole.
    final public var color: UIColor
}

/// A class for stroke symbol layers with customized geometric effects. Currently it supports only dash effects.
/// Commonly used in line symbols to describe the appearance of the line, or in polygon symbols as an outline.
///
/// A ``SolidStrokeSymbolLayer`` represents a polyline geometry symbolized with a solid color.
///
/// This symbol layer, in a ``MultilayerPolylineSymbol``, colors the geometry of the line
/// with the specified solid color. The class also allows setting a collection of geometric effects,
/// which modify the stroke in various ways (see documentation for geometric effects).
///
/// The ``SolidStrokeSymbolLayer`` is used to represent the Web Scene specification's LineSymbol3DLayer and PathSymbol3DLayer.
/// LineSymbol3DLayer maps to the 'strip' 3D line style of ``SolidStrokeSymbolLayer``, and PathSymbol3DLayer
/// maps to the 'tube' 3D line style.
///
/// The ``SolidStrokeSymbolLayer`` provides a similar user experience to the ``SimpleLineSymbol``, but,
/// since it is a symbol layer, can be used in a ``MultilayerSymbol``. The simple line styles of the
/// ``SimpleLineSymbol`` are represented here by the ``DashGeometricEffect``, but all dash patterns
/// are custom. A solid stroke symbol layer in a multilayer polygon symbol will act as the outline of the fill.
/// - Note: See Also: ``DashGeometricEffect``
/// - Since: 200.1
final public class SolidStrokeSymbolLayer : ArcGIS.StrokeSymbolLayer {

    /// Create a solid stroke symbol layer with width, color, geometric effects and 3D line style.
    ///
    /// Create a solid stroke symbol layer with a stroke width, a color, a collection of geometric effects, and
    /// a 3D line style. The function sets the width, color, geometric effects, and 3D line style on the newly-created
    /// solid stroke. Stroke caps default to 'round'.
    /// - Parameters:
    ///   - width: The desired width for the symbol layer.
    ///   - color: The desired color for the symbol layer.
    ///   - geometricEffects: The effects to be applied to the symbol layer, e.g., dash patterns.
    ///   - lineStyle3D: The desired 3D line style.
    /// - Note: See Also: ``GeometricEffect``, ``DashGeometricEffect``
    /// - Precondition: `width >= 0`
    public convenience init(width: CGFloat = 5.333333492279053, color: UIColor = .black, geometricEffects: [ArcGIS.GeometricEffect] = [], lineStyle3D: ArcGIS.StrokeSymbolLayer.LineStyle3D = .strip)

    /// The color of a solid stroke symbol layer.
    ///
    /// The solid color of the ``SolidStrokeSymbolLayer``. The stroke will render with the specified color.
    /// When getting the color from a symbol, the consensus value (for all layers) is
    /// reported. If there is no consensus (one or more layers have different colors), a `nil` value is
    /// reported for the color. Likewise, setting a value for color on a symbol will apply that color to
    /// all layers the symbol contains.
    ///
    /// If you don't want changes to the symbol color to propagate to some of the symbol layers it contains,
    /// you can lock the color for those layers. If a symbol layer is color-locked,
    /// changes to the parent symbol will not affect the symbol layer. This also means that the layer will
    /// not be considered when determining a consensus color for the symbol as a whole.
    final public var color: UIColor

    /// The collection of geometric effects held by a solid stroke symbol layer.
    ///
    /// The collection of geometric effects held by a ``SolidStrokeSymbolLayer``. Setting the geometric effects
    /// will apply the collection of geometric effects to the stroke when rendering. See the documentation for geometric
    /// effects to understand how they apply.
    /// - Note: See Also: ``GeometricEffect``, ``DashGeometricEffect``
    final public var geometricEffects: [ArcGIS.GeometricEffect] { get }

    /// Adds a sequence of `GeometricEffect` values to the end of the `geometricEffects` property.
    /// - Parameter newGeometricEffects: The new `GeometricEffect` values to append.
    final public func addGeometricEffects<S>(_ newGeometricEffects: S) where S : Sequence, S.Element == ArcGIS.GeometricEffect

    /// Adds a `GeometricEffect` value to the end of the `geometricEffects` property.
    /// - Parameter newGeometricEffect: The new `GeometricEffect` value to append.
    final public func addGeometricEffect(_ newGeometricEffect: ArcGIS.GeometricEffect)

    /// Inserts a collection of `GeometricEffect` values into the `geometricEffects` property at the specified position.
    /// - Parameters:
    ///   - newGeometricEffects: The new `GeometricEffect` values to insert.
    ///   - index: The position at which to insert the new `GeometricEffect` values.
    final public func insertGeometricEffects<C>(_ newGeometricEffects: C, at index: Int) where C : Collection, C.Element == ArcGIS.GeometricEffect

    /// Inserts a `GeometricEffect` value into the `geometricEffects` property at the specified position.
    /// - Parameters:
    ///   - newGeometricEffect: The new `GeometricEffect` value to insert.
    ///   - index: The position at which to insert the new `GeometricEffect` value.
    final public func insertGeometricEffect(_ newGeometricEffect: ArcGIS.GeometricEffect, at index: Int)

    /// Removes all values from the `geometricEffects` property.
    final public func removeAllGeometricEffects()

    /// Removes a sequence of `GeometricEffect` values from the `geometricEffects` property.
    /// - Parameter geometricEffects: The `GeometricEffect` values to remove.
    final public func removeGeometricEffects<S>(_ geometricEffects: S) where S : Sequence, S.Element == ArcGIS.GeometricEffect

    /// Removes a `GeometricEffect` value from the `geometricEffects` property.
    /// - Parameter geometricEffect: The `GeometricEffect` value to remove.
    final public func removeGeometricEffect(_ geometricEffect: ArcGIS.GeometricEffect)
}

/// A structure that describes a source object position.
///
/// Class presents position of network element on network source.
/// - Since: 200.1
final public class SourceObjectPosition {

    /// Creates a source object position instance.
    ///
    /// Creates a source object position.
    /// - Parameters:
    ///   - sourceIndex: A source instance.
    ///   - sourceOID: A source OID.
    ///   - position: A position.
    public convenience init(sourceIndex: Int, sourceOID: Int, position: Double)

    /// Position.
    ///
    /// Source object's position.
    final public var position: Double

    /// Source index.
    ///
    /// Index of the source.
    final public var sourceIndex: Int

    /// Source object ID.
    final public var sourceObjectID: Int
}

/// The spatial reference specifies how geometry coordinates relate to real-world space.
///
/// Instances of this class represent a specific coordinate system identified by a well-known ID (WKID) number
/// or well-known text (WKT) string. There are two broad classes of coordinate systems:
///  * Geographic coordinate systems use a 3-dimensional spherical surface to define locations on the earth.
///  * Projected coordinate systems use a flat, 2-dimensional surface.
/// See https://developers.arcgis.com/documentation/spatial-references/ for more information about spatial references.
///
/// ``SpatialReference`` ensures that you can accurately view, query, and analyze the layers of a ``GeoModel``.
///
/// The spatial reference value is available from a map or scene after loading has completed, and is immutable.
/// If you want to set this value for a new map or scene, use the ``Map/init(spatialReference:)`` or
/// ``Scene/init(tilingScheme:)`` constructors.
/// - Since: 200.1
public struct SpatialReference {

    /// Creates a spatial reference based on WKID for the horizontal coordinate system and vertical coordinate system.
    ///
    /// The method creates a spatial reference that has both horizontal and vertical coordinate systems.
    /// When the vertical WKID is 0, the method is equivalent to calling ``init(wkid:verticalWKID:)``,
    /// and does not define a vertical coordinate system part.
    /// - Parameters:
    ///   - wkid: The well-known ID of the horizontal coordinate system. Must be a positive value.
    ///   - verticalWKID: The well-known ID of the vertical  coordinate system. Must be a non negative value.
    public init?(wkid: ArcGIS.WKID, verticalWKID: ArcGIS.WKID? = nil)

    /// Creates a spatial reference based on well-known text.
    /// - Parameter wkText: The well-known text of the spatial reference to create.
    public init?(wkText: String)
}

extension SpatialReference {

    /// If the given spatial reference is a projected coordinate system, then this returns the geographic coordinate system of that system.
    ///
    /// If the spatial reference is a projected coordinate system, then a spatial reference object representing the underlying geographic
    /// coordinate system is returned. Every projected coordinate system has an underlying geographic coordinate system. If the
    /// spatial reference is a geographic coordinate system, then a reference to itself is returned.
    /// If the spatial reference is a local spatial reference, a `nil` is returned with an error.
    public var baseGeographic: ArcGIS.SpatialReference? { get }

    /// `true` if spatial reference has a vertical coordinate system set; `false` otherwise.
    ///
    /// A spatial reference can optionally include a definition for a vertical coordinate system (VCS), which
    /// can be used to interpret the z-values of a geometry. A VCS defines linear units of measure, the origin of
    /// z-values, and whether z-values are "positive up" (representing heights above a surface) or "positive down"
    /// (indicating that values are depths below a surface).
    ///
    /// A ``SpatialReference`` may have a VCS set, for example by calling the
    /// ``init(wkid:verticalWKID:)`` constructor. ``verticalWKID``,
    /// ``wkText``, and ``verticalUnit`` provide more information about the
    /// specific VCS set on this instance.
    ///
    /// VCSs are used when projecting geometries using a ``HorizontalVerticalTransformation``.
    /// - Note: See Also: ``verticalWKID``, ``verticalUnit``
    public var hasVertical: Bool { get }

    /// `true` if spatial reference is a Geographic Coordinate System.
    public var isGeographic: Bool { get }

    /// `true` if coordinate system is horizontally pannable.
    public var isPannable: Bool { get }

    /// `true` if spatial reference is a Projected Coordinate System.
    public var isProjected: Bool { get }

    /// The unit of measure for the horizontal coordinate system of this spatial reference.
    public var unit: ArcGIS.Unit { get }

    /// The unit of measure for the vertical coordinate system of this spatial reference.
    ///
    /// Is `nil` if ``hasVertical`` is `false`.
    public var verticalUnit: ArcGIS.LinearUnit? { get }

    /// The well-known ID for the vertical coordinate system (VCS), or 0 if the spatial reference
    /// has no VCS or has a custom VCS.
    /// - Note: See Also: ``init(wkid:verticalWKID:)``
    public var verticalWKID: ArcGIS.WKID? { get }

    /// Creates a spatial reference based on web Mercator.
    ///
    /// The method creates a web Mercator spatial reference.
    public static var webMercator: ArcGIS.SpatialReference { get }

    /// Creates a spatial reference based on WGS84.
    ///
    /// The method creates a WGS84 spatial reference.
    public static var wgs84: ArcGIS.SpatialReference { get }

    /// The well-known text for the horizontal and vertical coordinate system.
    public var wkText: String { get }

    /// The well-known ID for the horizontal coordinate system, or 0 if the spatial reference
    /// has a custom horizontal coordinate system.
    public var wkid: ArcGIS.WKID? { get }
}

extension SpatialReference {

    /// Calculate the grid convergence for a spatial reference at a given point.
    ///
    /// The grid convergence is the angle between `true` North and Grid North
    /// at a point on a map. The grid convergence can be used to convert a
    /// horizontal direction expressed as an azimuth in a geographic
    /// coordinate system (relative to `true` North) to a direction expressed
    /// as a bearing in a projected coordinate system (relative to Grid
    /// North), and vice versa.
    ///
    /// Sign convention
    ///
    /// The grid convergence returned by this method is positive when Grid
    /// North lies east of `true` North. The following formula demonstrates
    /// how to obtain a bearing (b) from an azimuth (a) using the grid
    /// convergence (c) returned by this method:
    ///
    /// b = a - c
    ///
    /// This sign convention is sometimes named the Gauss-Bomford convention.
    ///
    /// Other notes:
    /// * Returns 0 if the spatial reference is a geographic coordinate system
    /// * Returns `nan` if the point is outside the projection's horizon or on error
    /// * If the point has no spatial reference, it is assumed to be in the
    ///   given spatial reference
    /// * If the point's spatial reference differs from the spatial
    ///   reference given, its location is transformed automatically to
    ///   the given spatial reference
    /// - Parameter point: The point
    /// - Returns: The grid convergence in degrees.
    public func convergenceAngle(at point: ArcGIS.Point) -> Double
}

extension SpatialReference : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.SpatialReference, rhs: ArcGIS.SpatialReference) -> Bool
}

extension SpatialReference : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension SpatialReference : ArcGIS.JSONSerializable {

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public static func fromJSON(_ json: String) throws -> ArcGIS.SpatialReference

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension SpatialReference : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

/// The various operators for spatially relating geometries.
/// - Since: 200.1
public enum SpatialRelationship {

    /// Relate operator.
    case relate

    /// Equals operator.
    case equals

    /// Disjoint operator.
    case disjoint

    /// Intersects operator.
    case intersects

    /// Touches operator.
    case touches

    /// Crosses operator.
    case crosses

    /// Within operator.
    case within

    /// Contains operator.
    case contains

    /// Overlaps operator.
    case overlaps

    /// Envelope intersects operator.
    case envelopeIntersects

    /// Index intersects operator.
    case indexIntersects

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SpatialRelationship, b: ArcGIS.SpatialRelationship) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension SpatialRelationship : Equatable {
}

extension SpatialRelationship : Hashable {
}

/// The standard deviation stretch parameters object.
/// - Since: 200.1
final public class StandardDeviationStretchParameters : ArcGIS.StretchParameters {

    /// Creates a standard deviation stretch parameters object.
    /// - Parameter factor: The standard deviation factor.
    public convenience init(factor: Double)

    /// Factor from a standard deviation stretch parameters object.
    final public var factor: Double { get }
}

/// A start time usage type. Allows to choose how to enter a time value.
/// - Since: 200.1
public enum StartTimeUsage {

    /// Use departure time.
    case departureTime

    /// Use arrival time.
    case arrivalTime

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.StartTimeUsage, b: ArcGIS.StartTimeUsage) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension StartTimeUsage : Equatable {
}

extension StartTimeUsage : Hashable {
}

/// Represents a type used for defining a statistic to be queried for in the table.
/// - Since: 200.1
final public class StatisticDefinition {

    /// An enumeration that represents the various statistics that can be calculated for values in a field in a table.
    public enum StatisticType {

        /// Returns the average for all non-`nil` values in a column.
        case average

        /// Returns the number of non-`nil` values in a column.
        case count

        /// Returns the maximum value found within a column.
        case maximum

        /// Returns the minimum value found within a column.
        case minimum

        /// Returns the standard deviation of the values within a column.
        case standardDeviation

        /// Returns the sum of all non-`nil` values within a column.
        case sum

        /// Returns the variance of the values within a column.
        case variance

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.StatisticDefinition.StatisticType, b: ArcGIS.StatisticDefinition.StatisticType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a statistic definition. A statistic definition must specify a field name and statistic type. Optionally, you can provide a name for the output statistic result.
    /// - Parameters:
    ///   - fieldName: The name of the field in the table containing values to be used for the statistic.
    ///   - statisticType: The statistic to calculate.
    ///   - outputAlias: The optional name for this statistic in the results.
    /// - Precondition: `!fieldName.isEmpty`
    public convenience init(fieldName: String, statisticType: ArcGIS.StatisticDefinition.StatisticType, outputAlias: String = "")

    /// The name of the field in the table containing values to be used for the statistic.
    final public var fieldName: String

    /// The name for this statistic in the results.
    ///
    /// If an output alias is not specified, a default name that identifies the statistic type and input field name will be used for the result.
    final public var outputAlias: String

    /// The statistic to calculate.
    final public var statisticType: ArcGIS.StatisticDefinition.StatisticType
}

extension StatisticDefinition.StatisticType : Equatable {
}

extension StatisticDefinition.StatisticType : Hashable {
}

/// Represents a value within the ``StatisticsQueryResult`` iterator.
/// - Since: 200.1
final public class StatisticRecord {

    /// The dictionary of GroupBy fields (if any were specified) and their associated values.
    ///
    /// The returned dictionary maps the GroupBy fields in the ``StatisticsQueryParameters`` to the group values. The type of value depends on the type of the GroupBy field.
    final public var group: [String : Any] { get }

    /// The dictionary of statistics values returned in the query result.
    final public var statistics: [String : Any] { get }
}

/// Parameters to perform a statistical query on a ``FeatureTable``.
///
/// Perform statistical analyses such as average, count, maximum, and standard deviation on a feature table by
/// defining a ``StatisticDefinition/StatisticType-swift.enum`` on a ``StatisticDefinition``. Use a combination of attribute, spatial,
/// and temporal criteria to filter the features to be analyzed. If no filters are defined, all features in the
/// table are included in the statistical query. You can also control how to group the results.
/// - Note: See Also: `FeatureTable.queryStatistics(using:)`, ``StatisticDefinition/statisticType-swift.property``
/// - Since: 200.1
final public class StatisticsQueryParameters {

    /// Creates statistics query parameters using one or more ``StatisticDefinition``.
    /// - Parameter statisticDefinitions: An `Array` containing ``StatisticDefinition`` instances.
    /// - Precondition: `!statisticDefinitions.isEmpty`
    public convenience init(statisticDefinitions: [ArcGIS.StatisticDefinition])

    /// The geometry used to filter the results.
    ///
    /// The geometry that (along with the ``spatialRelationship``) defines features to be included in the statistical query.
    final public var geometry: ArcGIS.Geometry?

    /// The fields by which statistical query results will be grouped.
    final public var groupByFieldNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `groupByFieldNames` property.
    /// - Parameter newGroupByFieldNames: The new `String` values to append.
    final public func addGroupByFieldNames<S>(_ newGroupByFieldNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `groupByFieldNames` property.
    /// - Parameter newGroupByFieldName: The new `String` value to append.
    final public func addGroupByFieldName(_ newGroupByFieldName: String)

    /// Inserts a collection of `String` values into the `groupByFieldNames` property at the specified position.
    /// - Parameters:
    ///   - newGroupByFieldNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertGroupByFieldNames<C>(_ newGroupByFieldNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `groupByFieldNames` property at the specified position.
    /// - Parameters:
    ///   - newGroupByFieldName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertGroupByFieldName(_ newGroupByFieldName: String, at index: Int)

    /// Removes all values from the `groupByFieldNames` property.
    final public func removeAllGroupByFieldNames()

    /// Removes a sequence of `String` values from the `groupByFieldNames` property.
    /// - Parameter groupByFieldNames: The `String` values to remove.
    final public func removeGroupByFieldNames<S>(_ groupByFieldNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `groupByFieldNames` property.
    /// - Parameter groupByFieldName: The `String` value to remove.
    final public func removeGroupByFieldName(_ groupByFieldName: String)

    /// The fields by which statistical query results will be ordered.
    ///
    /// Results can be sorted by one or more fields. Each ``OrderBy`` instance includes a field name and whether to
    /// sort by that field in ascending or descending order. If a service-based table is being queried it must
    /// support advanced queries.
    final public var orderByFields: [ArcGIS.OrderBy] { get }

    /// Adds a sequence of `OrderBy` values to the end of the `orderByFields` property.
    /// - Parameter newOrderByFields: The new `OrderBy` values to append.
    final public func addOrderByFields<S>(_ newOrderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Adds an `OrderBy` value to the end of the `orderByFields` property.
    /// - Parameter newOrderByField: The new `OrderBy` value to append.
    final public func addOrderByField(_ newOrderByField: ArcGIS.OrderBy)

    /// Inserts a collection of `OrderBy` values into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByFields: The new `OrderBy` values to insert.
    ///   - index: The position at which to insert the new `OrderBy` values.
    final public func insertOrderByFields<C>(_ newOrderByFields: C, at index: Int) where C : Collection, C.Element == ArcGIS.OrderBy

    /// Inserts an `OrderBy` value into the `orderByFields` property at the specified position.
    /// - Parameters:
    ///   - newOrderByField: The new `OrderBy` value to insert.
    ///   - index: The position at which to insert the new `OrderBy` value.
    final public func insertOrderByField(_ newOrderByField: ArcGIS.OrderBy, at index: Int)

    /// Removes all values from the `orderByFields` property.
    final public func removeAllOrderByFields()

    /// Removes a sequence of `OrderBy` values from the `orderByFields` property.
    /// - Parameter orderByFields: The `OrderBy` values to remove.
    final public func removeOrderByFields<S>(_ orderByFields: S) where S : Sequence, S.Element == ArcGIS.OrderBy

    /// Removes an `OrderBy` value from the `orderByFields` property.
    /// - Parameter orderByField: The `OrderBy` value to remove.
    final public func removeOrderByField(_ orderByField: ArcGIS.OrderBy)

    /// The spatial relationship that (along with the ``geometry``) defines features to be included in the query.
    ///
    /// The default spatial relationship is ``SpatialRelationship/intersects``.
    final public var spatialRelationship: ArcGIS.SpatialRelationship

    /// The definition of statistics (input field, output name, statistic type) to include in the statistical query of a table.
    final public var statisticDefinitions: [ArcGIS.StatisticDefinition] { get }

    /// Adds a sequence of `StatisticDefinition` values to the end of the `statisticDefinitions` property.
    /// - Parameter newStatisticDefinitions: The new `StatisticDefinition` values to append.
    final public func addStatisticDefinitions<S>(_ newStatisticDefinitions: S) where S : Sequence, S.Element == ArcGIS.StatisticDefinition

    /// Adds a `StatisticDefinition` value to the end of the `statisticDefinitions` property.
    /// - Parameter newStatisticDefinition: The new `StatisticDefinition` value to append.
    final public func addStatisticDefinition(_ newStatisticDefinition: ArcGIS.StatisticDefinition)

    /// Inserts a collection of `StatisticDefinition` values into the `statisticDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newStatisticDefinitions: The new `StatisticDefinition` values to insert.
    ///   - index: The position at which to insert the new `StatisticDefinition` values.
    final public func insertStatisticDefinitions<C>(_ newStatisticDefinitions: C, at index: Int) where C : Collection, C.Element == ArcGIS.StatisticDefinition

    /// Inserts a `StatisticDefinition` value into the `statisticDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newStatisticDefinition: The new `StatisticDefinition` value to insert.
    ///   - index: The position at which to insert the new `StatisticDefinition` value.
    final public func insertStatisticDefinition(_ newStatisticDefinition: ArcGIS.StatisticDefinition, at index: Int)

    /// Removes all values from the `statisticDefinitions` property.
    final public func removeAllStatisticDefinitions()

    /// Removes a sequence of `StatisticDefinition` values from the `statisticDefinitions` property.
    /// - Parameter statisticDefinitions: The `StatisticDefinition` values to remove.
    final public func removeStatisticDefinitions<S>(_ statisticDefinitions: S) where S : Sequence, S.Element == ArcGIS.StatisticDefinition

    /// Removes a `StatisticDefinition` value from the `statisticDefinitions` property.
    /// - Parameter statisticDefinition: The `StatisticDefinition` value to remove.
    final public func removeStatisticDefinition(_ statisticDefinition: ArcGIS.StatisticDefinition)

    /// The time extent that defines features to be included in the statistics query.
    ///
    /// A combination of attribute, spatial, and temporal criteria can be used to filter the features evaluated in a statistical query. If no filters are defined, all features in the table are included in the query.
    final public var timeExtent: ArcGIS.TimeExtent?

    /// The attribute expression that defines features to be included in the statistics query.
    ///
    /// The where clause should follow standard SQL syntax similar to that discussed in the document
    /// [SQL reference for query expressions used in ArcGIS](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm#GUID-940733A1-D6D1-4200-B290-24CA2E1056D4).
    ///
    /// If the where clause includes dates, they must be correctly formatted based on the geodatabase datasource
    /// used in the service. Refer to [Dates and time](https://pro.arcgis.com/en/pro-app/latest/help/mapping/navigation/sql-reference-for-elements-used-in-query-expressions.htm#GUID-85C03D85-F4A5-48FC-8E8C-3F79919430DB)
    /// for date formats expected by different data sources.
    ///
    /// ``ArcGISFeatureTable`` objects expect that any ``FieldType/globalID`` or ``FieldType/guid`` parameters in
    /// the where clause are formatted as: '{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}'. All characters are uppercase,
    /// wrapped in curly braces and surrounded by single quotes.
    final public var whereClause: String
}

/// Represents a type that contains the results of a statistics query.
/// - Since: 200.1
final public class StatisticsQueryResult {

    /// Returns the statistic records iterator.
    /// - Returns: An `AnySequence` that returns ``StatisticRecord``.
    final public func statisticRecords() -> AnySequence<ArcGIS.StatisticRecord>
}

/// A class that represents a location to be visited along a route.
///
/// The Stop class contains location inputs for the Route_task.
/// The Route_task will create a route between two or more Stops.
/// A Stop object is not an arbitrary bag of properties, but contains only the properties
/// needed for routing (for example, a Stop object does not have address information).
/// Stop objects are collected into an `Array` by value, and passed as an input to ``RouteTask``.
///
/// The stop class is derived from the graphic class.
/// - Note: See Also: ``RouteTask``
/// - Since: 200.1
final public class Stop {

    /// A stop's type. Specifies the type of a route stop.
    public enum Kind {

        /// Stop. A location where a vehicle would arrive and/or depart.
        case stop

        /// Waypoint. A location between stops that a route must pass through.
        case waypoint

        /// Rest break. A location where a route pauses e.g. for a required lunch break.
        case restBreak

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Stop.Kind, b: ArcGIS.Stop.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a stop instance with point.
    ///
    /// Creates a stop.
    /// - Parameter point: A point.
    /// - Note: See Also: ``Point``
    public convenience init(point: ArcGIS.Point)

    /// Arrival curb approach.
    /// - Note: See Also: ``CurbApproach``
    final public var arrivalCurbApproach: ArcGIS.CurbApproach? { get }

    /// Arrival time.
    /// - Note: See Also: `Date`
    final public var arrivalDate: Date? { get }

    /// The time zone shift for the arrival date.
    final public var arrivalDateShift: TimeInterval { get }

    /// Curb approach.
    /// - Note: See Also: ``CurbApproach``
    final public var curbApproach: ArcGIS.CurbApproach?

    /// Current bearing in degrees.
    ///
    /// Current bearing in degrees, measured clockwise from `true` north. Typical values are 0 to 360 or `nan`,
    /// negative values will be subtracted from 360 (e.g. -15 => 345), values greater than 360 will be have 360
    /// subtracted from them (e.g. 385 => 25). For this property to be used the bearing tolerance also has to be set.
    final public var currentBearing: Double

    /// Current bearing tolerance in degrees. Valid values are 0 to 180 or `nan`.
    final public var currentBearingTolerance: Double

    /// Departure curb approach.
    /// - Note: See Also: ``CurbApproach``
    final public var departureCurbApproach: ArcGIS.CurbApproach? { get }

    /// Departure time.
    /// - Note: See Also: `Date`
    final public var departureDate: Date? { get }

    /// The time zone shift for the departure date.
    final public var departureDateShift: TimeInterval { get }

    /// Distance to network location in meters.
    final public var distanceToNetworkLocation: Measurement<UnitLength> { get }

    /// The geometry of a stop.
    ///
    /// The point geometry of Stop.
    /// - Note: See Also: ``Point``
    final public var geometry: ArcGIS.Point?

    /// Stop ID.
    ///
    /// This is a caller supplied foreign key that can be used to associate output stops with input stops.
    /// - Note: See Also: `RouteParameters.setStops(fromFeaturesIn:queryParameters:)`, ``Route/stops``
    final public var id: Int

    /// Stop's type.
    ///
    /// Default value that will be returned on error is ``Kind-swift.enum/stop``.
    /// - Note: See Also: `String`
    final public var kind: ArcGIS.Stop.Kind

    /// Location status.
    /// - Note: See Also: ``LocationStatus``
    final public var locationStatus: ArcGIS.LocationStatus { get }

    /// Stop's name.
    /// - Note: See Also: `String`
    final public var name: String

    /// Navigation latency in seconds.
    final public var navigationLatency: TimeInterval

    /// Navigation speed in meters per second.
    final public var navigationSpeed: Double

    /// Network location.
    ///
    /// A `nil` for resetting a network location.
    /// - Note: See Also: ``NetworkLocation``
    final public var networkLocation: ArcGIS.NetworkLocation?

    /// Route's name.
    /// - Note: See Also: `String`
    final public var routeName: String

    /// Sequence.
    final public var sequence: Int { get }

    /// Time window end.
    /// - Note: See Also: `Date`
    final public var timeWindowEnd: Date?

    /// Time window start.
    /// - Note: See Also: `Date`
    final public var timeWindowStart: Date?

    /// The violation time for the route.
    final public var violationTime: TimeInterval { get }

    /// The wait time for the route.
    final public var waitTime: TimeInterval { get }

    /// Gets added cost attribute value.
    ///
    /// In case when attribute's name can not be found 0.0 will be returned.
    /// - Parameter attributeName: The name of the cost attribute.
    /// - Returns: The value of added cost.
    final public func addedCost(forAttributeNamed attributeName: String) -> Double

    /// Clones the ``Stop``.
    /// - Returns: A new ``Stop`` with the same values as the current ``Stop``.
    final public func clone() -> Self

    /// Gets cumulative cost attribute value.
    ///
    /// In case when attribute's name can not be found 0.0 will be returned.
    /// - Parameter attributeName: The name of cumulative attribute.
    /// - Returns: The value of cumulative cost.
    final public func cumulativeCost(forAttributeNamed attributeName: String) -> Double

    /// Sets added cost.
    /// - Parameters:
    ///   - addedCost: The added cost.
    ///   - attributeName: The attribute name.
    final public func setAddedCost(_ addedCost: Double, forAttributeNamed attributeName: String)
}

extension Stop.Kind : Equatable {
}

extension Stop.Kind : Hashable {
}

/// A property wrapper where the `projectedValue` is an async sequence
/// that emits a value when the property that is being wrapped changes.
/// - Since: 200.1
@propertyWrapper public struct Streamed<Value> {

    public var wrappedValue: Value

    public var projectedValue: AsyncStream<Value> { get }

    public init(wrappedValue: Value)
}

/// The stretch parameters object.
/// - Since: 200.1
public class StretchParameters {
}

/// A stretch renderer object which is derived from a base stretch renderer object.
/// - Note: See Also: ``RasterRenderer``, ``BaseStretchRenderer``
/// - Since: 200.1
final public class StretchRenderer : ArcGIS.BaseStretchRenderer {

    /// Creates a stretch renderer.
    /// - Parameters:
    ///   - parameters: The stretch parameters handle.
    ///   - gammas: Gamma adjustment. An `Array` of double. Can be `nil`.
    ///   - estimatesStatistics: Whether to estimate statistics if it does not exist.
    ///   - colorRamp: The color ramp object, can be `nil`.
    public convenience init(parameters: ArcGIS.StretchParameters?, gammas: [Double], estimatesStatistics: Bool, colorRamp: ArcGIS.ColorRamp?)
}

/// A ``StrokeSymbolLayer`` represents a symbol layer that, when applied to a polyline
/// geometry, draws a stroke along that geometry. The ``StrokeSymbolLayer`` can also control
/// drawing the outline of a polygon geometry.
///
/// Applied to a polyline geometry, the ``StrokeSymbolLayer`` will draw a segment of stroke adhering
/// to the selected visual properties for each line segment. Similarly, as the outline of a polygon
/// geometry, the ``StrokeSymbolLayer`` draws a stroke segment for each line segment of the polygon outline.
///
/// This symbol layer controls many common operations vital for working with strokes. Cap style
/// and line style 3D are controllable on the ``StrokeSymbolLayer``. These properties
/// provide the ability to pick between various options for rendering strokes. Line style 3D
/// applies only in 3D, but cap style and width have effects in both 2D and 3D.
/// - Since: 200.1
public class StrokeSymbolLayer : ArcGIS.SymbolLayer {

    /// The list of possible cap styles.
    ///
    /// The cap style describes the way that line symbol layers will terminate when combined with a geometry.
    /// The term "cap" refers to the end of the line. The options here control the shape that cap will take.
    public enum CapStyle {

        /// Applying the "butt" cap style will terminate the line ending exactly where the geometry ends.
        /// The end cap will be squared off. That is, two 90 degree angles form a butted ending to the symbol.
        case butt

        /// Applying the "round" cap style will terminate the line ending with a semicircle of radius equal to the stroke width.
        /// That semicircle will be centered at the line endpoint.
        case round

        /// Applying the "square" cap style will extend the termination of the line ending past the end of the geometry.
        /// The end cap will be squared off. That is, two 90 degree angles form a squared ending to the symbol.
        case square

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.StrokeSymbolLayer.CapStyle, b: ArcGIS.StrokeSymbolLayer.CapStyle) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of possible 3D line styles.
    ///
    /// The 3D line style describes the way that line symbol layers will render in 3D.
    /// The property refers to the rendering style of a 3D stroke layer.
    /// In a scene view, changing this property will change the fundamental appearance of the stroke layer.
    public enum LineStyle3D {

        /// The tube style causes the stroke to appear as a 3D tube.
        /// A "tube" here refers to a solid circular cylinder, following the given geometry.
        case tube

        /// The strip style causes the stroke to appear as a flat strip of surface. Note that the cap style for this line is
        /// always ``StrokeSymbolLayer/CapStyle-swift.enum/butt``.
        /// A "strip" here refers to a flat 2D surface with more significant width than a line, though it is presented in 3D.
        case strip

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.StrokeSymbolLayer.LineStyle3D, b: ArcGIS.StrokeSymbolLayer.LineStyle3D) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The cap style of stroke symbol layer.
    ///
    /// The default cap style is 'round,' meaning that the ends of the stroke are rounded off. Cap styles
    /// affect strokes in Map Views, as well as the 'strip' and 'tube' line styles in Scene Views.
    public var capStyle: ArcGIS.StrokeSymbolLayer.CapStyle

    /// The 3D line style of the stroke symbol layer.
    ///
    /// The 3D line style controls the rendering of the stroke in 3D. As a consequence of that,
    /// 3D line style has no effect on strokes in Map Views, but does affect strokes in Scene Views.
    public var lineStyle3D: ArcGIS.StrokeSymbolLayer.LineStyle3D

    /// The width of the stroke symbol layer.
    ///
    /// The return value may be any non-negative number (default is 0). A larger width means a larger stroke.
    public var width: CGFloat
}

extension StrokeSymbolLayer.CapStyle : Equatable {
}

extension StrokeSymbolLayer.CapStyle : Hashable {
}

extension StrokeSymbolLayer.LineStyle3D : Equatable {
}

extension StrokeSymbolLayer.LineStyle3D : Hashable {
}

/// The source of an ``ArcGISMapImageSublayer``.
///
/// Depending on the type of ``SublayerSource``, these layers are classified as follows:
/// * Map: a layer in the current map service (see ``MapSublayerSource``)
/// * Dynamic table: data from a table data source (see ``TableSublayerSource``)
/// * Dynamic query table: data from a queryTable data source (see
///    ``TableQuerySublayerSource``)
/// * Dynamic raster: data from a raster data source (see ``RasterSublayerSource``)
/// * Dynamic join table: data from a joinTable data source (see ``TableJoinSublayerSource``)
/// - Note: See Also: `ArcGISMapImageSublayer.init(id:source:)`, ``ArcGISMapImageSublayer/source``, ``MapSublayerSource``, ``TableSublayerSource``, ``TableJoinSublayerSource``, ``TableQuerySublayerSource``, ``RasterSublayerSource``
/// - Since: 200.1
public class SublayerSource {
}

/// Information about the user's subscription.
/// - Since: 200.1
public struct SubscriptionInfo : Hashable {

    /// The expiration date of the user's subscription.
    public let expirationDate: Date

    /// The current state of the user's subscription.
    public let state: ArcGIS.SubscriptionState?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SubscriptionInfo, b: ArcGIS.SubscriptionInfo) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// State of the user's subscription.
/// - Since: 200.1
public enum SubscriptionState : String {

    /// Subscription is active and allows all functionality.
    case active

    /// Subscription was canceled.
    case canceled

    /// Subscription was deleted.
    case deleted

    /// Subscription has expired.
    case expired

    /// Subscription has run out of credits.
    case restricted

    /// Subscription was suspended.
    case suspended

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: String)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = String

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: String { get }
}

extension SubscriptionState : Equatable {
}

extension SubscriptionState : Hashable {
}

extension SubscriptionState : RawRepresentable {
}

/// A layer that can visualize feature data with different visibility, rendering, popup
/// properties, and so on for some or all of the subtypes in an ``ArcGISFeatureTable``.
///
/// The ``ArcGISFeatureTable`` must have an ``ArcGISFeatureLayerInfo/subtypeField``
/// and at least one ``FeatureSubtype`` defined, otherwise the layer will fail to load.
///
/// Subtypes provide a way to organize your data within an ArcGIS feature table. For example,
/// the streets in a city streets feature table could be categorized into three subtypes - local
/// streets, collector streets, and arterial streets. The benefit of the subtype feature layer
/// is that it allows you to configure different layer properties per subtype. This is particularly
/// useful for data, such as utility networks, in which many different network elements are
/// grouped into a single subtype feature layer.
///
/// Functional characteristics
/// The subtype feature layer acts like a group layer that automatically creates one feature
/// layer, or subtype sublayer, for each subtype in the table. Each subtype sublayer can be
/// configured independently of one another. They can have different renderers, label definitions,
/// max and min scales, visibility, layer order in the map, and so on. When a subtype group layer is
/// read from a web map or mobile map, it is represented as a ``SubtypeFeatureLayer``. Saving a map
/// that contains a ``SubtypeFeatureLayer`` will save the layer as a subtype group layer. Subtype
/// feature layers are supported in offline maps and will work in offline editing workflows.
///
/// Performance characteristics
/// Queries are optimized across all sublayers. For example, a pan of the map sends a single
/// request to the feature table to cover all the sublayers. If you had manually created a
/// feature layer for each subtype, this would have resulted in one query per feature layer.
/// - Note: See Also: ``FeatureLayer``
/// - Since: 200.1
final public class SubtypeFeatureLayer : ArcGIS.FeatureLayer {

    /// Creates a new subtype feature layer object.
    ///
    /// If are there no ``ArcGISFeatureTable/featureSubtypes`` objects defined on the
    /// ``ArcGISFeatureTable``, the layer will fail to load.
    /// - Parameter featureTable: The feature table used as the source of the subtype feature layer
    public convenience init(featureTable: ArcGIS.ArcGISFeatureTable)

    /// Creates a new subtype feature layer object from a feature service portal item.
    /// - Parameters:
    ///   - item: A feature service ``PortalItem``.
    ///   - layerID: The layer id for which to create the layer.
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item, layerID: Int)

    /// The mutable collection of ``SubtypeSublayer``
    ///
    /// The objects in this collection are the same objects in ``LayerContent/subLayerContents``.
    /// The difference between the two collections is this collection is modifiable so the layer
    /// order is configurable.
    final public var subtypeSublayers: [ArcGIS.SubtypeSublayer] { get }

    /// Adds a sequence of `SubtypeSublayer` values to the end of the `subtypeSublayers` property.
    /// - Parameter newSubtypeSublayers: The new `SubtypeSublayer` values to append.
    final public func addSubtypeSublayers<S>(_ newSubtypeSublayers: S) where S : Sequence, S.Element == ArcGIS.SubtypeSublayer

    /// Adds a `SubtypeSublayer` value to the end of the `subtypeSublayers` property.
    /// - Parameter newSubtypeSublayer: The new `SubtypeSublayer` value to append.
    final public func addSubtypeSublayer(_ newSubtypeSublayer: ArcGIS.SubtypeSublayer)

    /// Inserts a collection of `SubtypeSublayer` values into the `subtypeSublayers` property at the specified position.
    /// - Parameters:
    ///   - newSubtypeSublayers: The new `SubtypeSublayer` values to insert.
    ///   - index: The position at which to insert the new `SubtypeSublayer` values.
    final public func insertSubtypeSublayers<C>(_ newSubtypeSublayers: C, at index: Int) where C : Collection, C.Element == ArcGIS.SubtypeSublayer

    /// Inserts a `SubtypeSublayer` value into the `subtypeSublayers` property at the specified position.
    /// - Parameters:
    ///   - newSubtypeSublayer: The new `SubtypeSublayer` value to insert.
    ///   - index: The position at which to insert the new `SubtypeSublayer` value.
    final public func insertSubtypeSublayer(_ newSubtypeSublayer: ArcGIS.SubtypeSublayer, at index: Int)

    /// Removes all values from the `subtypeSublayers` property.
    final public func removeAllSubtypeSublayers()

    /// Removes a sequence of `SubtypeSublayer` values from the `subtypeSublayers` property.
    /// - Parameter subtypeSublayers: The `SubtypeSublayer` values to remove.
    final public func removeSubtypeSublayers<S>(_ subtypeSublayers: S) where S : Sequence, S.Element == ArcGIS.SubtypeSublayer

    /// Removes a `SubtypeSublayer` value from the `subtypeSublayers` property.
    /// - Parameter subtypeSublayer: The `SubtypeSublayer` value to remove.
    final public func removeSubtypeSublayer(_ subtypeSublayer: ArcGIS.SubtypeSublayer)

    /// Finds a ``SubtypeSublayer`` for a feature subtype based on the ``FeatureSubtype/code``
    ///
    /// When working with a particular ``ArcGISFeature``, the ``FeatureSubtype/code`` is the value
    /// of the ``ArcGISFeatureLayerInfo/subtypeField`` field.  The corresponding ``SubtypeSublayer``
    /// can be found using the value of that field.
    /// - Parameter code: The subtype code of the sublayer to retrieve.
    /// - Returns: The ``SubtypeSublayer`` of the subtype code.
    final public func sublayer(withSubtypeCode code: Any) -> ArcGIS.SubtypeSublayer?

    /// Finds a ``SubtypeSublayer`` for a feature subtype based on the subtype name.
    /// - Parameter name: The subtype name of the sublayer to retrieve.
    /// - Returns: The ``SubtypeSublayer`` of the subtype name.
    final public func sublayer(withSubtypeName name: String) -> ArcGIS.SubtypeSublayer?
}

/// A sublayer that allows custom rendering for features of a particular subtype.
/// - Since: 200.1
final public class SubtypeSublayer : ArcGIS.ArcGISSublayer {

    /// The collection of ``LabelDefinition`` objects for this layer.
    final public var labelDefinitions: [ArcGIS.LabelDefinition] { get }

    /// Adds a sequence of `LabelDefinition` values to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinitions: The new `LabelDefinition` values to append.
    final public func addLabelDefinitions<S>(_ newLabelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Adds a `LabelDefinition` value to the end of the `labelDefinitions` property.
    /// - Parameter newLabelDefinition: The new `LabelDefinition` value to append.
    final public func addLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition)

    /// Inserts a collection of `LabelDefinition` values into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinitions: The new `LabelDefinition` values to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` values.
    final public func insertLabelDefinitions<C>(_ newLabelDefinitions: C, at index: Int) where C : Collection, C.Element == ArcGIS.LabelDefinition

    /// Inserts a `LabelDefinition` value into the `labelDefinitions` property at the specified position.
    /// - Parameters:
    ///   - newLabelDefinition: The new `LabelDefinition` value to insert.
    ///   - index: The position at which to insert the new `LabelDefinition` value.
    final public func insertLabelDefinition(_ newLabelDefinition: ArcGIS.LabelDefinition, at index: Int)

    /// Removes all values from the `labelDefinitions` property.
    final public func removeAllLabelDefinitions()

    /// Removes a sequence of `LabelDefinition` values from the `labelDefinitions` property.
    /// - Parameter labelDefinitions: The `LabelDefinition` values to remove.
    final public func removeLabelDefinitions<S>(_ labelDefinitions: S) where S : Sequence, S.Element == ArcGIS.LabelDefinition

    /// Removes a `LabelDefinition` value from the `labelDefinitions` property.
    /// - Parameter labelDefinition: The `LabelDefinition` value to remove.
    final public func removeLabelDefinition(_ labelDefinition: ArcGIS.LabelDefinition)

    /// The flag indicating whether the sublayer's labels are enabled/disabled.
    override final public var labelsAreEnabled: Bool

    /// The sublayer's maximum scale. If `nil`, there is no maximum.
    override final public var maxScale: Double?

    /// The sublayer's minimum scale. If `nil`, there is no minimum.
    override final public var minScale: Double?

    /// The sublayer's opacity.
    override final public var opacity: Float

    /// The sublayer's renderer.
    override final public var renderer: ArcGIS.Renderer?

    /// The subtype in the feature service that this subtype represents.
    final public var subtype: ArcGIS.FeatureSubtype { get }
}

/// A structure representing parameters for a geocoding suggestion operation.
///
/// Geocoding suggestions provide character-by-character auto-completion for facilitating interactive search experiences.
/// - Since: 200.1
final public class SuggestParameters {

    /// Creates a new suggest parameters object.
    public convenience init()

    /// Categories.
    ///
    /// Determines addresses from which categories should be returned.
    /// - Note: See Also: `Array`
    final public var categories: [String] { get }

    /// Adds a sequence of `String` values to the end of the `categories` property.
    /// - Parameter newCategories: The new `String` values to append.
    final public func addCategories<S>(_ newCategories: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `categories` property.
    /// - Parameter newCategory: The new `String` value to append.
    final public func addCategory(_ newCategory: String)

    /// Inserts a collection of `String` values into the `categories` property at the specified position.
    /// - Parameters:
    ///   - newCategories: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertCategories<C>(_ newCategories: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `categories` property at the specified position.
    /// - Parameters:
    ///   - newCategory: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertCategory(_ newCategory: String, at index: Int)

    /// Removes all values from the `categories` property.
    final public func removeAllCategories()

    /// Removes a sequence of `String` values from the `categories` property.
    /// - Parameter categories: The `String` values to remove.
    final public func removeCategories<S>(_ categories: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `categories` property.
    /// - Parameter category: The `String` value to remove.
    final public func removeCategory(_ category: String)

    /// Country code.
    ///
    /// Determines addresses from which the country should be returned.
    /// - Note: See Also: `String`
    final public var countryCode: String

    /// Max results.
    ///
    /// Determines the maximum number of returned suggestions. Supported value from interval [1..15], 5 by default.
    final public var maxResults: Int

    /// Preferred search location.
    ///
    /// Point specifying the preferred location where candidates will be searched.
    /// - Note: See Also: ``Point``
    final public var preferredSearchLocation: ArcGIS.Point?

    /// Search area.
    ///
    /// Input geometry specifying the area where candidates will be searched.
    /// - Note: See Also: ``Geometry``
    final public var searchArea: ArcGIS.Geometry?
}

/// A class representing the result of a geocoding suggestion operation.
///
/// A suggestion result can be forwarded to geocoding find operation.
/// - Since: 200.1
final public class SuggestResult {

    /// A flag that indicates candidate is related to a category or group.
    ///
    /// Candidate can be related with a category or group for example 'coffee', or some business name for example 'Starbucks'.
    final public var isCollection: Bool { get }

    /// Label.
    ///
    /// A label that contains suggested address.
    /// - Note: See Also: `String`
    final public var label: String { get }
}

/// The surface contains elevation sources and defines a surface upon which layers and overlays can be draped.
///
/// The surface is used to represent the ground in a scene. It is comprised of a collection of
/// elevation sources (``ElevationSource``) which are combined in the scene to generate the surface.
/// - Since: 200.1
final public class Surface : ArcGIS.Loadable {

    /// The list of options for constraining navigation based on the surface elevation.
    ///
    /// Used to constrain all forms of camera navigation to the elevation surface.
    public enum NavigationConstraint {

        /// Camera navigation is unconstrained. In this mode the camera
        /// may pass above and below the elevation surface.
        case unconstrained

        /// Camera navigation is constrained to remaining above the elevation surface.
        /// The altitude of the camera may not fall below the elevation of the surface.
        /// If the elevation is added or updates resulting in the camera altitude being below the
        /// elevation the camera will be pushed up to be at the surface.
        case stayAbove

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Surface.NavigationConstraint, b: ArcGIS.Surface.NavigationConstraint) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a surface object.
    ///
    /// Provides a surface on which layers may be draped or from which relative layers maybe offset.
    /// The most common use of the surface is to represent the ground in a scene.  It is comprised of a
    /// collection of elevation sources ``ElevationSource`` which are combined in the scene to generate the
    /// surface. If the data from the elevation sources is spatially coincident it will use the elevation
    /// source order to determine which source to use.
    public convenience init()

    /// Grid and color settings to render the background grid of this surface.
    ///
    /// The background grid is visible when no data is draped on the surface.
    /// - Note: See Also: ``BackgroundGrid``
    final public var backgroundGrid: ArcGIS.BackgroundGrid

    /// The exaggeration for the surface.
    ///
    /// The altitude values of the surface data are multiplied by the exaggeration value.
    /// The default value is 1.0, indicating no exaggeration.
    final public var elevationExaggeration: Float

    /// The elevation sources for the surface.
    ///
    /// Elevation sources are an ordered collection of ``ElevationSource`` data that are combined to
    /// generate elevation values for the surface. The order of the elevation sources in the collection
    /// indicate which elevation has priority when the sources are spatially coincident. The collection is
    /// specific to a surface so you cannot reuse an elevation source collection coming from another
    /// ``Surface``.
    /// - Note: See Also: ``Surface``
    final public var elevationSources: [ArcGIS.ElevationSource] { get }

    /// Adds a sequence of `ElevationSource` values to the end of the `elevationSources` property.
    /// - Parameter newElevationSources: The new `ElevationSource` values to append.
    final public func addElevationSources<S>(_ newElevationSources: S) where S : Sequence, S.Element == ArcGIS.ElevationSource

    /// Adds an `ElevationSource` value to the end of the `elevationSources` property.
    /// - Parameter newElevationSource: The new `ElevationSource` value to append.
    final public func addElevationSource(_ newElevationSource: ArcGIS.ElevationSource)

    /// Inserts a collection of `ElevationSource` values into the `elevationSources` property at the specified position.
    /// - Parameters:
    ///   - newElevationSources: The new `ElevationSource` values to insert.
    ///   - index: The position at which to insert the new `ElevationSource` values.
    final public func insertElevationSources<C>(_ newElevationSources: C, at index: Int) where C : Collection, C.Element == ArcGIS.ElevationSource

    /// Inserts an `ElevationSource` value into the `elevationSources` property at the specified position.
    /// - Parameters:
    ///   - newElevationSource: The new `ElevationSource` value to insert.
    ///   - index: The position at which to insert the new `ElevationSource` value.
    final public func insertElevationSource(_ newElevationSource: ArcGIS.ElevationSource, at index: Int)

    /// Removes all values from the `elevationSources` property.
    final public func removeAllElevationSources()

    /// Removes a sequence of `ElevationSource` values from the `elevationSources` property.
    /// - Parameter elevationSources: The `ElevationSource` values to remove.
    final public func removeElevationSources<S>(_ elevationSources: S) where S : Sequence, S.Element == ArcGIS.ElevationSource

    /// Removes an `ElevationSource` value from the `elevationSources` property.
    /// - Parameter elevationSource: The `ElevationSource` value to remove.
    final public func removeElevationSource(_ elevationSource: ArcGIS.ElevationSource)

    /// `true` if the surface is enabled, `false` otherwise.
    ///
    /// This value indicates if the surface is enabled and is rendered. If `true`, the surface's elevation
    /// sources are only used in the calculation of the surface if their ``ElevationSource/isEnabled`` is
    /// also `true`.
    final public var isEnabled: Bool

    /// The name for the surface.
    /// - Note: See Also: `String`
    final public var name: String

    /// The type of navigation constraint of the surface.
    ///
    /// This property determines whether the camera altitude is affected by the elevation at the location of
    /// the camera. You can restrict the camera to stay above the ground or allow it to move below the
    /// surface.
    /// The default value is ``NavigationConstraint-swift.enum/stayAbove``.
    /// - Note: See Also: ``NavigationConstraint-swift.enum``
    final public var navigationConstraint: ArcGIS.Surface.NavigationConstraint

    /// The opacity applied to the surface.
    ///
    /// The opacity value of all layers in the basemap, associated with this surface, and the
    /// ``backgroundGrid`` are multiplied by this opacity value.
    /// The value can be between 0 and 1.0, where 0 is transparent and 1.0 is solid or opaque.
    final public var opacity: Float

    /// Gets the elevation (in meters) for the specified location on the surface.
    /// - Parameter point: The point to find the elevation for.
    /// - Returns: An asynchronous task of type double for the elevation at the specified position.
    final public func elevation(at point: ArcGIS.Point) async throws -> Double

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension Surface.NavigationConstraint : Equatable {
}

extension Surface.NavigationConstraint : Hashable {
}

/// The options for handling altitude values.
/// - Since: 200.1
public enum SurfacePlacement : CaseIterable {

    /// Ignore Z values and drape symbols onto the surface, billboarded to always face the camera.
    ///
    /// In the case of a ``ModelSceneSymbol``, there is no difference in behavior between
    /// ``SurfacePlacement/drapedFlat`` and ``SurfacePlacement/drapedBillboarded``.
    case drapedBillboarded

    /// Treat the Z values as absolute altitude values.
    case absolute

    /// Treat the Z values as relative to the surface altitude values.
    case relative

    /// Treat the Z values as relative to the scene altitude values.
    case relativeToScene

    /// Ignore Z values and drape symbols flat on the surface.
    ///
    /// In the case of a ``ModelSceneSymbol``, there is no difference in behavior between
    /// ``SurfacePlacement/drapedFlat`` and ``SurfacePlacement/drapedBillboarded``.
    case drapedFlat

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SurfacePlacement, b: ArcGIS.SurfacePlacement) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// A type that can represent a collection of all values of this type.
    public typealias AllCases = [ArcGIS.SurfacePlacement]

    /// A collection of all values of this type.
    public static var allCases: [ArcGIS.SurfacePlacement] { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension SurfacePlacement : Equatable {
}

extension SurfacePlacement : Hashable {
}

/// A base class to represent symbols.
///
/// A symbol defines display properties for features and graphics (collectively referred to as
/// geoelements). A geoelement has a geometry (location and shape), and optional descriptive
/// information. For features and graphics to appear on a map, they must be assigned a symbol.
///
/// There are two models for defining symbols in your map: simple and advanced (multilayer). In general, simple
/// symbols are single-layer symbols that provide basic representations, such as marker, line, fill, text, or
/// picture. Advanced symbols are composed of one or several layers that can be defined individually and combined
/// to create complex representations.
///
/// Both of these are more fully described as follows:
/// * Simple symbols follow the web map specification and you work with them through the simple
///   symbol classes. These are also the symbols you get from web maps or from
///   feature services when advanced symbology is turned off. Simple symbols can be created for
///   points (marker symbols), lines (line symbols), and polygons (fill symbols). Each of the
///   simple symbol types provides an enumeration of pre-defined styles that can be applied to
///   the symbol.
/// * Advanced symbols, accessed through multilayer symbol classes, follow the ArcGIS Pro
///   symbol model. These symbols come from feature services (that use advanced symbology),
///   mobile style files, the dictionary renderer, and mobile map packages. You can also build
///   your own advanced symbols for points, lines, and polygons.
///
/// Simple symbology is the symbology of the web map. When authoring maps in ArcGIS Pro as web
/// maps, your multilayer symbols will be converted to simple symbols. In general, point
/// symbols are converted to picture marker symbols optimized for the web, and line and polygon
/// symbols are simplified while representing the original symbol as closely as possible. If
/// you're authoring a feature service from ArcGIS Pro or ArcGIS Desktop, however, both the
/// original symbols and the simplified symbols are stored. This allows clients that support
/// advanced symbols to render the features as originally symbolized, while those that do not
/// support advanced symbols (such as ArcGIS Online Map Viewer) can use the simple symbols for
/// display. Having both sets of symbols allows you to retain the advanced symbology where
/// available and still share the feature service as widely as possible.
///
/// If your app works primarily with web maps that you want to look the same throughout the
/// platform, your app should use the simple symbols API. Otherwise, make sure your users
/// understand that advanced symbols render slightly differently on clients that don't support
/// advanced symbology.
///
/// If your maps are used only with this API and ArcGIS Pro, you can use advanced symbols exclusively.
/// When rendered by this API, advanced symbols are vectorized. This allows them to scale better on
/// devices with high resolution screens.
///
/// You can set ``LoadSettings/usesAdvancedSymbology`` to control whether the map uses advanced
/// symbols (when available) or always renders with simple symbols.
/// - Since: 200.1
public class Symbol : ArcGIS.JSONSerializable {

    /// Clones the ``Symbol``.
    /// - Returns: A new ``Symbol`` with the same values as the current ``Symbol``.
    public func clone() -> Self

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension Symbol : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Symbol, rhs: ArcGIS.Symbol) -> Bool
}

extension Symbol : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension Symbol {

    /// Makes a swatch of the symbol.
    /// - Remark: This method will scale the symbol up or down in order to fit it in the desired width and height of the swatch.
    /// - Note: Picture marker symbols without a set size are not scaled by the given scale, as
    ///   a `nil` size is taken to mean "render at native scale".
    /// - Parameters:
    ///   - scale: The scale factor to assume when interpreting the image data. This value is used to scale
    ///   symbology when rendering the swatch. The value should be set appropriately in order to render
    ///   swatches at the correct scale for a given display.
    ///   - size: The size of the swatch in points.
    ///   - backgroundColor: The background color of the swatch. The default is `clear`.
    /// - Returns: A `UIImage` that represents the swatch.
    public func makeSwatch(scale: CGFloat, size: CGSize? = nil, backgroundColor: UIColor = .clear) async throws -> UIImage

    /// Makes a swatch of the symbol.
    /// - Parameters:
    ///   - scale: The scale factor to assume when interpreting the image data. This value is used to scale
    ///   symbology when rendering the swatch. The value should be set appropriately in order to render
    ///   swatches at the correct scale for a given display.
    ///   - size: The size of the swatch in points.
    ///   - geometry: The geometry of the symbol to be drawn in the swatch image. The specified
    ///   geometry is in points, with the point {0,0} located at the center of the swatch image. The X-axis
    ///   increases towards the right side of the swatch image. The Y-axis increases towards the top of the
    ///   swatch image. For example, when creating a swatch for a ``MarkerSymbol``, specifying a
    ///   geometry of {10,10} will draw the marker 10 points up and to the right of the center of the swatch.
    ///   The geometry type (``Point``, ``Polyline``,  ``Polygon``) should correspond to the
    ///   symbol type (``MarkerSymbol``, ``LineSymbol``, ``FillSymbol``).
    ///   The geometry's spatial reference is ignored.
    ///   - backgroundColor: The background color for the swatch. The default is `clear`.
    /// - Returns: A `UIImage` that represents the swatch.
    public func makeSwatch(scale: CGFloat, size: CGSize, geometry: ArcGIS.Geometry, backgroundColor: UIColor = .clear) async throws -> UIImage
}

/// Implements the anchor of a symbol layer, including placement mode and x, y, z anchor values.
///
/// ``SymbolAnchor`` contains the properties necessary to define the anchor for a symbol layer.
/// These anchor properties define both the anchor values (x, y, z) and the placement mode. This object
/// can be passed to ``MarkerSymbolLayer`` objects to control marker anchor properties.
/// - Since: 200.1
public struct SymbolAnchor : Hashable {

    /// The list of possible symbol anchor placement modes.
    ///
    /// ``SymbolAnchor/PlacementMode-swift.enum`` enumerates the ways in which symbol anchor values may be
    /// specified. Different placement modes control how anchor values are interpreted.
    public enum PlacementMode {

        /// Specify anchor with relative values. This mode causes anchor values to be interpreted as
        /// percentages, relative to the origin of the symbol. Percentage values must be
        /// expressed as fractions between [0, 1]. A 50% (.5) x-anchor, for example, moves the symbol
        /// layer anchor in the positive-x direction an amount equal to 50% of the symbol layer size.
        case relative

        /// Specify anchor with absolute values. This mode causes anchor values to be interpreted
        /// as absolute units (DIPs) rather than percentages.
        case absolute

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.SymbolAnchor.PlacementMode, b: ArcGIS.SymbolAnchor.PlacementMode) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The x-component of the symbol anchor object.
    ///
    /// The x-component of the ``SymbolAnchor`` can be any real number. The units of the value depend
    /// on the anchor placement mode of the ``SymbolAnchor``. The default value is 0, regardless of placement mode.
    /// A positive x-component will adjust the anchor point of the symbol in the positive-x direction. This has the visual
    /// effect of pushing the marker in the negative-x direction, since the anchor remains on the location of the marker.
    public var x: Double

    /// The y-component of the symbol anchor object.
    ///
    /// The y-component of the ``SymbolAnchor`` can be any real number. The units of the value depend
    /// on the anchor placement mode of the ``SymbolAnchor``. The default value is 0, regardless of placement mode.
    /// A positive y-component will adjust the anchor point of the symbol in the positive-y direction. This has the visual
    /// effect of pushing the marker in the negative-y direction, since the anchor remains on the location of the marker.
    public var y: Double

    /// The anchor placement mode of the symbol anchor object.
    ///
    /// The ``PlacementMode-swift.enum`` determines how Runtime interprets the ``SymbolAnchor`` anchor values.
    /// See the ``PlacementMode-swift.enum`` documentation for a description of the effects of each mode.
    /// The default mode is 'relative.'
    public var placementMode: ArcGIS.SymbolAnchor.PlacementMode

    /// Creates a symbol anchor and sets up the properties.
    ///
    /// The function sets up the ``SymbolAnchor`` with the provided arguments.
    /// - Parameters:
    ///   - x: The x-component of the anchor point.
    ///   - y: The y-component of the anchor point.
    ///   - placementMode: The anchor placement mode to use for the anchor values.
    public init(x: Double, y: Double, placementMode: ArcGIS.SymbolAnchor.PlacementMode)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SymbolAnchor, b: ArcGIS.SymbolAnchor) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension SymbolAnchor.PlacementMode : Equatable {
}

extension SymbolAnchor.PlacementMode : Hashable {
}

/// The list of possible symbol angle alignment types.
///
/// Marker symbol alignment when map is rotated.
/// - Since: 200.1
public enum SymbolAngleAlignment {

    /// Marker top edge always aligned with map north.
    case map

    /// Marker top edge always aligned with screen top edge.
    case screen

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SymbolAngleAlignment, b: ArcGIS.SymbolAngleAlignment) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension SymbolAngleAlignment : Equatable {
}

extension SymbolAngleAlignment : Hashable {
}

/// An error than can occur when dealing with symbol dictionaries.
/// - Since: 200.1
public enum SymbolDictionaryError : Error {

    /// Symbol dictionary not supported.
    case notSupported

    /// Missing symbol dictionary configuration.
    case missingConfiguration

    /// Missing symbol dictionary script.
    case missingScript

    /// Missing symbol dictionary display name.
    case missingDisplayName

    /// Error parsing the symbol dictionary configuration.
    case configurationParsingError

    /// Error parsing the symbol dictionary script.
    case arcadeParsingError

    /// Error evaluating the symbol dictionary script.
    case arcadeEvaluationError

    /// Error establishing connection with the stylx file for symbol dictionary.
    case stylxConnectionError

    /// Error converting ordered anchor points to geometry for symbol dictionary.
    case orderedAnchorPointToGeometryError

    /// Error converting geometry to ordered anchor points for symbol dictionary.
    case geometryToOrderedAnchorPointError

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension SymbolDictionaryError : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SymbolDictionaryError, b: ArcGIS.SymbolDictionaryError) -> Bool
}

extension SymbolDictionaryError : Hashable {
}

/// A base class to represent symbol layers, which are the fundamental components used to
/// build multilayer symbols.
///
/// The available symbol layer types correspond to the primitive geometry they are designed to
/// render: marker layers for point, stroke layers for line, and fill layers for area. Layer
/// types, however, are not applied exclusively to the corresponding geoelement geometry type.
/// A marker symbol layer, for example, could be applied to a polyline feature to render its
/// vertices. Each layer type has a unique set of properties to control its display.
///
/// A symbol can contain one or several symbol layers of the same or different type. A symbol
/// used to render polygons, for example, might contain a fill symbol layer to render the
/// polygon interior, a stroke symbol layer for rendering the polygon outline, and a marker
/// symbol layer to render polygon vertices. A symbol to render a polyline might contain
/// several stroke layers of varying widths. If a symbol contains a layer that cannot render
/// the type of geometry to which it is applied, that symbol layer is ignored when rendering.
///
/// The following table lists symbol types and symbol layers:
///
/// <table>
/// <tr>
/// <th>Symbol type</th>
/// <th>Typical symbol layers</th>
/// <th>Role</th>
/// </tr>
/// <tr>
/// <td>
/// <p>Point symbol</p>
/// </td>
/// <td>
/// <p>Marker layers</p>
/// </td>
/// <td>
/// <p>Draw relative to the point geometry</p>
/// </td>
/// </tr>
/// <tr>
/// <td rowspan="2">
/// <p>Polyline symbol</p>
/// </td>
/// <td>
/// <p>Marker layers</p>
/// </td>
/// <td>
/// <p>Draw at specified locations relative to the line geometry</p>
/// </td>
/// </tr>
/// <tr>
/// <td>
/// <p>Stroke layers</p>
/// </td>
/// <td>
/// <p>Draw relative to the line geometry</p>
/// </td>
/// </tr>
/// <tr>
/// <td rowspan="3">
/// <p>Polygon symbol</p>
/// </td>
/// <td>
/// <p>Marker layers</p>
/// </td>
/// <td>
/// <p>Draw relative to the polygon outline or in the interior, depending on placement setting</p>
/// </td>
/// </tr>
/// <tr>
/// <td>
/// <p>Stroke layers</p>
/// </td>
/// <td>
/// <p>Draw relative to the polygon outline</p>
/// </td>
/// </tr>
/// <tr>
/// <td>
/// <p>Fill layers</p>
/// </td>
/// <td>
/// <p>Draw relative to the polygon interior</p>
/// </td>
/// </tr>
/// </table>
///
/// Symbol and layer property interaction
///
/// Most ``SymbolLayer`` properties are only accessible on the symbol layer. There are some
/// properties, however, that are also exposed for the symbol as a whole. Properties such as
/// color and size, for example, can be modified either for an individual symbol layer, or for
/// the symbol itself. For such properties, the value provided for the symbol may have an
/// effect on the corresponding property for the symbol layers it contains. Similarly, the
/// property value for a multilayer symbol might be determined from the values of the
/// individual symbol layers it contains.
///
/// There are no notifications from a symbol or symbol layer when a property has been changed.
/// If your app needs to respond to property changes in a symbol (as a result of a propagated
/// change, for example) you will need to reread property values to identify changes.
///
/// Unknown symbol layers or properties
///
/// The multilayer symbol specification is complex and continues to evolve. It is possible that
/// some symbol layers (or properties) do not expose an API or are not known to the ArcGIS Maps
/// API. In these cases the symbol will be handled as follows:
/// * If a symbol can be rendered, but there is no public API, the base class for the appropriate
///   symbol layer is returned in the layer collection.
/// * The multilayer symbology specification for an existing symbol layer type may have been updated
///   to include properties that are not recognized by this API. The symbol layer is created
///   and rendered using the recognized properties. Any properties that cannot be identified are ignored.
/// * In the event that a new (unrecognized) symbol layer is encountered, the symbol is ignored
///   and is not added to the symbol layer collection.
/// - Since: 200.1
public class SymbolLayer {

    /// The symbol layer color locked property.
    ///
    /// The color-locked status of the symbol layer.
    /// If color_locked is `true`, the color of that layer will not change.
    public var colorIsLocked: Bool

    /// The symbol layer enabled property.
    ///
    /// The enable status of the symbol layer.
    /// Layer will be rendered only if it is enabled.
    public var isEnabled: Bool

    /// Clones the ``SymbolLayer``.
    /// - Returns: A new ``SymbolLayer`` with the same values as the current ``SymbolLayer``.
    public func clone() -> Self
}

extension SymbolLayer : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.SymbolLayer, rhs: ArcGIS.SymbolLayer) -> Bool
}

/// Symbol properties that changes how symbols behave when attached to a renderer.
///
/// ``SymbolReferenceProperties`` contains conditional properties that are not used directly by the symbol but
/// rather by the renderer to change how a symbol is visualized based on the state of the view and the data. For
/// example, ``minScale`` and ``maxScale`` will be used by
/// class breaks and unique value renderers to determine if a symbol break or unique value is visible at a certain
/// scale. Additional symbols can be assigned as alternate symbols for the renderers. This allows the map author to
/// control which symbol is displayed at certain scales.
/// - Since: 200.1
final public class SymbolReferenceProperties {

    /// Creates a symbol reference properties object with minimum and maximum scales.
    ///
    /// Minimum and maximum scales are used in the context of alternate symbols.
    /// - Parameters:
    ///   - minScale: Scale at which the symbol starts rendering.
    ///   - maxScale: Scale at which the symbol stops rendering.
    /// - Precondition: Scale values must be non-negative numbers.
    public convenience init(minScale: Double? = nil, maxScale: Double? = nil)

    /// The maximum scale at which the symbol will be visible. If `nil`, there is no maximum.
    ///
    /// This is the scale at which the symbol starts rendering. The default value is 0.
    final public var maxScale: Double?

    /// The minimum scale at which the symbol will be visible. If `nil`, there is no minimum.
    ///
    /// This is the scale at which the symbol stops rendering. The default value is 0.
    final public var minScale: Double?
}

/// A symbol style object.
///
/// A ``SymbolStyle`` is created either from a style file on disk (an SQLite database with a .stylx extension, created with ArcGIS Pro)
/// or from a style file hosted on ArcGIS Online or an ArcGIS Enterprise portal (also referred to as a web style).
///
/// When used by itself, the symbol style supports two key workflows. One is to return a symbol based on a provided set of key values.
/// Since each symbol in the style has a key that uniquely identifies it, you can pass an array of keys into `SymbolStyle.symbol(forKeys:)`
/// to return a new ``Symbol`` built from the individual symbols represented by those keys. You might use this symbol to create a new ``Graphic``.
///
/// The other common workflow is to use a standalone symbol style to search for symbol primitives. Symbol primitives are the individual symbols that compose more complex symbols.
/// This is achieved using `SymbolStyle.searchSymbols(using:)`. You could create a symbol picker app, for example, that searches for all symbols in the style that have the tag "maritime" in it.
/// The search results contain symbols that you could use directly. You could also extract their individual symbol components to create a new multilayer symbol.
/// - Note: See Also: ``DictionarySymbolStyle``
/// - Since: 200.1
public class SymbolStyle : ArcGIS.Loadable {

    /// Creates a new symbol style object from a portal item. The portal item must contain a style.
    ///
    /// If you have the item id of a style file, you can search the portal to find the item using its item id.
    /// Use this constructor if you have a reference to a portal item.
    /// - Parameter portalItem: A ``PortalItem`` that contains a web style.
    public convenience init(portalItem: ArcGIS.PortalItem)

    /// Creates a new symbol style object using the registered style name of the Esri web style on the portal.
    ///
    /// Esri provides a set of web symbol styles "out of the box" for localized use with ArcGIS Online and Enterprise.
    /// Users can use this constructor only if you are creating a symbol style using the Esri web style's unique name on your portal or arcgis.com.
    /// If `nil` is passed for portal parameter, [ArcGIS online](https://www.arcgis.com/index.html) is used as the default portal.
    /// An overview of esri web styles and symbols currently in production is available [for 3D](https://developers.arcgis.com/javascript/latest/visualization/symbols-color-ramps/esri-web-style-symbols-3d/) and
    /// [2D](https://developers.arcgis.com/javascript/latest/visualization/symbols-color-ramps/esri-web-style-symbols-2d/).
    /// Tip: Click on the symbol icon to find its associated style name.
    /// Esri registered style names can also be found in the json of symbol web style.
    /// As an example see item json for https://www.arcgis.com/sharing/rest/content/items/bf27400d167d4c2e8e12c8a46f87afe4?f=pjson hosted on ArcGIS Online.
    /// - Parameters:
    ///   - styleName: The registered Esri symbol style name. The styleName cannot be a custom web style name.
    ///   - portal: A Portal hosting the Esri web style. If `nil` is passed, [ArcGIS online](https://www.arcgis.com/index.html) is used as the default portal.
    public convenience init(styleName: String, portal: ArcGIS.Portal? = nil)

    /// Returns a Symbol Style Search Parameters object providing all available search parameters from the database.
    ///
    /// This asynchronous task retrieves all the valid input search parameters for a style.
    /// This means you get all of the possible input values for categories, keys,
    /// names, symbolClasses, and tags. This is an expensive task that should be used sparingly.
    public var defaultSearchParameters: ArcGIS.SymbolStyleSearchParameters { get async throws }

    /// The portal that hosts the web style identified with ``styleName``. This will be `nil` if the style was identified with a PortalItem or Uri or a local .stylx file on disk.
    public var portal: ArcGIS.Portal? { get }

    /// The portal item representing the web style.
    ///
    /// The PortalItem will be set when SymbolStyle is created using ``init(portalItem:)`` or `SymbolStyle.style(from:)`.
    /// This will be `nil` if the style was created using ``init(styleName:portal:)`` or is identified with a local .stylx file on disk.
    public var portalItem: ArcGIS.PortalItem? { get }

    /// The name of the web style. This will be empty if the style was identified with a URL or a PortalItem or a local .stylx file on disk.
    public var styleName: String { get }

    /// The URL of the web style. This will be empty if the style was identified with a PortalItem or style name or a local .stylx file on disk.
    public var url: URL? { get }

    /// Returns a collection of Symbol Style Search Result object.
    ///
    /// This asynchronous task searches for symbol primitives in the symbol style. The
    /// input searchParameters define what is searched for. For example, you could search
    /// for all symbols that have the tag "airspace". You can also set the match to be strict
    /// or not, which will determine if the search uses "=" or "LIKE" for each parameter.
    /// - Parameter parameters: an object of type ``SymbolStyleSearchParameters``.
    /// - Returns: An array of the ``SymbolStyleSearchResult`` objects that match the search parameters.
    public func searchSymbols(using parameters: ArcGIS.SymbolStyleSearchParameters) async throws -> [ArcGIS.SymbolStyleSearchResult]

    /// Asynchronously returns a symbol based on the provided list of keys.
    ///
    /// This function is useful for obtaining a single, multi-layer symbol from supplied
    /// keys. This is commonly used to create symbols and graphics on-the-fly. For
    /// example, assume XYZ style has a symbol with key "abc" which is the central symbol and another symbol with key "pqr",
    /// which could be the modifier/echelon placed at some offset from central geometry. So if you provide these two keys as attributes
    /// then symbol style will find and assemble a symbol accordingly.
    /// Once you have that symbol, you can apply it to a Graphic or Renderer,
    /// obtain its swatch image, or serialize to JSON.
    /// If the Symbol style is not loaded then starting this task will start the
    /// load cycle.
    /// - Parameter keys: `Array` of `String` type value. It is the list of keys required to obtain a symbol from the style.
    /// - Returns: A ``Symbol``.
    public func symbol(forKeys keys: [String]) async throws -> ArcGIS.Symbol

    /// The load status.
    @ArcGIS.Streamed public var loadStatus: ArcGIS.LoadStatus { get }

    public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed public var loadError: Error? { get }

    public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    public func cancelLoad()
}

extension SymbolStyle {

    /// Creates a symbol style with the specified .stylx file or using a web style item URL.
    ///
    /// For example, this [URL](https://www.arcgis.com/home/item.html?id=bf27400d167d4c2e8e12c8a46f87afe4)
    /// is the "Basic Shapes" style on ArcGIS Online.
    /// - Parameter url: The URL to a .stylx file on disk or to a web style item.
    @objc dynamic public convenience init(url: URL)
}

/// Search parameters used to search for symbol primitives in a symbol style .
///
/// SymbolStyleSearchParameters allow you to specify different parameters when searching
/// a symbol style  with `SymbolStyle.searchSymbols(using:)`. For example, you may want
/// to search for any symbols where the category is "2", the name contains "destroyed", and
/// the tags contain "Protection Lines".
///
/// This object allows you to set the parameters in order to perform a search on symbol style . You can make a copy of this and pass it or reuse it for different search.
/// - Note: See Also: ``DictionarySymbolStyle``, ``SymbolStyle``, ``SymbolStyleSearchResult``
/// - Since: 200.1
final public class SymbolStyleSearchParameters {

    /// Creates a new Symbol Style Search Parameters object.
    ///
    /// This object is a collection of name, class, category, tags and keys. Symbol style performs a search based on that and looks for all the symbols matching these entries in stylx file.
    public convenience init()

    /// The string list of categories defined in the database to be used for search.
    ///
    /// For example, with mil2525d you may want to search for symbols where the categories are
    /// "Activities : Main Icon" or "Sea Surface : Main Icon".
    final public var categories: [String] { get }

    /// Adds a sequence of `String` values to the end of the `categories` property.
    /// - Parameter newCategories: The new `String` values to append.
    final public func addCategories<S>(_ newCategories: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `categories` property.
    /// - Parameter newCategory: The new `String` value to append.
    final public func addCategory(_ newCategory: String)

    /// Inserts a collection of `String` values into the `categories` property at the specified position.
    /// - Parameters:
    ///   - newCategories: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertCategories<C>(_ newCategories: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `categories` property at the specified position.
    /// - Parameters:
    ///   - newCategory: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertCategory(_ newCategory: String, at index: Int)

    /// Removes all values from the `categories` property.
    final public func removeAllCategories()

    /// Removes a sequence of `String` values from the `categories` property.
    /// - Parameter categories: The `String` values to remove.
    final public func removeCategories<S>(_ categories: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `categories` property.
    /// - Parameter category: The `String` value to remove.
    final public func removeCategory(_ category: String)

    /// A boolean showing if the categories parameter is to be matched exactly against the database.
    ///
    /// A strict match will force the search to use "=", as opposed to "LIKE". The
    /// default value is `false`.
    final public var categoriesStrictlyMatch: Bool

    /// A boolean showing if all the parameters are empty.
    final public var isEmpty: Bool { get }

    /// A string list of all the keys(unique identifiers) used for search.
    ///
    /// For example, with mil2525d you may want to search for symbols where the keys are "25272100"
    /// or "2_635_1c".
    final public var keys: [String] { get }

    /// Adds a sequence of `String` values to the end of the `keys` property.
    /// - Parameter newKeys: The new `String` values to append.
    final public func addKeys<S>(_ newKeys: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `keys` property.
    /// - Parameter newKey: The new `String` value to append.
    final public func addKey(_ newKey: String)

    /// Inserts a collection of `String` values into the `keys` property at the specified position.
    /// - Parameters:
    ///   - newKeys: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertKeys<C>(_ newKeys: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `keys` property at the specified position.
    /// - Parameters:
    ///   - newKey: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertKey(_ newKey: String, at index: Int)

    /// Removes all values from the `keys` property.
    final public func removeAllKeys()

    /// Removes a sequence of `String` values from the `keys` property.
    /// - Parameter keys: The `String` values to remove.
    final public func removeKeys<S>(_ keys: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `keys` property.
    /// - Parameter key: The `String` value to remove.
    final public func removeKey(_ key: String)

    /// A boolean showing if the keys parameter is to be matched exactly against the database.
    ///
    /// A strict match will force the search to use "=", as opposed to "LIKE". The
    /// default value is `false`.
    final public var keysStrictlyMatch: Bool

    /// The string list of names to be used for search.
    ///
    /// For example, with mil2525d you may want to search for symbols where the names are
    /// "Ship Propulsion : Nuclear Powered" or "Simulation : Friend : Air".
    final public var names: [String] { get }

    /// Adds a sequence of `String` values to the end of the `names` property.
    /// - Parameter newNames: The new `String` values to append.
    final public func addNames<S>(_ newNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `names` property.
    /// - Parameter newName: The new `String` value to append.
    final public func addName(_ newName: String)

    /// Inserts a collection of `String` values into the `names` property at the specified position.
    /// - Parameters:
    ///   - newNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertNames<C>(_ newNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `names` property at the specified position.
    /// - Parameters:
    ///   - newName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertName(_ newName: String, at index: Int)

    /// Removes all values from the `names` property.
    final public func removeAllNames()

    /// Removes a sequence of `String` values from the `names` property.
    /// - Parameter names: The `String` values to remove.
    final public func removeNames<S>(_ names: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `names` property.
    /// - Parameter name: The `String` value to remove.
    final public func removeName(_ name: String)

    /// A boolean showing if the names parameter is to matched exactly against the database.
    ///
    /// A strict match will force the search to use "=", as opposed to "LIKE". The
    /// default value is `false`.
    final public var namesStrictlyMatch: Bool

    /// A string list of all the symbol classes(symbol types) used for search. e.g. Point, Line, Polygon
    ///
    /// For example, with mil2525d you may want to search for symbols where the symbol classes
    /// are "3" (Point Symbol) or "7" (North Arrow).
    final public var symbolClasses: [String] { get }

    /// Adds a sequence of `String` values to the end of the `symbolClasses` property.
    /// - Parameter newSymbolClasses: The new `String` values to append.
    final public func addSymbolClasses<S>(_ newSymbolClasses: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `symbolClasses` property.
    /// - Parameter newSymbolClass: The new `String` value to append.
    final public func addSymbolClass(_ newSymbolClass: String)

    /// Inserts a collection of `String` values into the `symbolClasses` property at the specified position.
    /// - Parameters:
    ///   - newSymbolClasses: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertSymbolClasses<C>(_ newSymbolClasses: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `symbolClasses` property at the specified position.
    /// - Parameters:
    ///   - newSymbolClass: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertSymbolClass(_ newSymbolClass: String, at index: Int)

    /// Removes all values from the `symbolClasses` property.
    final public func removeAllSymbolClasses()

    /// Removes a sequence of `String` values from the `symbolClasses` property.
    /// - Parameter symbolClasses: The `String` values to remove.
    final public func removeSymbolClasses<S>(_ symbolClasses: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `symbolClasses` property.
    /// - Parameter symbolClass: The `String` value to remove.
    final public func removeSymbolClass(_ symbolClass: String)

    /// A boolean showing if the symbol classes parameter is to be matched exactly against the database.
    ///
    /// A strict match will force the search to use "=", as opposed to "LIKE". The
    /// default value is `false`.
    final public var symbolClassesStrictlyMatch: Bool

    /// The string list of tags to be used for search.
    ///
    /// For example, with mil2525d you may want to search for symbols where the tags
    /// include "Airspace Control Points" or "Meteorological - Oceanographic".
    final public var tags: [String] { get }

    /// Adds a sequence of `String` values to the end of the `tags` property.
    /// - Parameter newTags: The new `String` values to append.
    final public func addTags<S>(_ newTags: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `tags` property.
    /// - Parameter newTag: The new `String` value to append.
    final public func addTag(_ newTag: String)

    /// Inserts a collection of `String` values into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTags: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertTags<C>(_ newTags: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTag: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertTag(_ newTag: String, at index: Int)

    /// Removes all values from the `tags` property.
    final public func removeAllTags()

    /// Removes a sequence of `String` values from the `tags` property.
    /// - Parameter tags: The `String` values to remove.
    final public func removeTags<S>(_ tags: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `tags` property.
    /// - Parameter tag: The `String` value to remove.
    final public func removeTag(_ tag: String)

    /// A boolean showing if the tags parameter is to matched exactly against the database.
    ///
    /// A strict match will force the search to use "=", as opposed to "LIKE". The
    /// default value is `false`.
    final public var tagsStrictlyMatch: Bool
}

/// A search result object returned by symbol style.
///
/// This object is returned by symbol style  based on the search performed using search parameters.
/// It contains the information related to name, tags, category, class type, key associated to a symbol.
/// It also returns the symbol.
///
/// This object returns the results based on search performed in the symbol style using the search parameters. This returns the symbol and all the parameters associated to it.
/// - Note: See Also: ``DictionarySymbolStyle``, ``SymbolStyle``, ``SymbolStyleSearchParameters``
/// - Since: 200.1
final public class SymbolStyleSearchResult {

    /// The category associated to a symbol.
    final public var category: String { get }

    /// The key(unique identifier) associated to a symbol.
    final public var key: String { get }

    /// The name associated to a symbol.
    final public var name: String { get }

    /// Asynchronously returns a symbol from the search result.
    final public var symbol: ArcGIS.Symbol { get async throws }

    /// The class associated to a symbol.
    final public var symbolClass: String { get }

    /// A string list of all the tags associated to a symbol.
    final public var tags: [String] { get }
}

/// An object that identifies the various synchronization capabilities of an ArcGIS Feature Service.
/// - Since: 200.1
final public class SyncCapabilities {

    /// Indicates if Annotation data is available for downloading.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// This property indicates whether Annotation data is also available from the service,
    /// for generation of, or downloading to, an offline geodatabase.
    ///
    /// Once this data is taken offline to a local geodatabase, any inserts, edits or deletions
    /// will NOT be applied to the server data when the geodatabase is re-synchronized.
    /// If features linked to the annotation have been changed,
    /// the server WILL apply the feature-linked-annotation updates.
    /// Another download from the server will replace any
    /// offline inserts, edits or deletions of Annotation features.
    /// - Note: See Also: ``GenerateGeodatabaseParameters/syncsAnnotations``
    final public var supportsAnnotations: Bool { get }

    /// `true` if asynchronous operations are supported.
    final public var supportsAsync: Bool { get }

    /// `true` if the service supports options to define how attachments will be synced.
    final public var supportsAttachmentsSyncDirection: Bool { get }

    /// Indicates if Contingent Value data is available.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// This property indicates whether Contingent Value data is also available from the service,
    /// for generation of an offline geodatabase and for resynchronization.
    /// - Note: See Also: ``GenerateGeodatabaseParameters/syncsContingentValues``
    final public var supportsContingentValues: Bool { get }

    /// Indicates if Dimension data is available.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// This property indicates whether Dimension data is also available from the service,
    /// for generation of an offline geodatabase and for resynchronization.
    /// - Note: See Also: ``GenerateGeodatabaseParameters/syncsDimensions``
    final public var supportsDimensions: Bool { get }

    /// `true` if registering existing data is supported.
    final public var supportsRegisteringExistingData: Bool { get }

    /// If rollback on failure is supported.
    final public var supportsRollbackOnFailure: Bool { get }

    /// If synchronization direction control is supported.
    final public var supportsSyncDirectionControl: Bool { get }

    /// If per replica synchronization is supported.
    final public var supportsSyncModelGeodatabase: Bool { get }

    /// If per layer synchronization is supported.
    final public var supportsSyncModelLayer: Bool { get }

    /// If no sync model is supported.
    final public var supportsSyncModelNone: Bool { get }

    /// Indicates if Utility Network System data is available.
    ///
    /// Feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// This property indicates whether Utility Network System data is also available from the service,
    /// for generation of an offline geodatabase and for resynchronization.
    /// - Note: See Also: ``GenerateGeodatabaseParameters/utilityNetworkSyncMode``
    final public var supportsUtilityNetworkSystem: Bool { get }

    /// Indicates if utility network topology data is available.
    ///
    /// When syncing Utility Network data, feature layers and tables are always included in the generation and synchronization of the geodatabase.
    /// This property indicates whether utility network topology data is also available from the service,
    /// for generation of an offline geodatabase and for resynchronization.
    /// - Note: See Also: ``GenerateGeodatabaseParameters/utilityNetworkSyncMode``
    final public var supportsUtilityNetworkTopology: Bool { get }
}

/// The direction to synchronize as part of geodatabase sync task.
/// - Since: 200.1
public enum SyncDirection {

    /// There is no specified sync direction.
    case noSync

    /// The geodatabase changes are downloaded only.
    case download

    /// The geodatabase changes are uploaded only.
    case upload

    /// The geodatabase changes are both uploaded and downloaded.
    case bidirectional

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.SyncDirection, b: ArcGIS.SyncDirection) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension SyncDirection : Equatable {
}

extension SyncDirection : Hashable {
}

/// A ``Job`` that synchronizes changes to a local geodatabase back to a feature service.
/// - Note: See Also: ``Job``, ``GenerateGeodatabaseJob``
/// - Since: 200.1
final public class SyncGeodatabaseJob : ArcGIS.Job, ArcGIS.JobProtocol {

    /// Returns information on geodatabase upload and download delta files.
    ///
    /// When ``SyncGeodatabaseParameters/keepsGeodatabaseDeltas`` is set to `true`, this property provides information
    /// about the synced geodatabase along with the paths to its uploaded and downloaded deltas.
    ///
    /// Delta geodatabases allow you to troubleshoot sync problems - for example by inspecting the changes they
    /// contain or sending the file to the system administrator for the feature service.
    ///
    /// This property will be set even if the job fails. If ``SyncGeodatabaseParameters/keepsGeodatabaseDeltas`` is
    /// `false`, this property will be `nil`.
    final public var geodatabaseDeltaInfo: ArcGIS.GeodatabaseDeltaInfo? { get }

    /// The type associated with the result of a successful job.
    public typealias Output = [ArcGIS.SyncLayerResult]

    /// The result of the completed job.
    /// - Remark: Accessing this property does not start the job.
    final public var result: Result<ArcGIS.SyncGeodatabaseJob.Output, Error> { get async }
}

/// An object that represents parameters to sync geodatabase task.
/// - Since: 200.1
final public class SyncGeodatabaseParameters {

    /// Create a parameters object for use with the sync method on the geodatabase sync task.
    public convenience init()

    /// The synchronization direction that will be used when synchronizing the geodatabase.
    ///
    /// This is only used if the Geodatabase has a sync model of ``Geodatabase/SyncModel-swift.enum/geodatabase``, it is ignored for ``Geodatabase/SyncModel-swift.enum/layer``
    final public var geodatabaseSyncDirection: ArcGIS.SyncDirection

    /// Indicates whether or not the upload or downloaded server delta geodatabases will be removed at the end of the sync job.
    ///
    /// A delta geodatabase is a file that contains the changes that have occurred since a
    /// mobile replica ``Geodatabase`` was last synchronized with its feature service. See
    /// https://developers.arcgis.com/rest/services-reference/enterprise/synchronize-replica.htm
    /// for an overview of the delta files used in synchronization.
    ///
    /// There are two types of delta geodatabase:
    /// * Local edits, performed on the user's device, are exported as an "upload" delta that
    ///   is applied to the originating feature service
    /// * Online edits, performed by other users are requested as a "download" delta which is
    ///   then applied to the local replica geodatabase
    ///
    /// Delta geodatabases allow you to troubleshoot sync problems. For example, you can inspect
    /// the geodatabase changes or you could send the file to the administrator of the feature
    /// service.
    ///
    /// You can choose to retain both the uploaded and downloaded delta geodatabases once the
    /// sync job has completed. Set to `true` to retain both delta geodatabases and set to `false`
    /// to have them deleted at the end of the sync job. Deltas will be retained regardless of
    /// whether the job succeeds or fails.  Note that when this property is set to `true`, the
    /// upload delta geodatabase will only be available if there are changes to upload and the
    /// sync direction is ``SyncDirection/upload`` or ``SyncDirection/bidirectional``. The
    /// download delta geodatabase will only be available when there are changes to download
    /// and the sync direction is ``SyncDirection/download`` or
    /// ``SyncDirection/bidirectional``. The default value is `false`.
    /// - Note: See Also: `GeodatabaseSyncTask.exportDelta(from:to:)`
    final public var keepsGeodatabaseDeltas: Bool

    /// The list of sync layer options to include in the sync operation.
    final public var layerOptions: [ArcGIS.SyncLayerOption] { get }

    /// Adds a sequence of `SyncLayerOption` values to the end of the `layerOptions` property.
    /// - Parameter newLayerOptions: The new `SyncLayerOption` values to append.
    final public func addLayerOptions<S>(_ newLayerOptions: S) where S : Sequence, S.Element == ArcGIS.SyncLayerOption

    /// Adds a `SyncLayerOption` value to the end of the `layerOptions` property.
    /// - Parameter newLayerOption: The new `SyncLayerOption` value to append.
    final public func addLayerOption(_ newLayerOption: ArcGIS.SyncLayerOption)

    /// Inserts a collection of `SyncLayerOption` values into the `layerOptions` property at the specified position.
    /// - Parameters:
    ///   - newLayerOptions: The new `SyncLayerOption` values to insert.
    ///   - index: The position at which to insert the new `SyncLayerOption` values.
    final public func insertLayerOptions<C>(_ newLayerOptions: C, at index: Int) where C : Collection, C.Element == ArcGIS.SyncLayerOption

    /// Inserts a `SyncLayerOption` value into the `layerOptions` property at the specified position.
    /// - Parameters:
    ///   - newLayerOption: The new `SyncLayerOption` value to insert.
    ///   - index: The position at which to insert the new `SyncLayerOption` value.
    final public func insertLayerOption(_ newLayerOption: ArcGIS.SyncLayerOption, at index: Int)

    /// Removes all values from the `layerOptions` property.
    final public func removeAllLayerOptions()

    /// Removes a sequence of `SyncLayerOption` values from the `layerOptions` property.
    /// - Parameter layerOptions: The `SyncLayerOption` values to remove.
    final public func removeLayerOptions<S>(_ layerOptions: S) where S : Sequence, S.Element == ArcGIS.SyncLayerOption

    /// Removes a `SyncLayerOption` value from the `layerOptions` property.
    /// - Parameter layerOption: The `SyncLayerOption` value to remove.
    final public func removeLayerOption(_ layerOption: ArcGIS.SyncLayerOption)

    /// Indicates if a sync should roll back on a failure.
    final public var shouldRollbackOnFailure: Bool
}

/// The can be used in conjunction with ``SyncGeodatabaseParameters`` to specify per layer synchronization options.
/// - Since: 200.1
final public class SyncLayerOption {

    /// Creates a new sync layer option with layer id and sync direction.
    /// - Parameters:
    ///   - layerID: A layer id to sync.
    ///   - syncDirection: the direction to sync the layer.
    public convenience init(layerID: Int = 0, syncDirection: ArcGIS.SyncDirection = .bidirectional)

    /// The layer or table Id to further filter in the generated geodatabase.
    ///
    /// The Ids used here must match Ids used in the synchronized geodatabase.
    /// Only layers that need further refining need to be included.
    final public var layerID: Int

    /// The sync direction for the specified layer Id.
    final public var syncDirection: ArcGIS.SyncDirection

    /// Clones the ``SyncLayerOption``.
    /// - Returns: A new ``SyncLayerOption`` with the same values as the current ``SyncLayerOption``.
    final public func clone() -> Self
}

/// An object that represents the result of sync operation on a table or layer if there has been edit errors with individual features.
///
/// If the server has an error applying an edit, this is returned as ``FeatureEditResult`` error.
/// Only errors are reported, the feature edit results of a sync operation do not contain information
/// about successful adds, deletes or updates.
/// - Since: 200.1
final public class SyncLayerResult {

    /// An array of any errors from sync feature edit results representing the result of a sync.
    ///
    /// If the server has an error applying an edit, this is returned as ``FeatureEditResult`` error.
    /// Only errors are reported, the feature edit results of a sync operation do not contain information
    /// about successful adds, deletes or updates.
    final public var editResults: [ArcGIS.FeatureEditResult] { get }

    /// The table name for the sync result.
    final public var tableName: String { get }
}

extension SyncLayerResult {

    /// The layer or table identifier.
    /// - Remark: If there's an error the value is `nil`.
    final public var layerID: Int? { get }
}

/// A ``LocationDataSource`` subclass that reports the device's location. The
/// locations are obtained from the operating system.
/// - Since: 200.1
final public class SystemLocationDataSource : ArcGIS.LocationDataSource {

    /// A Boolean value indicating whether the app should receive location updates when suspended.
    /// - Remark: The default is `false`.
    final public var allowsBackgroundLocationUpdates: Bool

    public convenience init()
}

/// A key in a table capabilities dictionary.
public typealias TableCapabilityKey = ArcGIS.FeatureTableKey

/// An object that describes a ``GeodatabaseFeatureTable`` to be created.
///
/// Creation of fields and tables is currently only supported on mobile geodatabases,
/// either created in ArcGIS Pro or via `Geodatabase.createEmpty(fileURL:)`.
/// - Since: 200.1
final public class TableDescription {

    /// Creates a new table description object with the specified name.
    /// - Parameter name: The table's name.
    public convenience init(name: String)

    /// Creates a new table description object with the specified name, spatial reference, and geometry type.
    /// - Parameters:
    ///   - name: The field's name.
    ///   - spatialReference: The table's spatial reference.
    ///   - geometryType: The table's geometry type.
    public convenience init(name: String, spatialReference: ArcGIS.SpatialReference, geometryType: ArcGIS.Geometry.Type?)

    /// An `Array` of ``FieldDescription`` objects that represent the descriptions of the fields to be created.
    ///
    /// If no ObjectID field is provided, one will be automatically added.
    final public var fieldDescriptions: [ArcGIS.FieldDescription] { get }

    /// Adds a sequence of `FieldDescription` values to the end of the `fieldDescriptions` property.
    /// - Parameter newFieldDescriptions: The new `FieldDescription` values to append.
    final public func addFieldDescriptions<S>(_ newFieldDescriptions: S) where S : Sequence, S.Element == ArcGIS.FieldDescription

    /// Adds a `FieldDescription` value to the end of the `fieldDescriptions` property.
    /// - Parameter newFieldDescription: The new `FieldDescription` value to append.
    final public func addFieldDescription(_ newFieldDescription: ArcGIS.FieldDescription)

    /// Inserts a collection of `FieldDescription` values into the `fieldDescriptions` property at the specified position.
    /// - Parameters:
    ///   - newFieldDescriptions: The new `FieldDescription` values to insert.
    ///   - index: The position at which to insert the new `FieldDescription` values.
    final public func insertFieldDescriptions<C>(_ newFieldDescriptions: C, at index: Int) where C : Collection, C.Element == ArcGIS.FieldDescription

    /// Inserts a `FieldDescription` value into the `fieldDescriptions` property at the specified position.
    /// - Parameters:
    ///   - newFieldDescription: The new `FieldDescription` value to insert.
    ///   - index: The position at which to insert the new `FieldDescription` value.
    final public func insertFieldDescription(_ newFieldDescription: ArcGIS.FieldDescription, at index: Int)

    /// Removes all values from the `fieldDescriptions` property.
    final public func removeAllFieldDescriptions()

    /// Removes a sequence of `FieldDescription` values from the `fieldDescriptions` property.
    /// - Parameter fieldDescriptions: The `FieldDescription` values to remove.
    final public func removeFieldDescriptions<S>(_ fieldDescriptions: S) where S : Sequence, S.Element == ArcGIS.FieldDescription

    /// Removes a `FieldDescription` value from the `fieldDescriptions` property.
    /// - Parameter fieldDescription: The `FieldDescription` value to remove.
    final public func removeFieldDescription(_ fieldDescription: ArcGIS.FieldDescription)

    /// The type of geometry to be used by features in the table.
    ///
    /// The default geometry type is `nil` and represents a non-spatial table.
    /// When setting a known geometry type, the spatial reference also needs to be specified via
    /// the ``spatialReference`` property.
    final public var geometryType: ArcGIS.Geometry.Type?

    /// `true` if the features should support attachments.
    ///
    /// The default value is `false`. Enabling attachments requires a GlobalID field.
    final public var hasAttachments: Bool

    /// `true` if the feature geometries should contain M values.
    ///
    /// The default value is `false`.
    final public var hasM: Bool

    /// `true` if the feature geometries should contain Z values.
    ///
    /// The default value is `false`.
    final public var hasZ: Bool

    /// The spatial reference to be used by feature geometries in the table.
    ///
    /// The default spatial reference is `nil` and represents a non-spatial table.
    /// When setting to a non-`nil` spatial reference, the geometry type also needs to be specified
    /// via the ``geometryType`` property.
    final public var spatialReference: ArcGIS.SpatialReference?

    /// The table's name.
    ///
    /// The table name must be non-empty, consist only of alphanumeric characters and underscores,
    /// and cannot start with a number or an underscore.
    final public var tableName: String
}

/// A key in a table errors dictionary.
public typealias TableErrorKey = ArcGIS.FeatureTableKey

/// Table Join sublayer source is the result of a join operation.
///
/// Nested joins are supported. To use nested joins, set either leftTableSource or rightTableSource to be a ``TableJoinSublayerSource``.
/// - Note: See Also: ``TableSublayerSource``, ``TableQuerySublayerSource``, ``RasterSublayerSource``, ``MapSublayerSource``, `TableJoinSublayerSource.Type`
/// - Since: 200.1
final public class TableJoinSublayerSource : ArcGIS.SublayerSource {

    /// The join type (left outer or left inner) of a table join sublayer source.
    ///
    /// Can get the join type by calling ``TableJoinSublayerSource/joinType-swift.property``.
    /// - Note: See Also: ``TableJoinSublayerSource``
    public enum JoinType {

        /// Inner join type.
        case innerJoin

        /// Left outer join type.
        case leftOuterJoin

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TableJoinSublayerSource.JoinType, b: ArcGIS.TableJoinSublayerSource.JoinType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a table join sublayer source.
    /// - Parameters:
    ///   - leftFieldName: The left field name.
    ///   - leftSublayerSource: The left sublayer source.
    ///   - rightFieldName: The right field name.
    ///   - rightSublayerSource: The right sublayer source.
    ///   - joinType: The join type
    /// - Note: See Also: ``SublayerSource``, ``ArcGISMapImageSublayer/source``
    public convenience init(leftFieldName: String, leftSublayerSource: ArcGIS.SublayerSource, rightFieldName: String, rightSublayerSource: ArcGIS.SublayerSource, joinType: ArcGIS.TableJoinSublayerSource.JoinType?)

    /// The join type.
    final public var joinType: ArcGIS.TableJoinSublayerSource.JoinType? { get }

    /// The left field name.
    final public var leftFieldName: String { get }

    /// The left sublayer source.
    final public var leftSublayerSource: ArcGIS.SublayerSource { get }

    /// The right field name.
    final public var rightFieldName: String { get }

    /// The right sublayer source.
    final public var rightSublayerSource: ArcGIS.SublayerSource { get }
}

extension TableJoinSublayerSource.JoinType : Equatable {
}

extension TableJoinSublayerSource.JoinType : Hashable {
}

/// Query table sublayer source is a layer/table that is defined by a SQL query.
/// - Note: See Also: ``TableSublayerSource``, ``TableJoinSublayerSource``, ``RasterSublayerSource``, ``MapSublayerSource``, `TableSublayerSource.Type`
/// - Since: 200.1
final public class TableQuerySublayerSource : ArcGIS.SublayerSource {

    /// Creates a table query sublayer source.
    /// - Parameters:
    ///   - workspaceID: The workspace ID.
    ///   - sqlQuery: The SQL query.
    ///   - objectIDFieldNames: The object ID field names as an `Array` of `String`.
    /// - Note: See Also: ``SublayerSource``, ``ArcGISMapImageSublayer/source``
    public convenience init(workspaceID: String, sqlQuery: String, objectIDFieldNames: [String])

    /// The geometry type.
    final public var geometryType: ArcGIS.Geometry.Type?

    /// The object ID field names.
    final public var objectIDFieldNames: [String] { get }

    /// The spatial reference.
    final public var spatialReference: ArcGIS.SpatialReference?

    /// The SQL query.
    final public var sqlQuery: String { get }

    /// The workspace ID.
    final public var workspaceID: String { get }
}

/// A key in a table results dictionary.
public typealias TableResultKey = ArcGIS.FeatureTableKey

/// Table sublayer source is a table, feature class, or raster that resides in a registered workspace (either a folder or geodatabase).
///
/// In the case of a geodatabase, if versioned, use geodatabaseVersion property to switch to an alternate geodatabase version. If version is empty or missing, the registered geodatabase version will be used.
/// - Note: See Also: ``TableJoinSublayerSource``, ``TableQuerySublayerSource``, ``RasterSublayerSource``, ``MapSublayerSource``, `TableSublayerSource.Type`
/// - Since: 200.1
final public class TableSublayerSource : ArcGIS.SublayerSource {

    /// Create a table sublayer source from a workspace ID and a data source name.
    /// - Parameters:
    ///   - workspaceID: The workspace id.
    ///   - dataSourceName: The data source name.
    /// - Note: See Also: ``SublayerSource``, ``ArcGISMapImageSublayer/source``
    public convenience init(workspaceID: String, dataSourceName: String)

    /// The data source name.
    final public var dataSourceName: String { get }

    /// The geodatabase version of the table sublayer source.
    final public var geodatabaseVersion: String

    /// The workspace id.
    final public var workspaceID: String { get }
}

/// A type that contains the details about a task.
public protocol TaskDetails {

    /// An identifier that uniquely identifies this task.
    var taskID: UUID { get }
}

/// Represents a pop-up element of type text that is displayed in a pop-up for a geoelement.
/// - Note: See Also: `PopupElement.Type`, ``PopupElement``
/// - Since: 200.1
final public class TextPopupElement : ArcGIS.PopupElement {

    /// Creates a new text pop-up element with the given text.
    /// - Parameter text: This is string value indicating the text to be displayed within the popupElement. If no `text` property is provided, the popupElement will display whatever is specified in the ``PopupDefinition/description`` property.
    public convenience init(text: String = "")

    /// The text to display in the pop-up.
    final public var text: String
}

/// Used to display text at points on a layer.
///
/// Text symbols are used to display text for graphics. The graphics can be based on any type of geometry - point, multipoint, polyline, or polygon.
/// - Note: See Also: ``MarkerSymbol``, ``Symbol``
/// - Since: 200.1
final public class TextSymbol : ArcGIS.MarkerSymbol {

    /// The list of possible font decorations.
    ///
    /// Enum to represent decoration of font supported by ArcGIS Server.
    public enum FontDecoration {

        /// A line is drawn through the text.
        case lineThrough

        /// The text is underlined.
        case underline

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TextSymbol.FontDecoration, b: ArcGIS.TextSymbol.FontDecoration) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of possible font styles.
    ///
    /// Enum to represent style of font supported by ArcGIS Server.
    public enum FontStyle {

        /// The text is italicized.
        case italic

        /// No alteration is made to the text.
        case normal

        /// The text is obliqued.
        case oblique

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TextSymbol.FontStyle, b: ArcGIS.TextSymbol.FontStyle) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of possible font weights.
    ///
    /// Enum to represent weight of font supported by ArcGIS Server.
    public enum FontWeight {

        /// The text is made bold.
        case bold

        /// No alteration is made to the text.
        case normal

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TextSymbol.FontWeight, b: ArcGIS.TextSymbol.FontWeight) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of possible horizontal alignments.
    ///
    /// Specifies how a text symbol should be horizontally aligned.
    public enum HorizontalAlignment {

        /// The text is center aligned.
        case center

        /// The text is justified.
        case justify

        /// The text is left aligned.
        case left

        /// The text is right aligned.
        case right

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TextSymbol.HorizontalAlignment, b: ArcGIS.TextSymbol.HorizontalAlignment) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The list of possible vertical alignments.
    ///
    /// Specifies how a text symbol should be vertically aligned.
    public enum VerticalAlignment {

        /// Baseline alignment.
        case baseline

        /// The text is bottom aligned.
        case bottom

        /// The text is middle aligned.
        case middle

        /// The text is top aligned.
        case top

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TextSymbol.VerticalAlignment, b: ArcGIS.TextSymbol.VerticalAlignment) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a text symbol object with some initial values.
    /// - Parameters:
    ///   - text: The text to be displayed for the associated graphic.
    ///   - color: The color of the text symbol.
    ///   - size: The size of the text symbol.
    ///   - horizontalAlignment: The horizontal alignment of the text.
    ///   - verticalAlignment: The vertical alignment of the text.
    public convenience init(text: String = "", color: UIColor = .black, size: CGFloat = 8, horizontalAlignment: ArcGIS.TextSymbol.HorizontalAlignment = .center, verticalAlignment: ArcGIS.TextSymbol.VerticalAlignment = .middle)

    /// The color for the text symbol background.
    final public var backgroundColor: UIColor

    /// The color for the text symbol.
    final public var color: UIColor

    /// The type of font decoration for the text symbol.
    final public var fontDecoration: ArcGIS.TextSymbol.FontDecoration?

    /// The font family of the text symbol.
    final public var fontFamily: String

    /// The font style of the text symbol.
    final public var fontStyle: ArcGIS.TextSymbol.FontStyle

    /// The font weight of the text symbol.
    final public var fontWeight: ArcGIS.TextSymbol.FontWeight

    /// The color for the halo around the text symbol.
    final public var haloColor: UIColor?

    /// The size of the halo around the text symbol, in DIPs.
    final public var haloWidth: CGFloat

    /// The horizontal alignment of the text symbol.
    final public var horizontalAlignment: ArcGIS.TextSymbol.HorizontalAlignment

    /// If kerning needs to be enabled. It is disabled by default.
    ///
    /// Determines whether to adjust the spacing between characters in the text string.
    final public var kerningIsEnabled: Bool

    /// The color for the text symbol outline.
    final public var outlineColor: UIColor?

    /// The width of the text symbol outline, in DIPs.
    final public var outlineWidth: CGFloat

    /// The font size of the text symbol.
    final public var size: CGFloat

    /// The text of the text symbol.
    final public var text: String

    /// The vertical alignment of the text symbol.
    final public var verticalAlignment: ArcGIS.TextSymbol.VerticalAlignment
}

extension TextSymbol.FontDecoration : Equatable {
}

extension TextSymbol.FontDecoration : Hashable {
}

extension TextSymbol.FontStyle : Equatable {
}

extension TextSymbol.FontStyle : Hashable {
}

extension TextSymbol.FontWeight : Equatable {
}

extension TextSymbol.FontWeight : Hashable {
}

extension TextSymbol.HorizontalAlignment : Equatable {
}

extension TextSymbol.HorizontalAlignment : Hashable {
}

extension TextSymbol.VerticalAlignment : Equatable {
}

extension TextSymbol.VerticalAlignment : Hashable {
}

/// A local cache of pre-rendered map tiles that can be used to create a layer.
///
/// A tile cache stores a collection of images at various scales. A client can request the tiles needed
/// to display a particular map extent. You can use ``ExportTileCacheTask`` to generate and download tiles
/// from a service, creating a tile package (.tpk/.tpkx). Alternatively, you can use ArcGIS Pro
/// to create a map tile package and provision it to the device.
///
/// Functional characteristics
/// ArcGIS tiled layers do not support reprojection, query, select, identify, or editing.
///
/// Performance characteristics
/// Tiles are generated when the cache is created. Requests for tiles are made on multiple threads
/// and handled asynchronously. The size of each returned tile increases as the resolution or
/// complexity of the image in the tile increases. For example, high-resolution imagery tiles can
/// be larger files than topographic mapping for the same area and map extent.
///
/// Local tile caches are ideal for providing basemaps, or for infrequent changes to contextual layers when network
/// access is limited or non-existent. Use ``ExportTileCacheJob`` to create and download a local tile cache to a device.
/// Alternatively, the cache can be provisioned directly to local storage. The supported types of
/// cache file formats are:
/// - Tile package (.tpk, .tpkx) - a tile cache of data, packaged into one convenient, portable file, ideal for
/// offline sharing of complete tiled layers in a disconnected environment or via a portal.
/// - Compact Cache - a directory structure where groups of tiles are combined into larger .bundle files, preserving
/// performance and reducing copy times and the size on disk of the cache.
/// - Exploded Cache - a directory structure where map tiles are stored as individual files.
///
/// A tile cache is often used as a basemap, but can also be used to create an ``ArcGISTiledLayer`` that is added to
/// a map as an operational layer. An offline ``ArcGISTiledElevationSource`` can also be created from an appropriate
/// tile cache and added to the ``Scene/baseSurface`` of a ``Scene``.
/// - Note: See Also: ``ArcGISTiledLayer``
/// - Since: 200.1
final public class TileCache : ArcGIS.Loadable {

    /// The storage format of a tile cache.
    /// - Note: See Also: ``TileCache/storageFormat-swift.property``
    public enum StorageFormat {

        /// Compact storage format (.tpk).
        case compact

        /// Compact V2 storage format (.tpkx).
        ///
        /// For more details on the specification of a tpkx file, see https://github.com/Esri/tile-package-spec.
        case compactV2

        /// Exploded storage format.
        case exploded

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TileCache.StorageFormat, b: ArcGIS.TileCache.StorageFormat) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Create a tile cache from the specified tile cache path.
    ///
    /// Creates a tile cache from the given local path to a tile package (.tpk or .tpkx file), or directory
    /// containing a compact or exploded cache.
    /// - Parameter fileURL: The path to the tile cache.
    /// - Note: See Also: ``ArcGISTiledLayer``
    public convenience init(fileURL: URL)

    /// The path of the tile cache.
    ///
    /// For caches based on tile packages (.tpk or .tpkx files) this is the full path of the .tpk or .tpkx file; for caches based on
    /// compact or exploded caches this is the path of the directory containing the cache.
    ///
    /// This path can be empty when the tile cache is contained within a ``MobileMapPackage`` or
    /// ``MobileScenePackage``.
    /// - Note: See Also: ``init(fileURL:)``
    final public var fileURL: URL? { get }

    /// The full extent of the tile cache.
    final public var fullExtent: ArcGIS.Envelope? { get }

    /// The antialiasing flag of this tile cache.
    final public var isAntialiasing: Bool { get }

    /// The storage format of this tile cache.
    final public var storageFormat: ArcGIS.TileCache.StorageFormat? { get }

    /// The thumbnail image of this tile cache.
    final public var thumbnail: UIImage? { get }

    /// Information about the tiling scheme used by this tile cache.
    ///
    /// For example, the tiling scheme indicates the origin of the cached tiles, the levels of detail available, and
    /// the size of each tile.
    final public var tileInfo: ArcGIS.TileInfo? { get }

    /// Clones the ``TileCache``.
    /// - Returns: A new ``TileCache`` with the same values as the current ``TileCache``.
    final public func clone() -> Self

    /// Returns the tile data for the specified tile key.
    /// - Parameter tileKey: The tile key.
    /// - Returns: the raw untouched/unclipped data straight out of the tile cache for the specified tile key.
    final public func data(forKey tileKey: ArcGIS.TileKey) -> Data?

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension TileCache : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.TileCache, rhs: ArcGIS.TileCache) -> Bool
}

extension TileCache : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

extension TileCache.StorageFormat : Equatable {
}

extension TileCache.StorageFormat : Hashable {
}

/// The image formats supported by tiled layers.
/// - Since: 200.1
public enum TileImageFormat {

    /// PNG.
    case png

    /// 8-bit PNG.
    case png8

    /// 24-bit PNG.
    case png24

    /// 32-bit PNG.
    case png32

    /// JPEG.
    case jpg

    /// Mixed (JPEG in the center of the cache and PNG 32 on the edge of the cache).
    case mixed

    /// Limited Error Raster Compression.
    case lerc

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.TileImageFormat, b: ArcGIS.TileImageFormat) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension TileImageFormat : Equatable {
}

extension TileImageFormat : Hashable {
}

/// Represents the tiling scheme used by a cached map service.
///
/// For example, ArcGIS Server cached map service, Bing Maps, etc. The tiling
/// scheme contains information about how a map is broken up into tiles of
/// images and how a client can use these tiles to display a map.
/// - Since: 200.1
final public class TileInfo {

    /// Create tile information.
    /// - Parameters:
    ///   - dpi: The DPI of each tile.
    ///   - format: The format of each tile.
    ///   - levelsOfDetail: An `Array` of ``LevelOfDetail``. Contents of the `Array` are copied.
    ///   - origin: The origin of the tiles.
    ///   - spatialReference: The spatial reference of the tiles.
    ///   - tileHeight: Height of a tile, in pixels.
    ///   - tileWidth: Width of a tile, in pixels.
    /// - Precondition: `dpi > 0`
    /// - Precondition: `!levelsOfDetail.isEmpty`
    /// - Precondition: `origin.spatialReference != nil`
    /// - Precondition: `tileHeight > 0`
    /// - Precondition: `tileWidth > 0`
    public convenience init(dpi: Int, format: ArcGIS.TileImageFormat?, levelsOfDetail: [ArcGIS.LevelOfDetail], origin: ArcGIS.Point, spatialReference: ArcGIS.SpatialReference, tileHeight: Int, tileWidth: Int)

    /// The compression quality of the tile images. The compression quality controls how much loss the image will
    /// be subjected to by the compression algorithm. The values of the pixels of an image compressed with a higher
    /// compression quality will be closer to those of the original image. The valid range of compression quality values is
    /// from 0 to 100.
    final public var compressionQuality: Float { get }

    /// The DPI (dots per inch) of the tiles.
    final public var dpi: Int { get }

    /// The format of the tile images.
    ///
    /// If there's an error the return value is `nil`.
    final public var format: ArcGIS.TileImageFormat? { get }

    /// A list of LevelOfDetail instances. Each one has properties for its particular resolution and scale.
    ///
    /// An `Array` with ``LevelOfDetail``
    /// - Note: See Also: ``LevelOfDetail``, `Array`
    final public var levelsOfDetail: [ArcGIS.LevelOfDetail] { get }

    /// The origin of the tile info within the spatial reference.
    ///
    /// The origin is the upper left corner of the tiling scheme grid.
    final public var origin: ArcGIS.Point { get }

    /// The spatial reference for the tile info.
    final public var spatialReference: ArcGIS.SpatialReference { get }

    /// The height of each tile in pixels.
    final public var tileHeight: Int { get }

    /// The width of each tile in pixels.
    final public var tileWidth: Int { get }
}

/// An object that represents a tile key identified by a level, a column and a row.
/// - Since: 200.1
public struct TileKey : Hashable {

    /// The level of the tile key.
    public var level: Int

    /// The column of the tile key.
    public var column: Int

    /// The row of the tile key.
    public var row: Int

    /// Create a tile key from the specified level, column and row.
    /// - Parameters:
    ///   - level: The level of the tile key.
    ///   - column: The column of the tile key.
    ///   - row: The row of the tile key.
    /// - Note: See Also: ``ImageTiledLayer``
    /// - Precondition: `level >= 0`
    /// - Precondition: `column >= 0`
    /// - Precondition: `row >= 0`
    public init(level: Int, column: Int, row: Int)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.TileKey, b: ArcGIS.TileKey) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// A interface that can be implemented by layers that support time.
///
/// When time is enabled on a layer, data can be filtered/fetched based on a time-range.
///
/// This interface is implemented by time-aware layers such as ``ArcGISMapImageLayer``.
/// - Since: 200.1
public protocol TimeAware {

    /// The full time extent of the object.
    var fullTimeExtent: ArcGIS.TimeExtent? { get }

    /// A flag indicating whether the object supports filtering its contents by time values with the extent set on the owning `GeoView`.
    var supportsTimeFiltering: Bool { get }

    /// A flag indicating whether the object must use the time extent defined on the owning `GeoView` to filter its data.
    var timeFilteringIsEnabled: Bool { get set }

    /// The suggested time slider step size for this time aware object.
    ///
    /// Can be `nil` if no time interval is suggested for this time aware object.
    var timeInterval: ArcGIS.TimeValue? { get }

    /// The time offset applied to this object.
    /// The offset is subtracted from the time extent set on the owning `GeoView`.
    /// This allows for data from different periods of time to be compared.
    var timeOffset: ArcGIS.TimeValue? { get set }
}

/// Represents a span of time between a start time and end time.
///
/// To create a time extent which represents an instant in time set the start time and end time to the same time value.
/// The ``TimeExtent`` is returned in the meta-data for time-aware services and layers. It is often used to create
/// a time slider ranging from a start time to an end time.
/// - Note: See Also: ``LayerTimeInfo``, ``ServiceTimeInfo``, `GeoView.timeExtent`
/// - Since: 200.1
public struct TimeExtent {

    /// Creates a time extent with a time instant.
    /// - Parameter date: The time instant is both the start and end time of the extent.
    public init(date: Date?)

    /// Creates a time extent with the given start and end times.
    /// - Parameters:
    ///   - startDate: The start time.
    ///   - endDate: The end time.
    /// - Precondition: If specified, the start date must be less than or equal to the end date.
    public init(startDate: Date?, endDate: Date?)
}

extension TimeExtent {

    /// The end time of this time extent.
    public var endDate: Date? { get }

    /// The start time of this time extent.
    public var startDate: Date? { get }
}

extension TimeExtent : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.TimeExtent, rhs: ArcGIS.TimeExtent) -> Bool
}

/// Represents information about the reference units for time values.
/// See ``LayerTimeInfo/timeReference``
///
/// Includes information about the time zone and if
/// the time respects daylight savings which allows ArcGIS to integrate datasets that were recorded in different time zones.
/// - Since: 200.1
final public class TimeReference {

    /// Whether the time reference observes daylight savings.
    final public var respectsDaylightSavings: Bool { get }

    /// The time zone information associated with the time reference.
    final public var timeZone: TimeZone? { get }
}

extension TimeReference {

    /// The name of the time zone associated with the time reference.
    final public var timeZoneName: String { get }
}

/// Defines a time offset or interval for any time related classes.
/// - Since: 200.1
public struct TimeValue : Hashable {

    /// The units of time used in a service, layer or sublayer which support time based operations.
    ///
    /// This is used to determine what the unit of time measurement is.
    public enum Unit {

        /// Centuries.
        case centuries

        /// Days.
        case days

        /// Decades.
        case decades

        /// Hours.
        case hours

        /// Milliseconds.
        case milliseconds

        /// Minutes.
        case minutes

        /// Months.
        case months

        /// Seconds.
        case seconds

        /// Weeks.
        case weeks

        /// Years.
        case years

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TimeValue.Unit, b: ArcGIS.TimeValue.Unit) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The length of the time value in the ``TimeValue``'s unit.
    public var duration: Double

    /// The unit of the time value.
    public var unit: ArcGIS.TimeValue.Unit?

    /// Creates a new time value object.
    /// - Parameters:
    ///   - duration: The duration of the time offset/interval.
    ///   - unit: The unit of the time offset/interval.
    public init(duration: Double, unit: ArcGIS.TimeValue.Unit?)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.TimeValue, b: ArcGIS.TimeValue) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension TimeValue.Unit : Equatable {
}

extension TimeValue.Unit : Hashable {
}

/// A credential used to access token-secured ArcGIS resources.
/// - Since: 200.1
final public class TokenCredential : ArcGIS.ArcGISCredential {

    /// The length of time a token credential remains valid. Represented in minutes. If not explicitly set,
    /// the server default is used.
    ///
    /// This will return `nil` if the value was `<= 0` while creating credential.
    final public var tokenExpirationMinutes: Int? { get }

    /// Returns an instance of ``TokenInfo`` generated by this credential.
    ///
    /// If the token has expired, this method regenerates the access token. Token expiration is based on the
    /// ``tokenExpirationMinutes``.
    final public var tokenInfo: ArcGIS.TokenInfo { get async throws }

    /// Creates a ``TokenCredential`` with information needed to access an ArcGIS resource.
    /// - Parameters:
    ///   - url: The URL of the token-secured resource.
    ///   - username: The username used to access the secured resource or retrieve a token.
    ///   - password: The password used to access the secured resource or retrieve a token.
    ///   - tokenExpirationMinutes: The duration the token will remain valid, represented in minutes. The value must be greater than 0, otherwise the server default is used.
    /// - Returns: Returns a ``TokenCredential``.
    final public class func credential(for url: URL, username: String, password: String, tokenExpirationMinutes: Int? = nil) async throws -> ArcGIS.TokenCredential

    /// Creates a ``TokenCredential`` with information needed to access an ArcGIS resource.
    /// - Parameters:
    ///   - challenge: An ``ArcGISAuthenticationChallenge`` object from which to construct the ``TokenCredential``.
    ///   - username: The username used to access the secured resource or retrieve a token.
    ///   - password: The password used to access the secured resource or retrieve a token.
    ///   - tokenExpirationMinutes: The duration the token will remain valid, represented in minutes. The value must be greater than 0, otherwise the server default is used.
    /// - Returns: Returns a ``TokenCredential``.
    final public class func credential(for challenge: ArcGIS.ArcGISAuthenticationChallenge, username: String, password: String, tokenExpirationMinutes: Int? = nil) async throws -> ArcGIS.TokenCredential

    /// Creates a ``TokenCredential`` with information needed to access an ArcGIS resource.
    /// - Parameters:
    ///   - url: The URL of the token secured resource.
    ///   - username: The username used to access the secured resource or retrieve a token.
    ///   - tokenExpirationMinutes: The duration the token will remain valid, represented in minutes. The value must be greater than 0, otherwise the server default is used.
    /// - Returns: Returns a ``TokenCredential``.
    final public class func credential(forNetworkSecured url: URL, username: String, tokenExpirationMinutes: Int? = nil) async throws -> ArcGIS.TokenCredential
}

/// The access token information that can be used by clients in exchange for user credentials. The access
/// token represents the authenticated user for a certain amount of time to access API functionality.
/// - Since: 200.1
final public class TokenInfo {

    /// Creates an instance of token info from given parameters.
    /// - Parameters:
    ///   - accessToken: The access token string.
    ///   - expirationDate: The token expiration date.
    ///   - isSSLRequired: A Boolean value that indicates whether the token must be passed over HTTPS.
    public convenience init?(accessToken: String, expirationDate: Date, isSSLRequired: Bool)

    /// The access token string.
    final public var accessToken: String { get }

    /// The token expiration date.
    final public var expirationDate: Date { get }

    /// A Boolean value that indicates whether the token must be passed over HTTPS.
    final public var isSSLRequired: Bool { get }
}

extension TokenInfo : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.TokenInfo, rhs: ArcGIS.TokenInfo) -> Bool
}

extension TokenInfo : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// Controls the display of tracks for a ``DynamicEntityLayer``.
///
/// Track display properties allow you to control the display of dynamic entity observations by setting a maximum number
/// of observations to show, displaying a line that connects them (track line), and applying renderers to the previous
/// observations and/or track line.
/// - Since: 200.1
final public class TrackDisplayProperties {

    /// The maximum time (in seconds) a previous observation displays in the track.
    /// Previous observations older than the specified maximum duration are not displayed.
    ///
    /// The default value is 0.0 which means the maximum duration is disabled and there is no age expiration applied to
    /// observations.
    ///
    /// Setting maximum duration to anything below 1.0 defaults to 1.0.
    final public var maximumDuration: TimeInterval

    /// The maximum number of observations displayed per track (this includes latest and previous observations).
    ///
    /// The default value is 5.
    final public var maximumObservations: Int

    /// The ``Renderer`` to display the previous observations.
    final public var previousObservationRenderer: ArcGIS.Renderer?

    /// A flag indicating whether to show previous observations.
    ///
    /// This flag only affects previous observations, the latest observation of the track is always displayed.
    final public var showsPreviousObservations: Bool

    /// A flag indicating whether to show a line that connects observations with the same track ID.
    final public var showsTrackLine: Bool

    /// The ``Renderer`` to display the track lines that connect observations.
    ///
    /// Only ``SimpleRenderer`` types are supported since the track line has no attributes to support other renderer types.
    final public var trackLineRenderer: ArcGIS.Renderer?
}

/// Defines tracking distance
///
/// Tracking distance contains two types of distances - raw and display.
/// Raw distance is always in meters (fixed units).
/// Display distance is in ``displayTextUnits`` (``LinearUnit``).
/// - Since: 200.1
final public class TrackingDistance {

    /// Formatted and rounded distance, ready for displaying.
    ///
    /// Use this property to have consistent distances/units with voice guidances.
    /// The distance is in ``displayTextUnits`` (``LinearUnit``).
    ///
    /// The following rules are used for rounding and formatting:
    /// IMPERIAL
    /// * 0 -> 50' => Round to increments of 10' (e.g. "10", "20", "30", "40")
    /// * 50' -> 0.1 mi (528') => Round to increments of 50' (e.g. "50", "100", "150", etc.)
    /// * 0.1 -> 1.0 mi => Round to decimal mile (e.g "0.1", "0.2", "0.3", etc.)
    /// * 1.0 mi -> 10 mi => Round to half mile (e.g. "1.0", "1.5", "2.0", etc.)
    /// * 10+ mi => Round to mile (e.g. "10", "11", "12", etc.)
    /// METRIC
    /// * 0 -> 50 m => Round to increments of 10 m (e.g. "10", "20", "30", "40")
    /// * 50 m -> 500 m => Round to increments of 50 m (e.g. "50", "100", "150", etc.)
    /// * 500 m -> 10 km => Round to half km (e.g. "1.0", "1.5", "2.0", etc.)
    /// * 10+ km => Round to whole km (e.g. "10", "11", "12", etc.)
    /// - Note: See Also: ``VoiceGuidance``
    final public var displayText: String { get }

    /// The units used in the ``displayText`` which vary base on distance from maneuver/destination.
    final public var displayTextUnits: ArcGIS.LinearUnit { get }

    /// The distance in meters.
    ///
    /// The raw distance without rounding and formatting, in meters.
    final public var distance: Measurement<UnitLength> { get }
}

/// Defines tracking progress (passed and remaining geometries, remaining time and distance).
/// - Since: 200.1
final public class TrackingProgress {

    /// The distance still to be traversed.
    /// - Note: See Also: ``TrackingDistance``
    final public var remainingDistance: ArcGIS.TrackingDistance { get }

    /// The polyline geometry still to be traversed.
    final public var remainingGeometry: ArcGIS.Polyline { get }

    /// The time to traverse remaining geometry/distance.
    final public var remainingTime: TimeInterval { get }

    /// The polyline geometry already traversed.
    final public var traversedGeometry: ArcGIS.Polyline { get }
}

/// Defines route tracking current status data
///
/// Contains information about route tracker status.
/// Subscribe to `RouteTrackerTrackingStatusChangedEvent` for getting all updates in the event model.
/// - Since: 200.1
final public class TrackingStatus {

    /// The list of route tracking destination statuses.
    ///
    /// Used to determine how close the current location is to the next destination.
    public enum DestinationStatus {

        /// Not reached destination status.
        ///
        /// Default value
        case notReached

        /// Approaching destination status.
        ///
        /// Value returned when provided GPS location gets within 500 meters of the next destination.
        /// This status can be used to manually call `RouteTracker.switchToNextDestination()` if a
        /// vehicle can not get closer to a destination to trigger a status of ``TrackingStatus/DestinationStatus-swift.enum/reached``.
        case approaching

        /// Reached destination status.
        ///
        /// Value returned when provided GPS location gets within 7-40 meters, along the route, of the next destination.
        /// Once within 40 meters of the next destination the vehicle is tracked to determine if it is getting closer or
        /// moving away from the next destination. If the vehicle continues to get closer this value will be returned
        /// when within 7 meter of the next destination, if the vehicle starts to move away this value is returned.
        /// This status can be used to automatically call `RouteTracker.switchToNextDestination()`.
        case reached

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TrackingStatus.DestinationStatus, b: ArcGIS.TrackingStatus.DestinationStatus) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The current maneuver index.
    ///
    /// The index of current maneuver in ``Route/directionManeuvers``.
    final public var currentManeuverIndex: Int { get }

    /// The tracking progress until next destination (``Stop``).
    /// - Note: See Also: ``TrackingProgress``
    final public var destinationProgress: ArcGIS.TrackingProgress { get }

    /// The destination status.
    /// - Note: See Also: ``DestinationStatus-swift.enum``
    final public var destinationStatus: ArcGIS.TrackingStatus.DestinationStatus { get }

    /// The display location
    ///
    /// If current location isOnRoute = `true` then this will be an adjusted location (snapped to route) and bearing (smoothed).
    /// If current location isOnRoute = `false` then this will be the passed in GPS location, but with an adjusted bearing (smoothed).
    /// This location should be used for displaying current position on a map.
    /// - Note: See Also: ``Location``
    final public var displayLocation: ArcGIS.Location { get }

    /// Returns `true` if the next ``Stop`` (or stops) are the final destination in the route.
    ///
    /// If there are coincident stops at the end the ``RouteTracker/skipsCoincidentStops`` value determines
    /// if they are treated as single destination or not.
    final public var isApproachingFinalDestination: Bool { get }

    /// Boolean indicating whether the route is currently being calculated.
    ///
    /// For getting event about route calculating start subscribe to `RouteTrackerRerouteStartedEvent`.
    /// - Note: See Also: `RouteTrackerRerouteStartedEvent`, `RouteTrackerRerouteCompletedEvent`
    final public var isCalculatingRoute: Bool { get }

    /// Boolean indicating whether or not the current location is on the route.
    final public var isOnRoute: Bool { get }

    /// The location on route
    ///
    /// Snapped to route location of last GPS location passed in to `RouteTracker.track(_:)`.
    /// If current status is isOnRoute = `true` this will be the same as the ``displayLocation``.
    /// If current status is isOnRoute = `false` this value is not updated and last location that was on
    /// the route will be returned.
    /// - Note: See Also: ``Location``
    final public var locationOnRoute: ArcGIS.Location { get }

    /// The tracking progress along current maneuver.
    /// - Note: See Also: ``TrackingProgress``
    final public var maneuverProgress: ArcGIS.TrackingProgress { get }

    /// The remaining destination count.
    ///
    /// The number of (routed) stops yet to be visited.  This value does not include waypoints,
    /// unlocated/unrouted locations.
    /// Calling `RouteTracker.switchToNextDestination()` will decrease value.
    /// The invalid value for remaining destination count is -1.
    /// - Note: See Also: `RouteTracker.switchToNextDestination()`
    final public var remainingDestinationCount: Int { get }

    /// The tracking progress along entire route.
    /// - Note: See Also: ``TrackingProgress``
    final public var routeProgress: ArcGIS.TrackingProgress { get }

    /// The route result presently being used by route tracker.
    ///
    /// If rerouting happened during tracking, this ``RouteResult`` can be different
    /// than the ``RouteResult`` originally set in the ``RouteTracker``.
    /// For getting new route result from callback subscribe to `RouteTrackerRerouteCompletedEvent`.
    /// - Note: See Also: ``RouteResult``, `RouteTrackerRerouteCompletedEvent`
    final public var routeResult: ArcGIS.RouteResult { get }

    /// The ``Route/stops`` index values relating to the upcoming destination/arrival.
    ///
    /// If there are coincident stops and the ``RouteTracker/skipsCoincidentStops`` = `true` this will return a list with
    /// multiple index values. When there are no coincident stops or the ``RouteTracker/skipsCoincidentStops`` = `false` this
    /// will return a list with just a single index value. This list can be used to relate a destination/arrival to the
    /// stops in the ``Route/stops`` array.
    final public var stopIndexesAtNextDestination: [Int] { get }
}

extension TrackingStatus.DestinationStatus : Equatable {
}

extension TrackingStatus.DestinationStatus : Hashable {
}

/// Allows discovery and management of the transformations used to convert coordinates between different datums.
///
/// The transformation catalog class provides a mechanism for discovering available ``DatumTransformation`` objects.
/// You can retrieve the default transformation used internally to convert coordinates, and find
/// other available transformations. An area of interest may be taken into account.
///
/// This class also allows you to set the location where Projection Engine data files needed for some
/// transformations are found on local storage. The ``projectionEngineDirectoryURL`` property
/// must be set before using any geometry classes.
///
/// The default transformation used when reprojecting geometries is the most suitable available transformation
/// across the area covered by the input and output spatial references. You can sometimes get a more suitable
/// transformation for work within a smaller area by specifying the extent of your specific work area, using
/// `TransformationCatalog.defaultTransformation(from:to:areaOfInterest:ignoreVertical:)`.
/// - Since: 200.1
public enum TransformationCatalog {

    /// Returns the best usable transformation used to transform between the input and output spatial references,
    /// taking into account the area of interest, if specified. Optionally disregards any vertical transformations.
    ///
    /// Use this method to determine whether or not any vertical coordinate systems set on the
    /// spatial reference parameters should be accounted for in the returned transformation.
    /// This method can be used to replicate the former (prior to version 100.9.0) behavior of
    /// the `TransformationCatalog.defaultTransformation(from:to:areaOfInterest:ignoreVertical:)` and
    /// `TransformationCatalog.defaultTransformation(from:to:areaOfInterest:ignoreVertical:)`
    /// methods:
    /// * Calling this method with 'ignoreVertical = `false`' is equivalent to calling
    /// `TransformationCatalog.defaultTransformation(from:to:areaOfInterest:ignoreVertical:)`
    /// * Calling this method with 'ignoreVertical = `true`' is equivalent to calling
    /// `TransformationCatalog.defaultTransformation(from:to:areaOfInterest:ignoreVertical:)`
    /// in releases prior to 100.9.0
    /// - Parameters:
    ///   - inputSpatialReference: The spatial reference to use as the input.
    ///   - outputSpatialReference: The spatial reference to use as the output.
    ///   - areaOfInterest: The bounding box of coordinates to be transformed, or `nil` to consider the entire world extent.
    ///   - ignoreVertical: `true` if ``TransformationCatalog`` should ignore any vertical coordinate system set on the  inputSpatialReference or outputSpatialReference, and only consider horizontal (geographic)  transformations; `false` otherwise.
    /// - Returns: A ``DatumTransformation`` instance that represents the best choice given the parameters. Always returns a
    /// usable transformation where ``DatumTransformation/isMissingProjectionEngineFiles`` is `false`. The specific
    /// type returned depends on the given value of the ignoreVertical parameter.
    ///
    /// Returns `nil` if no transformation is required for the given input parameters, or if no usable transformation
    /// is available.
    public static func defaultTransformation(from inputSpatialReference: ArcGIS.SpatialReference, to outputSpatialReference: ArcGIS.SpatialReference, areaOfInterest: ArcGIS.Envelope? = nil, ignoreVertical: Bool = false) -> ArcGIS.DatumTransformation?

    /// Returns a collection of transformations suitable for projecting between the input and output spatial
    /// references, taking into account the area of interest, if specified. Optionally checks for suitable
    /// vertical transformations.
    ///
    /// The collection is ordered in descending order by suitability, with the most suitable being first in the
    /// list. The given area of interest can affect the number and order of transformations returned.
    ///
    /// A geographic transformation is not needed when input and output spatial references
    /// have the same underlying geographic coordinate system, in which case an empty list
    /// is returned. A vertical transformation is not needed if both datums (for ellipsoidal
    /// heights) or vertical datums (for gravity-related heights) are the same. If neither
    /// type of transformation is needed, an empty collection is returned.
    ///
    /// Use this method to determine whether or not any vertical coordinate systems set on the
    /// spatial reference parameters should be accounted for in the returned list of
    /// transformations. This method can be used to replicate the former (prior to version
    /// 100.9.0) behavior of the
    /// `TransformationCatalog.transformations(from:to:areaOfInterest:ignoreVertical:)`
    /// and
    /// `TransformationCatalog.transformations(from:to:areaOfInterest:ignoreVertical:)`
    /// methods:
    /// * Calling this method with 'ignoreVertical = `false`' is equivalent to calling
    /// `TransformationCatalog.transformations(from:to:areaOfInterest:ignoreVertical:)`
    /// * Calling this method with 'ignoreVertical = `true`' is equivalent to calling
    /// `TransformationCatalog.transformations(from:to:areaOfInterest:ignoreVertical:)`
    /// in releases prior to 100.9.0
    ///
    /// Some transformations require a supporting Projection Engine (PE) dataset to function correctly. If this API
    /// cannot locate these datasets, the transformation is not usable, and
    /// ``DatumTransformation/isMissingProjectionEngineFiles`` is `true`. The list may include transformations like
    /// this. To use such transformations, ensure ``projectionEngineDirectoryURL`` is set
    /// correctly, and that the required dataset is available within that location. Use
    /// ``GeographicTransformationStep/projectionEngineFilenames`` and
    /// ``HorizontalVerticalTransformationStep/projectionEngineFilenames`` to determine the dataset required for a
    /// specific transformation instance.
    /// - Parameters:
    ///   - inputSpatialReference: The spatial reference to use as the input.
    ///   - outputSpatialReference: The spatial reference to use as the output.
    ///   - areaOfInterest: The bounding box of coordinates to be transformed, or `nil` to consider the entire world extent.
    ///   - ignoreVertical: `true` if ``TransformationCatalog`` should ignore any vertical coordinate systems set on the  inputSpatialReference or outputSpatialReference, and only consider horizontal (geographic)  transformations; `false` otherwise.
    /// - Returns: A collection of ``DatumTransformation`` objects suitable for the given parameters, ordered by suitability,
    /// or an empty collection if no transformation is required.
    public static func transformations(from inputSpatialReference: ArcGIS.SpatialReference, to outputSpatialReference: ArcGIS.SpatialReference, areaOfInterest: ArcGIS.Envelope? = nil, ignoreVertical: Bool = false) -> [ArcGIS.DatumTransformation]
}

extension TransformationCatalog {

    /// The URL to the directory of the Projection Engine files used by the
    /// transformation catalog.
    public static var projectionEngineDirectoryURL: URL? { get }

    /// Sets the URL to the directory of the Projection Engine files to be used
    /// by the transformation catalog.
    /// - Remark: This method should only be called immediately upon process
    /// startup before any other ArcGIS Runtime method calls.
    /// - Parameter url: The path to the directory.
    /// - Throws: An error is thrown if the URL is invalid.
    public static func setProjectionEngineDirectoryURL(_ url: URL) throws
}

/// A struct for holding a translation and quaternion array. This is used for camera movement while preventing gimbal lock.
/// - Since: 200.1
public struct TransformationMatrix {
}

extension TransformationMatrix {

    /// The identity transformation matrix.
    ///
    /// Subtracting a ``TransformationMatrix`` from an identity matrix is useful for getting the
    /// inverse of that transformation matrix, i.e., identity matrix - other matrix = inverse(other matrix).
    public static var identity: ArcGIS.TransformationMatrix { get }

    /// W quaternion.
    public var quaternionW: Double { get }

    /// X quaternion.
    public var quaternionX: Double { get }

    /// Y quaternion.
    public var quaternionY: Double { get }

    /// Z quaternion.
    public var quaternionZ: Double { get }

    /// X translation.
    public var translationX: Double { get }

    /// Y translation.
    public var translationY: Double { get }

    /// Z translation.
    public var translationZ: Double { get }
}

extension TransformationMatrix {

    /// Returns the result of adding the given transformation matrix to this transformation matrix.
    /// - Parameter other: The transformation matrix to be added onto this transformation matrix.
    /// - Returns: A new transformation matrix.
    public func adding(_ other: ArcGIS.TransformationMatrix) -> ArcGIS.TransformationMatrix

    /// Returns an instance with the given *x*, *y*, *z*, *w* quaternion normalized to be a unit vector and the given *x*, *y*, *z* translations.
    /// - Parameters:
    ///   - quaternionX: The x quaternion of the transformation matrix.
    ///   - quaternionY: The y quaternion of the transformation matrix.
    ///   - quaternionZ: The z quaternion of the transformation matrix.
    ///   - quaternionW: The w quaternion of the transformation matrix.
    ///   - translationX: The x position of the transformation matrix.
    ///   - translationY: The y position of the transformation matrix.
    ///   - translationZ: The z position of the transformation matrix.
    /// - Returns: A ``TransformationMatrix``.
    public static func normalized(quaternionX: Double, quaternionY: Double, quaternionZ: Double, quaternionW: Double, translationX: Double, translationY: Double, translationZ: Double) -> ArcGIS.TransformationMatrix

    /// Returns the result of subtracting the given transformation matrix from this transformation matrix.
    /// - Parameter other: The transformation matrix to be subtracted from this transformation matrix.
    /// - Returns: A new transformation matrix.
    public func subtracting(_ other: ArcGIS.TransformationMatrix) -> ArcGIS.TransformationMatrix
}

/// Support camera navigation by using ``TransformationMatrix``.
///
/// Transformation Matrix camera controller provides navigation by using
/// ``TransformationMatrix`` to control the camera's location and rotation.
/// You need to pass this object to all ``TransformationMatrixCameraController`` functions.
/// This can be used with transformation matrices produced by AR APIs like ARKit and ARCore.
/// - Note: See Also: ``OrbitLocationCameraController``, ``GlobeCameraController``, ``OrbitGeoElementCameraController``
/// - Since: 200.1
final public class TransformationMatrixCameraController : ArcGIS.CameraController {

    /// Creates a ``TransformationMatrixCameraController`` object.
    ///
    /// When the controller is set on the scene view using `SceneView.cameraController`, the interaction mode
    /// will change for the active navigation model and be located at the origin camera's location
    /// and point along its rotation. The default camera has no rotation and is located at 0,0,15e6 meters.
    public convenience init()

    /// Creates a ``TransformationMatrixCameraController`` with a ``Camera`` to describe the original location.
    ///
    /// When the controller is set on the scene view using `SceneView.cameraController`, the interaction mode
    /// will change for the active navigation model and be located at the ``TransformationMatrix``'s location
    /// and point along its rotation.
    /// - Parameter originCamera: All following movements will be relative to the origin camera's location.
    public convenience init(originCamera: ArcGIS.Camera)

    /// The ``Camera`` that describes the original location. Setting a new ``TransformationMatrix``
    /// on the ``TransformationMatrixCameraController`` will move the camera relative to the
    /// origin camera's location and orientation.
    @ArcGIS.Streamed final public var originCamera: ArcGIS.Camera

    final public var $originCamera: AsyncStream<ArcGIS.Camera> { get }

    /// The ``TransformationMatrix`` describes the current ``Camera``'s location relative to the origin camera.
    final public var transformationMatrix: ArcGIS.TransformationMatrix

    /// Defaults to 1.0. This value will be multiplied into the ``TransformationMatrix`` property.
    /// Setting the value to 3 will cause position changes indicated by the transformation matrix
    /// property to be multiplied by 3. Note this does not affect ``Camera`` rotation.
    @ArcGIS.Streamed final public var translationFactor: Double

    final public var $translationFactor: AsyncStream<Double> { get }
}

extension TransformationMatrixCameraController {

    /// Determines the clipping distance in meters around the ``TransformationMatrixCameraController/originCamera``.
    /// When the value is set to `nil`, there is no enforced clipping distance and therefore no limiting of displayed data.
    /// Setting the value to `10.0` will only render data 10 meters around the ``TransformationMatrixCameraController/originCamera``.
    final public var clippingDistance: Double?
}

/// Transportation network dataset.
/// - Since: 200.1
final public class TransportationNetworkDataset : ArcGIS.GeodatabaseDataset {

    /// Alias of transportation network dataset.
    /// - Note: See Also: `String`
    final public var alias: String { get }

    /// The geodatabase.
    ///
    /// Instance of geodatabase.
    /// - Note: See Also: ``Geodatabase``
    final public var geodatabase: ArcGIS.Geodatabase? { get }

    /// The name of geodatabase dataset.
    ///
    /// The geodatabase dataset's name.
    /// - Note: See Also: `String`
    final public var name: String { get }
}

/// A travel direction type. Options for traveling to or from the facility.
/// The default is defined in the network layer.
/// - Since: 200.1
public enum TravelDirection {

    /// Travel from facility.
    case fromFacility

    /// Travel to facility.
    case toFacility

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.TravelDirection, b: ArcGIS.TravelDirection) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension TravelDirection : Equatable {
}

extension TravelDirection : Hashable {
}

/// An object that represents a travel mode.
///
/// Travel modes on a network dataset define how a pedestrian, car, truck, or other medium of transportation moves
/// through the network. A travel mode consists of a collection of network dataset settings that define actions
/// that are allowed on the network and how the actions can be performed. Selecting a predefined travel mode allows
/// you to efficiently and consistently set a number of properties that are appropriate for the mode of travel
/// you intend to model.
/// Since a travel mode is a collection of properties that work together it is recommended to have a full understanding
/// of how these properties interact before altering them on the fly for a particular analysis. A best practice would be
/// to create a new travel mode in the network dataset in ArcGIS Desktop or ArcGIS Pro that is fully tested to ensure
/// that is returns the required solution.
/// - Since: 200.1
final public class TravelMode {

    /// Type of backtracking allowed when querying for adjacencies in a network view.
    public enum UTurnPolicy {

        /// Not allow backtracking.
        case notAllowed

        /// Allow backtracking at dead ends.
        case allowedAtDeadEnds

        /// Allow backtracking at intersections.
        case allowedAtIntersections

        /// Allow backtracking ad dead ends and intersections.
        case allowedAtDeadEndsAndIntersections

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.TravelMode.UTurnPolicy, b: ArcGIS.TravelMode.UTurnPolicy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a travel mode.
    ///
    /// Creates a travel mode object.
    public convenience init()

    /// Attribute parameter values.
    ///
    /// The attribute parameter values e.g. Vehicle Weight, Vehicle Height, etc. Attribute parameter values are useful
    /// for customizing individual restrictions ("Don't travel on a roads weight limits below 6 tons").
    /// - Note: See Also: `Dictionary`
    final public var attributeParameterValues: [ArcGIS.AttributeParameterValue] { get }

    /// Adds a sequence of `AttributeParameterValue` values to the end of the `attributeParameterValues` property.
    /// - Parameter newAttributeParameterValues: The new `AttributeParameterValue` values to append.
    final public func addAttributeParameterValues<S>(_ newAttributeParameterValues: S) where S : Sequence, S.Element == ArcGIS.AttributeParameterValue

    /// Adds an `AttributeParameterValue` value to the end of the `attributeParameterValues` property.
    /// - Parameter newAttributeParameterValue: The new `AttributeParameterValue` value to append.
    final public func addAttributeParameterValue(_ newAttributeParameterValue: ArcGIS.AttributeParameterValue)

    /// Inserts a collection of `AttributeParameterValue` values into the `attributeParameterValues` property at the specified position.
    /// - Parameters:
    ///   - newAttributeParameterValues: The new `AttributeParameterValue` values to insert.
    ///   - index: The position at which to insert the new `AttributeParameterValue` values.
    final public func insertAttributeParameterValues<C>(_ newAttributeParameterValues: C, at index: Int) where C : Collection, C.Element == ArcGIS.AttributeParameterValue

    /// Inserts an `AttributeParameterValue` value into the `attributeParameterValues` property at the specified position.
    /// - Parameters:
    ///   - newAttributeParameterValue: The new `AttributeParameterValue` value to insert.
    ///   - index: The position at which to insert the new `AttributeParameterValue` value.
    final public func insertAttributeParameterValue(_ newAttributeParameterValue: ArcGIS.AttributeParameterValue, at index: Int)

    /// Removes all values from the `attributeParameterValues` property.
    final public func removeAllAttributeParameterValues()

    /// Removes a sequence of `AttributeParameterValue` values from the `attributeParameterValues` property.
    /// - Parameter attributeParameterValues: The `AttributeParameterValue` values to remove.
    final public func removeAttributeParameterValues<S>(_ attributeParameterValues: S) where S : Sequence, S.Element == ArcGIS.AttributeParameterValue

    /// Removes an `AttributeParameterValue` value from the `attributeParameterValues` property.
    /// - Parameter attributeParameterValue: The `AttributeParameterValue` value to remove.
    final public func removeAttributeParameterValue(_ attributeParameterValue: ArcGIS.AttributeParameterValue)

    /// Travel mode's description.
    ///
    /// A short text description of the travel mode.
    /// - Note: See Also: `String`
    final public var description: String

    /// Distance attribute name.
    ///
    /// Specifies the distance-based cost attribute for reporting directions, total length.
    /// - Note: See Also: `String`
    final public var distanceAttributeName: String

    /// Impedance attribute name.
    ///
    /// The impedance attribute (i.e. the cost attribute to be minimized on solve). For example: "TravelTime" or "Distance".
    /// - Note: See Also: `String`
    final public var impedanceAttributeName: String

    /// Travel mode's name.
    ///
    /// The unique name of the travel mode.
    /// - Note: See Also: `String`
    final public var name: String

    /// Output geometry precision in meters.
    ///
    /// Precision is useful for reducing the response size while sacrificing
    /// route shape or directions geometry quality. This parameter makes sense only for online services and doesn't affect local tasks.
    final public var outputGeometryPrecision: Double

    /// Restriction attribute names.
    ///
    /// Indicates the restriction attributes that are respected during solve.
    /// - Note: See Also: `Array`, `String`
    final public var restrictionAttributeNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `restrictionAttributeNames` property.
    /// - Parameter newRestrictionAttributeNames: The new `String` values to append.
    final public func addRestrictionAttributeNames<S>(_ newRestrictionAttributeNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `restrictionAttributeNames` property.
    /// - Parameter newRestrictionAttributeName: The new `String` value to append.
    final public func addRestrictionAttributeName(_ newRestrictionAttributeName: String)

    /// Inserts a collection of `String` values into the `restrictionAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newRestrictionAttributeNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertRestrictionAttributeNames<C>(_ newRestrictionAttributeNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `restrictionAttributeNames` property at the specified position.
    /// - Parameters:
    ///   - newRestrictionAttributeName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertRestrictionAttributeName(_ newRestrictionAttributeName: String, at index: Int)

    /// Removes all values from the `restrictionAttributeNames` property.
    final public func removeAllRestrictionAttributeNames()

    /// Removes a sequence of `String` values from the `restrictionAttributeNames` property.
    /// - Parameter restrictionAttributeNames: The `String` values to remove.
    final public func removeRestrictionAttributeNames<S>(_ restrictionAttributeNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `restrictionAttributeNames` property.
    /// - Parameter restrictionAttributeName: The `String` value to remove.
    final public func removeRestrictionAttributeName(_ restrictionAttributeName: String)

    /// Time attribute name.
    ///
    /// Specifies the time-based cost attribute for reporting directions, total time, travel time and wait or late times.
    /// - Note: See Also: `String`
    final public var timeAttributeName: String

    /// Travel mode's type.
    ///
    /// Indicates the category of travel or vehicle represented by the travel mode.
    /// - Note: See Also: `String`
    final public var type: String

    /// Uturn policy.
    ///
    /// Indicates where the travel mode is allowed to make U-turns.
    /// Returns the enumeration value for the u-turn policy e.g. no u-turns, u-turns at stops, etc.
    /// - Note: See Also: ``UTurnPolicy-swift.enum``
    final public var uTurnPolicy: ArcGIS.TravelMode.UTurnPolicy

    /// Use hierarchy.
    ///
    /// Indicates whether the travel mode uses the network hierarchy in an analysis.
    /// Sets whether or not to solve using a hierarchy. A hierarchical solve tends to prefer higher-order streets such a
    /// freeways.
    final public var usesHierarchy: Bool
}

extension TravelMode.UTurnPolicy : Equatable {
}

extension TravelMode.UTurnPolicy : Hashable {
}

/// A class that represents the display of the United States
/// National Grid (USNG) on the map view.
///
/// The United States National Grid (USNG) is a point reference system
/// of grid references commonly used in the United States. It provides a
/// nationally consistent language of location in a user friendly
/// format. It is similar in design to the national grid reference
/// systems used throughout other nations. The USNG was developed by the
/// Federal Geographic Data Committee.
///
/// To display the USNG grid, create a USNGGrid and set it as the grid
/// property within the MapView.
///
/// USNGGrid inherits from Grid and adds a property for the label unit
/// to use.
/// - Note: See Also: `MapView.grid`
/// - Since: 200.1
final public class USNGGrid : ArcGIS.Grid {

    /// The unit to use when labeling an ``USNGGrid``.
    /// - Note: See Also: ``USNGGrid``
    public enum LabelUnit {

        /// Label the grid in either Kilometers or Meters, depending on the
        /// scale of the map view.
        case kilometersMeters

        /// Label the grid in Meters.
        case meters

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.USNGGrid.LabelUnit, b: ArcGIS.USNGGrid.LabelUnit) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Constructs an USNG grid for displaying on a map view.
    ///
    /// The grid is supported in spatial references which are continuously
    /// pannable or some polar spatial references.
    /// You can check the ``SpatialReference/isPannable`` property is `true` on your
    /// spatial reference.  Examples of continuously pannable spatial
    /// references include WGS84 (WKID 4326) and Web Mercator Auxiliary
    /// Sphere (WKID 102113, 102100, or 3857).
    ///
    /// The following polar spatial references are also supported:
    /// * North pole Azimuthal Equidistant (WKID 102016)
    /// * North pole gnomic (WKID 102034)
    /// * North pole Lambert equal area (WKID 102017)
    /// * North pole orthographic (WKID 102035)
    /// * North pole stereographic (WKID 102018)
    /// * NSIDE EASE North (WKID 3408)
    /// * NSIDC Sea Ice polar stereographic north (WKID 3411)
    /// * WGS 1984 NSIDC Sea Ice Polar Stereographic North (WKID 3413)
    /// * UPS North (WKID 32661)
    /// * South pole Azimuthal Equidistant (WKID 102019)
    /// * South pole gnomic (WKID 102036)
    /// * South pole Lambert equal area (WKID 102020)
    /// * South pole orthographic (WKID 102037)
    /// * South pole stereographic (WKID 102021)
    /// * NSIDE EASE South (WKID 3409)
    /// * NSIDC Sea Ice polar stereographic South (WKID 3412)
    /// * UPS South (WKID 32761)
    /// *- WGS1984 Antarctic polar stereographic (WKID 3031)
    public convenience init()

    /// The units used for labeling the grid.
    final public var labelUnit: ArcGIS.USNGGrid.LabelUnit
}

extension USNGGrid.LabelUnit : Equatable {
}

extension USNGGrid.LabelUnit : Hashable {
}

/// A class that represents the display of the Universal
/// Transverse Mercator (UTM) coordinate system grid on the map view.
///
/// The Universal Transverse Mercator (UTM) conformal projection uses a
/// 2-dimensional Cartesian coordinate system to give locations on the
/// surface of the Earth. Like the traditional method of latitude and
/// longitude, it is a horizontal position representation, i.e. it is
/// used to identify locations on the Earth independently of vertical
/// position. However, it differs from that method in several respects.
///
/// The UTM system is not a single map projection. The system instead
/// divides the Earth into sixty zones, each being a six-degree band of
/// longitude, and uses a secant transverse Mercator projection in each
/// zone.
///
/// To display the UTM grid, create a UTMGrid and set it as the grid
/// property within the MapView.
/// - Note: See Also: `MapView.grid`
/// - Since: 200.1
final public class UTMGrid : ArcGIS.Grid {

    /// Constructs a grid for displaying UTM zones on a map view.
    ///
    /// The grid is supported in spatial references which are continuously
    /// pannable or some polar spatial references.
    /// You can check the ``SpatialReference/isPannable`` property is `true` on your
    /// spatial reference.  Examples of continuously pannable spatial
    /// references include WGS84 (WKID 4326) and Web Mercator Auxiliary
    /// Sphere (WKID 102113, 102100, or 3857).
    ///
    /// The following polar spatial references are also supported:
    /// * North pole Azimuthal Equidistant (WKID 102016)
    /// * North pole gnomic (WKID 102034)
    /// * North pole Lambert equal area (WKID 102017)
    /// * North pole orthographic (WKID 102035)
    /// * North pole stereographic (WKID 102018)
    /// * NSIDE EASE North (WKID 3408)
    /// * NSIDC Sea Ice polar stereographic north (WKID 3411)
    /// * WGS 1984 NSIDC Sea Ice Polar Stereographic North (WKID 3413)
    /// * UPS North (WKID 32661)
    /// * South pole Azimuthal Equidistant (WKID 102019)
    /// * South pole gnomic (WKID 102036)
    /// * South pole Lambert equal area (WKID 102020)
    /// * South pole orthographic (WKID 102037)
    /// * South pole stereographic (WKID 102021)
    /// * NSIDE EASE South (WKID 3409)
    /// * NSIDC Sea Ice polar stereographic South (WKID 3412)
    /// * UPS South (WKID 32761)
    /// *- WGS1984 Antarctic polar stereographic (WKID 3031)
    public convenience init()
}

/// A unique value object.
/// - Since: 200.1
final public class UniqueValue : ArcGIS.JSONSerializable {

    /// Creates a new unique value (or unique combination of values) object with alternate symbols.
    ///
    /// A unique value can have alternate symbols to the primary symbol. Alternate symbols allow you to tailor the visualization of unique value at different scales by selecting different symbol for different scales.
    /// Alternate symbols are supported only when unique value's primary symbol and other symbols in alternate symbol list are of type ``MultilayerSymbol`` and have ``SymbolReferenceProperties`` defining valid min max scales at which the symbol becomes visible.
    /// Renderer will pick only one symbol at a given map scale. If primary symbol's scale range falls within the map's scale, primary symbol is used.
    /// If not, then symbols in alternate symbols list are iterated through and first symbol matching the current map scale is picked for rendering.
    /// A symbol becomes visible if the map scale is less than or equal to symbol's minimum scale and greater than symbol's maximum scale.
    /// For more information on Scale-based symbol classes and alternate symbols see the following documentation:
    /// https://pro.arcgis.com/en/pro-app/latest/help/mapping/layer-properties/scale-based-symbol-classes.htm
    /// - Parameters:
    ///   - description: A description of the unique value. "Parcels zoned for residential use", for example.
    ///   - label: A label for the unique value. "Residential", for example.
    ///   - symbol: A symbol used to represent elements with this unique value.
    ///   - values: An `Array` containing `Any` types that define a unique value or unique combination of values.
    ///   - alternateSymbols: The alternate symbols for the unique value. Only ``MultilayerSymbol`` are supported as alternates.
    public convenience init(description: String = "", label: String = "", symbol: ArcGIS.Symbol? = nil, values: [Any] = [], alternateSymbols: [ArcGIS.Symbol] = [])

    /// The alternate symbols for the unique value's primary symbol. Symbols in this list should be of type ``MultilayerSymbol`` and must have ``SymbolReferenceProperties`` set with valid minimum and maximum scale at which symbol becomes visible. Renderer will pick only one symbol at a given map scale. If primary symbol's scale range falls within the map's scale, primary symbol is used. If not, then symbols in alternate symbols list are iterated through and first symbol matching the current map scale is picked for rendering. A symbol becomes visible if the map scale is less than or equal to symbol's minimum scale and greater than symbol's maximum scale.
    final public var alternateSymbols: [ArcGIS.Symbol] { get }

    /// Adds a sequence of `Symbol` values to the end of the `alternateSymbols` property.
    /// - Parameter newAlternateSymbols: The new `Symbol` values to append.
    final public func addAlternateSymbols<S>(_ newAlternateSymbols: S) where S : Sequence, S.Element == ArcGIS.Symbol

    /// Adds a `Symbol` value to the end of the `alternateSymbols` property.
    /// - Parameter newAlternateSymbol: The new `Symbol` value to append.
    final public func addAlternateSymbol(_ newAlternateSymbol: ArcGIS.Symbol)

    /// Inserts a collection of `Symbol` values into the `alternateSymbols` property at the specified position.
    /// - Parameters:
    ///   - newAlternateSymbols: The new `Symbol` values to insert.
    ///   - index: The position at which to insert the new `Symbol` values.
    final public func insertAlternateSymbols<C>(_ newAlternateSymbols: C, at index: Int) where C : Collection, C.Element == ArcGIS.Symbol

    /// Inserts a `Symbol` value into the `alternateSymbols` property at the specified position.
    /// - Parameters:
    ///   - newAlternateSymbol: The new `Symbol` value to insert.
    ///   - index: The position at which to insert the new `Symbol` value.
    final public func insertAlternateSymbol(_ newAlternateSymbol: ArcGIS.Symbol, at index: Int)

    /// Removes all values from the `alternateSymbols` property.
    final public func removeAllAlternateSymbols()

    /// Removes a sequence of `Symbol` values from the `alternateSymbols` property.
    /// - Parameter alternateSymbols: The `Symbol` values to remove.
    final public func removeAlternateSymbols<S>(_ alternateSymbols: S) where S : Sequence, S.Element == ArcGIS.Symbol

    /// Removes a `Symbol` value from the `alternateSymbols` property.
    /// - Parameter alternateSymbol: The `Symbol` value to remove.
    final public func removeAlternateSymbol(_ alternateSymbol: ArcGIS.Symbol)

    /// A description of the unique value. "Parcels zoned for residential use", for example.
    final public var description: String

    /// A label for the unique value. "Residential", for example.
    final public var label: String

    /// A symbol used to represent elements with this unique value.
    final public var symbol: ArcGIS.Symbol?

    /// An `Array` containing `Any` types that define a unique value or unique combination of values.
    final public var values: [Any] { get }

    /// Adds a sequence of `Any` values to the end of the `values` property.
    /// - Parameter newValues: The new `Any` values to append.
    final public func addValues<S>(_ newValues: S) where S : Sequence, S.Element == Any

    /// Adds an `Any` value to the end of the `values` property.
    /// - Parameter newValue: The new `Any` value to append.
    final public func addValue(_ newValue: Any)

    /// Inserts a collection of `Any` values into the `values` property at the specified position.
    /// - Parameters:
    ///   - newValues: The new `Any` values to insert.
    ///   - index: The position at which to insert the new `Any` values.
    final public func insertValues<C>(_ newValues: C, at index: Int) where C : Collection, C.Element == Any

    /// Inserts an `Any` value into the `values` property at the specified position.
    /// - Parameters:
    ///   - newValue: The new `Any` value to insert.
    ///   - index: The position at which to insert the new `Any` value.
    final public func insertValue(_ newValue: Any, at index: Int)

    /// Removes all values from the `values` property.
    final public func removeAllValues()

    /// Removes a sequence of `Any` values from the `values` property.
    /// - Parameter values: The `Any` values to remove.
    final public func removeValues<S>(_ values: S) where S : Sequence, S.Element == Any

    /// Removes an `Any` value from the `values` property.
    /// - Parameter value: The `Any` value to remove.
    final public func removeValue(_ value: Any)

    /// Clones the ``UniqueValue``.
    /// - Returns: A new ``UniqueValue`` with the same values as the current ``UniqueValue``.
    final public func clone() -> Self

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    final public class func fromJSON(_ json: String) throws -> Self

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    final public func toJSON() -> String
}

extension UniqueValue : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.UniqueValue, rhs: ArcGIS.UniqueValue) -> Bool
}

extension UniqueValue : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// A Unique Value Renderer object.
/// - Since: 200.1
final public class UniqueValueRenderer : ArcGIS.Renderer {

    /// Creates a new unique value renderer object.
    /// - Parameters:
    ///   - fieldNames: An `Array` containing `String` types.
    ///   - uniqueValues: An `Array` containing ``UniqueValue`` types.
    ///   - defaultLabel: The default label.
    ///   - defaultSymbol: The symbol.
    public convenience init(fieldNames: [String] = [], uniqueValues: [ArcGIS.UniqueValue] = [], defaultLabel: String = "", defaultSymbol: ArcGIS.Symbol? = nil)

    /// The renderer's default label.
    final public var defaultLabel: String

    /// The default symbol of this renderer.
    final public var defaultSymbol: ArcGIS.Symbol?

    /// The field names of this renderer.
    final public var fieldNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `fieldNames` property.
    /// - Parameter newFieldNames: The new `String` values to append.
    final public func addFieldNames<S>(_ newFieldNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `fieldNames` property.
    /// - Parameter newFieldName: The new `String` value to append.
    final public func addFieldName(_ newFieldName: String)

    /// Inserts a collection of `String` values into the `fieldNames` property at the specified position.
    /// - Parameters:
    ///   - newFieldNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertFieldNames<C>(_ newFieldNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `fieldNames` property at the specified position.
    /// - Parameters:
    ///   - newFieldName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertFieldName(_ newFieldName: String, at index: Int)

    /// Removes all values from the `fieldNames` property.
    final public func removeAllFieldNames()

    /// Removes a sequence of `String` values from the `fieldNames` property.
    /// - Parameter fieldNames: The `String` values to remove.
    final public func removeFieldNames<S>(_ fieldNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `fieldNames` property.
    /// - Parameter fieldName: The `String` value to remove.
    final public func removeFieldName(_ fieldName: String)

    /// A list of all the unique values in this renderer.
    final public var uniqueValues: [ArcGIS.UniqueValue] { get }

    /// Adds a sequence of `UniqueValue` values to the end of the `uniqueValues` property.
    /// - Parameter newUniqueValues: The new `UniqueValue` values to append.
    final public func addUniqueValues<S>(_ newUniqueValues: S) where S : Sequence, S.Element == ArcGIS.UniqueValue

    /// Adds an `UniqueValue` value to the end of the `uniqueValues` property.
    /// - Parameter newUniqueValue: The new `UniqueValue` value to append.
    final public func addUniqueValue(_ newUniqueValue: ArcGIS.UniqueValue)

    /// Inserts a collection of `UniqueValue` values into the `uniqueValues` property at the specified position.
    /// - Parameters:
    ///   - newUniqueValues: The new `UniqueValue` values to insert.
    ///   - index: The position at which to insert the new `UniqueValue` values.
    final public func insertUniqueValues<C>(_ newUniqueValues: C, at index: Int) where C : Collection, C.Element == ArcGIS.UniqueValue

    /// Inserts an `UniqueValue` value into the `uniqueValues` property at the specified position.
    /// - Parameters:
    ///   - newUniqueValue: The new `UniqueValue` value to insert.
    ///   - index: The position at which to insert the new `UniqueValue` value.
    final public func insertUniqueValue(_ newUniqueValue: ArcGIS.UniqueValue, at index: Int)

    /// Removes all values from the `uniqueValues` property.
    final public func removeAllUniqueValues()

    /// Removes a sequence of `UniqueValue` values from the `uniqueValues` property.
    /// - Parameter uniqueValues: The `UniqueValue` values to remove.
    final public func removeUniqueValues<S>(_ uniqueValues: S) where S : Sequence, S.Element == ArcGIS.UniqueValue

    /// Removes an `UniqueValue` value from the `uniqueValues` property.
    /// - Parameter uniqueValue: The `UniqueValue` value to remove.
    final public func removeUniqueValue(_ uniqueValue: ArcGIS.UniqueValue)
}

/// Defines a unit of measurement.
///
/// ``Unit`` is a base class for measurement classes such as ``LinearUnit``, ``AngularUnit``, and ``AreaUnit``. Many
/// function parameters only accept specific types of measurement to reduce the chance of accidental use of
/// inappropriate values, but some generic functions accept all unit types, such as for translation from ID to text
/// description.
///
/// ``LinearUnit`` - Projected coordinate systems define coordinates using linear measurements,
/// for example using meters or miles. They are also used to return distance measurements, for
/// example by some members of ``GeometryEngine``.
///
/// ``AngularUnit`` - Geographic coordinate systems define coordinates using angular
/// measurements, for example using degrees or radians.
///
/// ``AreaUnit`` - Projected coordinate systems define area units for two dimensional
/// measurements such as the area enclosed by a ring, for example in acres or square kilometers.
///
/// Linear, angular, and area units can be defined by using enumerations of the most common units
/// of measurement. They can also be defined by well-known ID (WKID) or well-known text (WKText).
/// Create the unit instances using the Unit base class or the subtype, passing in the
/// enumeration for a specific unit of measurement.
///
/// Construction of related units are also supported so that if, for instance, the LinearUnit
/// (e.g. METERS) is known, then the corresponding AreaUnit (e.g. SQUARE_METERS) can be created
/// based on the LinearUnit.
///
/// Custom unit implementations are not supported.
///
/// Each instance of the various units types has properties for the unit name (singular, plural,
/// and abbreviated) and provides methods for unit conversion between different units of
/// measurement in the same category of measurement.
///
/// All unit names and abbreviations are returned in the English language.
/// Instances of unit are immutable.
/// - Note: See Also: ``SpatialReference``
/// - Since: 200.1
public class Unit {

    /// The abbreviation of the unit.
    ///
    /// The abbreviation for a specific unit.
    public var abbreviation: String { get }

    /// The display name of the unit.
    ///
    /// The display name for a specific unit.
    public var displayName: String { get }

    /// The name of the unit.
    ///
    /// The name for a specific unit.
    public var name: String { get }

    /// The display name of the unit.
    ///
    /// The display name for a specific unit.
    public var pluralDisplayName: String { get }

    /// The well-known ID for the unit, or 0 for a custom unit.
    public var wkid: ArcGIS.WKID? { get }
}

extension Unit : Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Unit, rhs: ArcGIS.Unit) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension Unit {

    /// Creates a unit given its well known ID.
    /// - Parameter wkid: The well-known ID of the unit.
    /// - Returns: A unit. Depending on the well-known ID given, this may be a linear, angular or area object.
    public class func fromWKID(_ wkid: ArcGIS.WKID) -> Self?
}

/// Supported units of distance.
/// - Since: 200.1
public enum UnitSystem {

    /// Used for imperial units, e.g. miles.
    case imperial

    /// Used for metric units, e.g. kilometers.
    case metric

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.UnitSystem, b: ArcGIS.UnitSystem) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension UnitSystem : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension UnitSystem : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init?(_ description: String)
}

extension UnitSystem : Equatable {
}

extension UnitSystem : Hashable {
}

/// An instance of this class represents a layer whose type could not be determined.
///
/// The layer will not be persisted in the string returned by ``Map/toJSON()``,
/// and will not be drawn by the map view.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class UnknownLayer : ArcGIS.Layer {
}

/// An instance of this class represents a layer type that is not currently supported.
///
/// The layer will be persisted in the string returned by ``Map/toJSON()``,
/// but will not be drawn by the map view.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
final public class UnsupportedLayer : ArcGIS.Layer {
}

/// A pop-up element that is not yet supported by this API.
///
/// Unsupported popup elements are saved when the map is saved.
/// - Since: 200.1
final public class UnsupportedPopupElement : ArcGIS.PopupElement {
}

/// An instance of this class represents a renderer type that is not currently supported.
///
/// The renderer will be persisted in the string returned by ``Renderer/toJSON()``,
/// but cannot be used to draw a layer in the map view.
/// - Note: See Also: ``Renderer``
/// - Since: 200.1
final public class UnsupportedRenderer : ArcGIS.Renderer {
}

/// An instance of this class represents a symbol type that is not currently supported.
///
/// The symbol will be persisted in the string returned by ``Symbol/toJSON()``,
/// but cannot be used to draw.
/// - Note: See Also: ``Symbol``
/// - Since: 200.1
final public class UnsupportedSymbol : ArcGIS.Symbol {
}

/// A utility network asset group
///
/// ``UtilityAssetGroup`` is the first-level categorization of an
/// ``UtilityNetworkSource``. (``UtilityAssetType`` is the second-level
/// categorization.) This class provides information about the
/// ``UtilityAssetGroup``, including the ``UtilityAssetType`` collection
/// that is contained therein.
/// - Since: 200.1
final public class UtilityAssetGroup {

    /// The collection of ``UtilityAssetType`` objects defining the asset types contained in the ``UtilityAssetGroup``.
    final public var assetTypes: [ArcGIS.UtilityAssetType] { get }

    /// The code of the ``UtilityAssetGroup``.
    ///
    /// This property is the subtype code value.
    final public var code: Int { get }

    /// The name of the ``UtilityAssetGroup``.
    final public var name: String { get }

    /// Gets an ``UtilityAssetType`` from the ``UtilityAssetGroup`` by name.
    ///
    /// For example, an ``UtilityAssetGroup`` describing electrical transformers may contain an ``UtilityAssetType`` for a specific type of electrical transformer with a name such as "Single-phase Distribution Transformer".
    /// - Parameter name: The name of the ``UtilityAssetType`` to return.
    /// - Returns: An ``UtilityAssetType`` corresponding to the name provided, or `nil` if the ``UtilityAssetType`` is not found in the ``UtilityAssetGroup``.
    final public func assetType(named name: String) -> ArcGIS.UtilityAssetType?
}

/// A utility network asset type.
///
/// ``UtilityAssetType`` is the second-level categorization of an ``UtilityNetworkSource``.
/// (``UtilityAssetGroup`` is the first-level categorization.)
///
/// Examples of utility network asset types include:
/// * The ``UtilityAssetType`` for a transformer ``UtilityAssetGroup`` in an electric
///   distribution domain network could be StepTransformer, PowerTransformer, or
///   DistributionTransformer
/// * The ``UtilityAssetType`` for a line feature class in a water distribution domain network
///   could be PVCPipe, ClayPipe, or CastIronPipe
/// - Since: 200.1
final public class UtilityAssetType {

    /// An enumeration of the various association roles.
    ///
    /// A feature's association role specifies how the feature can associate
    /// with other features, such as containment or attachment.
    /// - Note: See Also: ``UtilityAssetType``
    public enum AssociationRole {

        /// Features of this asset type can contain other features as contents.
        case container

        /// Features of this asset type can have other features attached to
        /// them.
        case structure

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityAssetType.AssociationRole, b: ArcGIS.UtilityAssetType.AssociationRole) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The update applied to ``UtilityAssociation`` objects when deleting
    /// an object of this ``UtilityAssetType``.
    ///
    /// This determines the behavior that occurs when attempting to
    /// delete features with this asset type.
    final public var associationDeletionSemantics: ArcGIS.UtilityAssociationDeletionSemantics { get }

    /// The ``AssociationRole-swift.enum`` of the ``UtilityAssetType``.
    ///
    /// This property indicates whether the ``UtilityAssetType`` can be a
    /// container, a structure, or neither.
    final public var associationRole: ArcGIS.UtilityAssetType.AssociationRole? { get }

    /// The ``UtilityCategory`` collection for the ``UtilityAssetType``.
    ///
    /// This is a collection of system-provided network categories that
    /// incorporate semantics of the utility network for subnetwork
    /// management and tracing operations.
    final public var categories: [ArcGIS.UtilityCategory] { get }

    /// The code of the ``UtilityAssetType``.
    ///
    /// This property is the attribute domain value.
    final public var code: Int { get }

    /// The container view scale of the ``UtilityAssetType``.
    ///
    /// If the utility asset type is a point container, this property is
    /// the appropriate display scale (zoom level) for displaying the
    /// container when it is opened. For other utility asset types, this
    /// property defaults to 0.0.
    final public var containerViewScale: Double { get }

    /// The name of the ``UtilityAssetType``.
    final public var name: String { get }

    /// The ``UtilityTerminalConfiguration`` of the ``UtilityAssetType``.
    ///
    /// Only asset types whose network source is ``UtilityNetworkSource/UsageKind-swift.enum/device`` can have a terminal configuration.
    final public var terminalConfiguration: ArcGIS.UtilityTerminalConfiguration? { get }
}

extension UtilityAssetType.AssociationRole : Equatable {
}

extension UtilityAssetType.AssociationRole : Hashable {
}

/// A connectivity, containment, or structural attachment association.
///
/// Associations are an integral part of network topology. Connectivity associations allow connectivity between two junctions that don't have geometric coincidence (are not in the same location).
/// Structural attachment associations allow modeling equipment attached to structures. Containment associations allow modeling containment of features within other features.
/// Network traces make use of associations. Associations are defined using two ``UtilityElement`` objects.
/// - Since: 200.1
final public class UtilityAssociation {

    /// An enumeration of the various types of associations supported by the utility network.
    public enum Kind {

        /// The association represents connectivity between two junctions.
        case connectivity

        /// The association represents containment of one ``UtilityElement`` within another.
        case containment

        /// The association represents a structural attachment.
        case attachment

        /// The association represents a junction or non-spatial junction connected to the end point of a non-spatial edge.
        case junctionEdgeObjectConnectivityFromSide

        /// The association represents a junction or non-spatial junction connected along the midspan of a non-spatial edge.
        case junctionEdgeObjectConnectivityMidspan

        /// The association represents a junction or non-spatial junction connected to the start point of a non-spatial edge.
        case junctionEdgeObjectConnectivityToSide

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityAssociation.Kind, b: ArcGIS.UtilityAssociation.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// If this ``UtilityAssociation`` represents a containment association, returns whether the containment is visible.
    final public var containmentIsVisible: Bool { get }

    /// The relative location along the non-spatial edge where the junction is (logically) located.
    ///
    /// If this is a junction to a non-spatial edge connectivity association, this property represents how far the junction is located along the non-spatial edge,
    /// from 0.0 (the edge's start point) and 1.0 (the edge's end point).
    ///
    /// If this association represents ``Kind-swift.enum/junctionEdgeObjectConnectivityToSide``, the value will be 0.0,
    /// if ``Kind-swift.enum/junctionEdgeObjectConnectivityMidspan``, the value will be between 0.0 and 1.0, and
    /// if ``Kind-swift.enum/junctionEdgeObjectConnectivityFromSide``, the value will be 1.0.
    ///
    /// The default value is 0.0.
    final public var fractionAlongEdge: Double { get }

    /// The first participant in an ``UtilityAssociation``.
    ///
    /// If this is a containment association, this property represents the container. If this is a structural attachment association, this property represents the structure.
    final public var fromElement: ArcGIS.UtilityElement { get }

    /// The geometry of this ``UtilityAssociation``.
    ///
    /// This geometry represents the connection between ``fromElement`` and ``toElement``.
    /// This property is valid only on connectivity and structural attachment ``UtilityAssociation`` objects returned by
    /// `UtilityNetwork.associations(extent:type:)` or `UtilityNetwork.associations(extent:type:)`.
    final public var geometry: ArcGIS.Geometry? { get }

    /// The global ID of the association.
    final public var globalID: UUID { get }

    /// The ``Kind-swift.enum`` of this association.
    final public var kind: ArcGIS.UtilityAssociation.Kind { get }

    /// The second participant in an association.
    ///
    /// If this is a containment association, this property represents the content. If this is a structural attachment association, this property represents the attached item.
    final public var toElement: ArcGIS.UtilityElement { get }
}

extension UtilityAssociation.Kind : Equatable {
}

extension UtilityAssociation.Kind : Hashable {
}

/// An enumeration of various association deletion behaviors.
///
/// Determines the behavior that occurs when attempting to delete a
/// feature which has containment or structural attachment associations
/// to other features.
/// - Note: See Also: ``UtilityAssetType``
/// - Since: 200.1
public enum UtilityAssociationDeletionSemantics {

    /// Any associated features will not be deleted, but the associations will no longer exist.
    /// Default for ``UtilityAssetType/AssociationRole-swift.enum/structure``.
    case featuresNotDeleted

    /// Any associations features will be deleted.
    case cascade

    /// If the feature has any associations, deleting the feature will fail.
    /// Default for ``UtilityAssetType/AssociationRole-swift.enum/container``.
    ///
    /// If the ``UtilityAssetType`` of a feature cannot be determined (such as when it is
    /// filtered out by ``GenerateGeodatabaseParameters/extent``,
    /// ``GenerateGeodatabaseParameters/layerOptions``, or by a definition expression),
    /// ``UtilityAssociationDeletionSemantics/restricted`` is assumed.
    case restricted

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.UtilityAssociationDeletionSemantics, b: ArcGIS.UtilityAssociationDeletionSemantics) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension UtilityAssociationDeletionSemantics : Equatable {
}

extension UtilityAssociationDeletionSemantics : Hashable {
}

/// A category used to define a characteristic of an asset in a network.
///
/// ``UtilityCategory`` can be used during tracing operations to define constraints or conditions based upon specific characteristics of asset types in the network.
/// - Since: 200.1
final public class UtilityCategory {

    /// The name of the category.
    final public var name: String { get }
}

/// A condition evaluating whether a particular ``UtilityCategory`` exists on a feature in the trace.
/// - Since: 200.1
final public class UtilityCategoryComparison : ArcGIS.UtilityTraceConditionalExpression {

    /// An enumeration of the various types of operators to use when evaluating
    /// the existence of an ``UtilityCategory`` on a network feature.
    /// - Note: See Also: ``UtilityCategoryComparison``
    public enum Operator {

        /// Evaluate that the ``UtilityCategory`` exists on a network feature.
        case exists

        /// Evaluate that the ``UtilityCategory`` does not exist on a network feature.
        case doesNotExist

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityCategoryComparison.Operator, b: ArcGIS.UtilityCategoryComparison.Operator) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a condition evaluating whether an ``UtilityCategory`` exists
    /// on a feature.
    /// - Parameters:
    ///   - category: The category to evaluate as part of the condition.
    ///   - `operator`: The type of comparison to do between the ``UtilityCategory`` and each feature in the trace.
    public convenience init(category: ArcGIS.UtilityCategory, operator: ArcGIS.UtilityCategoryComparison.Operator)

    /// Creates a condition evaluating whether a category with this name exists
    /// on a feature.
    /// - Parameters:
    ///   - categoryName: The name of the category to evaluate as part of the condition.
    ///   - `operator`: The type of comparison to do between the category name and each feature in the trace.
    public convenience init(categoryName: String, operator: ArcGIS.UtilityCategoryComparison.Operator)

    /// The type of comparison to do between the ``UtilityCategory`` and
    /// each feature in the trace.
    final public var `operator`: ArcGIS.UtilityCategoryComparison.Operator { get }

    /// The category to evaluate as part of the condition.
    final public var category: ArcGIS.UtilityCategory { get }
}

extension UtilityCategoryComparison.Operator : Equatable {
}

extension UtilityCategoryComparison.Operator : Hashable {
}

/// A domain network inside a utility network.
///
/// Domain networks organize features in a utility network based on what
/// utility service they provide, such as natural gas, water, electricity,
/// or structural elements such as poles or conduits. Each utility network
/// will have a single structure network and one or more domain networks for
/// the actual utility services they provide.
///
/// ``UtilityDomainNetwork`` objects can be obtained from the utility network definition
/// using the ``UtilityNetworkDefinition/domainNetworks`` property.
/// - Since: 200.1
final public class UtilityDomainNetwork : Identifiable {

    /// The type of subnetwork controllers that are supported by a domain network.
    /// - Note: See Also: ``UtilityDomainNetwork``
    public enum SubnetworkControllerType {

        /// This domain network doesn't support subnetworks.
        case unsupported

        /// Subnetwork controllers within this domain network serve as sources.
        case source

        /// Subnetwork controllers within this domain network serve as sinks.
        case sink

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityDomainNetwork.SubnetworkControllerType, b: ArcGIS.UtilityDomainNetwork.SubnetworkControllerType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Describes the tier type of a domain network.
    /// - Note: See Also: ``UtilityDomainNetwork``
    public enum TierType {

        /// Tiers within this domain network are hierarchical.
        ///
        /// In hierarchical domain networks, tiers are nested within one another, so features existing in subnetworks for a lower tier naturally participate in all higher tiers.
        /// For example, in a gas network, a valve isolation zone is within a pressure zone, which in turn exists within a system zone.
        /// A feature in the isolation zone also exists in the pressure zone and in the system zone.
        case hierarchical

        /// Tiers within this domain network are partitioned.
        ///
        /// Features in partitioned domain networks only exist in one tier. The relationship between tiers is ordered and linear.
        /// Features can exist in one or multiple subnetworks within one tier.
        case partitioned

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityDomainNetwork.TierType, b: ArcGIS.UtilityDomainNetwork.TierType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The display (non-normalized) name of the ``UtilityDomainNetwork``.
    ///
    /// This name is suitable for display to end-users.
    final public var alias: String { get }

    /// The ID of the ``UtilityDomainNetwork``.
    final public var id: Int { get }

    /// Whether this ``UtilityDomainNetwork`` is the structure network.
    final public var isStructureNetwork: Bool { get }

    /// The normalized name of the ``UtilityDomainNetwork``.
    final public var name: String { get }

    /// The collection of ``UtilityNetworkSource`` objects in this ``UtilityDomainNetwork``.
    final public var networkSources: [ArcGIS.UtilityNetworkSource] { get }

    /// The type of subnetwork controller supported in this ``UtilityDomainNetwork``.
    final public var subnetworkControllerType: ArcGIS.UtilityDomainNetwork.SubnetworkControllerType { get }

    /// A collection of all of the ``UtilityTierGroup`` objects for this domain network.
    ///
    /// Only hierarchical domain networks support tier groups. If no tier groups exist, an empty list is returned.
    final public var tierGroups: [ArcGIS.UtilityTierGroup] { get }

    /// The tier type of this domain network
    ///
    /// Valid values in the ``TierType-swift.enum`` enum are Hierarchical (typically used with pressure networks) and Partitioned (typically used with electrical networks).
    final public var tierType: ArcGIS.UtilityDomainNetwork.TierType { get }

    /// A collection of all of the ``UtilityTier`` objects for this domain network.
    final public var tiers: [ArcGIS.UtilityTier] { get }

    /// Gets the ``UtilityTier`` object with the specified name.
    /// - Parameter tierName: The name of the desired ``UtilityTier`` object to return.
    /// - Returns: An ``UtilityTier`` object with the specified name.
    final public func tier(named tierName: String) -> ArcGIS.UtilityTier?

    /// Gets the ``UtilityTierGroup`` object with the specified name.
    /// - Parameter tierGroupName: The name of the desired ``UtilityTierGroup`` object to return.
    /// - Returns: An ``UtilityTierGroup`` object with the specified name.
    final public func tierGroup(named tierGroupName: String) -> ArcGIS.UtilityTierGroup?

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = Int
}

extension UtilityDomainNetwork.SubnetworkControllerType : Equatable {
}

extension UtilityDomainNetwork.SubnetworkControllerType : Hashable {
}

extension UtilityDomainNetwork.TierType : Equatable {
}

extension UtilityDomainNetwork.TierType : Hashable {
}

/// A entity in a utility network that corresponds to a ``Feature``.
///
/// ``UtilityElement`` includes a reference to a ``Feature`` inside a utility network source, plus a terminal (if applicable). ``UtilityElement`` objects are used across the utility network API. Some places where they are used are to specify starting points and barriers for use with tracing, and returned as results from tracing.
/// - Since: 200.1
final public class UtilityElement {

    /// The asset group the element belongs to.
    final public var assetGroup: ArcGIS.UtilityAssetGroup { get }

    /// The asset type the element belongs to.
    final public var assetType: ArcGIS.UtilityAssetType { get }

    /// How far the starting point or barrier is located along an edge in the
    /// utility network feature, from 0.0 (edge's start) to 1.0 (edge's end).
    ///
    /// This property is only valid when the ``globalID``
    /// property refers to an edge feature that is an input to a tracing
    /// operation.
    final public var fractionAlongEdge: Double

    /// The global ID of the element.
    final public var globalID: UUID { get }

    /// Indicates whether or not the ``UtilityElement`` has complete data available.
    ///
    /// When taking an ``UtilityNetwork`` offline, some of the data can be filtered out to limit
    /// the size of the data. This may leave some elements in an incomplete state.  For
    /// example, one element of an association may be included in the offline dataset while the
    /// other element may not.
    ///
    /// When an element is incomplete, the following properties should not be used:
    /// * ``assetGroup``
    /// * ``assetType``
    /// * ``objectID``
    /// * ``terminal``
    ///
    /// When ``isValid`` is `false`, the ``UtilityAssetType`` is assumed to have an
    /// ``UtilityAssociationDeletionSemantics`` of
    /// ``UtilityAssociationDeletionSemantics/restricted``.
    final public var isValid: Bool { get }

    /// The ``UtilityNetworkSource`` the element is from.
    final public var networkSource: ArcGIS.UtilityNetworkSource { get }

    /// The object ID of the element's corresponding feature in the ``networkSource``.
    ///
    /// Only valid on results from a tracing operation, or with elements that are created from an ``ArcGISFeature``.  Otherwise the value -1 is returned.
    final public var objectID: Int { get }

    /// The ``UtilityTerminal`` of the utility network feature.
    ///
    /// Only valid when the ``globalID`` refers to a device feature.
    final public var terminal: ArcGIS.UtilityTerminal?
}

/// A trace result set comprised of an collection of ``UtilityElement``
/// objects.
/// - Since: 200.1
final public class UtilityElementTraceResult : ArcGIS.UtilityTraceResult {

    /// The collection of ``UtilityElement`` that comprise the trace
    /// results.
    final public var elements: [ArcGIS.UtilityElement] { get }
}

/// A trace result set comprised of a collection of ``UtilityTraceFunctionOutput``
/// objects.
/// - Since: 200.1
final public class UtilityFunctionTraceResult : ArcGIS.UtilityTraceResult {

    /// The collection of ``UtilityTraceFunctionOutput`` that comprise the trace
    /// results.
    ///
    /// An ``UtilityTraceFunctionOutput`` is returned for every ``UtilityTraceFunction`` in the ``UtilityTraceConfiguration``.
    final public var functionOutputs: [ArcGIS.UtilityTraceFunctionOutput] { get }
}

/// The trace result comprised of a set of ``Geometry`` objects representing the network elements identified by the trace.
///
/// The ``UtilityGeometryTraceResult`` exposes the geometry result with a property for each potential geometry type:
/// ``Multipoint``, ``Polyline``, and ``Polygon``.
/// The geometry for these properties is the union of all geometries of that type returned by the trace.
/// If the result does not include a certain geometry type, the corresponding property will be `nil`.
/// - Since: 200.1
final public class UtilityGeometryTraceResult : ArcGIS.UtilityTraceResult {

    /// The ``Multipoint`` that comprise the trace results.
    ///
    /// The ``Multipoint`` is the union of all point geometries returned by the trace.
    /// If the result does not include points, this property will be `nil`.
    final public var multipoint: ArcGIS.Multipoint? { get }

    /// The ``Polygon`` that comprise the trace results.
    ///
    /// The ``Polygon`` is the union of all polygon geometries returned by the trace.
    /// If the result does not include polygons, this property will be `nil`.
    final public var polygon: ArcGIS.Polygon? { get }

    /// The ``Polyline`` that comprise the trace results.
    ///
    /// The ``Polyline`` is the union of all line geometries returned by the trace.
    /// If the result does not include lines, this property will be `nil`.
    /// The result may be a curve, in which case it should be densified.
    final public var polyline: ArcGIS.Polyline? { get }
}

/// An enumeration of the various types of minimum starting locations used in ``UtilityTraceParameters``.
/// - Note: See Also: ``UtilityTraceParameters/startingLocations``, ``UtilityNamedTraceConfiguration/minimumStartingLocations``
/// - Since: 200.1
public enum UtilityMinimumStartingLocations {

    /// At least one starting point is necessary for the particular trace parameters.
    ///
    /// Traces like downstream require at least 1 starting points.
    case one

    /// At least 2 starting points are necessary for the particular trace parameters.
    ///
    /// Traces like shortestPath require at least 2 starting points.
    case many

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.UtilityMinimumStartingLocations, b: ArcGIS.UtilityMinimumStartingLocations) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension UtilityMinimumStartingLocations : Equatable {
}

extension UtilityMinimumStartingLocations : Hashable {
}

/// A set of predefined trace options that can be used by ``UtilityTraceParameters``
/// to simplify configuring and running a trace operation.
///
/// Named trace configurations are created in the utility network and allow clients to
/// perform trace analytics without needing to understand the data model.
/// Applications can simply allow the user to choose from a set of named trace configurations
/// that provide tracing capabilities. The set can be configured for different workflows,
/// and a single application can be used by multiple customers and even across multiple problem domains.
/// - Note: See Also: `Map.namedTraceConfigurations(from:)`,
/// `UtilityNetwork.queryNamedTraceConfigurations(using:)`
/// - Since: 200.1
final public class UtilityNamedTraceConfiguration {

    /// The creator of the named trace configuration.
    ///
    /// The creator will be the active portal user when the named trace
    /// configuration was created.
    final public var creator: String { get }

    /// Gets a copy of the ``UtilityTraceConfiguration`` defined for this ``UtilityNamedTraceConfiguration``.
    final public var defaultTraceConfiguration: ArcGIS.UtilityTraceConfiguration { get }

    /// The description of the named trace configuration.
    final public var description: String { get }

    /// The global ID of the named trace configuration.
    final public var globalID: UUID { get }

    /// The minimum number of starting locations required for this
    /// trace type (e.g. shortest path trace requires 2).
    /// - Note: See Also: ``UtilityMinimumStartingLocations``
    final public var minimumStartingLocations: ArcGIS.UtilityMinimumStartingLocations { get }

    /// The name of the named trace configuration.
    final public var name: String { get }

    /// The result types returned by this named trace configuration.
    /// - Note: See Also: ``UtilityTraceParameters/ResultType``
    final public var resultTypes: [ArcGIS.UtilityTraceParameters.ResultType] { get }

    /// The user tags of the named trace configuration.
    final public var tags: [String] { get }

    /// The ``UtilityTraceParameters/TraceType-swift.enum`` used by the named trace configuration.
    /// - Note: See Also: ``UtilityTraceParameters/TraceType-swift.enum``
    final public var traceType: ArcGIS.UtilityTraceParameters.TraceType { get }
}

/// The query parameters to use when searching for applicable named trace configuration objects.
///
/// If none of the parameters are set the query will return all available
/// named trace configurations.
/// In the query the values in each property are combined using a logical OR and
/// between each property a logical AND is used.
/// - Note: See Also: ``UtilityNamedTraceConfiguration``
/// - Since: 200.1
final public class UtilityNamedTraceConfigurationQueryParameters {

    /// Creates an ``UtilityNamedTraceConfigurationQueryParameters``.
    public convenience init()

    /// Optional parameter representing the creators of the named trace configurations
    /// to be queried.
    final public var creators: [String] { get }

    /// Adds a sequence of `String` values to the end of the `creators` property.
    /// - Parameter newCreators: The new `String` values to append.
    final public func addCreators<S>(_ newCreators: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `creators` property.
    /// - Parameter newCreator: The new `String` value to append.
    final public func addCreator(_ newCreator: String)

    /// Inserts a collection of `String` values into the `creators` property at the specified position.
    /// - Parameters:
    ///   - newCreators: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertCreators<C>(_ newCreators: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `creators` property at the specified position.
    /// - Parameters:
    ///   - newCreator: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertCreator(_ newCreator: String, at index: Int)

    /// Removes all values from the `creators` property.
    final public func removeAllCreators()

    /// Removes a sequence of `String` values from the `creators` property.
    /// - Parameter creators: The `String` values to remove.
    final public func removeCreators<S>(_ creators: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `creators` property.
    /// - Parameter creator: The `String` value to remove.
    final public func removeCreator(_ creator: String)

    /// Optional parameter representing the global IDs of the named trace configurations
    /// to be queried.
    final public var globalIDs: [UUID] { get }

    /// Adds a sequence of `UUID` values to the end of the `globalIDs` property.
    /// - Parameter newGlobalIDs: The new `UUID` values to append.
    final public func addGlobalIDs<S>(_ newGlobalIDs: S) where S : Sequence, S.Element == UUID

    /// Adds an `UUID` value to the end of the `globalIDs` property.
    /// - Parameter newGlobalID: The new `UUID` value to append.
    final public func addGlobalID(_ newGlobalID: UUID)

    /// Inserts a collection of `UUID` values into the `globalIDs` property at the specified position.
    /// - Parameters:
    ///   - newGlobalIDs: The new `UUID` values to insert.
    ///   - index: The position at which to insert the new `UUID` values.
    final public func insertGlobalIDs<C>(_ newGlobalIDs: C, at index: Int) where C : Collection, C.Element == UUID

    /// Inserts an `UUID` value into the `globalIDs` property at the specified position.
    /// - Parameters:
    ///   - newGlobalID: The new `UUID` value to insert.
    ///   - index: The position at which to insert the new `UUID` value.
    final public func insertGlobalID(_ newGlobalID: UUID, at index: Int)

    /// Removes all values from the `globalIDs` property.
    final public func removeAllGlobalIDs()

    /// Removes a sequence of `UUID` values from the `globalIDs` property.
    /// - Parameter globalIDs: The `UUID` values to remove.
    final public func removeGlobalIDs<S>(_ globalIDs: S) where S : Sequence, S.Element == UUID

    /// Removes an `UUID` value from the `globalIDs` property.
    /// - Parameter globalID: The `UUID` value to remove.
    final public func removeGlobalID(_ globalID: UUID)

    /// Optional parameter representing the names of the named trace configurations
    /// to be queried.
    final public var names: [String] { get }

    /// Adds a sequence of `String` values to the end of the `names` property.
    /// - Parameter newNames: The new `String` values to append.
    final public func addNames<S>(_ newNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `names` property.
    /// - Parameter newName: The new `String` value to append.
    final public func addName(_ newName: String)

    /// Inserts a collection of `String` values into the `names` property at the specified position.
    /// - Parameters:
    ///   - newNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertNames<C>(_ newNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `names` property at the specified position.
    /// - Parameters:
    ///   - newName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertName(_ newName: String, at index: Int)

    /// Removes all values from the `names` property.
    final public func removeAllNames()

    /// Removes a sequence of `String` values from the `names` property.
    /// - Parameter names: The `String` values to remove.
    final public func removeNames<S>(_ names: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `names` property.
    /// - Parameter name: The `String` value to remove.
    final public func removeName(_ name: String)

    /// Optional parameter representing the user tags of the named trace configurations
    /// to be queried.
    final public var tags: [String] { get }

    /// Adds a sequence of `String` values to the end of the `tags` property.
    /// - Parameter newTags: The new `String` values to append.
    final public func addTags<S>(_ newTags: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `tags` property.
    /// - Parameter newTag: The new `String` value to append.
    final public func addTag(_ newTag: String)

    /// Inserts a collection of `String` values into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTags: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertTags<C>(_ newTags: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `tags` property at the specified position.
    /// - Parameters:
    ///   - newTag: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertTag(_ newTag: String, at index: Int)

    /// Removes all values from the `tags` property.
    final public func removeAllTags()

    /// Removes a sequence of `String` values from the `tags` property.
    /// - Parameter tags: The `String` values to remove.
    final public func removeTags<S>(_ tags: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `tags` property.
    /// - Parameter tag: The `String` value to remove.
    final public func removeTag(_ tag: String)
}

/// A filter set on ``UtilityTraceFilter/nearestNeighbor`` to return the next N features from the starting point.
/// - Since: 200.1
final public class UtilityNearestNeighbor {

    /// Creates a filter object to return the next N features from the starting point.
    /// - Parameters:
    ///   - costNetworkAttribute: The ``UtilityNetworkAttribute`` used to determine the definition of "nearest".
    ///   - count: The number of nearest features to return. This must be a positive number.
    ///   - assetTypes: The collection of ``UtilityAssetType`` that define features to return.
    /// - Precondition: `count > 0`
    /// - Precondition: `!assetTypes.isEmpty`
    public convenience init(costNetworkAttribute: ArcGIS.UtilityNetworkAttribute, count: Int, assetTypes: [ArcGIS.UtilityAssetType])

    /// Creates a filter object to return the next N features from the starting point.
    /// - Parameters:
    ///   - costNetworkAttribute: The ``UtilityNetworkAttribute`` used to determine the definition of "nearest".
    ///   - count: The number of nearest features to return. This must be a positive number.
    ///   - assetTypes: The collection of ``UtilityAssetType`` that are used to define features to return.
    ///   - categories: The collection of ``UtilityCategory`` that are used to define features to return.
    /// - Precondition: `count > 0`
    /// - Precondition: `!assetTypes.isEmpty || !categories.isEmpty`
    public convenience init(costNetworkAttribute: ArcGIS.UtilityNetworkAttribute, count: Int, assetTypes: [ArcGIS.UtilityAssetType], categories: [ArcGIS.UtilityCategory])

    /// Creates a filter object to return the next N features from the starting point.
    /// - Parameters:
    ///   - costNetworkAttribute: The ``UtilityNetworkAttribute`` used to determine the definition of "nearest".
    ///   - count: The number of nearest features to return. This must be a positive number.
    ///   - categories: The collection of ``UtilityCategory`` that are used to define features to return.
    /// - Precondition: `count > 0`
    /// - Precondition: `!categories.isEmpty`
    public convenience init(costNetworkAttribute: ArcGIS.UtilityNetworkAttribute, count: Int, categories: [ArcGIS.UtilityCategory])

    /// The collection of ``UtilityAssetType`` that are used to define features to return.
    ///
    /// Can be empty when the ``UtilityNearestNeighbor`` is created with an array of ``UtilityCategory``.
    final public var assetTypes: [ArcGIS.UtilityAssetType] { get }

    /// The collection of ``UtilityCategory`` that are used to define features to return.
    ///
    /// Can be empty when the ``UtilityNearestNeighbor`` is created with an array of ``UtilityAssetType``.
    final public var categories: [ArcGIS.UtilityCategory] { get }

    /// The ``UtilityNetworkAttribute`` used to determine the definition of "nearest".
    final public var costNetworkAttribute: ArcGIS.UtilityNetworkAttribute { get }

    /// The number of nearest features to return.
    final public var count: Int { get }
}

/// Indicates the result of ``UtilityNearestNeighbor`` in the ``UtilityTraceConfiguration/filter`` in relation to its requested count.
/// - Since: 200.1
public enum UtilityNearestNeighborResult {

    /// No ``UtilityNearestNeighbor`` was specified in the ``UtilityTraceConfiguration/filter``.
    case notApplicable

    /// The ``UtilityNearestNeighbor`` specified in the ``UtilityTraceConfiguration/filter`` returned the requested count.
    case allRequestedNeighborsFound

    /// The ``UtilityNearestNeighbor`` specified in the ``UtilityTraceConfiguration/filter`` did not return the requested count.
    case fewerNeighborsFound

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.UtilityNearestNeighborResult, b: ArcGIS.UtilityNearestNeighborResult) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension UtilityNearestNeighborResult : Equatable {
}

extension UtilityNearestNeighborResult : Hashable {
}

/// A utility network
///
/// This is the central class for utility network schema information and
/// tracing. ``UtilityNetwork`` follows the ``Loadable`` pattern. When it
/// loads, it is populated with the utility network schema. This class
/// provides methods to create ``UtilityElement`` objects for the ``UtilityNetwork``.
/// - Since: 200.1
final public class UtilityNetwork : ArcGIS.Loadable {

    /// Creates an ``UtilityNetwork`` using the URI to the feature service.
    /// - Parameter url: The URI to the feature service.
    public convenience init(url: URL)

    /// Creates a utility network with the URL to the feature service and a map.
    ///
    /// Creates a utility network associated with a particular service, using the same ``ArcGISFeatureTable``
    /// objects in use by ``FeatureLayer`` objects within the map.  This lets any ``UtilityElement`` or
    /// ``ArcGISFeature`` objects the ``UtilityNetwork`` creates or uses be associated with those existing
    /// tables and layers.  Usually used when instantiating an ``UtilityNetwork`` object from a web map.
    /// This ``UtilityNetwork`` will be added to ``Map/utilityNetworks``.
    /// - Parameters:
    ///   - url: The URI to the Feature Service.
    ///   - map: A Map that provides FeatureTables to be reused by the utility network.
    public convenience init(url: URL, map: ArcGIS.Map)

    /// The definition of the ``UtilityNetwork``.
    ///
    /// This definition is `nil` until the utility network is loaded.
    /// - Note: See Also: ``UtilityNetworkDefinition``
    final public var definition: ArcGIS.UtilityNetworkDefinition? { get }

    /// The ``Geodatabase`` that contains this ``UtilityNetwork``.
    ///
    /// The ``Geodatabase`` that contains this ``UtilityNetwork`` and is also used by the ``GeodatabaseFeatureTable``
    /// in ``UtilityNetworkDefinition/networkSources``.
    ///
    /// Use this property to manage transactions, sync edits, or access tables participating in this ``UtilityNetwork``.
    ///
    /// This property has a value when the ``UtilityNetwork`` is retrieved from a ``Geodatabase``;
    /// otherwise, when created using any of the constructors, this property is `nil`.
    ///
    /// Note that calling `Geodatabase.close()` on a ``Geodatabase`` that contains this ``UtilityNetwork``
    /// will render this ``UtilityNetwork`` unusable. An attempt to create an element, get associations, get features from elements, or
    /// perform a trace after this ``Geodatabase`` is closed will fail with `CoreErrorCode.geodatabaseDatabaseClosed`.
    final public var geodatabase: ArcGIS.Geodatabase? { get }

    /// The name of the ``UtilityNetwork``.
    ///
    /// This property is empty when ``UtilityNetwork`` is not loaded or ``UtilityNetwork`` is not retrieved from a ``Geodatabase``.
    final public var name: String { get }

    /// The ``ServiceGeodatabase`` of the ``UtilityNetwork``.
    ///
    /// The ``ServiceGeodatabase`` used by the ``ServiceFeatureTable`` in ``UtilityNetworkDefinition/networkSources``.
    ///
    /// Use this property to switch to a branch version, manage edits, or query related records of tables participating
    /// in this ``UtilityNetwork``.
    ///
    /// This property is `nil` until the ``UtilityNetwork`` is loaded. The ``Map`` that was used to create this ``UtilityNetwork``
    /// provides this ``ServiceGeodatabase``. When no matching ``ServiceGeodatabase`` is found in the ``Map``, this ``UtilityNetwork``
    /// will create and load a ``ServiceGeodatabase`` connected to the default version in ``FeatureServiceSessionType/transient`` mode.
    ///
    /// This property is also `nil` when the ``UtilityNetwork`` is retrieved from a ``Geodatabase``.
    ///
    /// Note that calling `ServiceGeodatabase.close()` on a ``ServiceGeodatabase`` that is used by an ``UtilityNetwork``
    /// will render this ``UtilityNetwork`` unusable. An attempt to create an element, get associations, get features from elements, or
    /// perform a trace after this ``ServiceGeodatabase`` is closed will fail with `CoreErrorCode.geodatabaseDatabaseClosed`.
    final public var serviceGeodatabase: ArcGIS.ServiceGeodatabase? { get }

    /// The URI of the ``UtilityNetwork``.
    ///
    /// This property is empty when ``UtilityNetwork`` is retrieved from a ``Geodatabase``.
    final public var url: URL? { get }

    /// Gets a collection of loaded ``ArcGISFeature`` objects that each
    /// correspond to one of a collection of ``UtilityElement`` objects.
    /// - Parameter elements: The collection of utility elements used to find corresponding features.
    /// - Returns: An `Array` of loaded ``ArcGISFeature``.
    final public func features<S>(for elements: S) async throws -> [ArcGIS.ArcGISFeature] where S : Sequence, S.Element == ArcGIS.UtilityElement

    /// Returns a list of ``UtilityNamedTraceConfiguration`` from the utility network.
    /// - Parameter parameters: Optional query parameter to filter the results.
    /// - Returns: An array of ``UtilityNamedTraceConfiguration`` objects from the utility network.
    /// - Note: See Also: ``UtilityNamedTraceConfigurationQueryParameters``
    final public func queryNamedTraceConfigurations(using parameters: ArcGIS.UtilityNamedTraceConfigurationQueryParameters? = nil) async throws -> [ArcGIS.UtilityNamedTraceConfiguration]

    /// Begins a trace with the supplied ``UtilityTraceParameters``.
    ///
    /// This method returns a task that
    /// supplies a collection of ``UtilityTraceResult`` objects when the
    /// utility network finishes the trace.
    ///
    /// If the ``UtilityTraceParameters/traceType-swift.property`` in ``UtilityTraceParameters`` is a subnetwork-based trace,
    /// it must have an ``UtilityDomainNetwork`` set in the ``UtilityTraceConfiguration`` returned from
    /// ``UtilityTraceParameters/traceConfiguration``.
    /// - Parameter parameters: The input arguments to the trace.
    /// - Returns: An array of ``UtilityTraceResult`` objects when the trace is finished.
    final public func trace(using parameters: ArcGIS.UtilityTraceParameters) async throws -> [ArcGIS.UtilityTraceResult]

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

extension UtilityNetwork {

    /// Returns a list of all ``UtilityAssociation`` objects (with their
    /// geometry) present in the geodatabase for a given ``Envelope``, of kind
    /// ``UtilityAssociation/Kind-swift.enum``, if provided.
    /// - Remark: Containment associations are not returned because no geometric
    /// relationship is defined between a container and its contents; consider
    /// using ``associations(for:ofKind:)`` instead. The method does not return
    /// a complete picture of connectivity; features that are connected by
    /// geometric coincidence are not returned. Note that the list returned can
    /// contain associations that have not yet been validated and are therefore
    /// not yet included in the topological index.
    /// - Parameters:
    ///   - extent: The envelope that defines the area for which associations to
    ///   return.
    ///   - kind: The kind of associations to return.
    /// - Returns: A list of all the ``UtilityAssociation`` objects (with their geometry) of the
    /// specified kind if available. Otherwise, an empty list is returned.
    final public func associations(forExtent extent: ArcGIS.Envelope, ofKind kind: ArcGIS.UtilityAssociation.Kind? = nil) async throws -> [ArcGIS.UtilityAssociation]

    /// Returns a list of all ``UtilityAssociation`` objects present in the
    /// geodatabase for a given ``UtilityElement``, of kind
    /// ``UtilityAssociation/Kind-swift.enum``, if provided.
    /// - Remark: The result is a list of all associations -- connectivity
    /// associations, containment associations, structural attachment
    /// associations -- that include the given ``UtilityElement`` object. The
    /// method does not return a complete picture of connectivity; features that
    /// are connected by geometric coincidence are not returned. Note that the
    /// list returned can contain associations that have not yet been validated
    /// and are therefore not yet included in the topological index.
    /// - Parameters:
    ///   - element: The element whose associations are to be returned.
    ///   - kind: The kind of associations to return.
    /// - Returns: A list of all the ``UtilityAssociation`` objects of the
    /// specified kind if available. Otherwise, an empty list is returned.
    final public func associations(for element: ArcGIS.UtilityElement, ofKind kind: ArcGIS.UtilityAssociation.Kind? = nil) async throws -> [ArcGIS.UtilityAssociation]

    /// Creates an ``UtilityElement`` from a feature and an optional ``UtilityTerminal``.
    /// - Remark: If the optional ``UtilityTerminal`` is not supplied, and the feature's
    /// ``UtilityAssetType`` supports an ``UtilityTerminalConfiguration``, a default
    /// ``UtilityTerminal`` will be assigned.
    /// This method will return `nil` if the input feature does not belong to this utility network or
    /// a supplied terminal does not belong to the feature's asset type.
    /// - Parameters:
    ///   - arcGISFeature: The ``ArcGISFeature`` from which the feature element is created.
    ///   - terminal: The ``UtilityTerminal``
    /// - Returns: A new ``UtilityElement`` object.
    final public func makeElement(arcGISFeature: ArcGIS.ArcGISFeature, terminal: ArcGIS.UtilityTerminal? = nil) -> ArcGIS.UtilityElement?

    /// Creates an ``UtilityElement`` from an ``UtilityAssetType``, a global ID, and an optional
    /// ``UtilityTerminal``.
    /// - Remark: If the optional ``UtilityTerminal`` is not supplied, and the feature's
    /// ``UtilityAssetType`` supports an ``UtilityTerminalConfiguration``, a default
    /// ``UtilityTerminal`` will be assigned.
    /// This method will return `nil` if the asset type does not belong to this utility network or
    /// a supplied terminal does not belong to the feature's asset type.
    /// - Parameters:
    ///   - assetType: The ``UtilityAssetType`` of the feature from which this feature element is
    ///   created.
    ///   - globalID: The global ID of the feature from which this feature element is created.
    ///   - terminal: The ``UtilityTerminal``
    /// - Returns: A new ``UtilityElement`` object.
    final public func makeElement(assetType: ArcGIS.UtilityAssetType, globalID: UUID, terminal: ArcGIS.UtilityTerminal? = nil) -> ArcGIS.UtilityElement?
}

/// A network attribute in a utility network.
///
/// A Network Attribute is an attribute that is copied and stored in the topological index.
/// The utility network tracing task can read and make decisions using network attributes that are
/// stored directly in the topological index. Without needing to fetch the individual features to get their attributes,
/// the topological index provides performance that is orders of magnitude faster.
///
/// The network attributes in a topological index are limited to specific data types and aggregate size.
/// - Since: 200.1
final public class UtilityNetworkAttribute {

    /// An enumeration of the various ``UtilityNetworkAttribute`` data types.
    ///
    /// The ``UtilityNetworkAttribute`` objects in a topological index are limited to specific data types.
    public enum DataType {

        /// A signed 64-bit integer value.
        case integer

        /// A floating point value.
        case float

        /// A double precision floating point value.
        case double

        /// A Boolean m-values.
        case boolean

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityNetworkAttribute.DataType, b: ArcGIS.UtilityNetworkAttribute.DataType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The ``DataType-swift.enum`` for the ``UtilityNetworkAttribute``.
    ///
    /// The network attributes in a topological index are limited to specific data types.
    final public var dataType: ArcGIS.UtilityNetworkAttribute.DataType { get }

    /// The ``Domain`` associated with this network attribute.
    ///
    /// If no domain is assigned, `nil` is returned.
    final public var domain: ArcGIS.Domain? { get }

    /// Whether the network attribute should be apportioned across the length of linear features.
    ///
    /// For example, if a point is chosen 25% of the distance along an edge, 25% of the attribute's value is assigned to the 25% (shorter) part of the edge,
    /// and 75% of the attribute's value is assigned to the 75% (longer) part of the edge.
    final public var isApportionable: Bool { get }

    /// Whether the ``UtilityNetworkAttribute`` is used as a substitution for another network attribute at tap features.
    ///
    /// If this value is `true`, this network attribute is the network attribute to substitute for ``networkAttributeToSubstitute`` at tap features.
    /// Taps are special features, identified with the "Subnetwork Tap" category, that work with attribute substitution.  See the online help for more information.
    final public var isSubstitution: Bool { get }

    /// The name of the ``UtilityNetworkAttribute``.
    final public var name: String { get }

    /// This property is the ``UtilityNetworkAttribute`` that is substituted for this ``UtilityNetworkAttribute`` at tap features.
    ///
    /// This property is only set if ``isSubstitution`` is set to `true`.
    /// Taps are special features, identified with the "Subnetwork Tap" category, that work with attribute substitution. See the online help for more information.
    final public var networkAttributeToSubstitute: ArcGIS.UtilityNetworkAttribute? { get }

    /// Indicates that the network attribute has been added by the system.
    final public var systemIsDefined: Bool { get }
}

extension UtilityNetworkAttribute.DataType : Equatable {
}

extension UtilityNetworkAttribute.DataType : Hashable {
}

/// A condition evaluating the value of an ``UtilityNetworkAttribute`` on
/// nodes in the network, either to another ``UtilityNetworkAttribute`` or
/// to a specific value.
/// - Since: 200.1
final public class UtilityNetworkAttributeComparison : ArcGIS.UtilityTraceConditionalExpression {

    /// An enumeration of the various comparisons to perform between an ``UtilityNetworkAttribute``
    /// and a second ``UtilityNetworkAttribute`` or a specific value.
    /// - Note: See Also: ``UtilityNetworkAttributeComparison``
    public enum Operator {

        /// Tests whether an attribute is equal to another attribute or a
        /// specific value.
        case equal

        /// Tests whether an attribute is not equal to another attribute or a
        /// specific value.
        case notEqual

        /// Tests whether an attribute is greater than another attribute or a
        /// specific value.
        case greaterThan

        /// Tests whether an attribute is greater than or equal to another
        /// attribute or a specific value.
        case greaterThanEqual

        /// Tests whether an attribute is less than another attribute or a
        /// specific value.
        case lessThan

        /// Tests whether an attribute is less than or equal to another
        /// attribute or a specific value.
        case lessThanEqual

        /// Tests whether an attribute includes all the values specified in
        /// another attribute or the particular values contained in the
        /// condition.
        case includesTheValues

        /// Tests whether an attribute does not include all of the values
        /// specified in another attribute or the particular values in the
        /// condition.
        case doesNotIncludeTheValues

        /// Tests whether an attribute includes any of the values specified in
        /// another attribute or the particular values contained in the
        /// condition.
        case includesAny

        /// Tests whether an attribute does not include any of the values
        /// specified in another attribute or the particular values in the
        /// condition.
        case doesNotIncludeAny

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityNetworkAttributeComparison.Operator, b: ArcGIS.UtilityNetworkAttributeComparison.Operator) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a condition comparing an ``UtilityNetworkAttribute`` to a
    /// specific value.
    /// - Parameters:
    ///   - networkAttribute: The source ``UtilityNetworkAttribute`` that the value is compared to.
    ///   - `operator`: The type of comparison to do between the source ``UtilityNetworkAttribute`` and the value.
    ///   - value: The specific value to compare networkAttribute against for each node in the trace.
    public convenience init?(networkAttribute: ArcGIS.UtilityNetworkAttribute, operator: ArcGIS.UtilityNetworkAttributeComparison.Operator, value: Any)

    /// Creates a condition comparing the value of one
    /// ``UtilityNetworkAttribute`` to another.
    /// - Parameters:
    ///   - networkAttribute: The source ``UtilityNetworkAttribute`` that the value is compared to.
    ///   - comparisonOperator: The type of comparison to do between the source ``UtilityNetworkAttribute`` and another ``UtilityNetworkAttribute``.
    ///   - otherNetworkAttribute: The ``UtilityNetworkAttribute`` being compared against  another ``UtilityNetworkAttribute`` on each of the nodes.
    public convenience init?(networkAttribute: ArcGIS.UtilityNetworkAttribute, comparisonOperator: ArcGIS.UtilityNetworkAttributeComparison.Operator, otherNetworkAttribute: ArcGIS.UtilityNetworkAttribute)

    /// The type of comparison to do between the source
    /// ``UtilityNetworkAttribute`` and either the second
    /// ``UtilityNetworkAttribute`` or the value.
    final public var `operator`: ArcGIS.UtilityNetworkAttributeComparison.Operator { get }

    /// The source ``UtilityNetworkAttribute`` that otherNetworkAttribute or value is compared
    /// to.
    final public var networkAttribute: ArcGIS.UtilityNetworkAttribute { get }

    /// The ``UtilityNetworkAttribute`` being compared against ``networkAttribute`` on each of the
    /// nodes.
    ///
    /// This is `nil` if the comparison is against a specific value.
    final public var otherNetworkAttribute: ArcGIS.UtilityNetworkAttribute? { get }

    /// The specific value to compare ``networkAttribute`` against for each node
    /// in the trace.
    ///
    /// The value can be an integer data type, which can contain a small or large integer, or it can be double data type, which can contain a double or a date.
    final public var value: Any? { get }
}

extension UtilityNetworkAttributeComparison.Operator : Equatable {
}

extension UtilityNetworkAttributeComparison.Operator : Hashable {
}

/// Defines the supported capabilities for a utility network.
///
/// These non-configurable capabilities indicate which utility network operations are supported.
/// They are dependent upon the utility network service capabilities or the contents of the geodatabase.
/// - Since: 200.1
final public class UtilityNetworkCapabilities {

    /// `true` if this utility network can query associations, `false` otherwise.
    ///
    /// Access to the system-defined associations table is required to enable querying associations.
    ///
    /// The associations table is available for a utility network if:
    /// * Utility network feature service grants access to the association table
    /// * Partial or full utility network model was requested when replica geodatabase was created
    /// * Association table was included with the stand-alone geodatabase exported from ArcGIS Pro
    /// - Note: See Also: ``UtilityNetworkSyncMode``
    final public var supportsQueryAssociations: Bool { get }

    /// `true` if this utility network can run a trace, `false` otherwise.
    ///
    /// Access to network topology is required to enable tracing capability.
    ///
    /// The network topology is available for a utility network if:
    /// * Utility network service has enabled network topology
    /// * Full utility network model was requested when replica geodatabase was created
    /// * Network topology was included with the stand-alone geodatabase exported from ArcGIS Pro
    /// - Note: See Also: ``UtilityNetworkSyncMode``
    final public var supportsTrace: Bool { get }
}

/// The metadata of a utility network.
///
/// Includes metadata such as domain networks, network sources, and so on.
/// - Since: 200.1
final public class UtilityNetworkDefinition {

    /// Gets a value indicating the supported utility network capabilities.
    ///
    /// Use this property to determine which operations are available for this utility network.
    final public var capabilities: ArcGIS.UtilityNetworkCapabilities { get }

    /// The collection of utility network categories in the utility network metadata.
    ///
    /// An ``UtilityCategory`` is used to define a characteristic of an asset in a network. The objects in this collection incorporate semantics of the utility network for subnetwork
    /// management and tracing operations.
    final public var categories: [ArcGIS.UtilityCategory] { get }

    /// The collection of domain networks in the utility network metadata.
    ///
    /// Domain networks organize features in a utility network based on what utility service they provide, such as natural gas, water, electricity, or structural elements like poles or conduits.
    final public var domainNetworks: [ArcGIS.UtilityDomainNetwork] { get }

    /// The ``Envelope`` representing the service territory area used to define the ``UtilityNetwork``.
    ///
    /// This is the extent of the network topology (i.e., the extent of the service territory plus a small buffer).
    final public var extent: ArcGIS.Envelope { get }

    /// The network attributes in the utility network definition.
    ///
    /// An ``UtilityNetworkAttribute`` is an attribute that is copied and stored in the topological index. The utility network tracing task can read and make decisions using network attributes that are stored in the topological index.
    final public var networkAttributes: [ArcGIS.UtilityNetworkAttribute] { get }

    /// The collection of network sources in the utility network definition.
    ///
    /// ``UtilityNetworkSource`` objects represent various sources of network information such as structures, lines, junctions, and associations.
    @ArcGIS.Streamed final public var networkSources: [ArcGIS.UtilityNetworkSource] { get }

    final public var $networkSources: AsyncStream<[ArcGIS.UtilityNetworkSource]> { get }

    /// The utility network schema version number reported by the utility network metadata.
    ///
    /// Only certain schema versions are supported by this API.
    final public var schemaVersion: Int { get }

    /// Returns the ``UtilityTerminalConfiguration`` objects defined for this utility network.
    final public var terminalConfigurations: [ArcGIS.UtilityTerminalConfiguration] { get }

    /// Gets the domain network with the specified name.
    /// - Parameter domainNetworkName: The name of the domain network.
    /// - Returns: An ``UtilityDomainNetwork``.
    final public func domainNetwork(named domainNetworkName: String) -> ArcGIS.UtilityDomainNetwork?

    /// Gets the associated network attribute with the specified network attribute name.
    /// - Parameter networkAttributeName: The name of the network attribute.
    /// - Returns: An ``UtilityNetworkAttribute``.
    final public func networkAttribute(named networkAttributeName: String) -> ArcGIS.UtilityNetworkAttribute?

    /// Gets the associated network source with the specified network source name.
    /// - Parameter networkSourceName: The name of the network source.
    /// - Returns: An ``UtilityNetworkSource``.
    final public func networkSource(named networkSourceName: String) -> ArcGIS.UtilityNetworkSource?

    /// Queries for a subset of ``UtilityRule`` objects that apply to a set of ``UtilityAssetType``.
    ///
    /// Use this method to return network rules applicable to features of specific asset types. Limiting these
    /// asset types to those features being edited can substantially reduce the number of network rules returned.
    ///
    /// These asset types will be matched against the ``UtilityRuleElement/assetType`` of the following rule elements:
    /// * ``UtilityRule/fromElement``
    /// * ``UtilityRule/toElement``
    /// * ``UtilityRule/viaElement``
    ///
    /// If the collection of ``UtilityAssetType`` is empty or no matching rules are found for these asset types,
    /// an empty collection of ``UtilityRule`` objects is returned.
    /// - Parameter assetTypes: The collection of ``UtilityAssetType`` objects to query applicable ``UtilityRule`` objects.
    /// - Returns: A collection of ``UtilityRule`` objects.
    /// - Note: See Also: ``UtilityAssetType``
    final public func rules(assetTypes: [ArcGIS.UtilityAssetType]) async throws -> [ArcGIS.UtilityRule]
}

/// A network source in a utility network.
///
/// Various sources of related information are associated to comprise the utility network. The most obvious sources are the structures and network features that are included with each domain network. Other sources are the set of associations and the system junctions.
///
/// The ``UtilityNetworkDefinition/networkSources`` property contains the collection of ``UtilityNetworkSource`` objects in the utility network definition.
/// - Since: 200.1
final public class UtilityNetworkSource : Identifiable {

    /// An enumeration of the various network source types.
    /// - Note: See Also: ``UtilityNetworkSource``
    public enum Kind {

        /// The network source references junctions in a feature class or table.
        case junction

        /// The network source references edges in a feature class or table.
        case edge

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityNetworkSource.Kind, b: ArcGIS.UtilityNetworkSource.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An enumeration of the various usage types of an ``UtilityNetworkSource``.
    ///
    /// These values indicate how an ``UtilityNetworkSource`` is used in a utility network.
    public enum UsageKind {

        /// Network devices, such as transformers or valves.
        case device

        /// Miscellaneous junctions not typically tracked as assets, such as taps.
        case junction

        /// Lines such as conductors, pipes, or fiber strands.
        case line

        /// Assemblies such as switchgear.
        case assembly

        /// System-generated subnetwork lines.
        case subnetLine

        /// Point structures, such as poles.
        case structureJunction

        /// Linear structures, such as ducts, conduits, or buffer tubes.
        case structureLine

        /// Polygonal structures, such as substations or town border stations.
        case structureBoundary

        /// Non-spatial junctions, such as a transceiver in a fiber network.
        case junctionObject

        /// Non-spatial edge, such as a fiber strand in a fiber cable.
        case edgeObject

        /// Non-spatial structure junction, such as a duct port in a manhole.
        case structureJunctionObject

        /// Non-spatial structure edge, such as a duct in a duct bank.
        case structureEdgeObject

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityNetworkSource.UsageKind, b: ArcGIS.UtilityNetworkSource.UsageKind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The collection of asset groups for the utility network source.
    ///
    /// ``UtilityAssetGroup`` is the first-level categorization of an ``UtilityNetworkSource``.
    final public var assetGroups: [ArcGIS.UtilityAssetGroup] { get }

    /// The ``ArcGISFeatureTable`` that corresponds to the utility network source.
    final public var featureTable: ArcGIS.ArcGISFeatureTable { get }

    /// The ID of the utility network source.
    final public var id: Int { get }

    /// The source type of the utility network source.
    ///
    /// This property indicates whether the network source is an edge type or junction type.
    final public var kind: ArcGIS.UtilityNetworkSource.Kind { get }

    /// The name of the utility network source.
    final public var name: String { get }

    /// The usage type of this utility network source.
    ///
    /// This property indicates how the network source is used, such as line, junction, or assembly.
    final public var usageKind: ArcGIS.UtilityNetworkSource.UsageKind { get }

    /// Gets an associated asset group by name.
    ///
    /// Gets one of the collection of asset groups for the utility network source.
    /// - Parameter assetGroupName: The name of the asset group.
    /// - Returns: An ``UtilityAssetGroup``.
    final public func assetGroup(named assetGroupName: String) -> ArcGIS.UtilityAssetGroup?

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = Int
}

extension UtilityNetworkSource.Kind : Equatable {
}

extension UtilityNetworkSource.Kind : Hashable {
}

extension UtilityNetworkSource.UsageKind : Equatable {
}

extension UtilityNetworkSource.UsageKind : Hashable {
}

/// The different modes for generation and synchronization of utility networks as part of a geodatabase sync task.
/// - Since: 200.1
public enum UtilityNetworkSyncMode {

    /// No utility network resource will be synced.
    case noSync

    /// Utility Network system tables will be synced.
    ///
    /// The service must return `true` for ``SyncCapabilities/supportsUtilityNetworkSystem``
    /// to support taking Utility Network System data offline.
    /// - Note: See Also: ``SyncCapabilities/supportsUtilityNetworkSystem``, ``UtilityNetworkCapabilities/supportsQueryAssociations``
    case syncSystemTables

    /// Utility network topology and system tables will be synced.
    ///
    /// The [utility network topology](https://pro.arcgis.com/en/pro-app/latest/help/data/utility-network/about-network-topology.htm) enables offline trace capability.
    /// The service must return `true` for ``SyncCapabilities/supportsUtilityNetworkTopology``
    /// to support taking utility network topology offline. Selecting this enum value will also
    /// sync the utility network system tables.
    /// - Note: See Also: ``SyncCapabilities/supportsUtilityNetworkSystem``, ``SyncCapabilities/supportsUtilityNetworkTopology``,
    /// ``UtilityNetworkCapabilities/supportsQueryAssociations``, ``UtilityNetworkCapabilities/supportsTrace``
    case syncSystemAndTopologyTables

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.UtilityNetworkSyncMode, b: ArcGIS.UtilityNetworkSyncMode) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension UtilityNetworkSyncMode : Equatable {
}

extension UtilityNetworkSyncMode : Hashable {
}

/// Propagator objects allow a subset of ``UtilityNetworkAttribute`` values to propagate through a network while executing a trace.
///
/// The propagated ``UtilityNetworkAttribute`` values can be tested to allow or disallow further traversal.
///
/// In the example of phase propagation, open devices along the network will restrict some phases from continuing along the trace.
///
/// Propagators only apply to subnetwork-based traces (``UtilityTraceParameters/TraceType-swift.enum/upstream``, ``UtilityTraceParameters/TraceType-swift.enum/downstream``, and so on).
///
/// ``UtilityPropagator`` is set in the ``UtilityTraceConfiguration``.
/// - Since: 200.1
final public class UtilityPropagator {

    /// The function types that can be used with ``UtilityPropagator`` objects.
    /// - Note: See Also: ``UtilityPropagator``
    public enum FunctionType {

        /// The network attribute value of the current element is bitwise-anded with the network attribute value propagated from the source.
        case bitwiseAnd

        /// The network attribute value of the current element is compared against the network attribute value propagated from the source -
        /// the maximum of these values is propagated further.
        case max

        /// The network attribute value of the current element is compared against the network attribute value propagated from the source -
        /// the minimum of these values is propagated further.
        case min

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityPropagator.FunctionType, b: ArcGIS.UtilityPropagator.FunctionType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The operator that is applied when executing the trace.
    ///
    /// This operator is used to compare the propagated value to the specified ``value``
    /// For example, if propagating phase, this would be ``UtilityNetworkAttributeComparison/Operator-swift.enum/includesAny``.
    final public var comparisonOperator: ArcGIS.UtilityNetworkAttributeComparison.Operator { get }

    /// The function type that is applied to the ``UtilityNetworkAttribute`` to propagate the attribute further along the trace.
    ///
    /// For example, if propagating phase, this would be ``FunctionType-swift.enum/bitwiseAnd``.
    final public var functionType: ArcGIS.UtilityPropagator.FunctionType { get }

    /// The ``UtilityNetworkAttribute`` to propagate further along the trace.
    ///
    /// For example, if propagating phase, this would be the ``UtilityNetworkAttribute`` that stores phase.
    final public var networkAttribute: ArcGIS.UtilityNetworkAttribute { get }

    /// The ``UtilityNetworkAttribute`` that maps each bit in another bitset network attribute value to a new value.
    final public var substitutionNetworkAttribute: ArcGIS.UtilityNetworkAttribute? { get }

    /// The value that is compared against the propagated value when executing the trace.
    ///
    /// The type of this numeric value is dependent on the ``UtilityNetworkAttribute/DataType-swift.enum`` of the ``UtilityNetworkAttribute``.
    final public var value: Any { get }
}

extension UtilityPropagator {

    /// Creates an object that allows a subset of ``UtilityNetworkAttribute`` values to propagate
    /// through a network.
    /// - Remark: This constructor allows the specification of a substitution network attribute.
    /// - Parameters:
    ///   - networkAttribute: The ``UtilityNetworkAttribute`` to propagate further along the trace.
    ///   - functionType: The function type that is applied to the
    ///   ``UtilityNetworkAttribute`` to propagate the attribute further along the trace.
    ///   - comparisonOperator: The filter operator that is applied when executing the trace. This
    ///   operator is used to compare the propagated value to the specified
    ///   ``UtilityPropagator/value``.
    ///   - value: The value that is compared against the propagated value when executing the trace.
    ///   - substitutionAttribute: An ``UtilityNetworkAttribute`` that maps each bit in another
    ///   bitset network attribute value to a new value.
    public convenience init(networkAttribute: ArcGIS.UtilityNetworkAttribute, functionType: ArcGIS.UtilityPropagator.FunctionType, comparisonOperator: ArcGIS.UtilityNetworkAttributeComparison.Operator, value: Any, substitutionAttribute: ArcGIS.UtilityNetworkAttribute? = nil)
}

extension UtilityPropagator.FunctionType : Equatable {
}

extension UtilityPropagator.FunctionType : Hashable {
}

/// Defines a permissible association between features in a utility network.
///
/// [Network rules](https://pro.arcgis.com/en/pro-app/latest/help/data/utility-network/network-rules.htm)
/// help maintain data integrity. They are imposed at the asset group, asset type, and terminal levels for the entire utility network
/// to manage the correctness of assets in the network by allowing you to select which types of features can be connected or associated.
/// A network rule supporting the type of association between features must exist or these features cannot be associated.
/// - Since: 200.1
final public class UtilityRule {

    /// An enumeration of the various types of network rules that determine permissible feature associations in a utility network.
    public enum Kind {

        /// A network rule governing connectivity between junction features.
        ///
        /// This connectivity network rule constrains the types of junction features that can be connected to a another junction feature based on its asset type.
        ///
        /// It supports terminal connectivity and affects ``UtilityAssociation/Kind-swift.enum/connectivity`` associations.
        case junctionJunctionConnectivity

        /// A network rule governing containment.
        ///
        /// Containment network rule constrains the types of features that can be contained in a given container feature based on its asset type.
        ///
        /// The ``UtilityRule/fromElement`` of this network rule represents a container and the ``UtilityRule/toElement`` represents a content
        /// or another container if nested containment is allowed.
        ///
        /// It does not support terminal connectivity and affects ``UtilityAssociation/Kind-swift.enum/containment`` associations.
        case containment

        /// A network rule governing structural attachment.
        ///
        /// Structural attachment network rule constrains the types of features that can be attached to a given structure feature based on its asset type.
        ///
        /// The ``UtilityRule/fromElement`` of this network rule represents a structure and the ``UtilityRule/toElement`` represents the attachments.
        ///
        /// It does not support terminal connectivity and affects ``UtilityAssociation/Kind-swift.enum/attachment`` associations.
        case attachment

        /// A network rule governing line-end connectivity to a device or junction.
        ///
        /// This connectivity network rule constrains the types of junction features that can be connected to edge features.
        ///
        /// The ``UtilityRule/fromElement`` of this network rule represents a junction and the ``UtilityRule/toElement`` represents an edge.
        ///
        /// It supports terminal connectivity and affects the following associations:
        /// * ``UtilityAssociation/Kind-swift.enum/junctionEdgeObjectConnectivityFromSide``, which allows a junction to be connected to the end point of an edge
        /// * ``UtilityAssociation/Kind-swift.enum/junctionEdgeObjectConnectivityMidspan``, which allows a junction to be connected along the midspan of an edge
        /// * ``UtilityAssociation/Kind-swift.enum/junctionEdgeObjectConnectivityToSide``, which allows a junction to be connected to the start point of an edge
        case junctionEdgeConnectivity

        /// A network rule governing connectivity between two edges and a junction.
        ///
        /// This connectivity network rule constrains the types of edge features that can be connected using an intermediate junction feature.
        case edgeJunctionEdgeConnectivity

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityRule.Kind, b: ArcGIS.UtilityRule.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// The first participant in a network rule.
    ///
    /// This may describe a container or structure feature, or any feature from which a connection
    /// to another feature can be made.
    final public var fromElement: ArcGIS.UtilityRuleElement { get }

    /// The ``Kind-swift.enum`` of this network rule.
    final public var kind: ArcGIS.UtilityRule.Kind { get }

    /// The ID of this network rule.
    final public var ruleID: Int { get }

    /// The second participant in a network rule.
    ///
    /// This may describe a content or attachment feature, a container feature in a nested containment,
    /// or any feature from which a connection to another feature can be made.
    final public var toElement: ArcGIS.UtilityRuleElement { get }

    /// An optional intermediate participant in a network rule.
    ///
    /// This is available only in a ``Kind-swift.enum/edgeJunctionEdgeConnectivity`` network rule
    /// and is commonly used to describe a junction feature without a terminal.
    final public var viaElement: ArcGIS.UtilityRuleElement? { get }
}

extension UtilityRule.Kind : Equatable {
}

extension UtilityRule.Kind : Hashable {
}

/// Specifies the type of features participating in a network rule.
///
/// A rule element describes the type of features to which a network rule is applied.
///
/// A rule element participating in a network rule can be one of the following:
///   * ``UtilityRule/fromElement``
///   * ``UtilityRule/toElement``
///   * ``UtilityRule/viaElement``
///
/// Attachment network rules place a structure feature in the ``UtilityRule/fromElement`` and attachment
/// features in the ``UtilityRule/toElement``. Containment network rules place a container feature
/// in the ``UtilityRule/fromElement`` and content features in the ``UtilityRule/toElement``. If nested
/// containment is allowed, another container feature may be placed in the ``UtilityRule/toElement``.
/// Connectivity network rules with an ``UtilityRule/viaElement`` have a junction feature.
///
/// Network rules that support terminal connectivity use these rule elements to define which terminal
/// the rule is applicable for.
/// - Since: 200.1
final public class UtilityRuleElement {

    /// The asset group that contains the asset type bound by a network rule.
    final public var assetGroup: ArcGIS.UtilityAssetGroup { get }

    /// The asset type bound by a network rule.
    final public var assetType: ArcGIS.UtilityAssetType { get }

    /// The network source that contains the asset group and asset type bound by a network rule.
    final public var networkSource: ArcGIS.UtilityNetworkSource { get }

    /// The terminal of the asset type where a network rule is applicable.
    ///
    /// Only applicable to asset types with terminals and network rules that support terminal connectivity.
    final public var terminal: ArcGIS.UtilityTerminal? { get }
}

/// A single terminal on a junction feature.
///
/// Terminal objects can be obtained from ``UtilityTerminalConfiguration/terminals``.
/// - Since: 200.1
final public class UtilityTerminal : Identifiable {

    /// The ID of the utility terminal.
    final public var id: Int { get }

    /// Whether this terminal is on the upstream side of the device.
    ///
    /// In source-based networks, upstream is towards the subnetwork controller. In sink-based networks, upstream is away from the subnetwork controller.
    final public var isUpstreamTerminal: Bool { get }

    /// The name of the utility terminal.
    final public var name: String { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = Int
}

extension UtilityTerminal : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.UtilityTerminal, rhs: ArcGIS.UtilityTerminal) -> Bool
}

extension UtilityTerminal : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    final public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    final public var hashValue: Int { get }
}

/// A utility network terminal configuration.
/// - Since: 200.1
final public class UtilityTerminalConfiguration : Identifiable {

    /// The configuration paths that constrain the flow paths between pairs of terminals.
    ///
    /// Of the set of possible paths that can be drawn between a set of terminals, these paths are the valid ones.
    /// If this ``UtilityTerminalConfiguration`` instance does not have configuration paths defined, an empty array is returned.
    final public var configurationPaths: [ArcGIS.UtilityTerminalConfigurationPath] { get }

    /// The default ``UtilityTerminalConfigurationPath`` defined for this terminal configuration.
    ///
    /// If this property returns `nil`, configuration paths do not apply to this terminal configuration.
    final public var defaultConfigurationPath: ArcGIS.UtilityTerminalConfigurationPath? { get }

    /// The directionality setting of terminals on a device.
    ///
    /// Directionality specifies whether flow through a device is one-way or bidirectional.
    final public var directionality: ArcGIS.UtilityTerminalDirectionality { get }

    /// The ID of the terminal configuration.
    final public var id: Int { get }

    /// The name of the terminal configuration.
    final public var name: String { get }

    /// The collection of terminals of the terminal configuration.
    final public var terminals: [ArcGIS.UtilityTerminal] { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = Int
}

/// The set of flow paths between terminals for a given device configuration.
/// - Since: 200.1
final public class UtilityTerminalConfigurationPath {

    /// The description of this ``UtilityTerminalConfigurationPath`` instance.
    final public var description: String { get }

    /// The name of this ``UtilityTerminalConfigurationPath`` instance.
    final public var name: String { get }

    /// The flow paths between pairs of terminals defined for this ``UtilityTerminalConfigurationPath`` instance.
    final public var terminalPaths: [ArcGIS.UtilityTerminalPath] { get }
}

/// An enumeration of the directionality setting of terminals on a device.
/// - Since: 200.1
public enum UtilityTerminalDirectionality {

    /// Only one flow direction is permissible.
    case unidirectional

    /// Both flow directions are permissible.
    case bidirectional

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.UtilityTerminalDirectionality, b: ArcGIS.UtilityTerminalDirectionality) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension UtilityTerminalDirectionality : Equatable {
}

extension UtilityTerminalDirectionality : Hashable {
}

/// Specifies a flow path between two ``UtilityTerminal`` objects.
/// - Since: 200.1
final public class UtilityTerminalPath {

    /// The ``UtilityTerminal`` that marks the beginning of the flow path.
    final public var fromTerminal: ArcGIS.UtilityTerminal { get }

    /// The ``UtilityTerminal`` that marks the end of the flow path.
    final public var toTerminal: ArcGIS.UtilityTerminal { get }
}

/// Tiers demarcate a logical level within a network.
///
/// For example, in an electric distribution network, there may be Subtransmission, Medium Voltage and Low Voltage tiers.
/// - Since: 200.1
final public class UtilityTier {

    /// Specifies the type of topology that makes up an ``UtilityTier`` definition.
    /// - Note: See Also: ``UtilityTier``
    public enum TopologyType {

        /// A radial network. Edges and junctions spread out radially from a single source.
        case radial

        /// A mesh network. Edges and junctions are connected to multiple sources in an interconnected lattice.
        case mesh

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityTier.TopologyType, b: ArcGIS.UtilityTier.TopologyType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Gets a copy of the ``UtilityTraceConfiguration`` for this ``UtilityTier``, if one is defined.
    final public var defaultTraceConfiguration: ArcGIS.UtilityTraceConfiguration? { get }

    /// The name of the ``UtilityTier``.
    final public var name: String { get }

    /// The numeric rank of the tier.
    ///
    /// It is possible for several tiers to have the same numeric rank.
    /// For example, in an electric distribution network, Radial Medium Voltage and Radial Multifeed Medium Voltage tiers would have the same rank.
    /// When doing a trace between a source tier and a target tier, the source and target tiers define a upper and lower tier value range for a trace.
    /// The trace will stop if it encounters a tier whose rank is outside the range specified by the source and target tiers.
    final public var rank: Int { get }

    /// The ``TopologyType-swift.enum`` of the tier.
    final public var topologyType: ArcGIS.UtilityTier.TopologyType { get }
}

extension UtilityTier.TopologyType : Equatable {
}

extension UtilityTier.TopologyType : Hashable {
}

/// Tier groups provide an extra level of organization for tiers.
///
/// For example, a gas network may be divided into two tier groups - Transmission and Distribution.
/// Each of these tier groups would contain a set of tiers specific to that group.
/// For example, Distribution Pressure and Distribution Isolation might be tiers within the Distribution tier group.
/// - Since: 200.1
final public class UtilityTierGroup {

    /// The name of the ``UtilityTierGroup``.
    final public var name: String { get }

    /// The collection of ``UtilityTier`` objects within this tier group.
    final public var tiers: [ArcGIS.UtilityTier] { get }

    /// Gets the ``UtilityTier`` object with the specified name.
    /// - Parameter tierName: The name of the desired ``UtilityTier`` object to return.
    /// - Returns: An ``UtilityTier`` object with the specified name.
    final public func tier(named tierName: String) -> ArcGIS.UtilityTier?
}

/// Combines two sub-expressions together using a logical AND operator.
/// - Since: 200.1
final public class UtilityTraceAndCondition : ArcGIS.UtilityTraceConditionalExpression {

    /// Creates a logical AND operator of two sub-expressions.
    /// - Parameters:
    ///   - leftExpression: The left sub-expression.
    ///   - rightExpression: The right sub-expression.
    public convenience init(leftExpression: ArcGIS.UtilityTraceConditionalExpression, rightExpression: ArcGIS.UtilityTraceConditionalExpression)

    /// The left sub-expression.
    final public var leftExpression: ArcGIS.UtilityTraceConditionalExpression { get }

    /// The right sub-expression.
    final public var rightExpression: ArcGIS.UtilityTraceConditionalExpression { get }
}

/// The base class for a utility network traversability condition.
/// - Since: 200.1
public class UtilityTraceCondition {
}

/// A trace condition that depends on the schema information in the Utility
/// Network, such as the existence of an ``UtilityCategory`` on a node, or
/// the value of an ``UtilityNetworkAttribute``.
/// - Since: 200.1
public class UtilityTraceConditionalExpression : ArcGIS.UtilityTraceCondition {
}

/// The set of utility network parameters that define elements of a trace or
/// of a subnetwork.
///
/// ``UtilityTraceConfiguration`` is set in the ``UtilityTraceParameters``.
/// - Since: 200.1
final public class UtilityTraceConfiguration {

    /// Creates an ``UtilityTraceConfiguration`` with default values.
    public convenience init()

    /// `true` to allow tracing across network features with indeterminate flow or `false` to stop the traversal when indeterminate flow is encountered.
    ///
    /// Indeterminate flow can occur when there is a loop in the network where traversal in either direction could be used to find the subnetwork controller
    /// (both upstream and downstream at the same time, in other words).
    /// This property is useful for upstream, downstream, or isolation traces where flow direction for the subnetwork is determined.
    /// This option is only applicable with Utility Network versions 5 or higher.
    /// The default is `true`.
    final public var allowsIndeterminateFlow: Bool

    /// The ``UtilityDomainNetwork`` from which to start the trace.
    ///
    /// The ``UtilityDomainNetwork`` property is required and only used with subnetwork-based traces (``UtilityTraceParameters/TraceType-swift.enum/subnetwork``, ``UtilityTraceParameters/TraceType-swift.enum/upstream``, etc.).
    final public var domainNetwork: ArcGIS.UtilityDomainNetwork?

    /// The criteria that define the dynamic barriers for the trace.
    final public var filter: ArcGIS.UtilityTraceFilter?

    /// A collection of ``UtilityTraceFunction`` objects to compute while performing the trace.
    ///
    /// Each ``UtilityTraceFunction`` returns an ``UtilityTraceFunctionOutput`` in the ``UtilityFunctionTraceResult``.
    final public var functions: [ArcGIS.UtilityTraceFunction] { get }

    /// Adds a sequence of `UtilityTraceFunction` values to the end of the `functions` property.
    /// - Parameter newFunctions: The new `UtilityTraceFunction` values to append.
    final public func addFunctions<S>(_ newFunctions: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceFunction

    /// Adds an `UtilityTraceFunction` value to the end of the `functions` property.
    /// - Parameter newFunction: The new `UtilityTraceFunction` value to append.
    final public func addFunction(_ newFunction: ArcGIS.UtilityTraceFunction)

    /// Inserts a collection of `UtilityTraceFunction` values into the `functions` property at the specified position.
    /// - Parameters:
    ///   - newFunctions: The new `UtilityTraceFunction` values to insert.
    ///   - index: The position at which to insert the new `UtilityTraceFunction` values.
    final public func insertFunctions<C>(_ newFunctions: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityTraceFunction

    /// Inserts an `UtilityTraceFunction` value into the `functions` property at the specified position.
    /// - Parameters:
    ///   - newFunction: The new `UtilityTraceFunction` value to insert.
    ///   - index: The position at which to insert the new `UtilityTraceFunction` value.
    final public func insertFunction(_ newFunction: ArcGIS.UtilityTraceFunction, at index: Int)

    /// Removes all values from the `functions` property.
    final public func removeAllFunctions()

    /// Removes a sequence of `UtilityTraceFunction` values from the `functions` property.
    /// - Parameter functions: The `UtilityTraceFunction` values to remove.
    final public func removeFunctions<S>(_ functions: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceFunction

    /// Removes an `UtilityTraceFunction` value from the `functions` property.
    /// - Parameter function: The `UtilityTraceFunction` value to remove.
    final public func removeFunction(_ function: ArcGIS.UtilityTraceFunction)

    /// Indicates whether to ignore barriers at starting points.
    ///
    /// The default is `false`.
    /// One example of how this can be used is with an upstream protective device trace.  The first call to the trace will return the first upstream device
    /// that meets the protective device criteria.  To find the next device upstream, you would set a starting point on the device returned by the first trace.
    /// With IgnoreBarriersAtStartingPoints set to `false`, this second trace would immediately stop at the starting point, since it meets the trace termination criteria.
    /// Setting this option to `true` will allow the trace to ignore the starting point, and continue to the subsequent device upstream.
    final public var ignoresBarriersAtStartingPoints: Bool

    /// Whether to include barriers in the trace results or
    /// subnetwork.
    ///
    /// The default is `true`.
    final public var includesBarriers: Bool

    /// Whether to include containment features in the trace results
    /// or subnetwork.
    ///
    /// The default is `false`.
    final public var includesContainers: Bool

    /// Whether to include content in the trace results or subnetwork.
    ///
    /// The default is `false`.
    final public var includesContent: Bool

    /// Whether to include isolated features in the trace results when used in conjunction with an isolation trace.
    ///
    /// The default is `false`.
    final public var includesIsolatedFeatures: Bool

    /// Whether to include structure features in the trace results or
    /// subnetwork.
    ///
    /// The default is `false`.
    final public var includesStructures: Bool

    /// `true` to include containment associations up to and including the first spatial container or `false` to include all containment associations.
    ///
    /// This property depends on the ``includesContainers`` property and is ignored if it's `false`.
    /// If no spatial containers are encountered but non-spatial containers are present for a given network element,
    /// all non-spatial containers are included in the results.
    /// This is typically used with telecommunications networks with multiple levels of containment with non-spatial objects
    /// (for example, splice points within a splice tray within a splice container).
    /// The default is `false`.
    final public var includesUpToFirstSpatialContainer: Bool

    /// A collection of ``UtilityAssetType`` objects which specifies what to include in the trace results.
    ///
    /// Only elements that belong to this ``UtilityAssetType`` are included in the trace result.
    /// This property is independent of asset types in the ``filter``.
    /// This is applied after all other tracing calculations, including traversal, filters, and function calculation.
    /// If this is empty and ``outputCondition`` is `nil`, all elements are returned.
    /// Otherwise, elements which match either of these criteria are returned.
    final public var outputAssetTypes: [ArcGIS.UtilityAssetType] { get }

    /// Adds a sequence of `UtilityAssetType` values to the end of the `outputAssetTypes` property.
    /// - Parameter newOutputAssetTypes: The new `UtilityAssetType` values to append.
    final public func addOutputAssetTypes<S>(_ newOutputAssetTypes: S) where S : Sequence, S.Element == ArcGIS.UtilityAssetType

    /// Adds an `UtilityAssetType` value to the end of the `outputAssetTypes` property.
    /// - Parameter newOutputAssetType: The new `UtilityAssetType` value to append.
    final public func addOutputAssetType(_ newOutputAssetType: ArcGIS.UtilityAssetType)

    /// Inserts a collection of `UtilityAssetType` values into the `outputAssetTypes` property at the specified position.
    /// - Parameters:
    ///   - newOutputAssetTypes: The new `UtilityAssetType` values to insert.
    ///   - index: The position at which to insert the new `UtilityAssetType` values.
    final public func insertOutputAssetTypes<C>(_ newOutputAssetTypes: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityAssetType

    /// Inserts an `UtilityAssetType` value into the `outputAssetTypes` property at the specified position.
    /// - Parameters:
    ///   - newOutputAssetType: The new `UtilityAssetType` value to insert.
    ///   - index: The position at which to insert the new `UtilityAssetType` value.
    final public func insertOutputAssetType(_ newOutputAssetType: ArcGIS.UtilityAssetType, at index: Int)

    /// Removes all values from the `outputAssetTypes` property.
    final public func removeAllOutputAssetTypes()

    /// Removes a sequence of `UtilityAssetType` values from the `outputAssetTypes` property.
    /// - Parameter outputAssetTypes: The `UtilityAssetType` values to remove.
    final public func removeOutputAssetTypes<S>(_ outputAssetTypes: S) where S : Sequence, S.Element == ArcGIS.UtilityAssetType

    /// Removes an `UtilityAssetType` value from the `outputAssetTypes` property.
    /// - Parameter outputAssetType: The `UtilityAssetType` value to remove.
    final public func removeOutputAssetType(_ outputAssetType: ArcGIS.UtilityAssetType)

    /// A condition object which specifies what to include in the trace results.
    ///
    /// Only elements that satisfy this ``UtilityTraceCondition`` are included in the trace result.
    /// This condition may perform comparisons against network attributes (``UtilityNetworkAttributeComparison``)
    /// and categories (``UtilityCategoryComparison``), or both (``UtilityTraceAndCondition``, ``UtilityTraceOrCondition``).
    /// This property is independent of barriers in the ``traversability`` or ``filter``.
    /// This is applied after all other tracing calculations, including traversal, filters, and function calculation.
    /// If this is `nil` and ``outputAssetTypes`` is empty, all elements are returned.
    /// Otherwise, elements which match either of these criteria are returned.
    final public var outputCondition: ArcGIS.UtilityTraceCondition?

    /// A collection of ``UtilityPropagator`` objects to execute while performing the trace.
    ///
    /// Propagator objects allow a subset of ``UtilityNetworkAttribute`` values to propagate through a network while executing a trace.
    /// For example, in phase propagation, open devices along the network will restrict some phases from continuing along the trace.
    /// Propagators only apply to subnetwork-based traces. (``UtilityTraceParameters/TraceType-swift.enum/upstream``, ``UtilityTraceParameters/TraceType-swift.enum/downstream``, and so on).
    final public var propagators: [ArcGIS.UtilityPropagator] { get }

    /// Adds a sequence of `UtilityPropagator` values to the end of the `propagators` property.
    /// - Parameter newPropagators: The new `UtilityPropagator` values to append.
    final public func addPropagators<S>(_ newPropagators: S) where S : Sequence, S.Element == ArcGIS.UtilityPropagator

    /// Adds an `UtilityPropagator` value to the end of the `propagators` property.
    /// - Parameter newPropagator: The new `UtilityPropagator` value to append.
    final public func addPropagator(_ newPropagator: ArcGIS.UtilityPropagator)

    /// Inserts a collection of `UtilityPropagator` values into the `propagators` property at the specified position.
    /// - Parameters:
    ///   - newPropagators: The new `UtilityPropagator` values to insert.
    ///   - index: The position at which to insert the new `UtilityPropagator` values.
    final public func insertPropagators<C>(_ newPropagators: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityPropagator

    /// Inserts an `UtilityPropagator` value into the `propagators` property at the specified position.
    /// - Parameters:
    ///   - newPropagator: The new `UtilityPropagator` value to insert.
    ///   - index: The position at which to insert the new `UtilityPropagator` value.
    final public func insertPropagator(_ newPropagator: ArcGIS.UtilityPropagator, at index: Int)

    /// Removes all values from the `propagators` property.
    final public func removeAllPropagators()

    /// Removes a sequence of `UtilityPropagator` values from the `propagators` property.
    /// - Parameter propagators: The `UtilityPropagator` values to remove.
    final public func removePropagators<S>(_ propagators: S) where S : Sequence, S.Element == ArcGIS.UtilityPropagator

    /// Removes an `UtilityPropagator` value from the `propagators` property.
    /// - Parameter propagator: The `UtilityPropagator` value to remove.
    final public func removePropagator(_ propagator: ArcGIS.UtilityPropagator)

    /// The ``UtilityNetworkAttribute`` used to calculate the shortest path.
    ///
    /// The shortest path may depend on some other numeric weight, such as cost or difficulty, rather than the shortest distance
    /// calculated from shape length.
    final public var shortestPathNetworkAttribute: ArcGIS.UtilityNetworkAttribute?

    /// The ``UtilityTier`` that is used as the start of the trace.
    ///
    /// This property is only used with subnetwork-based traces (subnetwork upstream, etc.).
    /// If ``domainNetwork`` represents a partitioned network, this property is optional.
    /// If not `nil`, the Trace routines will perform an additional check to validate that the starting points and barriers belong to this tier.
    /// If ``domainNetwork`` represents a hierarchical network, this property is required.
    /// Since rows in hierarchical networks can belong to multiple tiers, this property tells the subnetwork tracer which tier to use for tracing.
    final public var sourceTier: ArcGIS.UtilityTier?

    /// The ``UtilityTier`` that is used to constrain the tiers returned by the upstream and downstream traces.
    ///
    /// This property is optional.
    /// If `nil`, the upstream and downstream traces will stop in the current tier.
    /// If a target tier is specified, the trace will continue upstream or downstream into the specified tier (inclusive).
    final public var targetTier: ArcGIS.UtilityTier?

    /// The traversability conditions for the trace.
    final public var traversability: ArcGIS.UtilityTraversability?

    /// Indicates whether to validate network consistency as part of the trace operation.
    ///
    /// If set to `true`, trace operations will fail if dirty areas are encountered during the trace.  The default is `true`.
    final public var validatesConsistency: Bool

    /// `true` to fail trace operations if non-spatial objects are encountered without the necessary containment, attachment,
    /// or connectivity association to a spatial object, or `false` to allow tracing of those non-spatial objects.
    ///
    /// Locatability is determined by whether a non-spatial object has implied geometry. Geometry is implied for non-spatial objects if they are associated
    /// via containment (possibly multiple levels) with spatial features. This is typically used with telecommunications networks with many non-spatial objects.
    /// For example, if a splice tray (non-spatial junction object) is contained within a splice container (assembly feature), then it would be considered locatable.
    /// This property is only applicable for Utility Network versions 4 or later.
    /// The default is `false`.
    final public var validatesLocatability: Bool
}

/// A mechanism to stop tracing when returning results. ``UtilityTraceFilter`` objects do not stop traversability to the controller.
///
/// Consider an upstream protective device trace. At first, you might try defining an ``UtilityCategoryComparison``
/// that looks for a Protective Device category and assigning this to ``UtilityTraversability/barriers``. When you
/// try to run an upstream trace using this configuration, it will probably fail. This is because traversability
/// will stop at the first protective device, and the trace will be unable to find the subnetwork controller.
/// The correct way to implement this trace is to assign ``UtilityCategoryComparison`` to the filter.
///
/// ``UtilityTraceFilter`` is set in the ``UtilityTraceConfiguration``
/// - Since: 200.1
final public class UtilityTraceFilter {

    /// Creates an ``UtilityTraceFilter`` object with default values.
    public convenience init()

    /// A condition object specifying when to traverse a node or its subnodes.
    final public var barriers: ArcGIS.UtilityTraceCondition?

    /// Specifies that an ``UtilityNetworkAttribute`` stores a bitset, and this bitset should be used to filter results.
    final public var bitsetNetworkAttribute: ArcGIS.UtilityNetworkAttribute?

    /// A collection of ``UtilityTraceFunctionBarrier`` objects. If any of these objects evaluates to `true`, further traversal is terminated.
    final public var functionBarriers: [ArcGIS.UtilityTraceFunctionBarrier] { get }

    /// Adds a sequence of `UtilityTraceFunctionBarrier` values to the end of the `functionBarriers` property.
    /// - Parameter newFunctionBarriers: The new `UtilityTraceFunctionBarrier` values to append.
    final public func addFunctionBarriers<S>(_ newFunctionBarriers: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceFunctionBarrier

    /// Adds an `UtilityTraceFunctionBarrier` value to the end of the `functionBarriers` property.
    /// - Parameter newFunctionBarrier: The new `UtilityTraceFunctionBarrier` value to append.
    final public func addFunctionBarrier(_ newFunctionBarrier: ArcGIS.UtilityTraceFunctionBarrier)

    /// Inserts a collection of `UtilityTraceFunctionBarrier` values into the `functionBarriers` property at the specified position.
    /// - Parameters:
    ///   - newFunctionBarriers: The new `UtilityTraceFunctionBarrier` values to insert.
    ///   - index: The position at which to insert the new `UtilityTraceFunctionBarrier` values.
    final public func insertFunctionBarriers<C>(_ newFunctionBarriers: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityTraceFunctionBarrier

    /// Inserts an `UtilityTraceFunctionBarrier` value into the `functionBarriers` property at the specified position.
    /// - Parameters:
    ///   - newFunctionBarrier: The new `UtilityTraceFunctionBarrier` value to insert.
    ///   - index: The position at which to insert the new `UtilityTraceFunctionBarrier` value.
    final public func insertFunctionBarrier(_ newFunctionBarrier: ArcGIS.UtilityTraceFunctionBarrier, at index: Int)

    /// Removes all values from the `functionBarriers` property.
    final public func removeAllFunctionBarriers()

    /// Removes a sequence of `UtilityTraceFunctionBarrier` values from the `functionBarriers` property.
    /// - Parameter functionBarriers: The `UtilityTraceFunctionBarrier` values to remove.
    final public func removeFunctionBarriers<S>(_ functionBarriers: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceFunctionBarrier

    /// Removes an `UtilityTraceFunctionBarrier` value from the `functionBarriers` property.
    /// - Parameter functionBarrier: The `UtilityTraceFunctionBarrier` value to remove.
    final public func removeFunctionBarrier(_ functionBarrier: ArcGIS.UtilityTraceFunctionBarrier)

    /// A filter object specifying the next N features to be returned from the starting point.
    final public var nearestNeighbor: ArcGIS.UtilityNearestNeighbor?

    /// Determines whether traversability criteria are evaluated on edges, junctions, or both.
    ///
    /// The default value is ``UtilityTraversability/Scope-swift.enum/junctionsAndEdges``.
    final public var scope: ArcGIS.UtilityTraversability.Scope
}

/// Functions allow the computation of values during a network trace.
///
/// Functions are evaluated at each applicable network element. The meaning of applicable varies depending on the Tracer.
/// For an upstream trace, the functions are evaluated for each upstream element.
/// For a downstream trace, the functions are evaluated for each element in the subnetwork.
/// etc.
/// - Since: 200.1
final public class UtilityTraceFunction {

    /// The type of function calculation to perform.
    /// - Note: See Also: ``UtilityTraceFunction``
    public enum FunctionType {

        /// Computes the sum of the network attribute from each applicable element.
        case add

        /// Computes the average value of the network attribute from each applicable element.
        case average

        /// Counts the number of applicable elements.
        case count

        /// Computes the maximum value of the network attribute from each applicable element.
        case max

        /// Computes the minimum value of the network attribute from each applicable element.
        case min

        /// Takes the network attribute value from the starting point as the base number, and then subtracts the value of the network attribute from each applicable element.
        case subtract

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityTraceFunction.FunctionType, b: ArcGIS.UtilityTraceFunction.FunctionType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An ``UtilityTraceCondition`` to use to restrict the functional calculation to features that satisfy the condition.
    final public var condition: ArcGIS.UtilityTraceCondition?

    /// The calculation to perform.
    final public var functionType: ArcGIS.UtilityTraceFunction.FunctionType { get }

    /// The ``UtilityNetworkAttribute`` to use with the calculation.
    final public var networkAttribute: ArcGIS.UtilityNetworkAttribute { get }
}

extension UtilityTraceFunction {

    /// Creates a function object to compute a value from a network attribute.
    /// - Parameters:
    ///   - functionType: The calculation to perform.
    ///   - networkAttribute: The ``UtilityNetworkAttribute`` to use with the calculation.
    ///   - condition: An ``UtilityTraceCondition`` to use to restrict the functional calculation to features that satisfy the condition.
    public convenience init(functionType: ArcGIS.UtilityTraceFunction.FunctionType, networkAttribute: ArcGIS.UtilityNetworkAttribute, condition: ArcGIS.UtilityTraceCondition? = nil)
}

extension UtilityTraceFunction.FunctionType : Equatable {
}

extension UtilityTraceFunction.FunctionType : Hashable {
}

/// An ``UtilityTraceFunctionBarrier`` stops continued traversal when a comparison expression evaluates as `true`.
///
/// An ``UtilityTraceFunctionBarrier`` performs a comparison expression between the current results of an ``UtilityTraceFunction`` and a given value.
/// Remember that an ``UtilityTraceFunction`` references an ``UtilityNetworkAttribute`` and a calculation that is applied to it (Min, Max, Count, etc.)
/// Once the comparison evaluates as `true`, network traversal stops.
/// - Since: 200.1
final public class UtilityTraceFunctionBarrier {

    /// Creates a barrier that stops tracing when an ``UtilityTraceFunction`` compared to a value evaluates to `true`.
    /// - Parameters:
    ///   - traceFunction: The calculation to perform.
    ///   - comparisonOperator: The operator used for the comparison.
    ///   - value: The value to compare against.
    public convenience init(traceFunction: ArcGIS.UtilityTraceFunction, comparisonOperator: ArcGIS.UtilityNetworkAttributeComparison.Operator, value: Any)

    /// The operator used for the comparison.
    final public var comparisonOperator: ArcGIS.UtilityNetworkAttributeComparison.Operator { get }

    /// The calculation to perform.
    final public var traceFunction: ArcGIS.UtilityTraceFunction { get }

    /// The value to compare against.
    ///
    /// The type of this numeric value is dependent on the ``UtilityNetworkAttribute/DataType-swift.enum`` of the ``UtilityNetworkAttribute``.
    final public var value: Any { get }
}

/// An ``UtilityTraceFunctionOutput`` is comprised of an ``UtilityTraceFunction`` and its corresponding global result.
/// - Since: 200.1
final public class UtilityTraceFunctionOutput {

    /// The ``UtilityTraceFunction`` that was executed by the trace.
    final public var function: ArcGIS.UtilityTraceFunction { get }

    /// The global result of this ``UtilityTraceFunction``.
    ///
    /// The type of this numeric value is dependent on the ``UtilityNetworkAttribute/DataType-swift.enum`` of the ``UtilityNetworkAttribute``.
    final public var result: Any { get }
}

/// Two sub-expressions combined together using a logical OR operator.
/// - Since: 200.1
final public class UtilityTraceOrCondition : ArcGIS.UtilityTraceConditionalExpression {

    /// Creates a logical OR operator of two sub-expressions.
    /// - Parameters:
    ///   - leftExpression: The left sub-expression.
    ///   - rightExpression: The right sub-expression.
    public convenience init(leftExpression: ArcGIS.UtilityTraceConditionalExpression, rightExpression: ArcGIS.UtilityTraceConditionalExpression)

    /// The left sub-expression.
    final public var leftExpression: ArcGIS.UtilityTraceConditionalExpression { get }

    /// The right sub-expression.
    final public var rightExpression: ArcGIS.UtilityTraceConditionalExpression { get }
}

/// Utility network trace parameters.
/// - Since: 200.1
final public class UtilityTraceParameters {

    /// An enumeration of the result types returned by a trace operation.
    ///
    /// The default is ``elements``.
    public enum ResultType {

        /// An array of ``UtilityElement`` objects.
        case elements

        /// An array of ``UtilityTraceFunctionOutput`` objects.
        case functionOutputs

        /// A trace result consisting of three distinct ``Geometry`` types:
        /// a ``Polygon``, a ``Polyline``, and a ``Multipoint``.
        case geometry

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityTraceParameters.ResultType, b: ArcGIS.UtilityTraceParameters.ResultType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An enumeration of the various types of traces that may be performed with a utility network.
    public enum TraceType {

        /// A connected trace
        ///
        /// Finds all features connected to a given set of starting points, ignoring traversability.
        case connected

        /// A subnetwork trace
        ///
        /// Finds all features within the current subnetwork.
        case subnetwork

        /// An upstream trace
        ///
        /// For subnetworks with sources, upstream is defined as paths that lead to a source.
        /// For subnetworks with sinks, upstream is defined as paths that do not lead to a sink.
        case upstream

        /// A downstream trace
        ///
        /// For subnetworks with sources, downstream is defined as paths that do not lead to a source.
        /// For subnetworks with sinks, downstream is defined as paths that lead to a sink.
        case downstream

        /// An isolation trace
        ///
        /// The isolation trace requires that at least one ``UtilityTraceFilter`` barrier is set in the
        /// ``UtilityTraceConfiguration``. Typically this filter identifies those features that isolate
        /// the section of network (e.g., valves).
        case isolation

        /// Detects loops in the network
        ///
        /// The loops trace finds areas of the network where flow direction is ambiguous where resource
        /// can flow in either direction. Loops are expected with mesh networks but usually indicate error
        /// conditions in radial networks.
        case loops

        /// Discovers the shortest path
        ///
        /// This trace returns the shortest path based on cost or distance, which is calculated
        /// using a numeric network attribute such as shape length.
        case shortestPath

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityTraceParameters.TraceType, b: ArcGIS.UtilityTraceParameters.TraceType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Constructs a new ``UtilityTraceParameters`` from a pre-defined trace options
    /// with the supplied starting locations.
    /// - Parameters:
    ///   - namedTraceConfiguration: The ``UtilityNamedTraceConfiguration`` from which the ``UtilityTraceParameters`` object is generated.
    ///   - startingLocations: The collection of starting locations
    /// - Note: See Also: ``UtilityNamedTraceConfiguration``
    public convenience init(namedTraceConfiguration: ArcGIS.UtilityNamedTraceConfiguration, startingLocations: [ArcGIS.UtilityElement])

    /// Constructs a new ``UtilityTraceParameters`` for the specified trace type and
    /// with the supplied starting locations.
    /// - Parameters:
    ///   - traceType: The type of trace to perform.
    ///   - startingLocations: The collection of starting locations.
    public convenience init(traceType: ArcGIS.UtilityTraceParameters.TraceType, startingLocations: [ArcGIS.UtilityElement])

    /// The collection of barriers
    final public var barriers: [ArcGIS.UtilityElement] { get }

    /// Adds a sequence of `UtilityElement` values to the end of the `barriers` property.
    /// - Parameter newBarriers: The new `UtilityElement` values to append.
    final public func addBarriers<S>(_ newBarriers: S) where S : Sequence, S.Element == ArcGIS.UtilityElement

    /// Adds an `UtilityElement` value to the end of the `barriers` property.
    /// - Parameter newBarrier: The new `UtilityElement` value to append.
    final public func addBarrier(_ newBarrier: ArcGIS.UtilityElement)

    /// Inserts a collection of `UtilityElement` values into the `barriers` property at the specified position.
    /// - Parameters:
    ///   - newBarriers: The new `UtilityElement` values to insert.
    ///   - index: The position at which to insert the new `UtilityElement` values.
    final public func insertBarriers<C>(_ newBarriers: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityElement

    /// Inserts an `UtilityElement` value into the `barriers` property at the specified position.
    /// - Parameters:
    ///   - newBarrier: The new `UtilityElement` value to insert.
    ///   - index: The position at which to insert the new `UtilityElement` value.
    final public func insertBarrier(_ newBarrier: ArcGIS.UtilityElement, at index: Int)

    /// Removes all values from the `barriers` property.
    final public func removeAllBarriers()

    /// Removes a sequence of `UtilityElement` values from the `barriers` property.
    /// - Parameter barriers: The `UtilityElement` values to remove.
    final public func removeBarriers<S>(_ barriers: S) where S : Sequence, S.Element == ArcGIS.UtilityElement

    /// Removes an `UtilityElement` value from the `barriers` property.
    /// - Parameter barrier: The `UtilityElement` value to remove.
    final public func removeBarrier(_ barrier: ArcGIS.UtilityElement)

    /// The collection of filter barriers.
    ///
    /// A regular barrier, specified by ``barriers``, prevents traversal which, when used with subnetwork-based traces, can prevent traversal
    /// to the subnetwork controller. Like ``UtilityTraceConfiguration/filter``, filter barriers are evaluated in the second pass of a trace. Therefore, it can restrict
    /// the result set without impacting the ability to find subnetwork controllers from starting points.
    ///
    /// One example of where filter barriers can be used is in the gas distribution domain. Filter barriers can be used to simulate the location of a squeeze-off
    /// when executing a valve isolation trace. The user can place a filter barrier at the proposed location of the squeeze-off and then verify its impact using a trace.
    final public var filterBarriers: [ArcGIS.UtilityElement] { get }

    /// Adds a sequence of `UtilityElement` values to the end of the `filterBarriers` property.
    /// - Parameter newFilterBarriers: The new `UtilityElement` values to append.
    final public func addFilterBarriers<S>(_ newFilterBarriers: S) where S : Sequence, S.Element == ArcGIS.UtilityElement

    /// Adds an `UtilityElement` value to the end of the `filterBarriers` property.
    /// - Parameter newFilterBarrier: The new `UtilityElement` value to append.
    final public func addFilterBarrier(_ newFilterBarrier: ArcGIS.UtilityElement)

    /// Inserts a collection of `UtilityElement` values into the `filterBarriers` property at the specified position.
    /// - Parameters:
    ///   - newFilterBarriers: The new `UtilityElement` values to insert.
    ///   - index: The position at which to insert the new `UtilityElement` values.
    final public func insertFilterBarriers<C>(_ newFilterBarriers: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityElement

    /// Inserts an `UtilityElement` value into the `filterBarriers` property at the specified position.
    /// - Parameters:
    ///   - newFilterBarrier: The new `UtilityElement` value to insert.
    ///   - index: The position at which to insert the new `UtilityElement` value.
    final public func insertFilterBarrier(_ newFilterBarrier: ArcGIS.UtilityElement, at index: Int)

    /// Removes all values from the `filterBarriers` property.
    final public func removeAllFilterBarriers()

    /// Removes a sequence of `UtilityElement` values from the `filterBarriers` property.
    /// - Parameter filterBarriers: The `UtilityElement` values to remove.
    final public func removeFilterBarriers<S>(_ filterBarriers: S) where S : Sequence, S.Element == ArcGIS.UtilityElement

    /// Removes an `UtilityElement` value from the `filterBarriers` property.
    /// - Parameter filterBarrier: The `UtilityElement` value to remove.
    final public func removeFilterBarrier(_ filterBarrier: ArcGIS.UtilityElement)

    /// A collection that is pre-populated with the default of ``ResultType/elements``;
    /// it corresponds to the ``UtilityTraceResult`` collection returned by `UtilityNetwork.trace(using:)`.
    final public var resultTypes: [ArcGIS.UtilityTraceParameters.ResultType] { get }

    /// Adds a sequence of `ResultType` values to the end of the `resultTypes` property.
    /// - Parameter newResultTypes: The new `ResultType` values to append.
    final public func addResultTypes<S>(_ newResultTypes: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceParameters.ResultType

    /// Adds a `ResultType` value to the end of the `resultTypes` property.
    /// - Parameter newResultType: The new `ResultType` value to append.
    final public func addResultType(_ newResultType: ArcGIS.UtilityTraceParameters.ResultType)

    /// Inserts a collection of `ResultType` values into the `resultTypes` property at the specified position.
    /// - Parameters:
    ///   - newResultTypes: The new `ResultType` values to insert.
    ///   - index: The position at which to insert the new `ResultType` values.
    final public func insertResultTypes<C>(_ newResultTypes: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityTraceParameters.ResultType

    /// Inserts a `ResultType` value into the `resultTypes` property at the specified position.
    /// - Parameters:
    ///   - newResultType: The new `ResultType` value to insert.
    ///   - index: The position at which to insert the new `ResultType` value.
    final public func insertResultType(_ newResultType: ArcGIS.UtilityTraceParameters.ResultType, at index: Int)

    /// Removes all values from the `resultTypes` property.
    final public func removeAllResultTypes()

    /// Removes a sequence of `ResultType` values from the `resultTypes` property.
    /// - Parameter resultTypes: The `ResultType` values to remove.
    final public func removeResultTypes<S>(_ resultTypes: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceParameters.ResultType

    /// Removes a `ResultType` value from the `resultTypes` property.
    /// - Parameter resultType: The `ResultType` value to remove.
    final public func removeResultType(_ resultType: ArcGIS.UtilityTraceParameters.ResultType)

    /// The collection of starting locations.
    final public var startingLocations: [ArcGIS.UtilityElement] { get }

    /// Adds a sequence of `UtilityElement` values to the end of the `startingLocations` property.
    /// - Parameter newStartingLocations: The new `UtilityElement` values to append.
    final public func addStartingLocations<S>(_ newStartingLocations: S) where S : Sequence, S.Element == ArcGIS.UtilityElement

    /// Adds an `UtilityElement` value to the end of the `startingLocations` property.
    /// - Parameter newStartingLocation: The new `UtilityElement` value to append.
    final public func addStartingLocation(_ newStartingLocation: ArcGIS.UtilityElement)

    /// Inserts a collection of `UtilityElement` values into the `startingLocations` property at the specified position.
    /// - Parameters:
    ///   - newStartingLocations: The new `UtilityElement` values to insert.
    ///   - index: The position at which to insert the new `UtilityElement` values.
    final public func insertStartingLocations<C>(_ newStartingLocations: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityElement

    /// Inserts an `UtilityElement` value into the `startingLocations` property at the specified position.
    /// - Parameters:
    ///   - newStartingLocation: The new `UtilityElement` value to insert.
    ///   - index: The position at which to insert the new `UtilityElement` value.
    final public func insertStartingLocation(_ newStartingLocation: ArcGIS.UtilityElement, at index: Int)

    /// Removes all values from the `startingLocations` property.
    final public func removeAllStartingLocations()

    /// Removes a sequence of `UtilityElement` values from the `startingLocations` property.
    /// - Parameter startingLocations: The `UtilityElement` values to remove.
    final public func removeStartingLocations<S>(_ startingLocations: S) where S : Sequence, S.Element == ArcGIS.UtilityElement

    /// Removes an `UtilityElement` value from the `startingLocations` property.
    /// - Parameter startingLocation: The `UtilityElement` value to remove.
    final public func removeStartingLocation(_ startingLocation: ArcGIS.UtilityElement)

    /// The complete collection of trace options.
    final public var traceConfiguration: ArcGIS.UtilityTraceConfiguration?

    /// The trace type.
    final public var traceType: ArcGIS.UtilityTraceParameters.TraceType { get }
}

extension UtilityTraceParameters.ResultType : Equatable {
}

extension UtilityTraceParameters.ResultType : Hashable {
}

extension UtilityTraceParameters.TraceType : Equatable {
}

extension UtilityTraceParameters.TraceType : Hashable {
}

/// The base class for trace result objects.
/// - Since: 200.1
public class UtilityTraceResult {

    /// A value indicating the result of ``UtilityNearestNeighbor`` in relation to its requested count.
    public var nearestNeighborResult: ArcGIS.UtilityNearestNeighborResult { get }

    /// The list of warnings encountered while performing the trace.
    public var warnings: [String] { get }
}

/// A set of options controlling what objects are evaluated or returned
/// during a tracing operation.
///
/// ``UtilityTraversability`` is set in the ``UtilityTraceConfiguration``.
/// - Since: 200.1
final public class UtilityTraversability {

    /// Used to specify whether traversability criteria are applied to junctions, edges, or both.
    /// - Note: See Also: ``UtilityTraversability``
    public enum Scope {

        /// The traversability criteria should be evaluated at both junctions and edges.
        case junctionsAndEdges

        /// The traversability criteria should only be evaluated at junctions.
        case junctions

        /// The traversability criteria should only be evaluated at edges.
        case edges

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.UtilityTraversability.Scope, b: ArcGIS.UtilityTraversability.Scope) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates an ``UtilityTraversability`` object with default values.
    public convenience init()

    /// A condition object specifying when to traverse a node or its subnodes.
    final public var barriers: ArcGIS.UtilityTraceCondition?

    /// A collection of ``UtilityTraceFunctionBarrier`` objects. If any of these objects evaluates to `true`, further traversal is terminated.
    final public var functionBarriers: [ArcGIS.UtilityTraceFunctionBarrier] { get }

    /// Adds a sequence of `UtilityTraceFunctionBarrier` values to the end of the `functionBarriers` property.
    /// - Parameter newFunctionBarriers: The new `UtilityTraceFunctionBarrier` values to append.
    final public func addFunctionBarriers<S>(_ newFunctionBarriers: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceFunctionBarrier

    /// Adds an `UtilityTraceFunctionBarrier` value to the end of the `functionBarriers` property.
    /// - Parameter newFunctionBarrier: The new `UtilityTraceFunctionBarrier` value to append.
    final public func addFunctionBarrier(_ newFunctionBarrier: ArcGIS.UtilityTraceFunctionBarrier)

    /// Inserts a collection of `UtilityTraceFunctionBarrier` values into the `functionBarriers` property at the specified position.
    /// - Parameters:
    ///   - newFunctionBarriers: The new `UtilityTraceFunctionBarrier` values to insert.
    ///   - index: The position at which to insert the new `UtilityTraceFunctionBarrier` values.
    final public func insertFunctionBarriers<C>(_ newFunctionBarriers: C, at index: Int) where C : Collection, C.Element == ArcGIS.UtilityTraceFunctionBarrier

    /// Inserts an `UtilityTraceFunctionBarrier` value into the `functionBarriers` property at the specified position.
    /// - Parameters:
    ///   - newFunctionBarrier: The new `UtilityTraceFunctionBarrier` value to insert.
    ///   - index: The position at which to insert the new `UtilityTraceFunctionBarrier` value.
    final public func insertFunctionBarrier(_ newFunctionBarrier: ArcGIS.UtilityTraceFunctionBarrier, at index: Int)

    /// Removes all values from the `functionBarriers` property.
    final public func removeAllFunctionBarriers()

    /// Removes a sequence of `UtilityTraceFunctionBarrier` values from the `functionBarriers` property.
    /// - Parameter functionBarriers: The `UtilityTraceFunctionBarrier` values to remove.
    final public func removeFunctionBarriers<S>(_ functionBarriers: S) where S : Sequence, S.Element == ArcGIS.UtilityTraceFunctionBarrier

    /// Removes an `UtilityTraceFunctionBarrier` value from the `functionBarriers` property.
    /// - Parameter functionBarrier: The `UtilityTraceFunctionBarrier` value to remove.
    final public func removeFunctionBarrier(_ functionBarrier: ArcGIS.UtilityTraceFunctionBarrier)

    /// Determines whether traversability criteria are evaluated on edges, junctions, or both.
    ///
    /// The default value is ``Scope-swift.enum/junctionsAndEdges``.
    final public var scope: ArcGIS.UtilityTraversability.Scope
}

extension UtilityTraversability.Scope : Equatable {
}

extension UtilityTraversability.Scope : Hashable {
}

/// The ``VectorMarkerSymbolElement`` represents a component of a vector marker. A single
/// ``VectorMarkerSymbolElement`` is a combination of a symbol and a geometry.
///
/// The symbol held by the ``VectorMarkerSymbolElement`` is itself a ``MultilayerSymbol``. The geometry
/// of the ``VectorMarkerSymbolElement`` does not pertain to the geography of the Map or Scene. Rather,
/// the geometry property describes the shape of the Multilayer_symbol held by the ``VectorMarkerSymbolElement``.
/// The coordinate values defining the geometry are in points. This behavior facilitates creating a custom
/// ``VectorMarkerSymbolElement`` of custom shape and symbol, then combining it with zero or more other
/// elements to form a vector marker.
///
/// To create a red square, for example, construct a ``VectorMarkerSymbolElement`` with a
/// ``MultilayerPolygonSymbol`` that contains a red ``SolidFillSymbolLayer`` and a square
/// geometry. When combined in a ``VectorMarkerSymbolElement`` and placed in a
/// ``VectorMarkerSymbolLayer`` a red square displays.
///
/// The symbol and geometry properties must create a meaningful combination to have a visual effect. For example,
/// a ``MultilayerPolygonSymbol`` does not draw anything if the corresponding geometry is a point, but does
/// draw if the geometry is a polygon.
/// - Since: 200.1
final public class VectorMarkerSymbolElement {

    /// Creates a vector marker symbol element with geometry and symbol.
    ///
    /// This constructor creates a ``VectorMarkerSymbolElement`` using the geometry and symbol arguments
    /// provided.
    /// - Parameters:
    ///   - geometry: The geometry that defines the shape of the symbol.
    ///   - multilayerSymbol: The element's symbol.
    public convenience init(geometry: ArcGIS.Geometry, multilayerSymbol: ArcGIS.MultilayerSymbol)

    /// The geometry of the vector marker symbol element.
    ///
    /// The geometry can be a point, polyline, or polygon. When rendering, the symbol draws according to the
    /// shape of the geometry. When setting a geometry, make sure that the corresponding symbol is appropriate for
    /// the desired drawing effect. For instance, a polygon geometry would pair best with a
    /// ``MultilayerPolygonSymbol``, drawing the symbol with the polygon geometry. The coordinate values
    /// defining the geometry are in points.
    /// `CoreErrorCode.commonInvalidArgument` Raised when either the vector marker symbol element or geometry parameter is `nil`.
    final public var geometry: ArcGIS.Geometry?

    /// A multilayer symbol on a vector marker symbol element.
    ///
    /// The symbol, a ``MultilayerSymbol``, can be any arbitrary multilayer symbol. When rendering, the symbol
    /// draws according to the shape of the geometry. When setting a symbol, make sure that the corresponding
    /// geometry is appropriate for the desired drawing effect. For instance, a ``MultilayerPolygonSymbol``
    /// would pair best with a polygon geometry, drawing the symbol with the polygon geometry.
    /// `CoreErrorCode.commonInvalidArgument` Raised when either the vector marker symbol element or symbol parameter is `nil`.
    final public var multilayerSymbol: ArcGIS.MultilayerSymbol?
}

/// The ``VectorMarkerSymbolLayer`` represents a marker comprising vector graphics.
///
/// The ``VectorMarkerSymbolLayer`` is constructed from a collection of ``VectorMarkerSymbolElement``
/// which define the building blocks of the vector marker.
///
/// If it is the sole symbol layer in a ``MultilayerPointSymbol``, this symbol layer places a vector
/// marker at the location of the point feature.
///
/// This symbol layer is similar to the Web Scene specification's IconSymbol3DLayer, when the
/// IconSymbol3DLayer references a primitive shape.
/// - Since: 200.1
final public class VectorMarkerSymbolLayer : ArcGIS.MarkerSymbolLayer {

    /// Creates a vector marker symbol layer with a collection of vector marker symbol elements.
    ///
    /// This function creates a ``VectorMarkerSymbolLayer``, then sets the given vector of
    /// ``VectorMarkerSymbolElement`` as the collection comprising the vector marker.
    /// - Parameter vectorMarkerSymbolElements: The collection of elements of type ``VectorMarkerSymbolElement``.
    public convenience init(vectorMarkerSymbolElements: [ArcGIS.VectorMarkerSymbolElement])

    /// The collection of vector marker symbol elements held by the vector marker symbol layer.
    ///
    /// This function takes the input collection and sets it as the element collection of the symbol layer.
    /// The existing collection of symbol elements is removed and replaced with the new elements.
    final public var vectorMarkerSymbolElements: [ArcGIS.VectorMarkerSymbolElement] { get }

    /// Adds a sequence of `VectorMarkerSymbolElement` values to the end of the `vectorMarkerSymbolElements` property.
    /// - Parameter newVectorMarkerSymbolElements: The new `VectorMarkerSymbolElement` values to append.
    final public func addVectorMarkerSymbolElements<S>(_ newVectorMarkerSymbolElements: S) where S : Sequence, S.Element == ArcGIS.VectorMarkerSymbolElement

    /// Adds a `VectorMarkerSymbolElement` value to the end of the `vectorMarkerSymbolElements` property.
    /// - Parameter newVectorMarkerSymbolElement: The new `VectorMarkerSymbolElement` value to append.
    final public func addVectorMarkerSymbolElement(_ newVectorMarkerSymbolElement: ArcGIS.VectorMarkerSymbolElement)

    /// Inserts a collection of `VectorMarkerSymbolElement` values into the `vectorMarkerSymbolElements` property at the specified position.
    /// - Parameters:
    ///   - newVectorMarkerSymbolElements: The new `VectorMarkerSymbolElement` values to insert.
    ///   - index: The position at which to insert the new `VectorMarkerSymbolElement` values.
    final public func insertVectorMarkerSymbolElements<C>(_ newVectorMarkerSymbolElements: C, at index: Int) where C : Collection, C.Element == ArcGIS.VectorMarkerSymbolElement

    /// Inserts a `VectorMarkerSymbolElement` value into the `vectorMarkerSymbolElements` property at the specified position.
    /// - Parameters:
    ///   - newVectorMarkerSymbolElement: The new `VectorMarkerSymbolElement` value to insert.
    ///   - index: The position at which to insert the new `VectorMarkerSymbolElement` value.
    final public func insertVectorMarkerSymbolElement(_ newVectorMarkerSymbolElement: ArcGIS.VectorMarkerSymbolElement, at index: Int)

    /// Removes all values from the `vectorMarkerSymbolElements` property.
    final public func removeAllVectorMarkerSymbolElements()

    /// Removes a sequence of `VectorMarkerSymbolElement` values from the `vectorMarkerSymbolElements` property.
    /// - Parameter vectorMarkerSymbolElements: The `VectorMarkerSymbolElement` values to remove.
    final public func removeVectorMarkerSymbolElements<S>(_ vectorMarkerSymbolElements: S) where S : Sequence, S.Element == ArcGIS.VectorMarkerSymbolElement

    /// Removes a `VectorMarkerSymbolElement` value from the `vectorMarkerSymbolElements` property.
    /// - Parameter vectorMarkerSymbolElement: The `VectorMarkerSymbolElement` value to remove.
    final public func removeVectorMarkerSymbolElement(_ vectorMarkerSymbolElement: ArcGIS.VectorMarkerSymbolElement)
}

/// Metadata for a local cache of vector map tiles that can be used to create a layer.
///
/// Local tile caches are ideal for providing basemaps or less frequently changing contextual layers, where
/// network access is limited or non-existent. They can be created and downloaded onto a device by using an
/// ``ExportVectorTilesJob``, or alternatively can be provisioned directly to local storage. Currently the
/// only supported type of cache is:
/// - Vector tile package (.vtpk) - a map and the tile cache of the data contained within it, packaged into one convenient,
/// portable file, ideal for offline sharing or complete map documents in a disconnected environment or via a portal.
///
/// A VectorTileCache is often used as a basemap, but can also be used to create an ``ArcGISVectorTiledLayer`` that is added to
/// a map as an operational layer.
/// - Since: 200.1
final public class VectorTileCache : ArcGIS.Loadable {

    /// Create a vector tile cache with the given path.
    /// - Parameter fileURL: path
    public convenience init(fileURL: URL)

    /// The path to the on disk source file for this vector tile cache.
    ///
    /// This path can be empty when the vector tile cache is contained within a ``MobileMapPackage`` or
    /// ``MobileScenePackage``.
    final public var fileURL: URL? { get }

    /// Source info.
    final public var sourceInfo: ArcGIS.VectorTileSourceInfo? { get }

    /// Thumbnail.
    final public var thumbnail: UIImage? { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// This object represents the source metadata for a vector tile layer.
/// - Note: See Also: ``ArcGISVectorTiledLayer/sourceInfo``
/// - Since: 200.1
final public class VectorTileSourceInfo {

    /// Determines if this source supports exporting tiles.
    final public var allowsExportingTiles: Bool { get }

    /// The default style object.
    /// - Note: See Also: ``VectorTileStyle``
    final public var defaultStyle: ArcGIS.VectorTileStyle? { get }

    /// The current the default style URI.
    final public var defaultStyleURL: URL { get }

    /// The full extent of the source data.
    final public var fullExtent: ArcGIS.Envelope? { get }

    /// The initial extent of the source data.
    final public var initialExtent: ArcGIS.Envelope? { get }

    /// The levels of detail of the source data.
    /// - Note: See Also: ``LevelOfDetail``
    final public var levelsOfDetail: [ArcGIS.LevelOfDetail] { get }

    /// The maximum number of tiles that can be exported from the service.
    final public var maxExportTilesCount: Int { get }

    /// The maximum scale. If `nil`, there is no maximum.
    final public var maxScale: Double? { get }

    /// The minimum scale. If `nil`, there is no minimum.
    final public var minScale: Double? { get }

    /// The source name.
    final public var name: String { get }

    /// The origin of the source data.
    final public var origin: ArcGIS.Point? { get }

    /// The spatial reference of the source data.
    /// - Note: See Also: ``SpatialReference``
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The vector tile source URI.
    final public var url: URL { get }

    /// The source version.
    final public var version: String { get }
}

/// This object represents the style information for a vector tile layer.
/// - Note: See Also: ``VectorTileSourceInfo/defaultStyle``, ``ArcGISVectorTiledLayer/style``
/// - Since: 200.1
final public class VectorTileStyle {

    /// The vector tile source URI.
    final public var sourceURL: URL { get }

    /// The style version.
    final public var version: String { get }
}

/// A three part version number with a major version, a minor version, and a
/// patch version.
/// - Since: 200.1
public struct Version : Hashable {

    /// The major version number.
    public let major: Int

    /// The minor version number.
    public let minor: Int

    /// The patch version number.
    public let patch: Int

    /// Creates a version with the provided major, minor and patch versions.
    /// - Parameters:
    ///   - major: The major version number.
    ///   - minor: The minor version number.
    ///   - patch: The patch version number.
    /// - Precondition: The `major`, `minor`, and `patch` version numbers must be `>= 0`.
    public init(major: Int, minor: Int, patch: Int = 0)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.Version, b: ArcGIS.Version) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension Version : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: ArcGIS.Version, rhs: ArcGIS.Version) -> Bool
}

extension Version : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Version : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init?(_ description: String)
}

extension Version : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

/// The access permissions of a version in a branch-versioned service.
/// - Note: See Also: ``ServiceGeodatabase``
/// - Since: 200.1
public enum VersionAccess {

    /// The version is public.
    ///
    /// Any portal user can view and edit the version.
    case `public`

    /// The version is protected.
    ///
    /// Any portal user can view, but only the version owner, feature layer
    /// owner, and portal administrator can edit the version.
    case protected

    /// The version is private.
    ///
    /// Only the version owner, feature layer owner, and portal administrator
    /// can view and edit the version.
    case `private`

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.VersionAccess, b: ArcGIS.VersionAccess) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension VersionAccess : Equatable {
}

extension VersionAccess : Hashable {
}

/// Allows you to edit geometries in a ``GeometryEditor`` by interacting with individual vertices.
///
/// The default ``GeometryEditor/tool`` is a ``VertexTool``, and is suitable for creating and editing the widest
/// range of geometry types - ``Multipoint``, ``Point``, ``Polygon``, and ``Polyline``. You create and edit these
/// geometries by creating, selecting, and transforming individual vertices, and can also select and transform parts
/// of ``Multipart`` (polygon and polyline) geometries. Use the ``configuration`` properties to customize
/// the possible interactions.
/// - Note: See Also: ``FreehandTool``
/// - Since: 200.1
final public class VertexTool : ArcGIS.GeometryEditorTool {

    /// Creates a new ``VertexTool``.
    ///
    /// By default, this tool enables the creation, selection, transformation, and deletion interactions appropriate
    /// for creating and editing geometries by interacting with individual vertices. This behavior can be customized
    /// with ``configuration``.
    public convenience init()

    /// Defines the set of interactive operations enabled when using this tool.
    ///
    /// By default, the ``configuration`` allows you to create and select vertices by tapping on the
    /// map, and also allows you to move vertices by dragging the selected vertex.
    ///
    /// By default, it does not allow the creation of new parts, but does allow the selection, transformation, and
    /// deletion of any existing parts if they already exist in the ``GeometryEditor/geometry``. Set
    /// ``InteractionConfiguration/allowsPartCreation`` to `true` to allow you to tap on the view when there is no
    /// current selection (``GeometryEditor/selectedElement`` is `nil`) to start new parts in polyline and polygon
    /// geometries.
    final public var configuration: ArcGIS.InteractionConfiguration
}

/// A location on a view.
///
/// An immutable object used to set a location on a view.
/// - Since: 200.1
public struct Viewpoint {
}

extension Viewpoint {

    /// Different types of ``Viewpoint``.
    /// - Note: See Also: ``Viewpoint/kind-swift.property``
    public enum Kind {

        /// A center point and scale.
        case centerAndScale

        /// A visible area.
        case boundingGeometry

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.Viewpoint.Kind, b: ArcGIS.Viewpoint.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension Viewpoint {

    /// The viewpoint's ``Camera``.
    /// - Note: See Also: ``Viewpoint``, ``Camera``
    public var camera: ArcGIS.Camera? { get }

    /// The viewpoint's type.
    /// - Note: See Also: ``Viewpoint``, ``Kind-swift.enum``
    public var kind: ArcGIS.Viewpoint.Kind { get }

    /// The viewpoint rotation angle in degrees between 0 and 360.
    /// - Note: See Also: ``Viewpoint``
    public var rotation: Double { get }

    /// The viewpoint target geometry.
    /// - Note: See Also: ``Viewpoint``, ``kind-swift.property``
    public var targetGeometry: ArcGIS.Geometry { get }

    /// The viewpoint's target scale.
    /// - Note: See Also: ``Viewpoint``
    public var targetScale: Double { get }
}

extension Viewpoint : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.Viewpoint, rhs: ArcGIS.Viewpoint) -> Bool
}

extension Viewpoint : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension Viewpoint : ArcGIS.JSONSerializable {

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public static func fromJSON(_ json: String) throws -> ArcGIS.Viewpoint

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

extension Viewpoint {

    /// Create a viewpoint with center point, scale, rotation, and ``Camera``.
    /// - Parameters:
    ///   - center: The center of the visible area.
    ///   - scale: The ratio between a distance on the map and the corresponding distance on the ground.
    ///   - rotation: The rotation angle in degrees between 0 and 360.
    ///   - camera: A ``Camera`` object that defines the observer for the scene.
    /// - Precondition: `!center.isEmpty`
    public init(center: ArcGIS.Point, scale: Double, rotation: Double? = nil, camera: ArcGIS.Camera? = nil)

    /// Create a viewpoint with latitude, longitude, scale, and ``Camera``.
    /// - Remark: The spatial reference for the defined point is WGS84.
    /// - Parameters:
    ///   - latitude: The latitude coordinate for the viewpoint. Negative values are south of the equator.
    ///   - longitude: The longitude coordinate for the viewpoint. Negative values are west of the prime meridian.
    ///   - scale: The ratio between a distance on the map and the corresponding distance on the ground.
    ///   - camera: A ``Camera`` object that defines the observer for the scene.
    public init(latitude: Double, longitude: Double, scale: Double, camera: ArcGIS.Camera? = nil)

    /// Create a viewpoint with a bounding geometry, rotation, and ``Camera``.
    /// - Parameters:
    ///   - boundingGeometry: The geometry to use as the visible area.
    ///   - rotation: The rotation angle in degrees between 0 and 360.
    ///   - camera: A ``Camera`` object that defines the observer for the scene.
    /// - Precondition: `!boundingGeometry.extent.isEmpty`
    public init(boundingGeometry: ArcGIS.Geometry, rotation: Double? = nil, camera: ArcGIS.Camera? = nil)
}

extension Viewpoint : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Viewpoint.Kind : Equatable {
}

extension Viewpoint.Kind : Hashable {
}

/// Viewshed is a base class for the Analysis classes that determine visible and non-visible areas in a scene view, LocationViewshed and GeoElementViewshed.
///
/// This base class contains common members for Viewshed analysis objects.
/// - Since: 200.1
public class Viewshed : ArcGIS.Analysis {

    /// Gets the color used to render the frustum outline.
    ///
    /// The frustum (3D solid) within which visibility is evaluated can be symbolized with a specified outline color.
    public class var frustumOutlineColor: UIColor

    /// Whether or not the Viewshed frustum is visible.
    ///
    /// The frustum visibility can be controlled for individual Viewsheds.
    public var frustumOutlineIsVisible: Bool

    /// The horizontal angle of the observer's field of vision.
    ///
    /// Visible and non-visible areas are determined for an area defined by an observer location, horizontal and vertical view angles, and a minimum/maximum distance range. These properties define
    /// a frustum (3D solid) inside of which visibility is calculated. The horizontal angle must be greater than zero to define a valid frustum and is constrained to a maximum of 360 degrees.
    public var horizontalAngle: Double

    /// The maximum distance from the observer at which visibility will be evaluated. If `nil`, there is no maximum.
    ///
    /// Visibility is not evaluated beyond the maximum distance specified. This can be used to model factors that restrict the visible distance.
    public var maxDistance: Double?

    /// The minimum distance from the observer at which visibility will be evaluated. If `nil`, there is no minimum.
    ///
    /// The minimum distance allows you to exclude obstacles close to the observer (the corner of a building, for example). Since terrain and other obstacles between the observer and the specified minimum distance are completely excluded from the analysis, this value should be relatively small.
    public var minDistance: Double?

    /// Gets the color with which non-visible areas of all viewsheds will be rendered.
    ///
    /// Areas of the scene view that are not visible from the observer location and within the frustum defined for the viewshed analysis will be rendered using
    /// the specified color.
    public class var obstructedColor: UIColor

    /// The vertical angle of the observer's field of vision.
    ///
    /// Visible and non-visible areas are determined for an area defined by an observer location, horizontal and vertical view angles, and a minimum/maximum distance range. These properties define
    /// a frustum (3D solid) inside of which visibility is calculated. The vertical angle must be greater than zero to define a valid frustum and is constrained to a maximum of 360 degrees.
    public var verticalAngle: Double

    /// Gets the color with which visible areas of all viewsheds will be rendered.
    ///
    /// Areas of the scene view that are visible from the observer location and within the frustum defined for the viewshed analysis will be rendered using
    /// the specified color.
    public class var visibleColor: UIColor
}

/// Direction guidance text reformatted for speech
///
/// Contains voice guidance and type.
/// - Since: 200.1
final public class VoiceGuidance {

    /// The list of ``VoiceGuidance`` notification types.
    ///
    /// Used to determine type of voice guidance notification.
    public enum Kind {

        /// Approaching maneuver
        ///
        /// This guidance notification type is set:
        /// * After passing the previous maneuver (Example: In a half mile, Turn right on North
        ///   Eureka Street)
        /// * 20-30 seconds before next maneuver (Example: Turn right on North Eureka Street)
        /// * 9-10 seconds before next maneuver (Example: Turn right)
        case approachingManeuver

        /// At maneuver
        ///
        /// Guidance notification set when at maneuver, this type has no text.
        /// Can be used to notify user with a sound (e.g. beep) when at maneuver.
        case atManeuver

        /// Approaching destination
        ///
        /// Guidance notification type set when approaching a destination.
        /// Examples:
        /// * In 200 feet, the destination is ahead
        /// * You have arrived at 1099 East Hospitality Lane on your right
        case approachingDestination

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.VoiceGuidance.Kind, b: ArcGIS.VoiceGuidance.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Voice guidance notification type.
    /// - Note: See Also: ``Kind-swift.enum``
    final public var kind: ArcGIS.VoiceGuidance.Kind { get }

    /// Voice guidance.
    ///
    /// String representation of voice guidance text instruction.
    /// This text can be passed to a text to speech engine.
    final public var text: String { get }
}

extension VoiceGuidance.Kind : Equatable {
}

extension VoiceGuidance.Kind : Hashable {
}

/// An object that represents a WFS feature table.
/// - Since: 200.1
final public class WFSFeatureTable : ArcGIS.FeatureTable {

    /// The different ways to treat the x/y coordinates order.
    public enum OGCAxisOrder {

        /// Indicates swaping the axis order will be based on the OGC standard specification, version, and spatial reference.
        case auto

        /// Indicates the order of x/y coordinates will be swapped.
        case swap

        /// Indicates the order of x/y coordinates will stay as is, and all swapping rules by the OGC standards will be ignored.
        case noSwap

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ArcGIS.WFSFeatureTable.OGCAxisOrder, b: ArcGIS.WFSFeatureTable.OGCAxisOrder) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Creates a new WFS feature table.
    /// - Parameter layerInfo: A ``WFSLayerInfo``.
    public convenience init(layerInfo: ArcGIS.WFSLayerInfo)

    /// Creates a new WFS feature table.
    /// - Parameters:
    ///   - url: The URL of the WFS service to connect to.
    ///   - tableName: The name of the layer (feature type) from the service.
    public convenience init(url: URL, tableName: String)

    /// The axis order, which defines how coordinates are interpreted.
    ///
    /// Some WFS services return coordinates in (X,Y) order, while others use (Y,X). Setting this property to
    /// ``OGCAxisOrder/swap`` results in all coordinates in geometries being swapped from what was sent by the
    /// server. The axis order can be changed on a loaded table, but that change will only affect future calls to
    /// `WFSFeatureTable.populateFromService(using:clearCache:outFields:)`. Features that are already in the table will not be modified.
    /// The default value is ``OGCAxisOrder/auto``. In this mode, the results are optimized using heuristics from
    /// popular WFS Servers.
    final public var axisOrder: ArcGIS.WFSFeatureTable.OGCAxisOrder

    /// The mode defining when features are requested from the service.
    ///
    /// At v100.5, WFS feature table only supports ``FeatureRequestMode/manualCache`` but defaults to ``FeatureRequestMode/onInteractionCache``.
    /// Set the feature request mode to manual before attempting to populate the table.
    final public var featureRequestMode: ArcGIS.FeatureRequestMode

    /// The axis order of the filter, which determines how coordinates are ordered when sent to the server as part of spatial queries (those that specify a geometry).
    ///
    /// Some WFS services expect coordinates to be sent in (X,Y) order, while others use (Y,X). Use ``OGCAxisOrder/swap`` to send coordinates in (Y,X) order.
    /// Use ``OGCAxisOrder/noSwap`` to send coordinates in (X,Y) order. Defaults to ``OGCAxisOrder/auto``.
    final public var filterAxisOrder: ArcGIS.WFSFeatureTable.OGCAxisOrder

    /// The WFS layer metadata, which includes name and description.
    final public var layerInfo: ArcGIS.WFSLayerInfo? { get }

    /// The preferred spatial reference for the WFS feature table.
    ///
    /// The desired spatial reference for the table. If the preferred spatial reference isn't available from the
    /// service, the table will fail to load. Specify a preferred spatial reference that matches the map or scene's spatial reference
    /// to avoid automatic reprojection. The preferred spatial reference cannot be changed on a loaded table.
    final public var preferredSpatialReference: ArcGIS.SpatialReference?

    /// The URL of the WFS feature table.
    final public var url: URL { get }

    /// Populate the table using a query.
    ///
    /// Use the default (empty) QueryParameters to get all features from the service.
    /// Specifying `nil` or an empty `Array` for outfields will result in the default set of outfields being used.
    /// WFS is only compatible with a subset of possible queries defined by QueryParameters. Where clause only works when
    /// the table is backed by a service powered by GeoServer. Spatial queries (those that specify geometries) must use the Intersects spatial relationship.
    /// - Parameters:
    ///   - parameters: Options for controlling the operation.
    ///   - clearCache: If `true`, clears existing table data before populating with the query result.
    ///   - outFields: An `Array` containing `String`.
    /// - Returns: A ``FeatureQueryResult`` type.
    final public func populateFromService(using parameters: ArcGIS.QueryParameters?, clearCache: Bool, outFields: [String]) async throws -> ArcGIS.FeatureQueryResult

    /// Populate the table using an XML query.
    ///
    /// The XML query must be made against the same feature type represented by the WFS feature table.
    /// The schema of the query result must match or be a subset of the schema of the table.
    /// - Parameters:
    ///   - xmlRequest: An XML string representing the complete GetFeature request including but not limited to filters, joins, and aliases.
    ///   - clearCache: If `true`, clears existing table data before populating with the query result.
    /// - Returns: A ``FeatureQueryResult`` type.
    final public func populateFromService(usingXMLRequest xmlRequest: String, clearCache: Bool) async throws -> ArcGIS.FeatureQueryResult
}

extension WFSFeatureTable.OGCAxisOrder : Equatable {
}

extension WFSFeatureTable.OGCAxisOrder : Hashable {
}

/// An object that represents the metadata of a layer (feature type) in a WFS service.
///
/// Provides metadata (e.g name, title, description, and more) about a WFS feature type.
/// - Since: 200.1
final public class WFSLayerInfo {

    /// The layer's description (abstract).
    ///
    /// The description property contains the content from the Abstract field in the WFS GetCapabilities response.
    final public var description: String { get }

    /// The WFS layer's extent.
    final public var extent: ArcGIS.Envelope? { get }

    /// The keywords describing the layer.
    ///
    /// The keywords are returned in an `Array` of `String`.
    final public var keywords: [String] { get }

    /// The layer's uniquely-identifying name.
    ///
    /// Layers from a ``WFSService``, described by ``WFSLayerInfo`` objects, represent the "feature types" defined in the WFS standard.
    /// The name property is intended for use as a unique identifier for the layer. See ``title`` for a human-readable name.
    final public var name: String { get }

    /// The supported spatial references.
    final public var spatialReferences: [ArcGIS.SpatialReference] { get }

    /// The layer's human-readably title.
    ///
    /// The title property is intended for use as a human-readable layer identification. See ``name`` for a uniquely-identifying name.
    final public var title: String { get }
}

/// An object that represents a WFS service.
///
/// Provides an entry point to explore the WFS service metadata via ``WFSServiceInfo``.
/// - Since: 200.1
final public class WFSService : ArcGIS.Loadable {

    /// Creates a ``WFSService``, taking a URL to the service.
    ///
    /// The URL is the 'GetCapabilities' URL for the WFS service. Web Feature Service (WFS) is an OGC standard. This API supports WFS versions 2.0.0 and 2.0.2.
    /// - Parameter url: of the WFS service.
    public convenience init(url: URL)

    /// These parameters are appended to all WFS requests e.g. GetCapabilities, GetFeature, and DescribeFeatureType.
    /// Will throw `CoreErrorCode.commonIllegalState` if the WFS service is loaded.
    final public var customParameters: [String : String] { get }

    /// Sets a value in the `customParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setCustomParameterValue(_ value: String?, forKey key: String)

    /// The ``WFSServiceInfo``, which describes the WFS service metadata.
    ///
    /// The WFS service info is returned as ``WFSServiceInfo`` type.
    final public var serviceInfo: ArcGIS.WFSServiceInfo? { get }

    /// The service's URL.
    ///
    /// Will throw `CoreErrorCode.commonIllegalState` if the WFS service is loaded.
    final public var url: URL { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An object that represents the metadata of a WFS service.
///
/// Provides metadata (e.g name, title, description, and more) about a WFS service, and lists the contained WFS layers (feature types).
/// - Since: 200.1
final public class WFSServiceInfo {

    /// The service's description (abstract).
    ///
    /// The description property contains the content from the Abstract field in the WFS GetCapabilities response.
    final public var description: String { get }

    /// The keywords describing the WFS service.
    ///
    /// The keywords are returned in an `Array` of `String`.
    final public var keywords: [String] { get }

    /// Information about the layers (feature types) provided by the service.
    ///
    /// This property can be used to discover the layers (feature types) exposed by a WFS service in support of a browsing experience.
    final public var layerInfos: [ArcGIS.WFSLayerInfo] { get }

    /// The service's human-readable title.
    final public var title: String { get }
}

/// The well known identifier assigned to a coordinate system.
/// - Since: 200.1
public struct WKID : RawRepresentable, Hashable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: Int

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: Int)

    public init?(_ rawValue: Int)

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = Int
}

extension WKID : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

/// An object that represents a WMS feature.
///
/// Pass this object to all WMS feature methods.
/// - Note: See Also: ``WMSLayer``
/// - Since: 200.1
final public class WMSFeature : ArcGIS.GeoElement {

    /// The attributes of the ``GeoElement`` as a collection of name/value pairs.
    final public var attributes: [String : Any] { get }

    /// The geometry defines the shape and location of the ``GeoElement``.
    final public var geometry: ArcGIS.Geometry? { get }
}

/// Displays data from a WMS service.
///
/// The service may be hosted in the cloud on ArcGIS Online, on a third party server, or on-premises with ArcGIS
/// Server.
///
/// Web Map Service (WMS) is an Open Geospatial Consortium (OGC) standard for delivering map images from an online service.
/// WMS layer displays data from a web service that provides maps in the form of server-rendered images. This API
/// supports WMS versions 1.1.0, 1.1.1, and 1.3.0. The service may be hosted in the cloud on ArcGIS
/// Online, on a third party server, or on-premises ArcGIS Server.
///
/// Functional characteristics
/// A WMS service can contain multiple layers in a hierarchy. A Wms layer can be constructed directly with a URL to a
/// service and the uniquely identifying name of the desired layer. Alternatively, a ``WMSService`` can be used to
/// programmatically explore the available layers and allow the user to choose layers at run time.
///
/// The maps provided by a WMS service use predefined symbology defined by the server. As a result, it is not
/// possible to apply custom renderers or to visualize feature selection. WMS layers can have multiple style
/// options. Your app can choose from the available styles.
///
/// Some layers can be marked as opaque, which means that they cover most of the map area and are good candidates
/// for use as a basemap.
///
/// WMS layers support identify and time. They do not support selection or query. Note that due to the nature of WMS,
/// it is not possible to retrieve feature geometry from WMS identify results. WMS layers support custom parameters,
/// which can be specified for the service or an individual layer.
///
/// Performance characteristics
/// WMS servers render map images on demand, which can require more server resources than a similar tiled service.
/// WMS requires a service connection at all times.
/// - Note: See Also: ``Layer``, ``ImageAdjustmentLayer``, ``WMSSublayer``, ``WMSService``
/// - Since: 200.1
final public class WMSLayer : ArcGIS.ImageAdjustmentLayer, ArcGIS.TimeAware {

    /// Creates a WMS layer object from an item.
    /// - Parameter item: An ``Item`` (only ``PortalItem`` are supported).
    /// - Note: See Also: ``Layer/item``
    public convenience init(item: ArcGIS.Item)

    /// Creates a ``WMSLayer`` from the specified set of ``WMSLayerInfo`` objects.
    ///
    /// Use this method to create a ``WMSLayer`` when you have a set of ``WMSLayerInfo`` objects to include in the layer.
    /// - Parameter layerInfos: An `Array` of `CoreElementType.WMSLayerInfo` representing the visible WMS layers to include.
    /// - Note: See Also: ``WMSLayer``
    public convenience init(layerInfos: [ArcGIS.WMSLayerInfo])

    /// Creates a ``WMSLayer`` with known URL and layer names.
    ///
    /// Use this method to create a WMS layer.
    /// To specify a preferred WMS version, set the 'VERSION' parameter in the 'GetCapabilities' URL for the service.
    /// - Parameters:
    ///   - url: The URL of a WMS service.
    ///   - layerNames: An `Array` of the visible WMS layer names.
    /// - Note: See Also: ``WMSLayer``
    public convenience init(url: URL, layerNames: [String])

    /// These parameters are appended to GetMap and GetFeatureInfo requests.
    /// If a parameter with the same name is defined in the service's custom parameters, then layer-specific values take precedence over service-wide values.
    ///
    /// ``WMSLayer`` CustomParameters property will take precedence over CustomParameters property on ``WMSService``.
    final public var customParameters: [String : String] { get }

    /// Sets a value in the `customParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setCustomParameterValue(_ value: String?, forKey key: String)

    /// The WMS Layer's set of ``WMSLayerInfo`` objects.
    ///
    /// ``WMSLayerInfo`` objects describe the layers (as provided by the service).
    /// Multiple layers from a ``WMSService`` may be included in a single ``WMSLayer``.
    /// - Note: See Also: ``WMSLayerInfo``
    final public var layerInfos: [ArcGIS.WMSLayerInfo] { get }

    /// Adds a sequence of `WMSLayerInfo` values to the end of the `layerInfos` property.
    /// - Parameter newLayerInfos: The new `WMSLayerInfo` values to append.
    final public func addLayerInfos<S>(_ newLayerInfos: S) where S : Sequence, S.Element == ArcGIS.WMSLayerInfo

    /// Adds a `WMSLayerInfo` value to the end of the `layerInfos` property.
    /// - Parameter newLayerInfo: The new `WMSLayerInfo` value to append.
    final public func addLayerInfo(_ newLayerInfo: ArcGIS.WMSLayerInfo)

    /// Inserts a collection of `WMSLayerInfo` values into the `layerInfos` property at the specified position.
    /// - Parameters:
    ///   - newLayerInfos: The new `WMSLayerInfo` values to insert.
    ///   - index: The position at which to insert the new `WMSLayerInfo` values.
    final public func insertLayerInfos<C>(_ newLayerInfos: C, at index: Int) where C : Collection, C.Element == ArcGIS.WMSLayerInfo

    /// Inserts a `WMSLayerInfo` value into the `layerInfos` property at the specified position.
    /// - Parameters:
    ///   - newLayerInfo: The new `WMSLayerInfo` value to insert.
    ///   - index: The position at which to insert the new `WMSLayerInfo` value.
    final public func insertLayerInfo(_ newLayerInfo: ArcGIS.WMSLayerInfo, at index: Int)

    /// Removes all values from the `layerInfos` property.
    final public func removeAllLayerInfos()

    /// Removes a sequence of `WMSLayerInfo` values from the `layerInfos` property.
    /// - Parameter layerInfos: The `WMSLayerInfo` values to remove.
    final public func removeLayerInfos<S>(_ layerInfos: S) where S : Sequence, S.Element == ArcGIS.WMSLayerInfo

    /// Removes a `WMSLayerInfo` value from the `layerInfos` property.
    /// - Parameter layerInfo: The `WMSLayerInfo` value to remove.
    final public func removeLayerInfo(_ layerInfo: ArcGIS.WMSLayerInfo)

    /// The names of the visible WMS layers.
    /// - Note: See Also: ``WMSLayerInfo``
    final public var layerNames: [String] { get }

    /// Adds a sequence of `String` values to the end of the `layerNames` property.
    /// - Parameter newLayerNames: The new `String` values to append.
    final public func addLayerNames<S>(_ newLayerNames: S) where S : Sequence, S.Element == String

    /// Adds a `String` value to the end of the `layerNames` property.
    /// - Parameter newLayerName: The new `String` value to append.
    final public func addLayerName(_ newLayerName: String)

    /// Inserts a collection of `String` values into the `layerNames` property at the specified position.
    /// - Parameters:
    ///   - newLayerNames: The new `String` values to insert.
    ///   - index: The position at which to insert the new `String` values.
    final public func insertLayerNames<C>(_ newLayerNames: C, at index: Int) where C : Collection, C.Element == String

    /// Inserts a `String` value into the `layerNames` property at the specified position.
    /// - Parameters:
    ///   - newLayerName: The new `String` value to insert.
    ///   - index: The position at which to insert the new `String` value.
    final public func insertLayerName(_ newLayerName: String, at index: Int)

    /// Removes all values from the `layerNames` property.
    final public func removeAllLayerNames()

    /// Removes a sequence of `String` values from the `layerNames` property.
    /// - Parameter layerNames: The `String` values to remove.
    final public func removeLayerNames<S>(_ layerNames: S) where S : Sequence, S.Element == String

    /// Removes a `String` value from the `layerNames` property.
    /// - Parameter layerName: The `String` value to remove.
    final public func removeLayerName(_ layerName: String)

    /// The preferred image format of the ``WMSLayer``.
    ///
    /// If the service does not support the 'preferred' image format, images will be returned in a supported format; An error will not be generated.
    /// - Note: See Also: ``MapServiceImageFormat``
    final public var preferredImageFormat: ArcGIS.MapServiceImageFormat?

    /// The WMS Sublayers.
    @ArcGIS.Streamed final public var sublayers: [ArcGIS.LayerContent] { get }

    final public var $sublayers: AsyncStream<[ArcGIS.LayerContent]> { get }

    /// The URL of the ``WMSLayer``.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:layerNames:)``
    final public var url: URL? { get }

    /// The WMS version of the ``WMSLayer``.
    ///
    /// This API supports the following WMS versions: 1.3.0, 1.1.1, and 1.1.0.
    /// By default this value is the latest supported WMS version.
    final public var version: ArcGIS.WMSVersion { get }

    /// The full time extent of the object.
    @ArcGIS.Streamed final public var fullTimeExtent: ArcGIS.TimeExtent? { get }

    final public var $fullTimeExtent: AsyncStream<ArcGIS.TimeExtent?> { get }

    /// A flag indicating whether the object supports filtering its contents by time values with the extent set on the owning `GeoView`.
    final public var supportsTimeFiltering: Bool { get }

    /// A flag indicating whether the object must use the time extent defined on the owning `GeoView` to filter its data.
    final public var timeFilteringIsEnabled: Bool

    /// The suggested time slider step size for this time aware object.
    ///
    /// Can be `nil` if no time interval is suggested for this time aware object.
    final public var timeInterval: ArcGIS.TimeValue? { get }

    /// The time offset applied to this object.
    /// The offset is subtracted from the time extent set on the owning `GeoView`.
    /// This allows for data from different periods of time to be compared.
    final public var timeOffset: ArcGIS.TimeValue?
}

/// An object that represents the WMS Layer info.
/// - Since: 200.1
final public class WMSLayerInfo {

    /// The layer's description.
    final public var description: String { get }

    /// The WMS layer's extent.
    final public var extent: ArcGIS.Envelope? { get }

    /// A value indicating the height of maps the service is capable of producing.
    ///
    /// When present and nonzero, this property indicates that the server is not able to produce a map of
    /// the layer at a height different from the fixed height indicated.
    final public var fixedImageHeight: Int { get }

    /// A value indicating the width of maps the service is capable of producing.
    ///
    /// When present and nonzero, this property indicates that the server is not able to produce a map of
    /// the layer at a width different from the fixed width indicated.
    final public var fixedImageWidth: Int { get }

    /// The flag indicating whether the ``WMSLayer`` is opaque.
    ///
    /// The WMS layer's opaque property describes the layer's data content, not the picture format of the map response.
    /// A `true` value indicates that the map data are mostly or completely opaque.
    /// A `false` value indicates that the map data represent vector features that probably do not completely fill space.
    /// In practice, a layer with opaque set to `true` is a good candidate for use as a basemap.
    final public var isOpaque: Bool { get }

    /// The flag indicating whether the WMS layer is queryable.
    final public var isQueryable: Bool { get }

    /// The keywords describing the layer.
    ///
    /// The keywords are returned in an `Array` of `String`.
    final public var keywords: [String] { get }

    /// The layer's uniquely-identifying name.
    ///
    /// Layers from a ``WMSService``, described by ``WMSLayerInfo`` objects, have both a name and a title property.
    /// Only layers with a name are displayable. Layers with only a title are categories for other layers.
    /// Layers with a name may also have children; displaying these layers will display all sublayers.
    final public var name: String { get }

    /// The supported spatial references.
    final public var spatialReferences: [ArcGIS.SpatialReference] { get }

    /// The available styles for this layer.
    ///
    /// The WMS styles are returned in an `Array` of `String`.
    /// Styles are server-defined options for how the layer and its information are displayed. Note that the order of styles returned does not indicate which style is the default.
    /// Styles can be applied via the CurrentStyle property of WMS sublayers.
    final public var styles: [String] { get }

    /// The set of ``WMSLayerInfo`` objects for the layer's sublayers.
    ///
    /// The WMS sublayer infos are returned in an `Array` containing ``WMSLayerInfo`` types.
    final public var sublayerInfos: [ArcGIS.WMSLayerInfo] { get }

    /// The layer's title.
    ///
    /// The title property is intended for use as a human-readable layer identification.
    /// The title is not unique. Note also that a layer with a title but no name
    /// describes a category for use as a container for sublayers.
    final public var title: String { get }
}

/// An object that represents the service for an WMS Service.
/// - Since: 200.1
final public class WMSService : ArcGIS.Loadable {

    /// Creates a ``WMSService`` with provided URL to the service.
    ///
    /// To specify a preferred WMS version, set the 'VERSION' parameter in the 'GetCapabilities' URL for the service.
    /// - Parameter url: of the WMS service.
    public convenience init(url: URL)

    /// These parameters are appended to GetCapabilities, GetMap, and GetFeatureInfo requests.
    /// If a parameter with the same name is defined in a layer's custom parameters, then layer-specific values take precedence
    /// over service-wide values. Parameters intended for GetCapabilities requests should be set before the service is loaded.
    ///
    /// If used with the CustomParameters property on ``WMSLayer``, duplicate parameters in this service CustomParameters will not take precedence.
    final public var customParameters: [String : String] { get }

    /// Sets a value in the `customParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setCustomParameterValue(_ value: String?, forKey key: String)

    /// The ``WMSServiceInfo``.
    ///
    /// The WMS service info is returned as ``WMSServiceInfo`` type.
    final public var serviceInfo: ArcGIS.WMSServiceInfo? { get }

    /// The service metadata URL.
    final public var url: URL { get }

    /// The version of the WMS service.
    ///
    /// This API supports the following WMS versions: 1.3.0, 1.1.1, and 1.1.0.
    /// By default the value is the latest supported WMS version.
    final public var version: ArcGIS.WMSVersion { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An object that represents the service metadata for an WMS Service.
/// - Since: 200.1
final public class WMSServiceInfo {

    /// The service's description.
    final public var description: String { get }

    /// The WMS service's supported image formats.
    ///
    /// The returned collection of image formats supported by the WMS service is of type
    /// ``MapServiceImageFormat``.
    final public var imageFormats: [ArcGIS.MapServiceImageFormat] { get }

    /// The keywords describing the WMS service.
    ///
    /// The keywords are returned in an `Array` of `String`.
    final public var keywords: [String] { get }

    /// The WMS layers infos.
    ///
    /// This property can be used to discover which layers are exposed by a WMS service in support of a browsing experience.
    final public var layerInfos: [ArcGIS.WMSLayerInfo] { get }

    /// The service's name.
    final public var name: String { get }

    /// The service's title.
    final public var title: String { get }
}

/// An instance of this class allows you to get data from a WMS service.
///
/// You can get the `Array` of ``WMSSublayer`` from ``WMSLayer``.
/// - Note: See Also: ``WMSLayer``
/// - Since: 200.1
final public class WMSSublayer : ArcGIS.LayerContent {

    /// The name of the sublayer's current style.
    ///
    /// Setting current style to an empty string indicates the default style will be used.
    final public var currentStyle: String

    /// The WMS Layer information.
    final public var sublayerInfo: ArcGIS.WMSLayerInfo { get }

    /// Clones the ``WMSSublayer``.
    /// - Returns: A new ``WMSSublayer`` with the same values as the current ``WMSSublayer``.
    final public func clone() -> Self

    /// A flag indicating whether the layer content's visibility can be changed.
    ///
    /// A flag indicating whether the layer content visibility can be changed.
    final public var canChangeVisibility: Bool { get }

    /// The layer content's visibility.
    ///
    /// The layer content visibility.
    final public var isVisible: Bool

    /// Fetches the list of legend info.
    final public var legendInfos: [ArcGIS.LegendInfo] { get async throws }

    /// The layer content's name.
    ///
    /// The layer content name.
    final public var name: String { get }

    /// A flag indicating whether the layer content participates in the legend.
    ///
    /// A flag indicating whether the layer content is shown in the legend.
    final public var shouldShowInLegend: Bool

    /// The sub layer contents of a layer content.
    @ArcGIS.Streamed final public var subLayerContents: [ArcGIS.LayerContent] { get }

    final public var $subLayerContents: AsyncStream<[ArcGIS.LayerContent]> { get }

    /// Returns the layer content's effective visibility at the specified scale.
    ///
    /// Returns the effective layer content visibility. This effective visibility takes care of the effective visibility of the parents at the specified scale.
    /// - Parameter scale: The scale the visibility has to be calculated for.
    /// - Returns: A bool.
    final public func isVisible(atScale scale: Double) -> Bool
}

extension WMSSublayer : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ArcGIS.WMSSublayer, rhs: ArcGIS.WMSSublayer) -> Bool
}

/// The different versions of the WMS service.
/// - Since: 200.1
public enum WMSVersion {

    /// Version 1.1.0.
    case v110

    /// Version 1.1.1.
    case v111

    /// Version 1.3.0.
    case v130

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ArcGIS.WMSVersion, b: ArcGIS.WMSVersion) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension WMSVersion : Equatable {
}

extension WMSVersion : Hashable {
}

/// Displays data from a WMTS service by using pre-generated tiles.
///
/// Web Map Tile Service (WMTS) is an Open Geospatial Consortium (OGC) standard for delivering geographic data via
/// raster tiles. The service may be hosted in the cloud on ArcGIS Online, on a third party server, or on-premises
/// with ArcGIS Server. This API supports WMTS 1.0.0.
///
/// A WMTS layer uses pre-generated tiles to create a map instead of dynamically generating map images.
///
/// Functional characteristics
/// The maps provided by a WMTS service use predefined symbology defined by the server. As a result, it is not
/// possible to apply custom renderers or to visualize feature selection.
///
/// A WMTS service can contain multiple layers in a hierarchy. A WMTS layer can be constructed directly with a URL
/// to a service and the uniquely identifying name of the desired layer. Alternatively, a WMTS service can be used
/// to programmatically explore the available layers and allow the user to choose layers at run time.
///
/// Performance characteristics
/// WMTS layer consumes raster tiles that were prerendered by a server. WMTS requires fewer server resources than
/// WMS because the images are rendered and cached ahead of time. WMTS layer requires a connection to the service at
/// all times.
///
/// Creating a WMTS layer from URL
/// For some WMTS services it may be necessary to provide a direct URI to
/// the getCapabilities resource, by appending either /1.0.0/WMTSCapabilities.xml or
/// ?service=wmts&amp;request=getCapabilities&amp;version=1.0.0 to the root WMTS URI.
/// - Note: See Also: ``Layer``, ``ImageTiledLayer``
/// - Since: 200.1
final public class WMTSLayer : ArcGIS.ImageTiledLayer {

    /// Creates a WMTS layer object.
    ///
    /// Use this method to create a WMTS layer.
    /// - Parameters:
    ///   - url: The URL to a WMTS service.
    ///   - layerID: The identifier of the WMTS layer.
    ///   - tileMatrixSetID: The id of the tile matrix set supported by of the WMTS layer.
    ///   - preferredImageFormat: The preferred image format of the WMTS layer.
    /// - Note: See Also: ``WMTSLayer``
    public convenience init(url: URL, layerID: String, tileMatrixSetID: String = "", preferredImageFormat: ArcGIS.TileImageFormat? = nil)

    /// These parameters are appended to GetTile requests.
    /// If a parameter with the same name is defined in the service's custom parameters, then layer-specific values take precedence over service-wide values.
    ///
    /// ``customParameters`` property will take precedence over ``WMTSService/customParameters``.
    final public var customParameters: [String : String] { get }

    /// Sets a value in the `customParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setCustomParameterValue(_ value: String?, forKey key: String)

    /// The id of the WMTS layer.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    final public var layerID: String { get }

    /// The WMTS Layer information.
    /// - Note: See Also: ``WMTSLayerInfo``
    final public var layerInfo: ArcGIS.WMTSLayerInfo? { get }

    /// The preferred image format of the WMTS layer.
    /// - Note: See Also: ``TileImageFormat``
    final public var preferredImageFormat: ArcGIS.TileImageFormat? { get }

    /// The WMTS tile matrix set.
    /// - Note: See Also: ``WMTSTileMatrixSet``
    final public var tileMatrixSet: ArcGIS.WMTSTileMatrixSet? { get }

    /// The tile matrix set id of the WMTS layer.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    final public var tileMatrixSetID: String { get }

    /// The URL of the WMTS service.
    ///
    /// This method can't be called once the layer is loading else `CoreErrorCode.commonIllegalState` exception will occur.
    /// - Note: See Also: ``init(url:layerID:tileMatrixSetID:preferredImageFormat:)``
    final public var url: URL { get }
}

extension WMTSLayer {

    /// Creates a WMTS layer object from a WMTS layer info.
    /// - Parameters:
    ///   - layerInfo: The info for the layer.
    ///   - tileMatrixSet: A WMTS tile matrix set. The default value is `nil`.
    ///   - preferredImageFormat: The preferred image format of the WMTS layer.
    ///   The default value is `nil`.
    public convenience init(layerInfo: ArcGIS.WMTSLayerInfo, tileMatrixSet: ArcGIS.WMTSTileMatrixSet? = nil, preferredImageFormat: ArcGIS.TileImageFormat? = nil)
}

/// An object that represents the WMTS Layer info.
/// - Since: 200.1
final public class WMTSLayerInfo : Identifiable {

    /// The layer's description.
    final public var description: String { get }

    /// The layer's identifier.
    final public var id: String { get }

    /// The layer's image formats.
    ///
    /// The returned collection of image formats supported by the WMTS service is of type
    /// ``TileImageFormat``.
    final public var imageFormats: [ArcGIS.TileImageFormat] { get }

    /// The keywords describing the WMTS layer.
    ///
    /// The keywords are returned in an `Array` of `String`.
    final public var keywords: [String] { get }

    /// The WMTS styles.
    ///
    /// The WMTS styles are returned in an `Array` of `String`.
    final public var styles: [String] { get }

    /// The WMTS tile matrix sets.
    ///
    /// The WMTS tile matrix sets are returned in an `Array` containing ``WMTSTileMatrixSet`` types.
    final public var tileMatrixSets: [ArcGIS.WMTSTileMatrixSet] { get }

    /// The layer's title.
    final public var title: String { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = String
}

/// An object that represents the service for an WMTS Service.
/// - Since: 200.1
final public class WMTSService : ArcGIS.Loadable {

    /// Creates a WMTS service.
    /// - Parameter url: of the WMTS service.
    public convenience init(url: URL)

    /// These parameters are appended to GetCapabilities, and GetTile.
    /// If a parameter with the same name is defined in a layer's custom parameters, then layer-specific values take precedence
    /// over service-wide values. Parameters intended for GetCapabilities requests should be set before the service is loaded.
    ///
    /// If used with ``WMTSLayer/customParameters`` property, duplicate parameters in ``customParameters`` will not take precedence.
    final public var customParameters: [String : String] { get }

    /// Sets a value in the `customParameters` dictionary.
    /// - Parameters:
    ///   - value: The value to set for the given key or `nil` to remove an
    ///   existing entry in the dictionary.
    ///   - key: The key to use to store the given value.
    final public func setCustomParameterValue(_ value: String?, forKey key: String)

    /// The WMTS service info.
    ///
    /// The WMTS service info is returned as ``WMTSServiceInfo`` type.
    final public var serviceInfo: ArcGIS.WMTSServiceInfo? { get }

    /// The service metadata URL.
    final public var url: URL { get }

    /// The load status.
    @ArcGIS.Streamed final public var loadStatus: ArcGIS.LoadStatus { get }

    final public var $loadStatus: AsyncStream<ArcGIS.LoadStatus> { get }

    /// The error if the instance is not loaded due to a load failure operation,
    /// otherwise `nil`.
    @ArcGIS.Streamed final public var loadError: Error? { get }

    final public var $loadError: AsyncStream<Error?> { get }

    /// Loads the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will throw immediately with the previous error.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func load() async throws

    /// Loads or retries loading the metadata for the instance asynchronously.
    ///
    /// If the load status of this instance is ``LoadStatus/failed`` then this function
    /// will retry loading. This is where ``retryLoad()`` and ``load()`` differ, as the latter
    /// will fail in that case.
    ///
    /// - Remark: Cancelling a load must be done explicitly through the ``cancelLoad()`` method.
    /// Loading will not automatically be cancelled if the associated `Task`, within which this
    /// function was called, is cancelled. The reason for that is to prevent cancellation of loading
    /// for other callers of ``load()`` and ``retryLoad()``.
    final public func retryLoad() async throws

    /// Cancels loading. This affects all callers waiting for a load.
    final public func cancelLoad()
}

/// An object that represents the service metadata for an WMTS Service.
/// - Since: 200.1
final public class WMTSServiceInfo {

    /// The service's description.
    final public var description: String { get }

    /// The keywords describing the WMTS service.
    ///
    /// The keywords are returned in an `Array` of `String`.
    final public var keywords: [String] { get }

    /// The WMTS layers infos.
    ///
    /// The WMTS layers infos are returned in an `Array` containing ``WMTSLayerInfo`` types.
    final public var layerInfos: [ArcGIS.WMTSLayerInfo] { get }

    /// The WMTS tile matrix sets.
    ///
    /// The WMTS tile matrix sets are returned in an `Array` containing ``WMTSTileMatrixSet`` types.
    final public var tileMatrixSets: [ArcGIS.WMTSTileMatrixSet] { get }

    /// The service's title.
    final public var title: String { get }

    /// The service's version.
    final public var version: String { get }
}

/// An object that represents the WMTS tile matrix.
/// - Since: 200.1
final public class WMTSTileMatrix : Identifiable {

    /// The tile matrix identifier.
    final public var id: String { get }

    /// The scale denominator of the tile matrix.
    final public var scaleDenominator: Double { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = String
}

/// An object that represents the WMTS tile matrix set.
/// - Since: 200.1
final public class WMTSTileMatrixSet : Identifiable {

    /// The tile matrix set description.
    final public var description: String { get }

    /// The tile matrix set extent.
    final public var extent: ArcGIS.Envelope? { get }

    /// The tile matrix set identifier.
    final public var id: String { get }

    /// The keywords describing the WMTS layer.
    ///
    /// The keywords are returned in an `Array` of `String`.
    final public var keywords: [String] { get }

    /// The tile matrix set spatial reference.
    final public var spatialReference: ArcGIS.SpatialReference? { get }

    /// The WMTS tile matrices.
    ///
    /// The WMTS layers infos are returned in an `Array` containing ``WMTSTileMatrix`` types.
    final public var tileMatrices: [ArcGIS.WMTSTileMatrix] { get }

    /// The tile matrix set title.
    final public var title: String { get }

    /// The well known scale set id.
    final public var wellKnownScaleSetID: String { get }

    /// A type representing the stable identity of the entity associated with
    /// an instance.
    public typealias ID = String
}

/// A layer that requests images from a tiled image server based on a URL template.
///
/// It provides a simple way to integrate non-ArcGIS Services as a layer in a map. The URL
/// template usually follows a pattern similar to
/// https://{subDomain}.server.org/path/{level}/{col}/{row}.png, where:
/// * "subDomain" is one of the strings in the subDomains list
/// * "level" corresponds to a zoom level
/// * "col" represents the column of the tile
/// * "row" represents the row of the tile
///
/// The URL should be arranged to reflect how the tiles are organized in the cache or on the
/// server, and can point to a web server (https://) or to a local file cache (file://).
///
/// The tiles retrieved by this class are accessed directly by URL. Because the service is
/// only providing images, you are responsible for manually setting the attribution text on the
/// map or scene view.
///
/// To create a custom service tiled layer whose URL follows the above pattern (or a similar
/// pattern), you can extend this class. Alternatively, you can extend the super class
/// ``ServiceImageTiledLayer``, in which you implement a required method to set the request
/// information for a given LOD, column, and row. Extending ``WebTiledLayer``, however, has no
/// such requirement.
///
/// A `CoreErrorCode.commonInvalidArgument` exception will be thrown when attempting to load a layer with invalid template URI.
///
/// If ``TileInfo`` is not specified, tiles are assumed to be in the OpenStreetMap tiling scheme, with 256x256 PNG tiles
/// at 96 DPI, the WebMercator projection, and a FullExtent of [-180, -85.0511, 180, 85.051].
///
/// Functional characteristics
/// Tiles are fetched on demand using the specified URL template. Tiles are typically pre-rendered (cached) on the
/// server but may be generated on demand by some services. Web tiled layers do not support identify, query,
/// selection, or time.
///
/// Tiles are fetched on demand using the specified URL template. Tiles are typically
/// prerendered (cached) on the server but may be generated on demand by some services. Web
/// tiled layers do not support identify, query, selection, or time.
///
/// Specifying subdomains from which the layer will request tiles allows the load to be more
/// evenly distributed among servers.
///
/// Performance characteristics
///
/// Web tiled layer requires a connection to the service at all times. Performance is similar
/// to other raster tile layers.
/// - Note: See Also: ``Layer``
/// - Since: 200.1
public class WebTiledLayer : ArcGIS.ServiceImageTiledLayer {

    /// The array of sub-domains for the WebTiledLayer that can be used in the template URI.
    ///
    /// The array of sub-domain strings that can be used by the "{subDomain}" key in the template URI.
    /// - Note: See Also: `Array`
    public var subDomains: [String] { get }

    /// The URI template for the WebTiledLayer.
    ///
    /// The URI template of the WebTiledLayer.  The template uses the "{subDomain}" (optional), "{level}", "{row}",
    /// and "{col}" keys to note how the layer should construct the URI for individual tiles.
    /// - Note: See Also: `String`
    public var urlTemplate: String { get }

    override public func load() async throws
}

extension WebTiledLayer {

    /// Initializes a `WebTiledLayer`.
    /// - Remark: The URL template usually follows a pattern similar to
    /// https://{subDomain}.server.org/path/{level}/{col}/{row}.png, where "subDomain" is one of the available strings in
    /// ``subDomains``, "level" corresponds to a zoom level, "col" represents the tile column, and "row" represents
    /// the tile row. The URL template should be arranged to reflect how the tiles are arranged in the cache or on the server,
    /// and can point to a web server (https://) or to a local file cache (file://).
    /// - Parameters:
    ///   - urlTemplate: A template for the URL used for tile requests.
    ///   - subDomains: An array of strings listing available sub-domains.
    ///   - tileInfo: The tiling scheme info.
    ///   - fullExtent: The full extent of tiles in the cache or server.
    public convenience init(urlTemplate: String, subDomains: [String] = [], tileInfo: ArcGIS.TileInfo = defaultTileInfo, fullExtent: ArcGIS.Envelope = defaultFullExtent)
}

/// The label Webmap expression expects to hold a legal, Webmap script
/// and to be read and evaluated by a Webmap expression interpreter.
/// An example expression that combines text with a field value is
///
/// State {State_Name}
///
/// Note that quotes are not needed around the literal text.
/// Warning: If expression using attributes which don't exist then no label will be produced.
/// This is distinct from the attribute existing but having a `nil` or empty value,
/// which can form part of the produced text label.
/// - Since: 200.1
final public class WebmapLabelExpression : ArcGIS.LabelExpression {

    /// Create a label Webmap expression with a specific Webmap script.
    ///
    /// The expression is expected to be a complete, self-contained Webmap expression.
    /// - Parameter webmapExpression: The Webmap expression script string.
    public convenience init(webmapExpression: String = "")
}

extension Sequence where Self.Element : ArcGIS.Loadable {

    /// Loads the elements of the sequence asynchronously.
    /// - Returns: `true` if all elements loaded successfully, otherwise
    /// `false`.
    /// - Since: 200.1
    @discardableResult
    public func load() async -> Bool

    /// Retries loading the elements of the sequence asynchronously.
    /// - Returns: `true` if all elements loaded successfully, otherwise
    /// `false`.
    /// - Since: 200.1
    @discardableResult
    public func retryLoad() async -> Bool
}

extension UnitAngle {

    /// Creates a unit angle with the specified angular unit.
    /// - Parameter angularUnit: An `AngularUnit` object.
    public class func fromAngularUnit(_ angularUnit: ArcGIS.AngularUnit) -> UnitAngle

    /// The corresponding angular unit.
    ///
    /// This property is `nil` if the unit angle does not have a related angular unit.
    public var angularUnit: ArcGIS.AngularUnit? { get }
}

extension UnitArea {

    /// Creates a unit area with the specified area unit.
    /// - Parameter areaUnit: An `AreaUnit` object.
    public class func fromAreaUnit(_ areaUnit: ArcGIS.AreaUnit) -> UnitArea

    /// The corresponding area unit.
    ///
    /// This property is `nil` if the unit area does not have a related area
    /// unit.
    public var areaUnit: ArcGIS.AreaUnit? { get }
}

extension UnitLength {

    /// Creates a unit length with the specified linear unit.
    /// - Parameter linearUnit: A `LinearUnit` object.
    public class func fromLinearUnit(_ linearUnit: ArcGIS.LinearUnit) -> UnitLength

    /// The corresponding linear unit.
    ///
    /// This property is `nil` if the unit length does not have a related linear unit.
    public var linearUnit: ArcGIS.LinearUnit? { get }
}

extension Optional : ArcGIS.JSONSerializable where Wrapped : ArcGIS.JSONSerializable {

    /// Convert a JSON string to an object.
    /// - Parameter json: The JSON string.
    /// - Returns: An object.
    public static func fromJSON(_ json: String) throws -> Wrapped?

    /// Convert an object to JSON string.
    /// - Returns: A `String` which is the JSON string.
    public func toJSON() -> String
}

